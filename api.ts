declare module 'portable-fetch';
declare module 'url';

// <reference path="custom.d.ts" />

// tslint:disable
/**
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://secure.ultracart.com/rest/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryConfig
 */
export interface AccountsReceivableRetryConfig {
    /**
     * True if the retry should run daily.  False puts the retry service into an inactive state for this merchant.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    active?: boolean;
    /**
     * True if this account has linked accounts that it can process.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    allowProcessLinkedAccounts?: boolean;
    /**
     * The current service plan that the account is on.
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    currentServicePlan?: string;
    /**
     * A list of days and what actions should take place on those days after an order reaches accounts receivable
     * @type {Array<AccountsReceivableRetryDayActivity>}
     * @memberof AccountsReceivableRetryConfig
     */
    dailyActivityList?: Array<AccountsReceivableRetryDayActivity>;
    /**
     * If not null, this account is managed by the specified parent merchant id.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    managedByLinkedAccountMerchantId?: boolean;
    /**
     * UltraCart merchant ID
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    merchantId?: string;
    /**
     * A list of email addresses to receive summary notifications from the retry service.
     * @type {Array<string>}
     * @memberof AccountsReceivableRetryConfig
     */
    notifyEmails?: Array<string>;
    /**
     * If true, email addresses are notified of rejections.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    notifyRejections?: boolean;
    /**
     * If true, email addresses are notified of successful charges.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    notifySuccesses?: boolean;
    /**
     * If true, all linked accounts are also processed using the same rules.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    processLinkedAccounts?: boolean;
    /**
     * The percentage rate charged for the service.
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    processingPercentage?: string;
    /**
     * If true, the order is rejected the day after the last configured activity day
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    rejectAtEnd?: boolean;
    /**
     * True if the account is currently in trial mode.  Set to false to exit trial mode.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    trialMode?: boolean;
    /**
     * The date when trial mode expires.  If this date is reached without exiting trial mode, the service will de-activate.
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    trialModeExpirationDts?: string;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryConfigResponse
 */
export interface AccountsReceivableRetryConfigResponse {
    /**
     * 
     * @type {AccountsReceivableRetryConfig}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    config?: AccountsReceivableRetryConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    couponCodes?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    emails?: Array<string>;
    /**
     * 
     * @type {Error}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    error?: Error;
    /**
     * 
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    hasLinkedAccounts?: boolean;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryDayActivity
 */
export interface AccountsReceivableRetryDayActivity {
    /**
     * True if a charge attempt should be made on this day.  False means the order should be rejected on this day.
     * @type {boolean}
     * @memberof AccountsReceivableRetryDayActivity
     */
    charge?: boolean;
    /**
     * The coupon code that should be applied to this order.
     * @type {string}
     * @memberof AccountsReceivableRetryDayActivity
     */
    couponCode?: string;
    /**
     * The number of days since the order placed in Accounts Receivable
     * @type {number}
     * @memberof AccountsReceivableRetryDayActivity
     */
    day?: number;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatAccount
 */
export interface AccountsReceivableRetryStatAccount {
    /**
     * 
     * @type {Array<AccountsReceivableRetryStatMetrics>}
     * @memberof AccountsReceivableRetryStatAccount
     */
    days?: Array<AccountsReceivableRetryStatMetrics>;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatAccount
     */
    merchantId?: string;
    /**
     * 
     * @type {AccountsReceivableRetryStatMetrics}
     * @memberof AccountsReceivableRetryStatAccount
     */
    overall?: AccountsReceivableRetryStatMetrics;
    /**
     * 
     * @type {Array<AccountsReceivableRetryStatRevenue>}
     * @memberof AccountsReceivableRetryStatAccount
     */
    revenueForPeriod?: Array<AccountsReceivableRetryStatRevenue>;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatMetrics
 */
export interface AccountsReceivableRetryStatMetrics {
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    attempts?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    attemptsFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    conversionRate?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    conversionRateFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    day?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    discounts?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    discountsFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    revenue?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    revenueFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    successes?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    successesFormatted?: string;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatRevenue
 */
export interface AccountsReceivableRetryStatRevenue {
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatRevenue
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatRevenue
     */
    revenue?: number;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatsResponse
 */
export interface AccountsReceivableRetryStatsResponse {
    /**
     * 
     * @type {Error}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    error?: Error;
    /**
     * 
     * @type {Array<AccountsReceivableRetryStatAccount>}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    linkedAccounts?: Array<AccountsReceivableRetryStatAccount>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {AccountsReceivableRetryStatAccount}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    overall?: AccountsReceivableRetryStatAccount;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    metric?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    subject?: string;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    ts?: number;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface AddLibraryItemRequest
 */
export interface AddLibraryItemRequest {
    /**
     * Cjson to be added to library
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    cjson?: string;
    /**
     * flow, campaign, cjson, email, transactional_email or upsell
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    contentType?: string;
    /**
     * description of library item
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    description?: string;
    /**
     * Required if content_type is transactional_email. This is the name of the email template (html, not text).  This name should have a .vm file extension.  An example is auto_order_cancel_html.vm
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    emailName?: string;
    /**
     * Required if content_type is transactional_email. This is the full path to the email template stored in the file system.  This defines which StoreFront contains the desired email template.  An example is /themes/Elements/core/emails/auto_order_cancel_html.vm
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    emailPath?: string;
    /**
     * Screenshot urls for display
     * @type {Array<LibraryItemScreenshot>}
     * @memberof AddLibraryItemRequest
     */
    screenshots?: Array<LibraryItemScreenshot>;
    /**
     * StoreFront oid where content originates necessary for tracking down relative assets
     * @type {number}
     * @memberof AddLibraryItemRequest
     */
    storefrontOid?: number;
    /**
     * title of library item, usually the name of the flow or campaign, or description of cjson
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    title?: string;
    /**
     * Required if content_type is upsell. This is object identifier of a StoreFront Upsell Offer.
     * @type {number}
     * @memberof AddLibraryItemRequest
     */
    upsellOfferOid?: number;
    /**
     * UUID of communication flow, campaign, email, or null if this item is something else. transactional_email do not have a uuid because they are singleton objects within a storefront and easily identifiable by name
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface AffiliateClick
 */
export interface AffiliateClick {
    /**
     * Unique object identifier for this click
     * @type {number}
     * @memberof AffiliateClick
     */
    affiliateClickOid?: number;
    /**
     * Unique object identifier for for the link that this click is associated with
     * @type {number}
     * @memberof AffiliateClick
     */
    affiliateLinkOid?: number;
    /**
     * Affiliate object ID associated with this click
     * @type {number}
     * @memberof AffiliateClick
     */
    affiliateOid?: number;
    /**
     * Date/time that the click was made
     * @type {string}
     * @memberof AffiliateClick
     */
    clickDts?: string;
    /**
     * IP address that generated the click
     * @type {string}
     * @memberof AffiliateClick
     */
    ipAddress?: string;
    /**
     * URL of the landing page the customer was sent to.
     * @type {string}
     * @memberof AffiliateClick
     */
    landingPage?: string;
    /**
     * Query string on the landing page URL the customer was sent to.
     * @type {string}
     * @memberof AffiliateClick
     */
    landingPageQueryString?: string;
    /**
     * 
     * @type {AffiliateLink}
     * @memberof AffiliateClick
     */
    link?: AffiliateLink;
    /**
     * URL that referred the click (Browser Header Referer)
     * @type {string}
     * @memberof AffiliateClick
     */
    referrer?: string;
    /**
     * Query string that was on the referrer URL.
     * @type {string}
     * @memberof AffiliateClick
     */
    referrerQueryString?: string;
    /**
     * Sub ID value passed on the click
     * @type {string}
     * @memberof AffiliateClick
     */
    subId?: string;
}

/**
 * 
 * @export
 * @interface AffiliateClickQuery
 */
export interface AffiliateClickQuery {
    /**
     * Unique object identifier for for the link that this click is associated with
     * @type {number}
     * @memberof AffiliateClickQuery
     */
    affiliateLinkOid?: number;
    /**
     * Affiliate ID associated with the click
     * @type {number}
     * @memberof AffiliateClickQuery
     */
    affiliateOid?: number;
    /**
     * Minimum click date/time to return
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    clickDtsBegin?: string;
    /**
     * Maximum click date/time to return
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    clickDtsEnd?: string;
    /**
     * IP address that generated the click
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    ipAddress?: string;
    /**
     * Sub ID value passed on the click
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    subId?: string;
}

/**
 * 
 * @export
 * @interface AffiliateClicksResponse
 */
export interface AffiliateClicksResponse {
    /**
     * clicks
     * @type {Array<AffiliateClick>}
     * @memberof AffiliateClicksResponse
     */
    clicks?: Array<AffiliateClick>;
    /**
     * 
     * @type {Error}
     * @memberof AffiliateClicksResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AffiliateClicksResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AffiliateClicksResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AffiliateClicksResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AffiliateLedger
 */
export interface AffiliateLedger {
    /**
     * Unique object identifier for the click associated with this ledger entry
     * @type {number}
     * @memberof AffiliateLedger
     */
    affiliateClickOid?: number;
    /**
     * Unique object identifier for the link that this click is associated with
     * @type {number}
     * @memberof AffiliateLedger
     */
    affiliateLinkOid?: number;
    /**
     * Affiliate object ID associated with this transaction
     * @type {number}
     * @memberof AffiliateLedger
     */
    affiliateOid?: number;
    /**
     * User that assigned the transaction if it was done manually
     * @type {string}
     * @memberof AffiliateLedger
     */
    assignedByUser?: string;
    /**
     * 
     * @type {AffiliateClick}
     * @memberof AffiliateLedger
     */
    click?: AffiliateClick;
    /**
     * Item ID associated with this transaction
     * @type {string}
     * @memberof AffiliateLedger
     */
    itemId?: string;
    /**
     * 
     * @type {AffiliateLink}
     * @memberof AffiliateLedger
     */
    link?: AffiliateLink;
    /**
     * 
     * @type {Order}
     * @memberof AffiliateLedger
     */
    order?: Order;
    /**
     * Order ID associated with this transaction
     * @type {string}
     * @memberof AffiliateLedger
     */
    orderId?: string;
    /**
     * Date/time of the original transaction for reversals
     * @type {string}
     * @memberof AffiliateLedger
     */
    originalTransactionDts?: string;
    /**
     * Sub ID associated with transaction (from the click)
     * @type {string}
     * @memberof AffiliateLedger
     */
    subId?: string;
    /**
     * Tier number that this transaction earned
     * @type {string}
     * @memberof AffiliateLedger
     */
    tierNumber?: string;
    /**
     * Transaction amount
     * @type {number}
     * @memberof AffiliateLedger
     */
    transactionAmount?: number;
    /**
     * Amount of the transaction that has been paid out.
     * @type {number}
     * @memberof AffiliateLedger
     */
    transactionAmountPaid?: number;
    /**
     * Date/time that the transaction was made
     * @type {string}
     * @memberof AffiliateLedger
     */
    transactionDts?: string;
    /**
     * Memo explaining the transaction
     * @type {string}
     * @memberof AffiliateLedger
     */
    transactionMemo?: string;
    /**
     * Percentage associated with this transaction
     * @type {string}
     * @memberof AffiliateLedger
     */
    transactionPercentage?: string;
    /**
     * Transaction state
     * @type {string}
     * @memberof AffiliateLedger
     */
    transactionState?: AffiliateLedger.TransactionStateEnum;
}

/**
 * @export
 * @namespace AffiliateLedger
 */
export namespace AffiliateLedger {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}

/**
 * 
 * @export
 * @interface AffiliateLedgerQuery
 */
export interface AffiliateLedgerQuery {
    /**
     * Affiliate ID associated with the ledger
     * @type {number}
     * @memberof AffiliateLedgerQuery
     */
    affiliateOid?: number;
    /**
     * Item id associated with the ledger entry
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    itemId?: string;
    /**
     * Order ID associated with the ledger entries
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    orderId?: string;
    /**
     * Sub ID value passed on the click that generated the ledger
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    subId?: string;
    /**
     * Minimum transaction date/time to return
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    transactionDtsBegin?: string;
    /**
     * Maximum transaction date/time to return
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    transactionDtsEnd?: string;
}

/**
 * 
 * @export
 * @interface AffiliateLedgersResponse
 */
export interface AffiliateLedgersResponse {
    /**
     * 
     * @type {Error}
     * @memberof AffiliateLedgersResponse
     */
    error?: Error;
    /**
     * ledgers
     * @type {Array<AffiliateLedger>}
     * @memberof AffiliateLedgersResponse
     */
    ledgers?: Array<AffiliateLedger>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AffiliateLedgersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AffiliateLedgersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AffiliateLedgersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AffiliateLink
 */
export interface AffiliateLink {
    /**
     * Unique object identifier associated with this link
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliateLinkOid?: number;
    /**
     * Managed link OID that this link object was generated from
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliateManagedLinkOid?: number;
    /**
     * Affiliate object ID associated with this link
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliateOid?: number;
    /**
     * The affiliate program item this managed link is associated with
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliateProgramItemOid?: number;
    /**
     * Code associated with the link
     * @type {string}
     * @memberof AffiliateLink
     */
    code?: string;
    /**
     * Creative (image or text) associated with this link
     * @type {number}
     * @memberof AffiliateLink
     */
    creativeOid?: number;
    /**
     * Custom HTML associated with this link
     * @type {string}
     * @memberof AffiliateLink
     */
    customHtml?: string;
    /**
     * Approved status of the custom html
     * @type {string}
     * @memberof AffiliateLink
     */
    customHtmlApprovalStatus?: AffiliateLink.CustomHtmlApprovalStatusEnum;
    /**
     * Custom landing page URL if configured
     * @type {string}
     * @memberof AffiliateLink
     */
    customLandingUrl?: string;
    /**
     * True if the link has been deleted
     * @type {boolean}
     * @memberof AffiliateLink
     */
    deleted?: boolean;
    /**
     * Invisible link approval status
     * @type {string}
     * @memberof AffiliateLink
     */
    invisibleLinkApprovalStatus?: AffiliateLink.InvisibleLinkApprovalStatusEnum;
    /**
     * Invisible link URL prefix
     * @type {string}
     * @memberof AffiliateLink
     */
    invisibleLinkUrlPrefix?: string;
    /**
     * Name of the link
     * @type {string}
     * @memberof AffiliateLink
     */
    name?: string;
    /**
     * Type of link
     * @type {string}
     * @memberof AffiliateLink
     */
    type?: AffiliateLink.TypeEnum;
}

/**
 * @export
 * @namespace AffiliateLink
 */
export namespace AffiliateLink {
    /**
     * @export
     * @enum {string}
     */
    export enum CustomHtmlApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InvisibleLinkApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Image = <any> 'image',
        Text = <any> 'text',
        Invisible = <any> 'invisible',
        Direct = <any> 'direct'
    }
}

/**
 * 
 * @export
 * @interface ApiUserApplicationProfile
 */
export interface ApiUserApplicationProfile {
    /**
     * Application logo URL
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    apiApplicationLogoUrl?: string;
    /**
     * Application description
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    applicationDescription?: string;
    /**
     * Application name
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    applicationName?: string;
    /**
     * Developer name
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    developerName?: string;
    /**
     * Developer website
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    developerWebsite?: string;
}

/**
 * 
 * @export
 * @interface ApplyLibraryItemRequest
 */
export interface ApplyLibraryItemRequest {
    /**
     * Normal emails are applied to an existing email object, so when requesting a library item to be applied to an email, supply the email uuid.  This is only for normal emails.  Transactional emails do not have a uuid.
     * @type {string}
     * @memberof ApplyLibraryItemRequest
     */
    emailUuid?: string;
    /**
     * Library item oid that you wish to apply to the given StoreFront
     * @type {number}
     * @memberof ApplyLibraryItemRequest
     */
    libraryItemOid?: number;
    /**
     * StoreFront oid where content originates necessary for tracking down relative assets
     * @type {number}
     * @memberof ApplyLibraryItemRequest
     */
    storefrontOid?: number;
}

/**
 * 
 * @export
 * @interface ApplyLibraryItemResponse
 */
export interface ApplyLibraryItemResponse {
    /**
     * Cjson from library item, only populated if this library item was a cjson snippet or marketing email (not transactional)
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    cjson?: string;
    /**
     * flow, campaign, cjson, upsell, transactional_email or email
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    contentType?: string;
    /**
     * If a marketing email was applied, this is the path to the template encapsulating the cjson.  This is needed for the UltraCart UI.
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    emailTemplateVmPath?: string;
    /**
     * 
     * @type {Error}
     * @memberof ApplyLibraryItemResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ApplyLibraryItemResponse
     */
    metadata?: ResponseMetadata;
    /**
     * StoreFront oid where content originates necessary for tracking down relative assets
     * @type {number}
     * @memberof ApplyLibraryItemResponse
     */
    storefrontOid?: number;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ApplyLibraryItemResponse
     */
    success?: boolean;
    /**
     * title of library item, usually the name of the flow or campaign, or description of cjson
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    title?: string;
    /**
     * UUID of marketing email or communication flow/campaign if this library item was an email, campaign or flow
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    uuid?: string;
    /**
     * 
     * @type {Warning}
     * @memberof ApplyLibraryItemResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AutoOrder
 */
export interface AutoOrder {
    /**
     * Unique code assigned to this auto order
     * @type {string}
     * @memberof AutoOrder
     */
    autoOrderCode?: string;
    /**
     * Auto order object identifier
     * @type {number}
     * @memberof AutoOrder
     */
    autoOrderOid?: number;
    /**
     * Cancel this auto order after X additional rebills
     * @type {number}
     * @memberof AutoOrder
     */
    cancelAfterNextXOrders?: number;
    /**
     * True if the auto order was canceled because the customer purchased a downgrade item
     * @type {boolean}
     * @memberof AutoOrder
     */
    cancelDowngrade?: boolean;
    /**
     * True if the auto order was canceled because the customer purchased an upgrade item
     * @type {boolean}
     * @memberof AutoOrder
     */
    cancelUpgrade?: boolean;
    /**
     * The user that canceled the auto order
     * @type {string}
     * @memberof AutoOrder
     */
    canceledByUser?: string;
    /**
     * The date/time that the auto order was canceled
     * @type {string}
     * @memberof AutoOrder
     */
    canceledDts?: string;
    /**
     * True if the auto order ran successfully to completion
     * @type {boolean}
     * @memberof AutoOrder
     */
    completed?: boolean;
    /**
     * The number of credit card attempts that have taken place
     * @type {number}
     * @memberof AutoOrder
     */
    creditCardAttempt?: number;
    /**
     * The date/time the auto order was disabled due to failed rebills
     * @type {string}
     * @memberof AutoOrder
     */
    disabledDts?: string;
    /**
     * True if this auto order is enabled
     * @type {boolean}
     * @memberof AutoOrder
     */
    enabled?: boolean;
    /**
     * The reason this auto order failed during the last rebill attempt
     * @type {string}
     * @memberof AutoOrder
     */
    failureReason?: string;
    /**
     * The items that are setup to rebill
     * @type {Array<AutoOrderItem>}
     * @memberof AutoOrder
     */
    items?: Array<AutoOrderItem>;
    /**
     * The next time that the auto order will be attempted for processing
     * @type {string}
     * @memberof AutoOrder
     */
    nextAttempt?: string;
    /**
     * 
     * @type {Order}
     * @memberof AutoOrder
     */
    originalOrder?: Order;
    /**
     * The original order id that this auto order is associated with.
     * @type {string}
     * @memberof AutoOrder
     */
    originalOrderId?: string;
    /**
     * Override the affiliate id given credit for rebills of this auto order
     * @type {number}
     * @memberof AutoOrder
     */
    overrideAffiliateId?: number;
    /**
     * Rebill orders that have taken place on this auto order
     * @type {Array<Order>}
     * @memberof AutoOrder
     */
    rebillOrders?: Array<Order>;
    /**
     * The RTG code associated with this order for future rebills
     * @type {string}
     * @memberof AutoOrder
     */
    rotatingTransactionGatewayCode?: string;
    /**
     * The status of the auto order
     * @type {string}
     * @memberof AutoOrder
     */
    status?: AutoOrder.StatusEnum;
}

/**
 * @export
 * @namespace AutoOrder
 */
export namespace AutoOrder {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}

/**
 * 
 * @export
 * @interface AutoOrderItem
 */
export interface AutoOrderItem {
    /**
     * Arbitrary item id that should be rebilled instead of the normal schedule
     * @type {string}
     * @memberof AutoOrderItem
     */
    arbitraryItemId?: string;
    /**
     * An arbitrary percentage discount to provide on future rebills
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitraryPercentageDiscount?: number;
    /**
     * Arbitrary quantity to rebill
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitraryQuantity?: number;
    /**
     * The number of days to rebill if the frequency is set to an arbitrary number of days
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitraryScheduleDays?: number;
    /**
     * Arbitrary unit cost that rebills of this item should occur at
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitraryUnitCost?: number;
    /**
     * The number of rebills to give the arbitrary unit cost on before reverting to normal pricing.
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitraryUnitCostRemainingOrders?: number;
    /**
     * Primary key of AutoOrderItem
     * @type {number}
     * @memberof AutoOrderItem
     */
    autoOrderItemOid?: number;
    /**
     * Frequency of the rebill if not a fixed schedule
     * @type {string}
     * @memberof AutoOrderItem
     */
    frequency?: AutoOrderItem.FrequencyEnum;
    /**
     * The future rebill schedule for this item up to the next ten rebills
     * @type {Array<AutoOrderItemFutureSchedule>}
     * @memberof AutoOrderItem
     */
    futureSchedules?: Array<AutoOrderItemFutureSchedule>;
    /**
     * Date/time of the last order of this item
     * @type {string}
     * @memberof AutoOrderItem
     */
    lastOrderDts?: string;
    /**
     * The life time value of this item including the original purchase
     * @type {number}
     * @memberof AutoOrderItem
     */
    lifeTimeValue?: number;
    /**
     * The date/time of when the next pre-shipment notice should be sent
     * @type {string}
     * @memberof AutoOrderItem
     */
    nextPreshipmentNoticeDts?: string;
    /**
     * Date/time that this item is scheduled to rebill
     * @type {string}
     * @memberof AutoOrderItem
     */
    nextShipmentDts?: string;
    /**
     * Date/time after which no additional rebills of this item should occur
     * @type {string}
     * @memberof AutoOrderItem
     */
    noOrderAfterDts?: string;
    /**
     * The number of times this item has rebilled
     * @type {number}
     * @memberof AutoOrderItem
     */
    numberOfRebills?: number;
    /**
     * Options associated with this item
     * @type {Array<AutoOrderItemOption>}
     * @memberof AutoOrderItem
     */
    options?: Array<AutoOrderItemOption>;
    /**
     * The original item id purchased.  This item controls scheduling.  If you wish to modify a schedule, for example, from monthly to yearly, change this item from your monthly item to your yearly item, and then change the next_shipment_dts to your desired date.
     * @type {string}
     * @memberof AutoOrderItem
     */
    originalItemId?: string;
    /**
     * The original quantity purchased
     * @type {number}
     * @memberof AutoOrderItem
     */
    originalQuantity?: number;
    /**
     * The PayPal Payer ID tied to this item
     * @type {string}
     * @memberof AutoOrderItem
     */
    paypalPayerId?: string;
    /**
     * The PayPal Profile ID tied to this item
     * @type {string}
     * @memberof AutoOrderItem
     */
    paypalRecurringPaymentProfileId?: string;
    /**
     * True if the preshipment notice associated with the next rebill has been sent
     * @type {boolean}
     * @memberof AutoOrderItem
     */
    preshipmentNoticeSent?: boolean;
    /**
     * The value of the rebills of this item
     * @type {number}
     * @memberof AutoOrderItem
     */
    rebillValue?: number;
    /**
     * The number of rebills remaining before this item is complete
     * @type {number}
     * @memberof AutoOrderItem
     */
    remainingRepeatCount?: number;
    /**
     * 
     * @type {AutoOrderItemSimpleSchedule}
     * @memberof AutoOrderItem
     */
    simpleSchedule?: AutoOrderItemSimpleSchedule;
}

/**
 * @export
 * @namespace AutoOrderItem
 */
export namespace AutoOrderItem {
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}

/**
 * 
 * @export
 * @interface AutoOrderItemFutureSchedule
 */
export interface AutoOrderItemFutureSchedule {
    /**
     * Item ID that should rebill
     * @type {string}
     * @memberof AutoOrderItemFutureSchedule
     */
    itemId?: string;
    /**
     * The number of times this rebill represents
     * @type {number}
     * @memberof AutoOrderItemFutureSchedule
     */
    rebillCount?: number;
    /**
     * Date/time that this item is scheduled to rebill
     * @type {string}
     * @memberof AutoOrderItemFutureSchedule
     */
    shipmentDts?: string;
    /**
     * The unit cost of the item rebilling
     * @type {number}
     * @memberof AutoOrderItemFutureSchedule
     */
    unitCost?: number;
}

/**
 * 
 * @export
 * @interface AutoOrderItemOption
 */
export interface AutoOrderItemOption {
    /**
     * Label
     * @type {string}
     * @memberof AutoOrderItemOption
     */
    label?: string;
    /**
     * Value
     * @type {string}
     * @memberof AutoOrderItemOption
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface AutoOrderItemSimpleSchedule
 */
export interface AutoOrderItemSimpleSchedule {
    /**
     * Frequency of the rebill if not a fixed schedule
     * @type {string}
     * @memberof AutoOrderItemSimpleSchedule
     */
    frequency?: AutoOrderItemSimpleSchedule.FrequencyEnum;
    /**
     * Item ID that should rebill
     * @type {string}
     * @memberof AutoOrderItemSimpleSchedule
     */
    itemId?: string;
    /**
     * The number of times this simple schedule is configured for
     * @type {number}
     * @memberof AutoOrderItemSimpleSchedule
     */
    repeatCount?: number;
}

/**
 * @export
 * @namespace AutoOrderItemSimpleSchedule
 */
export namespace AutoOrderItemSimpleSchedule {
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}

/**
 * 
 * @export
 * @interface AutoOrderQuery
 */
export interface AutoOrderQuery {
    /**
     * Auto order code
     * @type {string}
     * @memberof AutoOrderQuery
     */
    autoOrderCode?: string;
    /**
     * Card type
     * @type {string}
     * @memberof AutoOrderQuery
     */
    cardType?: string;
    /**
     * City
     * @type {string}
     * @memberof AutoOrderQuery
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof AutoOrderQuery
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof AutoOrderQuery
     */
    countryCode?: string;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof AutoOrderQuery
     */
    customerProfileOid?: number;
    /**
     * Email
     * @type {string}
     * @memberof AutoOrderQuery
     */
    email?: string;
    /**
     * First name
     * @type {string}
     * @memberof AutoOrderQuery
     */
    firstName?: string;
    /**
     * Item ID
     * @type {string}
     * @memberof AutoOrderQuery
     */
    itemId?: string;
    /**
     * Last name
     * @type {string}
     * @memberof AutoOrderQuery
     */
    lastName?: string;
    /**
     * Next shipment date begin
     * @type {string}
     * @memberof AutoOrderQuery
     */
    nextShipmentDateBegin?: string;
    /**
     * Next shipment date end
     * @type {string}
     * @memberof AutoOrderQuery
     */
    nextShipmentDateEnd?: string;
    /**
     * Original order date begin
     * @type {string}
     * @memberof AutoOrderQuery
     */
    originalOrderDateBegin?: string;
    /**
     * Original order date end
     * @type {string}
     * @memberof AutoOrderQuery
     */
    originalOrderDateEnd?: string;
    /**
     * Original order ID
     * @type {string}
     * @memberof AutoOrderQuery
     */
    originalOrderId?: string;
    /**
     * Phone
     * @type {string}
     * @memberof AutoOrderQuery
     */
    phone?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof AutoOrderQuery
     */
    postalCode?: string;
    /**
     * State
     * @type {string}
     * @memberof AutoOrderQuery
     */
    state?: string;
    /**
     * Status
     * @type {string}
     * @memberof AutoOrderQuery
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface AutoOrderQueryBatch
 */
export interface AutoOrderQueryBatch {
    /**
     * Auto order oids
     * @type {Array<number>}
     * @memberof AutoOrderQueryBatch
     */
    autoOrderOids?: Array<number>;
}

/**
 * 
 * @export
 * @interface AutoOrderResponse
 */
export interface AutoOrderResponse {
    /**
     * 
     * @type {AutoOrder}
     * @memberof AutoOrderResponse
     */
    autoOrder?: AutoOrder;
    /**
     * 
     * @type {Error}
     * @memberof AutoOrderResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AutoOrderResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AutoOrderResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AutoOrderResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AutoOrdersRequest
 */
export interface AutoOrdersRequest {
    /**
     * auto_orders
     * @type {Array<AutoOrder>}
     * @memberof AutoOrdersRequest
     */
    autoOrders?: Array<AutoOrder>;
}

/**
 * 
 * @export
 * @interface AutoOrdersResponse
 */
export interface AutoOrdersResponse {
    /**
     * 
     * @type {Array<AutoOrder>}
     * @memberof AutoOrdersResponse
     */
    autoOrders?: Array<AutoOrder>;
    /**
     * 
     * @type {Error}
     * @memberof AutoOrdersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AutoOrdersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AutoOrdersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AutoOrdersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AvalaraConfig
 */
export interface AvalaraConfig {
    /**
     * Avalara account ID
     * @type {string}
     * @memberof AvalaraConfig
     */
    accountId?: string;
    /**
     * True if Avalara is active for this merchant
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    active?: boolean;
    /**
     * Unique identifier for this avalara config object
     * @type {number}
     * @memberof AvalaraConfig
     */
    avalaraOid?: number;
    /**
     * Avalara company ID
     * @type {string}
     * @memberof AvalaraConfig
     */
    companyId?: string;
    /**
     * True if this Avalara configuration is set to enable tax valuation by UPC
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    enableUpc?: boolean;
    /**
     * True if this Avalara configuration is to estimate taxes only and not report placed orders to Avalara
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    estimateOnly?: boolean;
    /**
     * Optional customer code for customers without profiles, defaults to GuestCustomer
     * @type {string}
     * @memberof AvalaraConfig
     */
    guestCustomerCode?: string;
    /**
     * Date/time of the connection test to Avalara
     * @type {string}
     * @memberof AvalaraConfig
     */
    lastTestDts?: string;
    /**
     * Avalara license key
     * @type {string}
     * @memberof AvalaraConfig
     */
    licenseKey?: string;
    /**
     * True if this Avalara instance is pointed at the Avalara Sandbox
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    sandbox?: boolean;
    /**
     * Send test orders through to Avalara.  The default is to not transmit test orders to Avalara.
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    sendTestOrders?: boolean;
    /**
     * Avalara service URL
     * @type {string}
     * @memberof AvalaraConfig
     */
    serviceUrl?: string;
    /**
     * Test results of the last connection test to Avalara
     * @type {string}
     * @memberof AvalaraConfig
     */
    testResults?: string;
}

/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * 
     * @type {Error}
     * @memberof BaseResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof BaseResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof BaseResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof BaseResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * 
     * @type {CartAffiliate}
     * @memberof Cart
     */
    affiliate?: CartAffiliate;
    /**
     * The ISO-4217 three letter base currency code of the account
     * @type {string}
     * @memberof Cart
     */
    baseCurrencyCode?: string;
    /**
     * 
     * @type {CartBilling}
     * @memberof Cart
     */
    billing?: CartBilling;
    /**
     * 
     * @type {CartBuysafe}
     * @memberof Cart
     */
    buysafe?: CartBuysafe;
    /**
     * Unique identifier for this cart
     * @type {string}
     * @memberof Cart
     */
    cartId?: string;
    /**
     * 
     * @type {CartCheckout}
     * @memberof Cart
     */
    checkout?: CartCheckout;
    /**
     * Coupons
     * @type {Array<CartCoupon>}
     * @memberof Cart
     */
    coupons?: Array<CartCoupon>;
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof Cart
     */
    currencyCode?: string;
    /**
     * 
     * @type {CartCurrencyConversion}
     * @memberof Cart
     */
    currencyConversion?: CartCurrencyConversion;
    /**
     * 
     * @type {CartCustomerProfile}
     * @memberof Cart
     */
    customerProfile?: CartCustomerProfile;
    /**
     * The exchange rate if the customer is viewing a different currency than the base
     * @type {number}
     * @memberof Cart
     */
    exchangeRate?: number;
    /**
     * 
     * @type {CartGift}
     * @memberof Cart
     */
    gift?: CartGift;
    /**
     * 
     * @type {CartGiftCertificate}
     * @memberof Cart
     */
    giftCertificate?: CartGiftCertificate;
    /**
     * Items
     * @type {Array<CartItem>}
     * @memberof Cart
     */
    items?: Array<CartItem>;
    /**
     * The ISO-631 three letter code the customer would like to checkout with
     * @type {string}
     * @memberof Cart
     */
    languageIsoCode?: string;
    /**
     * True if the customer is logged into their profile
     * @type {boolean}
     * @memberof Cart
     */
    loggedIn?: boolean;
    /**
     * 
     * @type {CartMarketing}
     * @memberof Cart
     */
    marketing?: CartMarketing;
    /**
     * Merchant ID this cart is associated with
     * @type {string}
     * @memberof Cart
     */
    merchantId?: string;
    /**
     * 
     * @type {CartPayment}
     * @memberof Cart
     */
    payment?: CartPayment;
    /**
     * Properties associated with the cart
     * @type {Array<CartProperty>}
     * @memberof Cart
     */
    properties?: Array<CartProperty>;
    /**
     * 
     * @type {CartSettings}
     * @memberof Cart
     */
    settings?: CartSettings;
    /**
     * 
     * @type {CartShipping}
     * @memberof Cart
     */
    shipping?: CartShipping;
    /**
     * 
     * @type {CartSummary}
     * @memberof Cart
     */
    summary?: CartSummary;
    /**
     * 
     * @type {CartTaxes}
     * @memberof Cart
     */
    taxes?: CartTaxes;
    /**
     * 
     * @type {CartUpsellAfter}
     * @memberof Cart
     */
    upsellAfter?: CartUpsellAfter;
}

/**
 * 
 * @export
 * @interface CartAffiliate
 */
export interface CartAffiliate {
    /**
     * Affiliate id associated with the cart
     * @type {number}
     * @memberof CartAffiliate
     */
    affiliateId?: number;
    /**
     * Affiliate sub id associated with the cart
     * @type {string}
     * @memberof CartAffiliate
     */
    affiliateSubId?: string;
}

/**
 * 
 * @export
 * @interface CartAffirmCheckoutResponse
 */
export interface CartAffirmCheckoutResponse {
    /**
     * Checkout JSON object
     * @type {string}
     * @memberof CartAffirmCheckoutResponse
     */
    checkoutJson?: string;
    /**
     * Errors that should be displayed to the customer
     * @type {Array<string>}
     * @memberof CartAffirmCheckoutResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartBilling
 */
export interface CartBilling {
    /**
     * Address line 1
     * @type {string}
     * @memberof CartBilling
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CartBilling
     */
    address2?: string;
    /**
     * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
     * @type {Array<string>}
     * @memberof CartBilling
     */
    ccEmails?: Array<string>;
    /**
     * City
     * @type {string}
     * @memberof CartBilling
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CartBilling
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CartBilling
     */
    countryCode?: string;
    /**
     * Day phone
     * @type {string}
     * @memberof CartBilling
     */
    dayPhone?: string;
    /**
     * Email
     * @type {string}
     * @memberof CartBilling
     */
    email?: string;
    /**
     * Email entered for confirmation
     * @type {string}
     * @memberof CartBilling
     */
    emailConfirm?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof CartBilling
     */
    eveningPhone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CartBilling
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CartBilling
     */
    lastName?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof CartBilling
     */
    postalCode?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CartBilling
     */
    stateRegion?: string;
    /**
     * Title
     * @type {string}
     * @memberof CartBilling
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CartBuysafe
 */
export interface CartBuysafe {
    /**
     * True if buySAFE is willing to bond the order
     * @type {boolean}
     * @memberof CartBuysafe
     */
    bondAvailable?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartBuysafe
     */
    bondCost?: Currency;
    /**
     * True if the bond is free (merchant paying for it)
     * @type {boolean}
     * @memberof CartBuysafe
     */
    bondFree?: boolean;
    /**
     * True if the customer wants the bond
     * @type {boolean}
     * @memberof CartBuysafe
     */
    bondWanted?: boolean;
    /**
     * Recommend text to display to the customer
     * @type {string}
     * @memberof CartBuysafe
     */
    cartDisplayText?: string;
    /**
     * URL associated with the recommended text
     * @type {string}
     * @memberof CartBuysafe
     */
    cartDisplayUrl?: string;
}

/**
 * 
 * @export
 * @interface CartCheckout
 */
export interface CartCheckout {
    /**
     * Comments from the customer.  Rarely used on the single page checkout.
     * @type {string}
     * @memberof CartCheckout
     */
    comments?: string;
    /**
     * Custom field 1
     * @type {string}
     * @memberof CartCheckout
     */
    customField1?: string;
    /**
     * Custom field 2
     * @type {string}
     * @memberof CartCheckout
     */
    customField2?: string;
    /**
     * Custom field 3
     * @type {string}
     * @memberof CartCheckout
     */
    customField3?: string;
    /**
     * Custom field 4
     * @type {string}
     * @memberof CartCheckout
     */
    customField4?: string;
    /**
     * Custom field 5
     * @type {string}
     * @memberof CartCheckout
     */
    customField5?: string;
    /**
     * Custom field 6
     * @type {string}
     * @memberof CartCheckout
     */
    customField6?: string;
    /**
     * Custom field 7
     * @type {string}
     * @memberof CartCheckout
     */
    customField7?: string;
    /**
     * IP Address (read only unless non-browser key authenticated)
     * @type {string}
     * @memberof CartCheckout
     */
    ipAddress?: string;
    /**
     * Return code assigned for send return email operation
     * @type {string}
     * @memberof CartCheckout
     */
    returnCode?: string;
    /**
     * Screen branding theme code
     * @type {string}
     * @memberof CartCheckout
     */
    screenBrandingThemeCode?: string;
    /**
     * StoreFront Host Name
     * @type {string}
     * @memberof CartCheckout
     */
    storefrontHostName?: string;
    /**
     * User agent of the browser
     * @type {string}
     * @memberof CartCheckout
     */
    userAgent?: string;
}

/**
 * 
 * @export
 * @interface CartCoupon
 */
export interface CartCoupon {
    /**
     * Coupon code
     * @type {string}
     * @memberof CartCoupon
     */
    couponCode?: string;
}

/**
 * 
 * @export
 * @interface CartCurrencyConversion
 */
export interface CartCurrencyConversion {
    /**
     * Base currency code for this merchant
     * @type {string}
     * @memberof CartCurrencyConversion
     */
    baseCurrencyCode?: string;
    /**
     * Conversion information for 1 unit of base currency to target currencies
     * @type {Array<Currency>}
     * @memberof CartCurrencyConversion
     */
    currencies?: Array<Currency>;
}

/**
 * 
 * @export
 * @interface CartCustomerProfile
 */
export interface CartCustomerProfile {
    /**
     * True if profile is allowed to bill to their 3rd party shipping account
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    allow3rdPartyBilling?: boolean;
    /**
     * True if this profile is allowed to use a COD
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    allowCod?: boolean;
    /**
     * True if this profile is allowed to use a purchase order
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    allowPurchaseOrder?: boolean;
    /**
     * Billing addresses on file for this profile
     * @type {Array<CartCustomerProfileAddress>}
     * @memberof CartCustomerProfile
     */
    billingAddresses?: Array<CartCustomerProfileAddress>;
    /**
     * Credit cards on file for this profile (masked)
     * @type {Array<CartCustomerProfileCreditCard>}
     * @memberof CartCustomerProfile
     */
    creditCards?: Array<CartCustomerProfileCreditCard>;
    /**
     * Unique identifier
     * @type {number}
     * @memberof CartCustomerProfile
     */
    customerProfileOid?: number;
    /**
     * DHL account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    dhlAccountNumber?: string;
    /**
     * DHL duty account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    dhlDutyAccountNumber?: string;
    /**
     * Email
     * @type {string}
     * @memberof CartCustomerProfile
     */
    email?: string;
    /**
     * FedEx account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    fedexAccountNumber?: string;
    /**
     * True if this profile always qualifies for free shipping
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    freeShipping?: boolean;
    /**
     * The minimum aount that this profile has to purchase to qualify for free shipping
     * @type {number}
     * @memberof CartCustomerProfile
     */
    freeShippingMinimum?: number;
    /**
     * Maximum item count this profile can purchase
     * @type {number}
     * @memberof CartCustomerProfile
     */
    maximumItemCount?: number;
    /**
     * Minimum item count this profile must purchase
     * @type {number}
     * @memberof CartCustomerProfile
     */
    minimumItemCount?: number;
    /**
     * Minimum subtotal this profile must purchase
     * @type {number}
     * @memberof CartCustomerProfile
     */
    minimumSubtotal?: number;
    /**
     * True if this profile is prevented from using coupons
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    noCoupons?: boolean;
    /**
     * True if this profile is never given free shipping
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    noFreeShipping?: boolean;
    /**
     * True if this customers orders are not charged in real-time
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    noRealtimeCharge?: boolean;
    /**
     * Pricing tier names this profile qualifies for
     * @type {Array<string>}
     * @memberof CartCustomerProfile
     */
    pricingTiers?: Array<string>;
    /**
     * Shipping addresses on file for this profile
     * @type {Array<CartCustomerProfileAddress>}
     * @memberof CartCustomerProfile
     */
    shippingAddresses?: Array<CartCustomerProfileAddress>;
    /**
     * True if this profile is exempt from sales tax
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    taxExempt?: boolean;
    /**
     * UPS account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    upsAccountNumber?: string;
}

/**
 * 
 * @export
 * @interface CartCustomerProfileAddress
 */
export interface CartCustomerProfileAddress {
    /**
     * Address 1
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    address1?: string;
    /**
     * Address 2
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    company?: string;
    /**
     * ISO-3166 Country code
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    countryCode?: string;
    /**
     * Day phone
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    dayPhone?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    eveningPhone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    lastName?: string;
    /**
     * Unique identifier for this address
     * @type {number}
     * @memberof CartCustomerProfileAddress
     */
    oid?: number;
    /**
     * Postal code
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    postalCode?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    stateRegion?: string;
    /**
     * Tax county if a billing address
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    taxCounty?: string;
    /**
     * Title
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CartCustomerProfileCreditCard
 */
export interface CartCustomerProfileCreditCard {
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof CartCustomerProfileCreditCard
     */
    cardExpirationMonth?: number;
    /**
     * Card expiration year (four digit)
     * @type {number}
     * @memberof CartCustomerProfileCreditCard
     */
    cardExpirationYear?: number;
    /**
     * Card number (masked last 4 digits)
     * @type {string}
     * @memberof CartCustomerProfileCreditCard
     */
    cardNumber?: string;
    /**
     * Card type
     * @type {string}
     * @memberof CartCustomerProfileCreditCard
     */
    cardType?: CartCustomerProfileCreditCard.CardTypeEnum;
    /**
     * Unique identifier for this stored card
     * @type {number}
     * @memberof CartCustomerProfileCreditCard
     */
    customerProfileCreditCardId?: number;
    /**
     * Last used
     * @type {string}
     * @memberof CartCustomerProfileCreditCard
     */
    lastUsedDate?: string;
}

/**
 * @export
 * @namespace CartCustomerProfileCreditCard
 */
export namespace CartCustomerProfileCreditCard {
    /**
     * @export
     * @enum {string}
     */
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        MasterCard = <any> 'MasterCard',
        JCB = <any> 'JCB',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface CartFinalizeOrderRequest
 */
export interface CartFinalizeOrderRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartFinalizeOrderRequest
     */
    cart?: Cart;
    /**
     * 
     * @type {CartFinalizeOrderRequestOptions}
     * @memberof CartFinalizeOrderRequest
     */
    options?: CartFinalizeOrderRequestOptions;
}

/**
 * 
 * @export
 * @interface CartFinalizeOrderRequestOptions
 */
export interface CartFinalizeOrderRequestOptions {
    /**
     * Automatically approve the purchase order
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    autoApprovePurchaseOrder?: boolean;
    /**
     * Channel partner code to associate this order with
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    channelPartnerCode?: string;
    /**
     * Channel partner oid to associate this order with
     * @type {number}
     * @memberof CartFinalizeOrderRequestOptions
     */
    channelPartnerOid?: number;
    /**
     * Channel partner order id for reference
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    channelPartnerOrderId?: string;
    /**
     * Consider this order a recurring order for the purposes of payment gateway recurring flag
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    considerRecurring?: boolean;
    /**
     * If the order was authorized outside of UltraCart, this is the amount of the authorization
     * @type {number}
     * @memberof CartFinalizeOrderRequestOptions
     */
    creditCardAuthorizationAmount?: number;
    /**
     * If the order was authorized outside of UltraCart, this is the date/time of the authorization
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    creditCardAuthorizationDate?: string;
    /**
     * If the order was authorized outside of UltraCart, this is the authorization reference number
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    creditCardAuthorizationReferenceNumber?: string;
    /**
     * Prevents normal real-time processing of the payment and sends the order to Accounts Receivable
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    noRealtimePaymentProcessing?: boolean;
    /**
     * True if the system should create another cart automatically if the current cart was logged into a profile
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    setupNextCart?: boolean;
    /**
     * Skip payment processing and move the order on to shipping (or completed if no shipping required)
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    skipPaymentProcessing?: boolean;
    /**
     * True the order in the completed stage
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    storeCompleted?: boolean;
    /**
     * Store the order in accounts receivable if the payment declines
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    storeIfPaymentDeclines?: boolean;
}

/**
 * 
 * @export
 * @interface CartFinalizeOrderResponse
 */
export interface CartFinalizeOrderResponse {
    /**
     * Error messages if the order could not be completed
     * @type {Array<string>}
     * @memberof CartFinalizeOrderResponse
     */
    errors?: Array<string>;
    /**
     * 
     * @type {Cart}
     * @memberof CartFinalizeOrderResponse
     */
    nextCart?: Cart;
    /**
     * 
     * @type {Order}
     * @memberof CartFinalizeOrderResponse
     */
    order?: Order;
    /**
     * Order ID assigned to the order
     * @type {string}
     * @memberof CartFinalizeOrderResponse
     */
    orderId?: string;
    /**
     * True if the cart was converted successfully to an order
     * @type {boolean}
     * @memberof CartFinalizeOrderResponse
     */
    successful?: boolean;
}

/**
 * 
 * @export
 * @interface CartGift
 */
export interface CartGift {
    /**
     * True if this order is a gift
     * @type {boolean}
     * @memberof CartGift
     */
    gift?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartGift
     */
    giftCharge?: Currency;
    /**
     * Email address of the gift recipient
     * @type {string}
     * @memberof CartGift
     */
    giftEmail?: string;
    /**
     * Message to the gift recipient
     * @type {string}
     * @memberof CartGift
     */
    giftMessage?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartGift
     */
    giftWrapCost?: Currency;
    /**
     * Title of the selected gift wrap
     * @type {string}
     * @memberof CartGift
     */
    giftWrapTitle?: string;
}

/**
 * 
 * @export
 * @interface CartGiftCertificate
 */
export interface CartGiftCertificate {
    /**
     * 
     * @type {Currency}
     * @memberof CartGiftCertificate
     */
    giftCertificateAmount?: Currency;
    /**
     * Gift certificate code
     * @type {string}
     * @memberof CartGiftCertificate
     */
    giftCertificateCode?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartGiftCertificate
     */
    giftCertificateRemainingBalanceAfterOrder?: Currency;
}

/**
 * 
 * @export
 * @interface CartItem
 */
export interface CartItem {
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    arbitraryUnitCost?: Currency;
    /**
     * Attributes
     * @type {Array<CartItemAttribute>}
     * @memberof CartItem
     */
    attributes?: Array<CartItemAttribute>;
    /**
     * Auto order schedule the customer selected
     * @type {string}
     * @memberof CartItem
     */
    autoOrderSchedule?: string;
    /**
     * URL to the default multimedia image
     * @type {string}
     * @memberof CartItem
     */
    defaultImageUrl?: string;
    /**
     * URL to the default multimedia thumbnail
     * @type {string}
     * @memberof CartItem
     */
    defaultThumbnailUrl?: string;
    /**
     * Description of the item
     * @type {string}
     * @memberof CartItem
     */
    description?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    discount?: Currency;
    /**
     * Extended description of the item
     * @type {string}
     * @memberof CartItem
     */
    extendedDescription?: string;
    /**
     * Item ID
     * @type {string}
     * @memberof CartItem
     */
    itemId?: string;
    /**
     * Item object identifier
     * @type {number}
     * @memberof CartItem
     */
    itemOid?: number;
    /**
     * True if this item is a kit
     * @type {boolean}
     * @memberof CartItem
     */
    kit?: boolean;
    /**
     * Options associated with the kit components
     * @type {Array<CartKitComponentOption>}
     * @memberof CartItem
     */
    kitComponentOptions?: Array<CartKitComponentOption>;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    manufacturerSuggestedRetailPrice?: Currency;
    /**
     * Maximum quantity the customer can purchase
     * @type {number}
     * @memberof CartItem
     */
    maximumQuantity?: number;
    /**
     * Minimum quantity the customer can purchase
     * @type {number}
     * @memberof CartItem
     */
    minimumQuantity?: number;
    /**
     * Multimedia
     * @type {Array<CartItemMultimedia>}
     * @memberof CartItem
     */
    multimedia?: Array<CartItemMultimedia>;
    /**
     * Options
     * @type {Array<CartItemOption>}
     * @memberof CartItem
     */
    options?: Array<CartItemOption>;
    /**
     * 
     * @type {CartItemPhysical}
     * @memberof CartItem
     */
    phsyical?: CartItemPhysical;
    /**
     * Position of the item in the cart
     * @type {number}
     * @memberof CartItem
     */
    position?: number;
    /**
     * True if this item is on pre-order
     * @type {boolean}
     * @memberof CartItem
     */
    preorder?: boolean;
    /**
     * quantity
     * @type {number}
     * @memberof CartItem
     */
    quantity?: number;
    /**
     * Customer selectable auto order schedules
     * @type {Array<string>}
     * @memberof CartItem
     */
    schedules?: Array<string>;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    totalCost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    totalCostWithDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    unitCost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    unitCostWithDiscount?: Currency;
    /**
     * True if this item was added to the cart as part of an upsell
     * @type {boolean}
     * @memberof CartItem
     */
    upsell?: boolean;
    /**
     * Variations
     * @type {Array<CartItemVariationSelection>}
     * @memberof CartItem
     */
    variations?: Array<CartItemVariationSelection>;
    /**
     * URL to view the product on the site
     * @type {string}
     * @memberof CartItem
     */
    viewUrl?: string;
}

/**
 * 
 * @export
 * @interface CartItemAttribute
 */
export interface CartItemAttribute {
    /**
     * Name of the attribute
     * @type {string}
     * @memberof CartItemAttribute
     */
    name?: string;
    /**
     * Type of attribute
     * @type {string}
     * @memberof CartItemAttribute
     */
    type?: string;
    /**
     * Value of the attribute
     * @type {string}
     * @memberof CartItemAttribute
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface CartItemMultimedia
 */
export interface CartItemMultimedia {
    /**
     * Code assigned to the multimedia
     * @type {string}
     * @memberof CartItemMultimedia
     */
    code?: string;
    /**
     * Description
     * @type {string}
     * @memberof CartItemMultimedia
     */
    description?: string;
    /**
     * True if the image should be excluded from galleries
     * @type {boolean}
     * @memberof CartItemMultimedia
     */
    excludeFromGallery?: boolean;
    /**
     * Image height
     * @type {number}
     * @memberof CartItemMultimedia
     */
    imageHeight?: number;
    /**
     * Image width
     * @type {number}
     * @memberof CartItemMultimedia
     */
    imageWidth?: number;
    /**
     * True if the multimedia is the default for this type
     * @type {boolean}
     * @memberof CartItemMultimedia
     */
    isDefault?: boolean;
    /**
     * Thumbnails of the images
     * @type {Array<CartItemMultimediaThumbnail>}
     * @memberof CartItemMultimedia
     */
    thumbnails?: Array<CartItemMultimediaThumbnail>;
    /**
     * Type of multimedia
     * @type {string}
     * @memberof CartItemMultimedia
     */
    type?: CartItemMultimedia.TypeEnum;
    /**
     * URL to view multimedia at
     * @type {string}
     * @memberof CartItemMultimedia
     */
    url?: string;
}

/**
 * @export
 * @namespace CartItemMultimedia
 */
export namespace CartItemMultimedia {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}

/**
 * 
 * @export
 * @interface CartItemMultimediaThumbnail
 */
export interface CartItemMultimediaThumbnail {
    /**
     * Height in pixels
     * @type {number}
     * @memberof CartItemMultimediaThumbnail
     */
    height?: number;
    /**
     * True if thumbnail is a PNG, otherwise its a JPEG
     * @type {boolean}
     * @memberof CartItemMultimediaThumbnail
     */
    png?: boolean;
    /**
     * True if the thumbnail is square
     * @type {boolean}
     * @memberof CartItemMultimediaThumbnail
     */
    square?: boolean;
    /**
     * URL for the thumbnail
     * @type {string}
     * @memberof CartItemMultimediaThumbnail
     */
    url?: string;
    /**
     * Width in pixels
     * @type {number}
     * @memberof CartItemMultimediaThumbnail
     */
    width?: number;
}

/**
 * 
 * @export
 * @interface CartItemOption
 */
export interface CartItemOption {
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOption
     */
    costIfSpecified?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOption
     */
    costPerLetter?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOption
     */
    costPerLine?: Currency;
    /**
     * True if the default answer is ignored
     * @type {boolean}
     * @memberof CartItemOption
     */
    ignoreIfDefault?: boolean;
    /**
     * Display label for the option
     * @type {string}
     * @memberof CartItemOption
     */
    label?: string;
    /**
     * Name of the option
     * @type {string}
     * @memberof CartItemOption
     */
    name?: string;
    /**
     * Charge the fee a single time instead of multiplying by the quantity
     * @type {boolean}
     * @memberof CartItemOption
     */
    oneTimeFee?: boolean;
    /**
     * Unique identifier for the option
     * @type {number}
     * @memberof CartItemOption
     */
    optionOid?: number;
    /**
     * True if the customer is required to select a value
     * @type {boolean}
     * @memberof CartItemOption
     */
    required?: boolean;
    /**
     * The value of the option specified by the customer
     * @type {string}
     * @memberof CartItemOption
     */
    selectedValue?: string;
    /**
     * Type of option
     * @type {string}
     * @memberof CartItemOption
     */
    type?: CartItemOption.TypeEnum;
    /**
     * Values that the customer can select from for radio or select type options
     * @type {Array<CartItemOptionValue>}
     * @memberof CartItemOption
     */
    values?: Array<CartItemOptionValue>;
}

/**
 * @export
 * @namespace CartItemOption
 */
export namespace CartItemOption {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}

/**
 * 
 * @export
 * @interface CartItemOptionValue
 */
export interface CartItemOptionValue {
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOptionValue
     */
    additionalCost?: Currency;
    /**
     * 
     * @type {Weight}
     * @memberof CartItemOptionValue
     */
    additionalWeight?: Weight;
    /**
     * True if this is the default value
     * @type {boolean}
     * @memberof CartItemOptionValue
     */
    defaultValue?: boolean;
    /**
     * Display order of the option value
     * @type {number}
     * @memberof CartItemOptionValue
     */
    displayOrder?: number;
    /**
     * Value of the option the customer can select
     * @type {string}
     * @memberof CartItemOptionValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface CartItemPhysical
 */
export interface CartItemPhysical {
    /**
     * 
     * @type {Distance}
     * @memberof CartItemPhysical
     */
    height?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof CartItemPhysical
     */
    length?: Distance;
    /**
     * 
     * @type {Weight}
     * @memberof CartItemPhysical
     */
    weight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof CartItemPhysical
     */
    width?: Distance;
}

/**
 * 
 * @export
 * @interface CartItemVariationSelection
 */
export interface CartItemVariationSelection {
    /**
     * Variation name
     * @type {string}
     * @memberof CartItemVariationSelection
     */
    variationName?: string;
    /**
     * Variation value
     * @type {string}
     * @memberof CartItemVariationSelection
     */
    variationValue?: string;
}

/**
 * 
 * @export
 * @interface CartKitComponentOption
 */
export interface CartKitComponentOption {
    /**
     * 
     * @type {Currency}
     * @memberof CartKitComponentOption
     */
    costIfSpecified?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartKitComponentOption
     */
    costPerLetter?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartKitComponentOption
     */
    costPerLine?: Currency;
    /**
     * True if the default answer is ignored
     * @type {boolean}
     * @memberof CartKitComponentOption
     */
    ignoreIfDefault?: boolean;
    /**
     * Kit component item id
     * @type {string}
     * @memberof CartKitComponentOption
     */
    itemId?: string;
    /**
     * Unique identifier for the kit component item
     * @type {number}
     * @memberof CartKitComponentOption
     */
    itemOid?: number;
    /**
     * Display label for the option
     * @type {string}
     * @memberof CartKitComponentOption
     */
    label?: string;
    /**
     * Name of the option
     * @type {string}
     * @memberof CartKitComponentOption
     */
    name?: string;
    /**
     * Charge the fee a single time instead of multiplying by the quantity
     * @type {boolean}
     * @memberof CartKitComponentOption
     */
    oneTimeFee?: boolean;
    /**
     * Unique identifier for the option
     * @type {number}
     * @memberof CartKitComponentOption
     */
    optionOid?: number;
    /**
     * True if the customer is required to select a value
     * @type {boolean}
     * @memberof CartKitComponentOption
     */
    required?: boolean;
    /**
     * The value of the option specified by the customer
     * @type {string}
     * @memberof CartKitComponentOption
     */
    selectedValue?: string;
    /**
     * Type of option
     * @type {string}
     * @memberof CartKitComponentOption
     */
    type?: CartKitComponentOption.TypeEnum;
    /**
     * Values that the customer can select from for radio or select type options
     * @type {Array<CartItemOptionValue>}
     * @memberof CartKitComponentOption
     */
    values?: Array<CartItemOptionValue>;
}

/**
 * @export
 * @namespace CartKitComponentOption
 */
export namespace CartKitComponentOption {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}

/**
 * 
 * @export
 * @interface CartMarketing
 */
export interface CartMarketing {
    /**
     * The advertising source the customer indicated
     * @type {string}
     * @memberof CartMarketing
     */
    advertisingSource?: string;
    /**
     * True if the customer agrees to receiving marketing emails
     * @type {boolean}
     * @memberof CartMarketing
     */
    mailingListOptIn?: boolean;
}

/**
 * 
 * @export
 * @interface CartPayment
 */
export interface CartPayment {
    /**
     * 
     * @type {CartPaymentAffirm}
     * @memberof CartPayment
     */
    affirm?: CartPaymentAffirm;
    /**
     * 
     * @type {CartPaymentAmazon}
     * @memberof CartPayment
     */
    amazon?: CartPaymentAmazon;
    /**
     * 
     * @type {CartPaymentCheck}
     * @memberof CartPayment
     */
    check?: CartPaymentCheck;
    /**
     * 
     * @type {CartPaymentCreditCard}
     * @memberof CartPayment
     */
    creditCard?: CartPaymentCreditCard;
    /**
     * Payment method
     * @type {string}
     * @memberof CartPayment
     */
    paymentMethod?: string;
    /**
     * 
     * @type {CartPaymentPurchaseOrder}
     * @memberof CartPayment
     */
    purchaseOrder?: CartPaymentPurchaseOrder;
    /**
     * Rotating transaction gateway code
     * @type {string}
     * @memberof CartPayment
     */
    rtgCode?: string;
}

/**
 * 
 * @export
 * @interface CartPaymentAffirm
 */
export interface CartPaymentAffirm {
    /**
     * Affirm checkout token
     * @type {string}
     * @memberof CartPaymentAffirm
     */
    affirmCheckoutToken?: string;
}

/**
 * 
 * @export
 * @interface CartPaymentAmazon
 */
export interface CartPaymentAmazon {
    /**
     * Amazon order reference id
     * @type {string}
     * @memberof CartPaymentAmazon
     */
    amazonOrderReferenceId?: string;
}

/**
 * 
 * @export
 * @interface CartPaymentCheck
 */
export interface CartPaymentCheck {
    /**
     * Check number they are paying with
     * @type {number}
     * @memberof CartPaymentCheck
     */
    checkNumber?: number;
}

/**
 * 
 * @export
 * @interface CartPaymentCreditCard
 */
export interface CartPaymentCreditCard {
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof CartPaymentCreditCard
     */
    cardExpirationMonth?: number;
    /**
     * Card expiration year (four digit year)
     * @type {number}
     * @memberof CartPaymentCreditCard
     */
    cardExpirationYear?: number;
    /**
     * Card number (masked to the last 4)
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    cardNumber?: string;
    /**
     * Hosted field token for the card number
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    cardNumberToken?: string;
    /**
     * Card type
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    cardType?: string;
    /**
     * Card verification number (masked)
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    cardVerificationNumber?: string;
    /**
     * Hosted field token for the card verification number
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    cardVerificationNumberToken?: string;
    /**
     * ID of the stored credit card to use
     * @type {number}
     * @memberof CartPaymentCreditCard
     */
    customerProfileCreditCardId?: number;
    /**
     * True if the customer wants to store the card on their profile for future re-use
     * @type {boolean}
     * @memberof CartPaymentCreditCard
     */
    storeCreditCard?: boolean;
}

/**
 * 
 * @export
 * @interface CartPaymentPurchaseOrder
 */
export interface CartPaymentPurchaseOrder {
    /**
     * Purchase order number
     * @type {string}
     * @memberof CartPaymentPurchaseOrder
     */
    purchaseOrderNumber?: string;
}

/**
 * 
 * @export
 * @interface CartProfileLoginRequest
 */
export interface CartProfileLoginRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileLoginRequest
     */
    cart?: Cart;
    /**
     * Unique identifier for customer profile.  Can not be used with browser key authentication type.
     * @type {number}
     * @memberof CartProfileLoginRequest
     */
    customerProfileOid?: number;
    /**
     * Password for the profile
     * @type {string}
     * @memberof CartProfileLoginRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface CartProfileLoginResponse
 */
export interface CartProfileLoginResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileLoginResponse
     */
    cart?: Cart;
    /**
     * Errors to display to the customer if they failed any of the validations checked
     * @type {Array<string>}
     * @memberof CartProfileLoginResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartProfileRegisterRequest
 */
export interface CartProfileRegisterRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileRegisterRequest
     */
    cart?: Cart;
    /**
     * Password for the profile
     * @type {string}
     * @memberof CartProfileRegisterRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface CartProfileRegisterResponse
 */
export interface CartProfileRegisterResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileRegisterResponse
     */
    cart?: Cart;
    /**
     * Errors to display to the customer if they failed any of the validations checked
     * @type {Array<string>}
     * @memberof CartProfileRegisterResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartProperty
 */
export interface CartProperty {
    /**
     * True if this property is displayed to the customer
     * @type {boolean}
     * @memberof CartProperty
     */
    display?: boolean;
    /**
     * The date/time that the property expires and is deleted
     * @type {string}
     * @memberof CartProperty
     */
    expirationDts?: string;
    /**
     * Name
     * @type {string}
     * @memberof CartProperty
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof CartProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface CartResponse
 */
export interface CartResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartResponse
     */
    cart?: Cart;
    /**
     * Errors that should be displayed to the customer
     * @type {Array<string>}
     * @memberof CartResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartSettings
 */
export interface CartSettings {
    /**
     * 
     * @type {CartSettingsBilling}
     * @memberof CartSettings
     */
    billing?: CartSettingsBilling;
    /**
     * 
     * @type {CartSettingsGift}
     * @memberof CartSettings
     */
    gift?: CartSettingsGift;
    /**
     * 
     * @type {CartSettingsPayment}
     * @memberof CartSettings
     */
    payment?: CartSettingsPayment;
    /**
     * 
     * @type {CartSettingsShipping}
     * @memberof CartSettings
     */
    shipping?: CartSettingsShipping;
    /**
     * 
     * @type {CartSettingsTaxes}
     * @memberof CartSettings
     */
    taxes?: CartSettingsTaxes;
    /**
     * 
     * @type {CartSettingsTerms}
     * @memberof CartSettings
     */
    terms?: CartSettingsTerms;
}

/**
 * 
 * @export
 * @interface CartSettingsBilling
 */
export interface CartSettingsBilling {
    /**
     * Provinces
     * @type {Array<CartSettingsProvince>}
     * @memberof CartSettingsBilling
     */
    provinces?: Array<CartSettingsProvince>;
}

/**
 * 
 * @export
 * @interface CartSettingsGift
 */
export interface CartSettingsGift {
    /**
     * True if this checkout supports gift giving
     * @type {boolean}
     * @memberof CartSettingsGift
     */
    allowGifts?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsGift
     */
    giftCharge?: Currency;
    /**
     * The gift wraps available for the customer to select from
     * @type {Array<CartSettingsGiftWrap>}
     * @memberof CartSettingsGift
     */
    giftWraps?: Array<CartSettingsGiftWrap>;
    /**
     * The maximum length of the gift message the giver can enter
     * @type {number}
     * @memberof CartSettingsGift
     */
    maxMessageLength?: number;
}

/**
 * 
 * @export
 * @interface CartSettingsGiftWrap
 */
export interface CartSettingsGiftWrap {
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsGiftWrap
     */
    cost?: Currency;
    /**
     * Title of the gift wrap
     * @type {string}
     * @memberof CartSettingsGiftWrap
     */
    title?: string;
    /**
     * URL for the sample of the gift wrap
     * @type {string}
     * @memberof CartSettingsGiftWrap
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsPayment
 */
export interface CartSettingsPayment {
    /**
     * 
     * @type {CartSettingsPaymentAmazon}
     * @memberof CartSettingsPayment
     */
    amazon?: CartSettingsPaymentAmazon;
    /**
     * 
     * @type {CartSettingsPaymentCreditCard}
     * @memberof CartSettingsPayment
     */
    creditCard?: CartSettingsPaymentCreditCard;
    /**
     * True if this card requires a payment from the customer
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    needPayment?: boolean;
    /**
     * 
     * @type {CartSettingsPaymentPayPal}
     * @memberof CartSettingsPayment
     */
    paypal?: CartSettingsPaymentPayPal;
    /**
     * True if Amazon payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsAmazon?: boolean;
    /**
     * True if check payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsCheck?: boolean;
    /**
     * True if COD payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsCod?: boolean;
    /**
     * True if credit card payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsCreditCard?: boolean;
    /**
     * True if money order payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsMoneyOrder?: boolean;
    /**
     * True if PayPal payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsPaypal?: boolean;
    /**
     * True if purchase order payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsPurchaseOrder?: boolean;
    /**
     * True if quote requests payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsQuoteRequest?: boolean;
    /**
     * True if wire transfer payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supportsWireTransfer?: boolean;
}

/**
 * 
 * @export
 * @interface CartSettingsPaymentAmazon
 */
export interface CartSettingsPaymentAmazon {
    /**
     * Amazon button URL
     * @type {string}
     * @memberof CartSettingsPaymentAmazon
     */
    amazonButtonUrl?: string;
    /**
     * Amazon merchant ID
     * @type {string}
     * @memberof CartSettingsPaymentAmazon
     */
    amazonMerchantId?: string;
    /**
     * Amazon widget URL
     * @type {string}
     * @memberof CartSettingsPaymentAmazon
     */
    amazonWidgetUrl?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsPaymentCreditCard
 */
export interface CartSettingsPaymentCreditCard {
    /**
     * True if the credit card verification number should be collected
     * @type {boolean}
     * @memberof CartSettingsPaymentCreditCard
     */
    collectCreditCardVerificationNumber?: boolean;
    /**
     * Available credit card types
     * @type {Array<string>}
     * @memberof CartSettingsPaymentCreditCard
     */
    creditCardTypes?: Array<string>;
    /**
     * The shoppingCartToken needed for proper initialization of hosted fields collection
     * @type {string}
     * @memberof CartSettingsPaymentCreditCard
     */
    hostedFieldsShoppingCartToken?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsPaymentPayPal
 */
export interface CartSettingsPaymentPayPal {
    /**
     * PayPal button alt text
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypalButtonAltText?: string;
    /**
     * PayPal button URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypalButtonUrl?: string;
    /**
     * PayPal Credit button URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypalCreditButtonUrl?: string;
    /**
     * PayPal Credit legal image URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypalCreditLegalImageUrl?: string;
    /**
     * PayPal Credit legal URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypalCreditLegalUrl?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsProvince
 */
export interface CartSettingsProvince {
    /**
     * 
     * @type {string}
     * @memberof CartSettingsProvince
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof CartSettingsProvince
     */
    province?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsShipping
 */
export interface CartSettingsShipping {
    /**
     * 
     * @type {CartSettingsShippingCalendar}
     * @memberof CartSettingsShipping
     */
    deliverOnDate?: CartSettingsShippingCalendar;
    /**
     * Estimates for this cart
     * @type {Array<CartSettingsShippingEstimate>}
     * @memberof CartSettingsShipping
     */
    estimates?: Array<CartSettingsShippingEstimate>;
    /**
     * True if this order needs shipping
     * @type {boolean}
     * @memberof CartSettingsShipping
     */
    needShipping?: boolean;
    /**
     * Provinces
     * @type {Array<CartSettingsProvince>}
     * @memberof CartSettingsShipping
     */
    provinces?: Array<CartSettingsProvince>;
    /**
     * 
     * @type {CartSettingsShippingCalendar}
     * @memberof CartSettingsShipping
     */
    shipOnDate?: CartSettingsShippingCalendar;
}

/**
 * 
 * @export
 * @interface CartSettingsShippingCalendar
 */
export interface CartSettingsShippingCalendar {
    /**
     * Specified dates that are blacked out on the calendar in ISO8601 format
     * @type {Array<string>}
     * @memberof CartSettingsShippingCalendar
     */
    blackouts?: Array<string>;
    /**
     * Days of week that should be enabled on the calendar (0 - Sunday through 6 - Saturday)
     * @type {Array<boolean>}
     * @memberof CartSettingsShippingCalendar
     */
    daysOfWeek?: Array<boolean>;
    /**
     * The earliest date that can be selected on the calendar
     * @type {string}
     * @memberof CartSettingsShippingCalendar
     */
    earliest?: string;
    /**
     * True if the customer is required to select a date
     * @type {boolean}
     * @memberof CartSettingsShippingCalendar
     */
    require?: boolean;
    /**
     * True if this calendar should be shown to the customer
     * @type {boolean}
     * @memberof CartSettingsShippingCalendar
     */
    show?: boolean;
}

/**
 * 
 * @export
 * @interface CartSettingsShippingEstimate
 */
export interface CartSettingsShippingEstimate {
    /**
     * True if this method allows the customer to use their own shipper account number
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    allow3rdPartyBilling?: boolean;
    /**
     * Comment to display to the customer about this method
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    comment?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    cost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    costBeforeDiscount?: Currency;
    /**
     * True if this is the default method
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    defaultMethod?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    discount?: Currency;
    /**
     * True if this method is discounted because of a coupon
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    discounted?: boolean;
    /**
     * The name to display to the customer
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    displayName?: string;
    /**
     * Date of the estimated delivery (or range)
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    estimatedDelivery?: string;
    /**
     * True if a lift gate option for this method should be offered to the customer
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    liftGateOption?: boolean;
    /**
     * Shipping method name
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    name?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    tax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    totalTax?: Currency;
}

/**
 * 
 * @export
 * @interface CartSettingsTaxes
 */
export interface CartSettingsTaxes {
    /**
     * 
     * @type {Array<string>}
     * @memberof CartSettingsTaxes
     */
    counties?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartSettingsTerms
 */
export interface CartSettingsTerms {
    /**
     * HTML version of the terms
     * @type {string}
     * @memberof CartSettingsTerms
     */
    html?: string;
    /**
     * Text version of the terms.
     * @type {string}
     * @memberof CartSettingsTerms
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface CartShipping
 */
export interface CartShipping {
    /**
     * Address line 1
     * @type {string}
     * @memberof CartShipping
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CartShipping
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CartShipping
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CartShipping
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CartShipping
     */
    countryCode?: string;
    /**
     * Day time phone
     * @type {string}
     * @memberof CartShipping
     */
    dayPhone?: string;
    /**
     * Date the customer is requesting delivery on. Typically used for perishable product delivery.
     * @type {string}
     * @memberof CartShipping
     */
    deliveryDate?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof CartShipping
     */
    eveningPhone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CartShipping
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CartShipping
     */
    lastName?: string;
    /**
     * Lift gate requested (LTL shipping methods only)
     * @type {boolean}
     * @memberof CartShipping
     */
    liftGate?: boolean;
    /**
     * Postal code
     * @type {string}
     * @memberof CartShipping
     */
    postalCode?: string;
    /**
     * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
     * @type {string}
     * @memberof CartShipping
     */
    shipOnDate?: string;
    /**
     * True if the shipping adress is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
     * @type {boolean}
     * @memberof CartShipping
     */
    shipToResidential?: boolean;
    /**
     * 3rd party account number to ship against for UPS or FedEx
     * @type {string}
     * @memberof CartShipping
     */
    shipping3rdPartyAccountNumber?: string;
    /**
     * Shipping method
     * @type {string}
     * @memberof CartShipping
     */
    shippingMethod?: string;
    /**
     * Special instructions from the customer regarding shipping
     * @type {string}
     * @memberof CartShipping
     */
    specialInstructions?: string;
    /**
     * State/Region
     * @type {string}
     * @memberof CartShipping
     */
    stateRegion?: string;
    /**
     * Title
     * @type {string}
     * @memberof CartShipping
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CartSummary
 */
export interface CartSummary {
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitraryShippingHandlingTotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitraryTax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitraryTaxRate?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitraryTaxableSubtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    shippingHandling?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    shippingHandlingDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    shippingHandlingWithDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    subtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    subtotalDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    subtotalWithDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    surcharge?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    tax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    taxableSubtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    taxableSubtotalDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    taxableSubtotalWithDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    total?: Currency;
}

/**
 * 
 * @export
 * @interface CartTaxes
 */
export interface CartTaxes {
    /**
     * Tax county if the state requires it.
     * @type {string}
     * @memberof CartTaxes
     */
    county?: string;
    /**
     * True if tax exempt
     * @type {boolean}
     * @memberof CartTaxes
     */
    exempt?: boolean;
    /**
     * Tax rate
     * @type {number}
     * @memberof CartTaxes
     */
    rate?: number;
}

/**
 * 
 * @export
 * @interface CartUpsellAfter
 */
export interface CartUpsellAfter {
    /**
     * The date/time after which the cart will finalize into an order.
     * @type {string}
     * @memberof CartUpsellAfter
     */
    finalizeAfterDts?: string;
    /**
     * The amount of inactivity in minutes after which the cart should be finalized into an order.  This will calculate the finalize_after_dts field.
     * @type {number}
     * @memberof CartUpsellAfter
     */
    finalizeAfterMinutes?: number;
    /**
     * Upsell path code
     * @type {string}
     * @memberof CartUpsellAfter
     */
    upsellPathCode?: string;
}

/**
 * 
 * @export
 * @interface CartValidationRequest
 */
export interface CartValidationRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartValidationRequest
     */
    cart?: Cart;
    /**
     * Checks to perform
     * @type {Array<string>}
     * @memberof CartValidationRequest
     */
    checks?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartValidationResponse
 */
export interface CartValidationResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartValidationResponse
     */
    cart?: Cart;
    /**
     * Errors to display to the customer if they failed any of the validations checked
     * @type {Array<string>}
     * @memberof CartValidationResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface ChargebackDispute
 */
export interface ChargebackDispute {
    /**
     * Account number
     * @type {string}
     * @memberof ChargebackDispute
     */
    accountNumber?: string;
    /**
     * Adjustment request text
     * @type {string}
     * @memberof ChargebackDispute
     */
    adjustmentRequestText?: string;
    /**
     * Amount
     * @type {number}
     * @memberof ChargebackDispute
     */
    amount?: number;
    /**
     * Auth code
     * @type {string}
     * @memberof ChargebackDispute
     */
    authCode?: string;
    /**
     * Case number
     * @type {string}
     * @memberof ChargebackDispute
     */
    caseNumber?: string;
    /**
     * Chargeback Dispute Oid
     * @type {number}
     * @memberof ChargebackDispute
     */
    chargebackDisputeOid?: number;
    /**
     * Chargeback dts
     * @type {string}
     * @memberof ChargebackDispute
     */
    chargebackDts?: string;
    /**
     * Currency
     * @type {string}
     * @memberof ChargebackDispute
     */
    currency?: string;
    /**
     * Customer care notes
     * @type {string}
     * @memberof ChargebackDispute
     */
    customerCareNotes?: string;
    /**
     * Encryption key
     * @type {string}
     * @memberof ChargebackDispute
     */
    encryptionKey?: string;
    /**
     * Expiration Dts
     * @type {string}
     * @memberof ChargebackDispute
     */
    expirationDts?: string;
    /**
     * Fax failure reason
     * @type {string}
     * @memberof ChargebackDispute
     */
    faxFailureReason?: string;
    /**
     * Fax number
     * @type {string}
     * @memberof ChargebackDispute
     */
    faxNumber?: string;
    /**
     * Fax transaction id
     * @type {number}
     * @memberof ChargebackDispute
     */
    faxTransactionId?: number;
    /**
     * icsid
     * @type {string}
     * @memberof ChargebackDispute
     */
    icsid?: string;
    /**
     * Merchant account profile oid
     * @type {number}
     * @memberof ChargebackDispute
     */
    merchantAccountProfileOid?: number;
    /**
     * 
     * @type {Order}
     * @memberof ChargebackDispute
     */
    order?: Order;
    /**
     * Order Id
     * @type {string}
     * @memberof ChargebackDispute
     */
    orderId?: string;
    /**
     * Partial card number
     * @type {string}
     * @memberof ChargebackDispute
     */
    partialCardNumber?: string;
    /**
     * PDF file oid
     * @type {string}
     * @memberof ChargebackDispute
     */
    pdfFileOid?: string;
    /**
     * Reason code
     * @type {string}
     * @memberof ChargebackDispute
     */
    reasonCode?: string;
    /**
     * Status
     * @type {string}
     * @memberof ChargebackDispute
     */
    status?: string;
    /**
     * Website URL
     * @type {string}
     * @memberof ChargebackDispute
     */
    websiteUrl?: string;
}

/**
 * 
 * @export
 * @interface ChargebackDisputeResponse
 */
export interface ChargebackDisputeResponse {
    /**
     * 
     * @type {ChargebackDispute}
     * @memberof ChargebackDisputeResponse
     */
    chargeback?: ChargebackDispute;
    /**
     * 
     * @type {Error}
     * @memberof ChargebackDisputeResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ChargebackDisputeResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ChargebackDisputeResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ChargebackDisputeResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ChargebackDisputesResponse
 */
export interface ChargebackDisputesResponse {
    /**
     * 
     * @type {Array<ChargebackDispute>}
     * @memberof ChargebackDisputesResponse
     */
    chargebacks?: Array<ChargebackDispute>;
    /**
     * 
     * @type {Error}
     * @memberof ChargebackDisputesResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ChargebackDisputesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ChargebackDisputesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ChargebackDisputesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CheckoutAllowedCountriesResponse
 */
export interface CheckoutAllowedCountriesResponse {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CheckoutAllowedCountriesResponse
     */
    countries?: Array<Country>;
}

/**
 * 
 * @export
 * @interface CheckoutHandoffRequest
 */
export interface CheckoutHandoffRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CheckoutHandoffRequest
     */
    cart?: Cart;
    /**
     * If any error happen during the processing on the UltraCart side, the browser will be redirected to your error_return_url with the error passed in this parameter name.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    errorParameterName?: string;
    /**
     * The URL to return the browser to if there are processing errors on the UltraCart side.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    errorReturnUrl?: string;
    /**
     * The type of handoff operation to perform
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    operation?: CheckoutHandoffRequest.OperationEnum;
    /**
     * The maximum amount of revenue that you think the customer could add during a custom upsell after sequence on your checkout.
     * @type {number}
     * @memberof CheckoutHandoffRequest
     */
    paypalMaximumUpsellRevenue?: number;
    /**
     * The URl to return the customers browser to after they have completed the PayPal process.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    paypalReturnUrl?: string;
    /**
     * The desired secure host name to perform the handoff on.  This should match the desired StoreFront.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    secureHostName?: string;
    /**
     * The UltraCart Analytics cookie value.  Populate this if you're handing off from a different domain than the checkout.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    ucacid?: string;
}

/**
 * @export
 * @namespace CheckoutHandoffRequest
 */
export namespace CheckoutHandoffRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Checkout = <any> 'checkout',
        PayPal = <any> 'payPal',
        PayPalCredit = <any> 'payPalCredit',
        View = <any> 'view',
        Affirm = <any> 'affirm'
    }
}

/**
 * 
 * @export
 * @interface CheckoutHandoffResponse
 */
export interface CheckoutHandoffResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CheckoutHandoffResponse
     */
    cart?: Cart;
    /**
     * Errors that occurred which are preventing the handoff operation.  Display these to the customer.
     * @type {Array<string>}
     * @memberof CheckoutHandoffResponse
     */
    errors?: Array<string>;
    /**
     * The URL that you should redirect the customers browser to
     * @type {string}
     * @memberof CheckoutHandoffResponse
     */
    redirectToUrl?: string;
}

/**
 * 
 * @export
 * @interface CheckoutSetupBrowserKeyRequest
 */
export interface CheckoutSetupBrowserKeyRequest {
    /**
     * Allowed referrers.  If URLs are specified, automatic translation will convert them to proper allowed referrer maskes.
     * @type {Array<string>}
     * @memberof CheckoutSetupBrowserKeyRequest
     */
    allowedReferrers?: Array<string>;
}

/**
 * 
 * @export
 * @interface CheckoutSetupBrowserKeyResponse
 */
export interface CheckoutSetupBrowserKeyResponse {
    /**
     * Browser key that is used to authenticate against the new linked application.
     * @type {string}
     * @memberof CheckoutSetupBrowserKeyResponse
     */
    browserKey?: string;
}

/**
 * 
 * @export
 * @interface CheckoutStateProvinceResponse
 */
export interface CheckoutStateProvinceResponse {
    /**
     * 
     * @type {Array<StateProvince>}
     * @memberof CheckoutStateProvinceResponse
     */
    stateProvinces?: Array<StateProvince>;
}

/**
 * 
 * @export
 * @interface CityStateZip
 */
export interface CityStateZip {
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    state?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CityStateZip
     */
    validZip?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface CountriesResponse
 */
export interface CountriesResponse {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CountriesResponse
     */
    countries?: Array<Country>;
}

/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * iso_2_code
     * @type {string}
     * @memberof Country
     */
    iso2Code?: string;
    /**
     * name
     * @type {string}
     * @memberof Country
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * Associates an order with an affiliate when this value is set.
     * @type {number}
     * @memberof Coupon
     */
    affiliateOid?: number;
    /**
     * True if multiple one time codes for this coupon can be used on a cart at the same time.
     * @type {boolean}
     * @memberof Coupon
     */
    allowMultipleOneTimeCodes?: boolean;
    /**
     * 
     * @type {CouponAmountOffItems}
     * @memberof Coupon
     */
    amountOffItems?: CouponAmountOffItems;
    /**
     * 
     * @type {CouponAmountOffShipping}
     * @memberof Coupon
     */
    amountOffShipping?: CouponAmountOffShipping;
    /**
     * 
     * @type {CouponAmountOffShippingWithItemsPurchase}
     * @memberof Coupon
     */
    amountOffShippingWithItemsPurchase?: CouponAmountOffShippingWithItemsPurchase;
    /**
     * 
     * @type {CouponAmountOffSubtotal}
     * @memberof Coupon
     */
    amountOffSubtotal?: CouponAmountOffSubtotal;
    /**
     * 
     * @type {CouponAmountOffSubtotalFreeShippingWithPurchase}
     * @memberof Coupon
     */
    amountOffSubtotalAndFreeShipping?: CouponAmountOffSubtotalFreeShippingWithPurchase;
    /**
     * 
     * @type {CouponAmountOffSubtotalAndShipping}
     * @memberof Coupon
     */
    amountOffSubtotalAndShipping?: CouponAmountOffSubtotalAndShipping;
    /**
     * 
     * @type {CouponAmountOffSubtotalWithBlockPurchase}
     * @memberof Coupon
     */
    amountOffSubtotalWithBlockPurchase?: CouponAmountOffSubtotalWithBlockPurchase;
    /**
     * 
     * @type {CouponAmountOffSubtotalWithItemsPurchase}
     * @memberof Coupon
     */
    amountOffSubtotalWithItemsPurchase?: CouponAmountOffSubtotalWithItemsPurchase;
    /**
     * 
     * @type {CouponAutomaticallyApplyCouponCodes}
     * @memberof Coupon
     */
    automaticallyApplyCouponCodes?: CouponAutomaticallyApplyCouponCodes;
    /**
     * Calculated description displayed to the customer if no description is specified.
     * @type {string}
     * @memberof Coupon
     */
    calculatedDescription?: string;
    /**
     * True if this coupon can be used with other coupons in a single order.
     * @type {boolean}
     * @memberof Coupon
     */
    canBeUsedWithOtherCoupons?: boolean;
    /**
     * Coupon oid.
     * @type {number}
     * @memberof Coupon
     */
    couponOid?: number;
    /**
     * Coupon type.
     * @type {string}
     * @memberof Coupon
     */
    couponType?: string;
    /**
     * Description of the coupon up to 50 characters.
     * @type {string}
     * @memberof Coupon
     */
    description?: string;
    /**
     * 
     * @type {CouponDiscountItemWithItemPurchase}
     * @memberof Coupon
     */
    discountItemWithItemPurchase?: CouponDiscountItemWithItemPurchase;
    /**
     * 
     * @type {CouponDiscountItems}
     * @memberof Coupon
     */
    discountItems?: CouponDiscountItems;
    /**
     * Date/time when coupon expires
     * @type {string}
     * @memberof Coupon
     */
    expirationDts?: string;
    /**
     * 
     * @type {CouponFreeItemAndShippingWithSubtotal}
     * @memberof Coupon
     */
    freeItemAndShippingWithSubtotal?: CouponFreeItemAndShippingWithSubtotal;
    /**
     * 
     * @type {CouponFreeItemWithItemPurchase}
     * @memberof Coupon
     */
    freeItemWithItemPurchase?: CouponFreeItemWithItemPurchase;
    /**
     * 
     * @type {CouponFreeItemWithSubtotal}
     * @memberof Coupon
     */
    freeItemWithSubtotal?: CouponFreeItemWithSubtotal;
    /**
     * 
     * @type {CouponFreeItemsWithItemPurchase}
     * @memberof Coupon
     */
    freeItemsWithItemPurchase?: CouponFreeItemsWithItemPurchase;
    /**
     * 
     * @type {CouponFreeItemsWithMixMatchPurchase}
     * @memberof Coupon
     */
    freeItemsWithMixmatchPurchase?: CouponFreeItemsWithMixMatchPurchase;
    /**
     * 
     * @type {CouponFreeShipping}
     * @memberof Coupon
     */
    freeShipping?: CouponFreeShipping;
    /**
     * 
     * @type {CouponFreeShippingSpecificItems}
     * @memberof Coupon
     */
    freeShippingSpecificItems?: CouponFreeShippingSpecificItems;
    /**
     * 
     * @type {CouponFreeShippingWithItemsPurchase}
     * @memberof Coupon
     */
    freeShippingWithItemsPurchase?: CouponFreeShippingWithItemsPurchase;
    /**
     * 
     * @type {CouponFreeShippingWithSubtotal}
     * @memberof Coupon
     */
    freeShippingWithSubtotal?: CouponFreeShippingWithSubtotal;
    /**
     * Merchant code of coupon up to 20 characters.
     * @type {string}
     * @memberof Coupon
     */
    merchantCode?: string;
    /**
     * Internal notes about this coupon.  These are not visible to customer.
     * @type {string}
     * @memberof Coupon
     */
    merchantNotes?: string;
    /**
     * 
     * @type {CouponMultipleAmountsOffItems}
     * @memberof Coupon
     */
    multipleAmountsOffItems?: CouponMultipleAmountsOffItems;
    /**
     * 
     * @type {CouponNoDiscount}
     * @memberof Coupon
     */
    noDiscount?: CouponNoDiscount;
    /**
     * 
     * @type {CouponPercentOffItemWithItemsQuantityPurchase}
     * @memberof Coupon
     */
    percentOffItemWithItemsQuantityPurchase?: CouponPercentOffItemWithItemsQuantityPurchase;
    /**
     * 
     * @type {CouponPercentOffItems}
     * @memberof Coupon
     */
    percentOffItems?: CouponPercentOffItems;
    /**
     * 
     * @type {CouponPercentOffItemsAndFreeShipping}
     * @memberof Coupon
     */
    percentOffItemsAndFreeShipping?: CouponPercentOffItemsAndFreeShipping;
    /**
     * 
     * @type {CouponPercentOffItemsWithItemsPurchase}
     * @memberof Coupon
     */
    percentOffItemsWithItemsPurchase?: CouponPercentOffItemsWithItemsPurchase;
    /**
     * 
     * @type {CouponPercentOffRetailPriceItems}
     * @memberof Coupon
     */
    percentOffRetailPriceItems?: CouponPercentOffRetailPriceItems;
    /**
     * 
     * @type {CouponPercentOffShipping}
     * @memberof Coupon
     */
    percentOffShipping?: CouponPercentOffShipping;
    /**
     * 
     * @type {CouponPercentOffSubtotal}
     * @memberof Coupon
     */
    percentOffSubtotal?: CouponPercentOffSubtotal;
    /**
     * 
     * @type {CouponPercentOffSubtotalAndFreeShipping}
     * @memberof Coupon
     */
    percentOffSubtotalAndFreeShipping?: CouponPercentOffSubtotalAndFreeShipping;
    /**
     * 
     * @type {CouponPercentOffSubtotalLimit}
     * @memberof Coupon
     */
    percentOffSubtotalLimit?: CouponPercentOffSubtotalLimit;
    /**
     * 
     * @type {CouponPercentOffSubtotalWithItemsPurchase}
     * @memberof Coupon
     */
    percentOffSubtotalWithItemsPurchase?: CouponPercentOffSubtotalWithItemsPurchase;
    /**
     * 
     * @type {CouponPercentOffSubtotalWithSubtotal}
     * @memberof Coupon
     */
    percentOffSubtotalWithSubtotal?: CouponPercentOffSubtotalWithSubtotal;
    /**
     * Quickbooks accounting code.
     * @type {string}
     * @memberof Coupon
     */
    quickbooksCode?: string;
    /**
     * Optional list of postal codes which restrict a coupon to within these postal codes.
     * @type {Array<string>}
     * @memberof Coupon
     */
    restrictByPostalCodes?: Array<string>;
    /**
     * Optional list of legacy screen branding theme codes to limit coupon use to only those themes.
     * @type {Array<CouponRestriction>}
     * @memberof Coupon
     */
    restrictByScreenBrandingThemeCodes?: Array<CouponRestriction>;
    /**
     * Optional list of storefronts to limit coupon use to only those storefronts.
     * @type {Array<CouponRestriction>}
     * @memberof Coupon
     */
    restrictByStorefronts?: Array<CouponRestriction>;
    /**
     * Date/time when coupon is valid
     * @type {string}
     * @memberof Coupon
     */
    startDts?: string;
    /**
     * 
     * @type {CouponTieredAmountOffItem}
     * @memberof Coupon
     */
    tieredAmountOffItem?: CouponTieredAmountOffItem;
    /**
     * 
     * @type {CouponTieredAmountOffSubtotal}
     * @memberof Coupon
     */
    tieredAmountOffSubtotal?: CouponTieredAmountOffSubtotal;
    /**
     * 
     * @type {CouponTieredPercentOffItems}
     * @memberof Coupon
     */
    tieredPercentOffItems?: CouponTieredPercentOffItems;
    /**
     * 
     * @type {CouponTieredPercentOffShipping}
     * @memberof Coupon
     */
    tieredPercentOffShipping?: CouponTieredPercentOffShipping;
    /**
     * 
     * @type {CouponTieredPercentOffSubtotal}
     * @memberof Coupon
     */
    tieredPercentOffSubtotal?: CouponTieredPercentOffSubtotal;
    /**
     * Who may use this coupon.
     * @type {string}
     * @memberof Coupon
     */
    usableBy?: string;
}

/**
 * 
 * @export
 * @interface CouponAmountOffItems
 */
export interface CouponAmountOffItems {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffItems
     */
    currencyCode?: string;
    /**
     * The amount of shipping discount
     * @type {number}
     * @memberof CouponAmountOffItems
     */
    discountAmount?: number;
    /**
     * A list of items which are eligible for the discount amount.
     * @type {Array<string>}
     * @memberof CouponAmountOffItems
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponAmountOffShipping
 */
export interface CouponAmountOffShipping {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffShipping
     */
    currencyCode?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffShipping
     */
    discountAmount?: number;
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponAmountOffShipping
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponAmountOffShippingWithItemsPurchase
 */
export interface CouponAmountOffShippingWithItemsPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    currencyCode?: string;
    /**
     * The amount of shipping discount
     * @type {number}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    discountAmount?: number;
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * One or more shipping methods that may receive this discount
     * @type {Array<string>}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotal
 */
export interface CouponAmountOffSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotal
     */
    currencyCode?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotal
     */
    discountAmount?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalAndShipping
 */
export interface CouponAmountOffSubtotalAndShipping {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalAndShipping
     */
    currencyCode?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalAndShipping
     */
    discountAmount?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalFreeShippingWithPurchase
 */
export interface CouponAmountOffSubtotalFreeShippingWithPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    currencyCode?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    discountAmount?: number;
    /**
     * The purchase amount to qualify for subtotal discount and free shipping
     * @type {number}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    purchaseAmount?: number;
    /**
     * One or more shipping methods that may be free
     * @type {Array<string>}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalWithBlockPurchase
 */
export interface CouponAmountOffSubtotalWithBlockPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    currencyCode?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    discountAmount?: number;
    /**
     * Required item that must be purchased for coupon to be valid
     * @type {string}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    requiredPurchaseItem?: string;
    /**
     * Discount amount is multiplied by the number of blocks.  A block is this many quantity of the required item.
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    requiredPurchaseQuantity?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalWithItemsPurchase
 */
export interface CouponAmountOffSubtotalWithItemsPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    currencyCode?: string;
    /**
     * The amount of shipping discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    discountAmount?: number;
    /**
     * A list of items of which a quantity of one or many must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * The quantity of items that must be purchased for the discount to be applied.
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    requiredPurchaseQuantity?: number;
}

/**
 * 
 * @export
 * @interface CouponAutomaticallyApplyCouponCodes
 */
export interface CouponAutomaticallyApplyCouponCodes {
    /**
     * The coupon codes to automatically apply if this coupon is applied
     * @type {Array<string>}
     * @memberof CouponAutomaticallyApplyCouponCodes
     */
    couponCodes?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponCodesRequest
 */
export interface CouponCodesRequest {
    /**
     * 
     * @type {Error}
     * @memberof CouponCodesRequest
     */
    error?: Error;
    /**
     * Expiration Date
     * @type {string}
     * @memberof CouponCodesRequest
     */
    expirationDts?: string;
    /**
     * Expiration seconds
     * @type {number}
     * @memberof CouponCodesRequest
     */
    expirationSeconds?: number;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponCodesRequest
     */
    metadata?: ResponseMetadata;
    /**
     * Quantity
     * @type {number}
     * @memberof CouponCodesRequest
     */
    quantity?: number;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponCodesRequest
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponCodesRequest
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponCodesResponse
 */
export interface CouponCodesResponse {
    /**
     * Coupon codes
     * @type {Array<string>}
     * @memberof CouponCodesResponse
     */
    couponCodes?: Array<string>;
    /**
     * 
     * @type {Error}
     * @memberof CouponCodesResponse
     */
    error?: Error;
    /**
     * Expiration date
     * @type {string}
     * @memberof CouponCodesResponse
     */
    expirationDts?: string;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponCodesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponCodesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponCodesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponDiscountItemWithItemPurchase
 */
export interface CouponDiscountItemWithItemPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    currencyCode?: string;
    /**
     * The item that will be sold at the discount_price when required_purchase_item is purchased.
     * @type {string}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    discountItem?: string;
    /**
     * The price (unit cost) of the discounted item
     * @type {number}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    discountPrice?: number;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    limit?: number;
    /**
     * The item that must be purchased for the discount to be applied to the discount item.
     * @type {string}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    requiredPurchaseItem?: string;
}

/**
 * 
 * @export
 * @interface CouponDiscountItems
 */
export interface CouponDiscountItems {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponDiscountItems
     */
    currencyCode?: string;
    /**
     * The price (unit cost) of the discounted item
     * @type {number}
     * @memberof CouponDiscountItems
     */
    discountPrice?: number;
    /**
     * A list of items that are eligible for this discount_price.
     * @type {Array<string>}
     * @memberof CouponDiscountItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponDiscountItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponEditorValues
 */
export interface CouponEditorValues {
    /**
     * coupon_types
     * @type {Array<string>}
     * @memberof CouponEditorValues
     */
    couponTypes?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeItemAndShippingWithSubtotal
 */
export interface CouponFreeItemAndShippingWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    currencyCode?: string;
    /**
     * A list of items that are eligible for this discount_price.
     * @type {Array<string>}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    items?: Array<string>;
    /**
     * The limit of free items that may be received when purchasing multiple items
     * @type {number}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    limit?: number;
    /**
     * One or more shipping methods that may be free
     * @type {Array<string>}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    shippingMethods?: Array<string>;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    subtotalAmount?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeItemWithItemPurchase
 */
export interface CouponFreeItemWithItemPurchase {
    /**
     * A list of free items which will receive a discount if one of the required purchase items is purchased.
     * @type {Array<string>}
     * @memberof CouponFreeItemWithItemPurchase
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponFreeItemWithItemPurchase
     */
    limit?: number;
    /**
     * If true then the free item is matched 1:1 with the free item in the list.
     * @type {boolean}
     * @memberof CouponFreeItemWithItemPurchase
     */
    matchRequiredPurchaseItemToFreeItem?: boolean;
    /**
     * Required items (at least one from the list) that must be purchased for coupon to be valid
     * @type {Array<string>}
     * @memberof CouponFreeItemWithItemPurchase
     */
    requiredPurchaseItems?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeItemWithSubtotal
 */
export interface CouponFreeItemWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponFreeItemWithSubtotal
     */
    currencyCode?: string;
    /**
     * A list of items that are eligible for this discount_price.
     * @type {Array<string>}
     * @memberof CouponFreeItemWithSubtotal
     */
    items?: Array<string>;
    /**
     * The limit of free items that may be received when purchasing multiple items
     * @type {number}
     * @memberof CouponFreeItemWithSubtotal
     */
    limit?: number;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponFreeItemWithSubtotal
     */
    subtotalAmount?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeItemsWithItemPurchase
 */
export interface CouponFreeItemsWithItemPurchase {
    /**
     * The item id of the free item that will be received when the required mix and match group quantity is purchased.
     * @type {string}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    freeItem?: string;
    /**
     * The quantity of free item that will be received.
     * @type {number}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    freeQuantity?: number;
    /**
     * The limit of free items that may be received when purchasing multiple items
     * @type {number}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    limit?: number;
    /**
     * Required item that must be purchased for coupon to be valid
     * @type {string}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    requiredPurchaseItem?: string;
    /**
     * Required quantity of mix and match group items that must be purchased for coupon to be valid
     * @type {number}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    requiredPurchaseQuantity?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeItemsWithMixMatchPurchase
 */
export interface CouponFreeItemsWithMixMatchPurchase {
    /**
     * The item id of the free item that will be received when the required mix and match group quantity is purchased.
     * @type {string}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    freeItem?: string;
    /**
     * The quantity of free item that will be received.
     * @type {number}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    freeQuantity?: number;
    /**
     * The limit of free items that may be received when purchasing multiple mix and match group items
     * @type {number}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    limit?: number;
    /**
     * Required mix and match group that must be purchased for coupon to be valid
     * @type {string}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    requiredPurchaseMixAndMatchGroup?: string;
    /**
     * Required quantity of mix and match group items that must be purchased for coupon to be valid
     * @type {number}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    requiredPurchaseQuantity?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeShipping
 */
export interface CouponFreeShipping {
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponFreeShipping
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeShippingSpecificItems
 */
export interface CouponFreeShippingSpecificItems {
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponFreeShippingSpecificItems
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeShippingWithItemsPurchase
 */
export interface CouponFreeShippingWithItemsPurchase {
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponFreeShippingWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * One or more shipping methods that may receive this discount
     * @type {Array<string>}
     * @memberof CouponFreeShippingWithItemsPurchase
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeShippingWithSubtotal
 */
export interface CouponFreeShippingWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponFreeShippingWithSubtotal
     */
    currencyCode?: string;
    /**
     * The purchase amount to qualify for subtotal discount and free shipping
     * @type {number}
     * @memberof CouponFreeShippingWithSubtotal
     */
    purchaseAmount?: number;
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponFreeShippingWithSubtotal
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponMultipleAmountsOffItems
 */
export interface CouponMultipleAmountsOffItems {
    /**
     * A list of item discounts.
     * @type {Array<CouponTierItemDiscount>}
     * @memberof CouponMultipleAmountsOffItems
     */
    discounts?: Array<CouponTierItemDiscount>;
    /**
     * The (optional) maximum quantity of items that may receive a discount.
     * @type {number}
     * @memberof CouponMultipleAmountsOffItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponNoDiscount
 */
export interface CouponNoDiscount {
}

/**
 * 
 * @export
 * @interface CouponPercentOffItemWithItemsQuantityPurchase
 */
export interface CouponPercentOffItemWithItemsQuantityPurchase {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    discountPercent?: number;
    /**
     * A list of items which will receive a discount if one of the required purchase items is purchased.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    limit?: number;
    /**
     * Required items (at least one from the list) that must be purchased for coupon to be valid
     * @type {Array<string>}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    requiredPurchaseItems?: Array<string>;
    /**
     * The quantity of items that must be purchased for the discount to be applied.
     * @type {number}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    requiredPurchaseQuantity?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffItems
 */
export interface CouponPercentOffItems {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItems
     */
    discountPercent?: number;
    /**
     * A list of items which cannot be discounted.
     * @type {Array<string>}
     * @memberof CouponPercentOffItems
     */
    excludedItems?: Array<string>;
    /**
     * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
     * @type {Array<string>}
     * @memberof CouponPercentOffItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffItemsAndFreeShipping
 */
export interface CouponPercentOffItemsAndFreeShipping {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItemsAndFreeShipping
     */
    discountPercent?: number;
    /**
     * A list of items which cannot be discounted.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsAndFreeShipping
     */
    excludedItems?: Array<string>;
    /**
     * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsAndFreeShipping
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffItemsWithItemsPurchase
 */
export interface CouponPercentOffItemsWithItemsPurchase {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    discountPercent?: number;
    /**
     * A list of items which will receive a discount if one of the required purchase items is purchased.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    limit?: number;
    /**
     * Required items (at least one from the list) that must be purchased for coupon to be valid
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    requiredPurchaseItems?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffRetailPriceItems
 */
export interface CouponPercentOffRetailPriceItems {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffRetailPriceItems
     */
    discountPercent?: number;
    /**
     * A list of items which cannot be discounted.
     * @type {Array<string>}
     * @memberof CouponPercentOffRetailPriceItems
     */
    excludedItems?: Array<string>;
    /**
     * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
     * @type {Array<string>}
     * @memberof CouponPercentOffRetailPriceItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffRetailPriceItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffShipping
 */
export interface CouponPercentOffShipping {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffShipping
     */
    discountPercent?: number;
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponPercentOffShipping
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotal
 */
export interface CouponPercentOffSubtotal {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotal
     */
    discountPercent?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalAndFreeShipping
 */
export interface CouponPercentOffSubtotalAndFreeShipping {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalAndFreeShipping
     */
    discountPercent?: number;
    /**
     * One or more shipping methods that may be free
     * @type {Array<string>}
     * @memberof CouponPercentOffSubtotalAndFreeShipping
     */
    shippingMethods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalLimit
 */
export interface CouponPercentOffSubtotalLimit {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponPercentOffSubtotalLimit
     */
    currencyCode?: string;
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalLimit
     */
    discountPercent?: number;
    /**
     * The maximum amount of subtotal used to determine discount.
     * @type {number}
     * @memberof CouponPercentOffSubtotalLimit
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalWithItemsPurchase
 */
export interface CouponPercentOffSubtotalWithItemsPurchase {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalWithItemsPurchase
     */
    discountPercent?: number;
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponPercentOffSubtotalWithItemsPurchase
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalWithSubtotal
 */
export interface CouponPercentOffSubtotalWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponPercentOffSubtotalWithSubtotal
     */
    currencyCode?: string;
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalWithSubtotal
     */
    discountPercent?: number;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponPercentOffSubtotalWithSubtotal
     */
    subtotalAmount?: number;
}

/**
 * 
 * @export
 * @interface CouponQuery
 */
export interface CouponQuery {
    /**
     * Affiliate oid
     * @type {number}
     * @memberof CouponQuery
     */
    affiliateOid?: number;
    /**
     * The type of coupon.
     * @type {string}
     * @memberof CouponQuery
     */
    couponType?: string;
    /**
     * Description of this coupon
     * @type {string}
     * @memberof CouponQuery
     */
    description?: string;
    /**
     * Exclude expired coupons if true
     * @type {boolean}
     * @memberof CouponQuery
     */
    excludeExpired?: boolean;
    /**
     * Expiration date begin
     * @type {string}
     * @memberof CouponQuery
     */
    expirationDtsBegin?: string;
    /**
     * Expiration date begin
     * @type {string}
     * @memberof CouponQuery
     */
    expirationDtsEnd?: string;
    /**
     * Merchant code is a unique character string for this coupon.
     * @type {string}
     * @memberof CouponQuery
     */
    merchantCode?: string;
    /**
     * Start date begin
     * @type {string}
     * @memberof CouponQuery
     */
    startDtsBegin?: string;
    /**
     * Start date end
     * @type {string}
     * @memberof CouponQuery
     */
    startDtsEnd?: string;
}

/**
 * 
 * @export
 * @interface CouponResponse
 */
export interface CouponResponse {
    /**
     * 
     * @type {Coupon}
     * @memberof CouponResponse
     */
    coupon?: Coupon;
    /**
     * 
     * @type {Error}
     * @memberof CouponResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponRestriction
 */
export interface CouponRestriction {
    /**
     * 
     * @type {boolean}
     * @memberof CouponRestriction
     */
    invalidForThis?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CouponRestriction
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CouponRestriction
     */
    validForThis?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CouponRestriction
     */
    validOnlyForThis?: boolean;
}

/**
 * 
 * @export
 * @interface CouponTierAmount
 */
export interface CouponTierAmount {
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponTierAmount
     */
    discountAmount?: number;
    /**
     * The amount of subtotal required to receive the discount amount
     * @type {number}
     * @memberof CouponTierAmount
     */
    subtotalAmount?: number;
}

/**
 * 
 * @export
 * @interface CouponTierItemDiscount
 */
export interface CouponTierItemDiscount {
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponTierItemDiscount
     */
    discountAmount?: number;
    /**
     * A list of items which will receive this discount.
     * @type {Array<string>}
     * @memberof CouponTierItemDiscount
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponTierPercent
 */
export interface CouponTierPercent {
    /**
     * The percent of subtotal discount
     * @type {number}
     * @memberof CouponTierPercent
     */
    discountPercent?: number;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponTierPercent
     */
    subtotalAmount?: number;
}

/**
 * 
 * @export
 * @interface CouponTierQuantityAmount
 */
export interface CouponTierQuantityAmount {
    /**
     * The amount of discount per item.
     * @type {number}
     * @memberof CouponTierQuantityAmount
     */
    discountAmount?: number;
    /**
     * The quantity of item purchased (in units)
     * @type {number}
     * @memberof CouponTierQuantityAmount
     */
    itemQuantity?: number;
}

/**
 * 
 * @export
 * @interface CouponTierQuantityPercent
 */
export interface CouponTierQuantityPercent {
    /**
     * The percent of discount per item.
     * @type {number}
     * @memberof CouponTierQuantityPercent
     */
    discountPercent?: number;
    /**
     * The quantity of item purchased (in units)
     * @type {number}
     * @memberof CouponTierQuantityPercent
     */
    itemQuantity?: number;
}

/**
 * 
 * @export
 * @interface CouponTieredAmountOffItem
 */
export interface CouponTieredAmountOffItem {
    /**
     * The item being discounted by this coupon.
     * @type {string}
     * @memberof CouponTieredAmountOffItem
     */
    item?: string;
    /**
     * The maximum amount of total discount by this coupon.
     * @type {number}
     * @memberof CouponTieredAmountOffItem
     */
    limit?: number;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierQuantityAmount>}
     * @memberof CouponTieredAmountOffItem
     */
    tiers?: Array<CouponTierQuantityAmount>;
}

/**
 * 
 * @export
 * @interface CouponTieredAmountOffSubtotal
 */
export interface CouponTieredAmountOffSubtotal {
    /**
     * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
     * @type {Array<string>}
     * @memberof CouponTieredAmountOffSubtotal
     */
    items?: Array<string>;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierAmount>}
     * @memberof CouponTieredAmountOffSubtotal
     */
    tiers?: Array<CouponTierAmount>;
}

/**
 * 
 * @export
 * @interface CouponTieredPercentOffItems
 */
export interface CouponTieredPercentOffItems {
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponTieredPercentOffItems
     */
    items?: Array<string>;
    /**
     * The maximum amount of total discount by this coupon.
     * @type {number}
     * @memberof CouponTieredPercentOffItems
     */
    limit?: number;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierQuantityPercent>}
     * @memberof CouponTieredPercentOffItems
     */
    tiers?: Array<CouponTierQuantityPercent>;
}

/**
 * 
 * @export
 * @interface CouponTieredPercentOffShipping
 */
export interface CouponTieredPercentOffShipping {
    /**
     * One or more shipping methods that may receive this discount
     * @type {Array<string>}
     * @memberof CouponTieredPercentOffShipping
     */
    shippingMethods?: Array<string>;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierPercent>}
     * @memberof CouponTieredPercentOffShipping
     */
    tiers?: Array<CouponTierPercent>;
}

/**
 * 
 * @export
 * @interface CouponTieredPercentOffSubtotal
 */
export interface CouponTieredPercentOffSubtotal {
    /**
     * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
     * @type {Array<string>}
     * @memberof CouponTieredPercentOffSubtotal
     */
    items?: Array<string>;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierPercent>}
     * @memberof CouponTieredPercentOffSubtotal
     */
    tiers?: Array<CouponTierPercent>;
}

/**
 * 
 * @export
 * @interface CouponsResponse
 */
export interface CouponsResponse {
    /**
     * 
     * @type {Array<Coupon>}
     * @memberof CouponsResponse
     */
    coupons?: Array<Coupon>;
    /**
     * 
     * @type {Error}
     * @memberof CouponsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * Currency code of the localized value
     * @type {string}
     * @memberof Currency
     */
    currencyCode?: string;
    /**
     * Exchange rate used to localize
     * @type {number}
     * @memberof Currency
     */
    exchangeRate?: number;
    /**
     * Value localized to the customer
     * @type {number}
     * @memberof Currency
     */
    localized?: number;
    /**
     * Value localized and formatted for the customer
     * @type {string}
     * @memberof Currency
     */
    localizedFormatted?: string;
    /**
     * Value in base currency
     * @type {number}
     * @memberof Currency
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {CustomerActivity}
     * @memberof Customer
     */
    activity?: CustomerActivity;
    /**
     * Affiliate oid
     * @type {number}
     * @memberof Customer
     */
    affiliateOid?: number;
    /**
     * Allow 3rd party billing
     * @type {boolean}
     * @memberof Customer
     */
    allow3rdPartyBilling?: boolean;
    /**
     * Allow COD
     * @type {boolean}
     * @memberof Customer
     */
    allowCod?: boolean;
    /**
     * Allow purchase orders by this customer
     * @type {boolean}
     * @memberof Customer
     */
    allowPurchaseOrder?: boolean;
    /**
     * Allow quote request
     * @type {boolean}
     * @memberof Customer
     */
    allowQuoteRequest?: boolean;
    /**
     * Allow selection of residential or business address type
     * @type {boolean}
     * @memberof Customer
     */
    allowSelectionOfAddressType?: boolean;
    /**
     * Attachments
     * @type {Array<CustomerAttachment>}
     * @memberof Customer
     */
    attachments?: Array<CustomerAttachment>;
    /**
     * Auto approve COD
     * @type {boolean}
     * @memberof Customer
     */
    autoApproveCod?: boolean;
    /**
     * Auto approve purchase orders by this customer
     * @type {boolean}
     * @memberof Customer
     */
    autoApprovePurchaseOrder?: boolean;
    /**
     * Automatic merchant notes are added to every order placed
     * @type {string}
     * @memberof Customer
     */
    automaticMerchantNotes?: string;
    /**
     * Billing addresses for this customer
     * @type {Array<CustomerBilling>}
     * @memberof Customer
     */
    billing?: Array<CustomerBilling>;
    /**
     * Business notes (internally visible only)
     * @type {string}
     * @memberof Customer
     */
    businessNotes?: string;
    /**
     * Credit Cards for this customer
     * @type {Array<CustomerCard>}
     * @memberof Customer
     */
    cards?: Array<CustomerCard>;
    /**
     * Additional emails to CC notification
     * @type {Array<CustomerEmail>}
     * @memberof Customer
     */
    ccEmails?: Array<CustomerEmail>;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof Customer
     */
    customerProfileOid?: number;
    /**
     * DHL account number
     * @type {string}
     * @memberof Customer
     */
    dhlAccountNumber?: string;
    /**
     * DHL duty account number
     * @type {string}
     * @memberof Customer
     */
    dhlDutyAccountNumber?: string;
    /**
     * Email address of this customer profile
     * @type {string}
     * @memberof Customer
     */
    email?: string;
    /**
     * Exempt shipping handling charge
     * @type {boolean}
     * @memberof Customer
     */
    exemptShippingHandlingCharge?: boolean;
    /**
     * FedEx account number
     * @type {string}
     * @memberof Customer
     */
    fedexAccountNumber?: string;
    /**
     * This customer always receives free shipping
     * @type {boolean}
     * @memberof Customer
     */
    freeShipping?: boolean;
    /**
     * If free_shipping is true, this is the minimum subtotal required for free shipping
     * @type {number}
     * @memberof Customer
     */
    freeShippingMinimum?: number;
    /**
     * Last modified by
     * @type {string}
     * @memberof Customer
     */
    lastModifiedBy?: string;
    /**
     * Last modified date
     * @type {string}
     * @memberof Customer
     */
    lastModifiedDts?: string;
    /**
     * 
     * @type {CustomerLoyalty}
     * @memberof Customer
     */
    loyalty?: CustomerLoyalty;
    /**
     * Maximum item count
     * @type {number}
     * @memberof Customer
     */
    maximumItemCount?: number;
    /**
     * Minimum item count
     * @type {number}
     * @memberof Customer
     */
    minimumItemCount?: number;
    /**
     * Minimum subtotal
     * @type {number}
     * @memberof Customer
     */
    minimumSubtotal?: number;
    /**
     * No coupons
     * @type {boolean}
     * @memberof Customer
     */
    noCoupons?: boolean;
    /**
     * No free shipping regardless of coupons or item level settings
     * @type {boolean}
     * @memberof Customer
     */
    noFreeShipping?: boolean;
    /**
     * No realtime charge
     * @type {boolean}
     * @memberof Customer
     */
    noRealtimeCharge?: boolean;
    /**
     * Orders associated with this customer profile
     * @type {Array<Order>}
     * @memberof Customer
     */
    orders?: Array<Order>;
    /**
     * 
     * @type {CustomerOrdersSummary}
     * @memberof Customer
     */
    ordersSummary?: CustomerOrdersSummary;
    /**
     * Password (may only be set, never read)
     * @type {string}
     * @memberof Customer
     */
    password?: string;
    /**
     * Pricing tiers for this customer
     * @type {Array<CustomerPricingTier>}
     * @memberof Customer
     */
    pricingTiers?: Array<CustomerPricingTier>;
    /**
     * 
     * @type {CustomerPrivacy}
     * @memberof Customer
     */
    privacy?: CustomerPrivacy;
    /**
     * QuickBooks class to import this customer as
     * @type {string}
     * @memberof Customer
     */
    qbClass?: string;
    /**
     * QuickBooks name to import this customer as
     * @type {string}
     * @memberof Customer
     */
    qbCode?: string;
    /**
     * Quotes associated with this customer profile
     * @type {Array<Order>}
     * @memberof Customer
     */
    quotes?: Array<Order>;
    /**
     * 
     * @type {CustomerQuotesSummary}
     * @memberof Customer
     */
    quotesSummary?: CustomerQuotesSummary;
    /**
     * Referral Source
     * @type {string}
     * @memberof Customer
     */
    referralSource?: string;
    /**
     * 
     * @type {CustomerReviewer}
     * @memberof Customer
     */
    reviewer?: CustomerReviewer;
    /**
     * Sales rep code
     * @type {string}
     * @memberof Customer
     */
    salesRepCode?: string;
    /**
     * Send signup notification, if true during customer creation, will send a notification.
     * @type {boolean}
     * @memberof Customer
     */
    sendSignupNotification?: boolean;
    /**
     * Shipping addresses for this customer
     * @type {Array<CustomerShipping>}
     * @memberof Customer
     */
    shipping?: Array<CustomerShipping>;
    /**
     * Signup date
     * @type {string}
     * @memberof Customer
     */
    signupDts?: string;
    /**
     * Software entitlements owned by this customer
     * @type {Array<CustomerSoftwareEntitlement>}
     * @memberof Customer
     */
    softwareEntitlements?: Array<CustomerSoftwareEntitlement>;
    /**
     * Suppress buySAFE (deprecated)
     * @type {boolean}
     * @memberof Customer
     */
    suppressBuysafe?: boolean;
    /**
     * Tags for this customer
     * @type {Array<CustomerTag>}
     * @memberof Customer
     */
    tags?: Array<CustomerTag>;
    /**
     * 
     * @type {CustomerTaxCodes}
     * @memberof Customer
     */
    taxCodes?: CustomerTaxCodes;
    /**
     * True if the customer is tax exempt
     * @type {boolean}
     * @memberof Customer
     */
    taxExempt?: boolean;
    /**
     * Tax ID
     * @type {string}
     * @memberof Customer
     */
    taxId?: string;
    /**
     * Terms for this customer
     * @type {string}
     * @memberof Customer
     */
    terms?: string;
    /**
     * True if the customer should be tracked separately in QuickBooks
     * @type {boolean}
     * @memberof Customer
     */
    trackSeparately?: boolean;
    /**
     * Unapproved
     * @type {boolean}
     * @memberof Customer
     */
    unapproved?: boolean;
    /**
     * UPS account number
     * @type {string}
     * @memberof Customer
     */
    upsAccountNumber?: string;
    /**
     * Website url
     * @type {string}
     * @memberof Customer
     */
    websiteUrl?: string;
}

/**
 * 
 * @export
 * @interface CustomerActivity
 */
export interface CustomerActivity {
    /**
     * 
     * @type {Array<Activity>}
     * @memberof CustomerActivity
     */
    activities?: Array<Activity>;
    /**
     * 
     * @type {Array<ListSegmentMembership>}
     * @memberof CustomerActivity
     */
    memberships?: Array<ListSegmentMembership>;
    /**
     * 
     * @type {Array<Metric>}
     * @memberof CustomerActivity
     */
    metrics?: Array<Metric>;
    /**
     * 
     * @type {Array<Property>}
     * @memberof CustomerActivity
     */
    propertiesList?: Array<Property>;
}

/**
 * 
 * @export
 * @interface CustomerAffiliate
 */
export interface CustomerAffiliate {
    /**
     * Affiliate object identifier
     * @type {number}
     * @memberof CustomerAffiliate
     */
    affiliateOid?: number;
    /**
     * email
     * @type {string}
     * @memberof CustomerAffiliate
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface CustomerAttachment
 */
export interface CustomerAttachment {
    /**
     * Attachment identifier
     * @type {number}
     * @memberof CustomerAttachment
     */
    customerProfileAttachmentOid?: number;
    /**
     * Description
     * @type {string}
     * @memberof CustomerAttachment
     */
    description?: string;
    /**
     * File name
     * @type {string}
     * @memberof CustomerAttachment
     */
    fileName?: string;
    /**
     * Mime typoe
     * @type {string}
     * @memberof CustomerAttachment
     */
    mimeType?: string;
    /**
     * Upload date/time
     * @type {string}
     * @memberof CustomerAttachment
     */
    uploadDts?: string;
}

/**
 * 
 * @export
 * @interface CustomerBilling
 */
export interface CustomerBilling {
    /**
     * Address line 1
     * @type {string}
     * @memberof CustomerBilling
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CustomerBilling
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CustomerBilling
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CustomerBilling
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CustomerBilling
     */
    countryCode?: string;
    /**
     * Customer profile billing object identifier
     * @type {number}
     * @memberof CustomerBilling
     */
    customerBillingOid?: number;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof CustomerBilling
     */
    customerProfileOid?: number;
    /**
     * Day phone
     * @type {string}
     * @memberof CustomerBilling
     */
    dayPhone?: string;
    /**
     * Default billing
     * @type {boolean}
     * @memberof CustomerBilling
     */
    defaultBilling?: boolean;
    /**
     * Evening phone
     * @type {string}
     * @memberof CustomerBilling
     */
    eveningPhone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CustomerBilling
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CustomerBilling
     */
    lastName?: string;
    /**
     * Last used date
     * @type {string}
     * @memberof CustomerBilling
     */
    lastUsedDts?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof CustomerBilling
     */
    postalCode?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CustomerBilling
     */
    stateRegion?: string;
    /**
     * Tax County
     * @type {string}
     * @memberof CustomerBilling
     */
    taxCounty?: string;
    /**
     * Title
     * @type {string}
     * @memberof CustomerBilling
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CustomerCard
 */
export interface CustomerCard {
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof CustomerCard
     */
    cardExpirationMonth?: number;
    /**
     * Card expiration year (four digit year)
     * @type {number}
     * @memberof CustomerCard
     */
    cardExpirationYear?: number;
    /**
     * Card number (masked to the last 4)
     * @type {string}
     * @memberof CustomerCard
     */
    cardNumber?: string;
    /**
     * Hosted field token for the card number
     * @type {string}
     * @memberof CustomerCard
     */
    cardNumberToken?: string;
    /**
     * Card type
     * @type {string}
     * @memberof CustomerCard
     */
    cardType?: string;
    /**
     * ID of the stored credit card to use
     * @type {number}
     * @memberof CustomerCard
     */
    customerProfileCreditCardId?: number;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof CustomerCard
     */
    customerProfileOid?: number;
    /**
     * Last used date
     * @type {string}
     * @memberof CustomerCard
     */
    lastUsedDts?: string;
}

/**
 * 
 * @export
 * @interface CustomerEditorValues
 */
export interface CustomerEditorValues {
    /**
     * affiliates
     * @type {Array<CustomerAffiliate>}
     * @memberof CustomerEditorValues
     */
    affiliates?: Array<CustomerAffiliate>;
    /**
     * card_exp_months
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    cardExpMonths?: Array<string>;
    /**
     * card_exp_years
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    cardExpYears?: Array<string>;
    /**
     * card_types
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    cardTypes?: Array<string>;
    /**
     * countries
     * @type {Array<Country>}
     * @memberof CustomerEditorValues
     */
    countries?: Array<Country>;
    /**
     * qb_classes
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    qbClasses?: Array<string>;
    /**
     * sales_rep_codes
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    salesRepCodes?: Array<string>;
    /**
     * terms
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    terms?: Array<string>;
}

/**
 * 
 * @export
 * @interface CustomerEmail
 */
export interface CustomerEmail {
    /**
     * ID of the email
     * @type {number}
     * @memberof CustomerEmail
     */
    customerProfileEmailOid?: number;
    /**
     * Email
     * @type {string}
     * @memberof CustomerEmail
     */
    email?: string;
    /**
     * Label
     * @type {string}
     * @memberof CustomerEmail
     */
    label?: string;
    /**
     * CC this email on receipt notifications
     * @type {boolean}
     * @memberof CustomerEmail
     */
    receiptNotification?: boolean;
    /**
     * CC this email on refund notifications
     * @type {boolean}
     * @memberof CustomerEmail
     */
    refundNotification?: boolean;
    /**
     * CC this email on shipment notifications
     * @type {boolean}
     * @memberof CustomerEmail
     */
    shipmentNotification?: boolean;
}

/**
 * 
 * @export
 * @interface CustomerEmailListChanges
 */
export interface CustomerEmailListChanges {
    /**
     * Add this customer to these email lists
     * @type {Array<string>}
     * @memberof CustomerEmailListChanges
     */
    addToLists?: Array<string>;
    /**
     * Remove this customer from these email lists
     * @type {Array<string>}
     * @memberof CustomerEmailListChanges
     */
    removeFromLists?: Array<string>;
}

/**
 * 
 * @export
 * @interface CustomerLoyalty
 */
export interface CustomerLoyalty {
    /**
     * Current Points
     * @type {number}
     * @memberof CustomerLoyalty
     */
    currentPoints?: number;
    /**
     * Ledger entries
     * @type {Array<CustomerLoyaltyLedger>}
     * @memberof CustomerLoyalty
     */
    ledgerEntries?: Array<CustomerLoyaltyLedger>;
    /**
     * Redemptions
     * @type {Array<CustomerLoyaltyRedemption>}
     * @memberof CustomerLoyalty
     */
    redemptions?: Array<CustomerLoyaltyRedemption>;
}

/**
 * 
 * @export
 * @interface CustomerLoyaltyLedger
 */
export interface CustomerLoyaltyLedger {
    /**
     * Created By
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    createdBy?: string;
    /**
     * Created date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    createdDts?: string;
    /**
     * Description
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    description?: string;
    /**
     * Email
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    email?: string;
    /**
     * Item Id
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    itemId?: string;
    /**
     * Item Index
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    itemIndex?: number;
    /**
     * Ledger date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    ledgerDts?: string;
    /**
     * Loyalty campaign oid
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    loyaltyCampaignOid?: number;
    /**
     * Loyalty ledger oid
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    loyaltyLedgerOid?: number;
    /**
     * Loyalty points
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    loyaltyPoints?: number;
    /**
     * Modified By
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    modifiedBy?: string;
    /**
     * Modified date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    modifiedDts?: string;
    /**
     * Order Id
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    orderId?: string;
    /**
     * Quantity
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    quantity?: number;
    /**
     * Vesting date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    vestingDts?: string;
}

/**
 * 
 * @export
 * @interface CustomerLoyaltyRedemption
 */
export interface CustomerLoyaltyRedemption {
    /**
     * Coupon code
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    couponCode?: string;
    /**
     * Coupon code OID
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    couponCodeOid?: number;
    /**
     * Coupon used
     * @type {boolean}
     * @memberof CustomerLoyaltyRedemption
     */
    couponUsed?: boolean;
    /**
     * Description for customer
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    descriptionForCustomer?: string;
    /**
     * Expiration date
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    expirationDts?: string;
    /**
     * Gift certificate code
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    giftCertificateCode?: string;
    /**
     * Gift certificate oid
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    giftCertificateOid?: number;
    /**
     * Loyalty ledger OID
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    loyaltyLedgerOid?: number;
    /**
     * Loyalty points
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    loyaltyPoints?: number;
    /**
     * Loyalty redemption OID
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    loyaltyRedemptionOid?: number;
    /**
     * Order id
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    orderId?: string;
    /**
     * Redemption date
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    redemptionDts?: string;
    /**
     * Remaining balance
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    remainingBalance?: number;
}

/**
 * 
 * @export
 * @interface CustomerOrdersSummary
 */
export interface CustomerOrdersSummary {
    /**
     * First order date
     * @type {string}
     * @memberof CustomerOrdersSummary
     */
    firstOrderDts?: string;
    /**
     * Last order date
     * @type {string}
     * @memberof CustomerOrdersSummary
     */
    lastOrderDts?: string;
    /**
     * Total number of orders
     * @type {number}
     * @memberof CustomerOrdersSummary
     */
    orderCount?: number;
    /**
     * Total amount associated with the orders
     * @type {number}
     * @memberof CustomerOrdersSummary
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface CustomerPricingTier
 */
export interface CustomerPricingTier {
    /**
     * Name
     * @type {string}
     * @memberof CustomerPricingTier
     */
    name?: string;
    /**
     * Pricing Tier Oid
     * @type {number}
     * @memberof CustomerPricingTier
     */
    pricingTierOid?: number;
}

/**
 * 
 * @export
 * @interface CustomerPrivacy
 */
export interface CustomerPrivacy {
    /**
     * Last update date
     * @type {string}
     * @memberof CustomerPrivacy
     */
    lastUpdateDts?: string;
    /**
     * The customer has opted in to marketing
     * @type {boolean}
     * @memberof CustomerPrivacy
     */
    marketing?: boolean;
    /**
     * The customer has opted in to preference tracking
     * @type {boolean}
     * @memberof CustomerPrivacy
     */
    preference?: boolean;
    /**
     * The customer has opted in to statistics collection
     * @type {boolean}
     * @memberof CustomerPrivacy
     */
    statistics?: boolean;
}

/**
 * 
 * @export
 * @interface CustomerQuery
 */
export interface CustomerQuery {
    /**
     * All tags the customer must have
     * @type {Array<string>}
     * @memberof CustomerQuery
     */
    allTags?: Array<string>;
    /**
     * Any of these tags the customer must have
     * @type {Array<string>}
     * @memberof CustomerQuery
     */
    anyTags?: Array<string>;
    /**
     * Billing city
     * @type {string}
     * @memberof CustomerQuery
     */
    billingCity?: string;
    /**
     * Billing company
     * @type {string}
     * @memberof CustomerQuery
     */
    billingCompany?: string;
    /**
     * Billing country code
     * @type {string}
     * @memberof CustomerQuery
     */
    billingCountryCode?: string;
    /**
     * Billing day phone
     * @type {string}
     * @memberof CustomerQuery
     */
    billingDayPhone?: string;
    /**
     * Billing evening phone
     * @type {string}
     * @memberof CustomerQuery
     */
    billingEveningPhone?: string;
    /**
     * Billing first name
     * @type {string}
     * @memberof CustomerQuery
     */
    billingFirstName?: string;
    /**
     * Billing last name
     * @type {string}
     * @memberof CustomerQuery
     */
    billingLastName?: string;
    /**
     * Billing postal code
     * @type {string}
     * @memberof CustomerQuery
     */
    billingPostalCode?: string;
    /**
     * Billing state
     * @type {string}
     * @memberof CustomerQuery
     */
    billingState?: string;
    /**
     * Email address of this customer profile
     * @type {string}
     * @memberof CustomerQuery
     */
    email?: string;
    /**
     * Last modified date end
     * @type {string}
     * @memberof CustomerQuery
     */
    lastModifiedDtsEnd?: string;
    /**
     * Last modified date start
     * @type {string}
     * @memberof CustomerQuery
     */
    lastModifiedDtsStart?: string;
    /**
     * Pricing tier name
     * @type {string}
     * @memberof CustomerQuery
     */
    pricingTierName?: string;
    /**
     * Pricing tier oid
     * @type {number}
     * @memberof CustomerQuery
     */
    pricingTierOid?: number;
    /**
     * QuickBooks class to import this customer as
     * @type {string}
     * @memberof CustomerQuery
     */
    qbClass?: string;
    /**
     * QuickBooks name to import this customer as
     * @type {string}
     * @memberof CustomerQuery
     */
    quickbooksCode?: string;
    /**
     * Billing city
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingCity?: string;
    /**
     * Billing company
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingCompany?: string;
    /**
     * Billing country code
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingCountryCode?: string;
    /**
     * Billing day phone
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingDayPhone?: string;
    /**
     * Billing evening phone
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingEveningPhone?: string;
    /**
     * Billing first name
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingFirstName?: string;
    /**
     * Billing last name
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingLastName?: string;
    /**
     * Billing postal code
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingPostalCode?: string;
    /**
     * Billing state
     * @type {string}
     * @memberof CustomerQuery
     */
    shippingState?: string;
    /**
     * Signup date end
     * @type {string}
     * @memberof CustomerQuery
     */
    signupDtsEnd?: string;
    /**
     * Signup date start
     * @type {string}
     * @memberof CustomerQuery
     */
    signupDtsStart?: string;
}

/**
 * 
 * @export
 * @interface CustomerQuotesSummary
 */
export interface CustomerQuotesSummary {
    /**
     * First quote date
     * @type {string}
     * @memberof CustomerQuotesSummary
     */
    firstQuoteDts?: string;
    /**
     * Last quote date
     * @type {string}
     * @memberof CustomerQuotesSummary
     */
    lastQuoteDts?: string;
    /**
     * Total number of quote
     * @type {number}
     * @memberof CustomerQuotesSummary
     */
    quoteCount?: number;
    /**
     * Total amount associated with the quotes
     * @type {number}
     * @memberof CustomerQuotesSummary
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface CustomerResponse
 */
export interface CustomerResponse {
    /**
     * 
     * @type {Customer}
     * @memberof CustomerResponse
     */
    customer?: Customer;
    /**
     * 
     * @type {Error}
     * @memberof CustomerResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CustomerResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CustomerResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CustomerResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CustomerReviewer
 */
export interface CustomerReviewer {
    /**
     * True if reviewes from this customer profile should automatically be approved
     * @type {boolean}
     * @memberof CustomerReviewer
     */
    autoApprove?: boolean;
    /**
     * Average overall rating of items reviewed
     * @type {number}
     * @memberof CustomerReviewer
     */
    averageOverallRating?: number;
    /**
     * True if the customer is an expert
     * @type {boolean}
     * @memberof CustomerReviewer
     */
    expert?: boolean;
    /**
     * First review
     * @type {string}
     * @memberof CustomerReviewer
     */
    firstReview?: string;
    /**
     * Last review
     * @type {string}
     * @memberof CustomerReviewer
     */
    lastReview?: string;
    /**
     * Location of the reviewer
     * @type {string}
     * @memberof CustomerReviewer
     */
    location?: string;
    /**
     * Nickname of the reviewer
     * @type {string}
     * @memberof CustomerReviewer
     */
    nickname?: string;
    /**
     * Number of helpful review votes
     * @type {number}
     * @memberof CustomerReviewer
     */
    numberHelpfulReviewVotes?: number;
    /**
     * Rank of this reviewer
     * @type {number}
     * @memberof CustomerReviewer
     */
    rank?: number;
    /**
     * Number of reviews contributed
     * @type {number}
     * @memberof CustomerReviewer
     */
    reviewsContributed?: number;
}

/**
 * 
 * @export
 * @interface CustomerShipping
 */
export interface CustomerShipping {
    /**
     * Address line 1
     * @type {string}
     * @memberof CustomerShipping
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CustomerShipping
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CustomerShipping
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CustomerShipping
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CustomerShipping
     */
    countryCode?: string;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof CustomerShipping
     */
    customerProfileOid?: number;
    /**
     * Customer profile shipping object identifier
     * @type {number}
     * @memberof CustomerShipping
     */
    customerShippingOid?: number;
    /**
     * Day phone
     * @type {string}
     * @memberof CustomerShipping
     */
    dayPhone?: string;
    /**
     * Default shipping
     * @type {boolean}
     * @memberof CustomerShipping
     */
    defaultShipping?: boolean;
    /**
     * Evening phone
     * @type {string}
     * @memberof CustomerShipping
     */
    eveningPhone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CustomerShipping
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CustomerShipping
     */
    lastName?: string;
    /**
     * Last used date
     * @type {string}
     * @memberof CustomerShipping
     */
    lastUsedDts?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof CustomerShipping
     */
    postalCode?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CustomerShipping
     */
    stateRegion?: string;
    /**
     * Tax County
     * @type {string}
     * @memberof CustomerShipping
     */
    taxCounty?: string;
    /**
     * Title
     * @type {string}
     * @memberof CustomerShipping
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CustomerSoftwareEntitlement
 */
export interface CustomerSoftwareEntitlement {
    /**
     * Activation Code Associated with the software
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    activationCode?: string;
    /**
     * Date/time when the activation code was created
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    activationDts?: string;
    /**
     * Customer profile software entitlement object identifier
     * @type {number}
     * @memberof CustomerSoftwareEntitlement
     */
    customerSoftwareEntitlementOid?: number;
    /**
     * Date/time when the activation code will expire
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    expirationDts?: string;
    /**
     * Item description used to purchase this software.
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    purchasedViaItemDescription?: string;
    /**
     * Item ID used to purchase this software.
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    purchasedViaItemId?: string;
    /**
     * Order ID used to purchase this software.
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    purchasedViaOrderId?: string;
    /**
     * SKU of the software
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    softwareSku?: string;
}

/**
 * 
 * @export
 * @interface CustomerTag
 */
export interface CustomerTag {
    /**
     * Tag Value
     * @type {string}
     * @memberof CustomerTag
     */
    tagValue?: string;
}

/**
 * 
 * @export
 * @interface CustomerTaxCodes
 */
export interface CustomerTaxCodes {
    /**
     * Avalara customer code
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    avalaraCustomerCode?: string;
    /**
     * Avalara entity use code
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    avalaraEntityUseCode?: string;
    /**
     * Sovos customer code
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    sovosCustomerCode?: string;
    /**
     * TaxJar customer id
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    taxjarCustomerId?: string;
    /**
     * TaxJar exemption type
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    taxjarExemptionType?: string;
}

/**
 * 
 * @export
 * @interface CustomersResponse
 */
export interface CustomersResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomersResponse
     */
    customers?: Array<Customer>;
    /**
     * 
     * @type {Error}
     * @memberof CustomersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CustomersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CustomersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CustomersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface DataTablesServerSideResponse
 */
export interface DataTablesServerSideResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof DataTablesServerSideResponse
     */
    data?: Array<Customer>;
    /**
     * 
     * @type {number}
     * @memberof DataTablesServerSideResponse
     */
    draw?: number;
    /**
     * 
     * @type {number}
     * @memberof DataTablesServerSideResponse
     */
    recordsFiltered?: number;
    /**
     * 
     * @type {number}
     * @memberof DataTablesServerSideResponse
     */
    recordsTotal?: number;
}

/**
 * 
 * @export
 * @interface Distance
 */
export interface Distance {
    /**
     * Unit of measure
     * @type {string}
     * @memberof Distance
     */
    uom?: Distance.UomEnum;
    /**
     * The distance measured in UOM
     * @type {number}
     * @memberof Distance
     */
    value?: number;
}

/**
 * @export
 * @namespace Distance
 */
export namespace Distance {
    /**
     * @export
     * @enum {string}
     */
    export enum UomEnum {
        IN = <any> 'IN',
        CM = <any> 'CM'
    }
}

/**
 * 
 * @export
 * @interface DistributionCenter
 */
export interface DistributionCenter {
    /**
     * Address line 1 of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    address1?: string;
    /**
     * Address line 2 of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    address2?: string;
    /**
     * City of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    city?: string;
    /**
     * Unique code for this distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    code?: string;
    /**
     * Country code of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    countryCode?: string;
    /**
     * True if this is the default distribution center on the account
     * @type {boolean}
     * @memberof DistributionCenter
     */
    defaultCenter?: boolean;
    /**
     * True if this distribution center handles all new items by default
     * @type {boolean}
     * @memberof DistributionCenter
     */
    defaultHandlesAllItems?: boolean;
    /**
     * Distribution center object identifier
     * @type {number}
     * @memberof DistributionCenter
     */
    distributionCenterOid?: number;
    /**
     * DUNS number assigned to this distribution center (EDI)
     * @type {string}
     * @memberof DistributionCenter
     */
    duns?: string;
    /**
     * Estimate shipments for this distribution center as if they came from the other distribution center
     * @type {number}
     * @memberof DistributionCenter
     */
    estimateFromDistributionCenterOid?: number;
    /**
     * Password associated with the virtual FTP
     * @type {string}
     * @memberof DistributionCenter
     */
    ftpPassword?: string;
    /**
     * The number of minutes to hold a shipment
     * @type {number}
     * @memberof DistributionCenter
     */
    holdBeforeShipmentMinutes?: number;
    /**
     * True if the shipment should be held before transmission and require a manual release
     * @type {boolean}
     * @memberof DistributionCenter
     */
    holdBeforeTransmission?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DistributionCenter
     */
    holdAutoOrderBeforeShipmentMinutes?: number;
    /**
     * Latitude where the distribution center is located
     * @type {number}
     * @memberof DistributionCenter
     */
    latitude?: number;
    /**
     * Longitude where the distribution center is located
     * @type {number}
     * @memberof DistributionCenter
     */
    longitude?: number;
    /**
     * Name of this distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    name?: string;
    /**
     * True if this distribution center does not handle customer direct shipments
     * @type {boolean}
     * @memberof DistributionCenter
     */
    noCustomerDirectShipments?: boolean;
    /**
     * True if this distribution center is not allowed to participate in a split shipment.
     * @type {boolean}
     * @memberof DistributionCenter
     */
    noSplitShipment?: boolean;
    /**
     * Postal code of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    postalCode?: string;
    /**
     * The number of processing days required before an order ships
     * @type {number}
     * @memberof DistributionCenter
     */
    processDays?: number;
    /**
     * The time (EST) after which inventory updates will be processed
     * @type {string}
     * @memberof DistributionCenter
     */
    processInventoryStartTime?: string;
    /**
     * The time (EST) before which inventory updates will be processed
     * @type {string}
     * @memberof DistributionCenter
     */
    processInventoryStopTime?: string;
    /**
     * True if ASNs are required for this distribution center (EDI)
     * @type {boolean}
     * @memberof DistributionCenter
     */
    requireAsn?: boolean;
    /**
     * True if we should send the kit instead of the components
     * @type {boolean}
     * @memberof DistributionCenter
     */
    sendKitInsteadOfComponents?: boolean;
    /**
     * The time (EST) after which shipments will not be processed on Friday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipmentCutoffTimeFriday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Monday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipmentCutoffTimeMonday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Saturday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipmentCutoffTimeSaturday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Sunday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipmentCutoffTimeSunday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Thursday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipmentCutoffTimeThursday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Tuesday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipmentCutoffTimeTuesday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Wednesday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipmentCutoffTimeWednesday?: string;
    /**
     * State of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    state?: string;
    /**
     * Transport mechanism for this distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    transport?: string;
}

/**
 * 
 * @export
 * @interface DistributionCentersResponse
 */
export interface DistributionCentersResponse {
    /**
     * 
     * @type {Array<DistributionCenter>}
     * @memberof DistributionCentersResponse
     */
    distributionCenters?: Array<DistributionCenter>;
    /**
     * 
     * @type {Error}
     * @memberof DistributionCentersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof DistributionCentersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof DistributionCentersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof DistributionCentersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailBaseTemplateListResponse
 */
export interface EmailBaseTemplateListResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailBaseTemplateListResponse
     */
    templatePaths?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailCampaign
 */
export interface EmailCampaign {
    /**
     * Click rate of emails
     * @type {string}
     * @memberof EmailCampaign
     */
    clickRateFormatted?: string;
    /**
     * Created date
     * @type {string}
     * @memberof EmailCampaign
     */
    createdDts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailCampaign
     */
    deleted?: boolean;
    /**
     * Email campaign UUID
     * @type {string}
     * @memberof EmailCampaign
     */
    emailCampaignUuid?: string;
    /**
     * Email communication sequence UUID
     * @type {string}
     * @memberof EmailCampaign
     */
    emailCommunicationSequenceUuid?: string;
    /**
     * True if the customer should end the flow once they purchase
     * @type {boolean}
     * @memberof EmailCampaign
     */
    endOnceCustomerPurchases?: boolean;
    /**
     * User of the sending address
     * @type {string}
     * @memberof EmailCampaign
     */
    espDomainUser?: string;
    /**
     * UUID of the sending domain
     * @type {string}
     * @memberof EmailCampaign
     */
    espDomainUuid?: string;
    /**
     * Friendly name of the sending email
     * @type {string}
     * @memberof EmailCampaign
     */
    espFriendlyName?: string;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof EmailCampaign
     */
    libraryItemOid?: number;
    /**
     * List and segment memberships
     * @type {Array<EmailListSegmentMembership>}
     * @memberof EmailCampaign
     */
    memberships?: Array<EmailListSegmentMembership>;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCampaign
     */
    merchantId?: string;
    /**
     * Name of email campaign
     * @type {string}
     * @memberof EmailCampaign
     */
    name?: string;
    /**
     * Open rate of emails
     * @type {string}
     * @memberof EmailCampaign
     */
    openRateFormatted?: string;
    /**
     * True if this campaign is prevented from sending at this time due to spam complaints.
     * @type {boolean}
     * @memberof EmailCampaign
     */
    preventSendingDueToSpam?: boolean;
    /**
     * Revenue associated with campaign
     * @type {string}
     * @memberof EmailCampaign
     */
    revenueFormatted?: string;
    /**
     * Scheduled date
     * @type {string}
     * @memberof EmailCampaign
     */
    scheduledDts?: string;
    /**
     * URL to a large full length screenshot
     * @type {string}
     * @memberof EmailCampaign
     */
    screenshotLargeFullUrl?: string;
    /**
     * Status of the campaign of draft, archived, and sent
     * @type {string}
     * @memberof EmailCampaign
     */
    status?: string;
    /**
     * Timestamp when the last status change happened
     * @type {string}
     * @memberof EmailCampaign
     */
    statusDts?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCampaign
     */
    storefrontOid?: number;
}

/**
 * 
 * @export
 * @interface EmailCampaignResponse
 */
export interface EmailCampaignResponse {
    /**
     * 
     * @type {EmailCampaign}
     * @memberof EmailCampaignResponse
     */
    campaign?: EmailCampaign;
    /**
     * 
     * @type {Error}
     * @memberof EmailCampaignResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCampaignResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCampaignResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCampaignResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCampaignsResponse
 */
export interface EmailCampaignsResponse {
    /**
     * 
     * @type {Array<EmailCampaign>}
     * @memberof EmailCampaignsResponse
     */
    campaigns?: Array<EmailCampaign>;
    /**
     * 
     * @type {Error}
     * @memberof EmailCampaignsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCampaignsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCampaignsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCampaignsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailClick
 */
export interface EmailClick {
    /**
     * Click Count
     * @type {number}
     * @memberof EmailClick
     */
    clickCount?: number;
    /**
     * url
     * @type {string}
     * @memberof EmailClick
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface EmailClicksResponse
 */
export interface EmailClicksResponse {
    /**
     * 
     * @type {Array<EmailClick>}
     * @memberof EmailClicksResponse
     */
    clicks?: Array<EmailClick>;
    /**
     * 
     * @type {Error}
     * @memberof EmailClicksResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailClicksResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailClicksResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailClicksResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseq
 */
export interface EmailCommseq {
    /**
     * Array of steps
     * @type {Array<EmailCommseqStep>}
     * @memberof EmailCommseq
     */
    emailCommunicationSequenceSteps?: Array<EmailCommseqStep>;
    /**
     * Email commseq UUID
     * @type {string}
     * @memberof EmailCommseq
     */
    emailCommunicationSequenceUuid?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseq
     */
    merchantId?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseq
     */
    storefrontOid?: number;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmail
 */
export interface EmailCommseqEmail {
    /**
     * Deleted
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    deleted?: boolean;
    /**
     * Edited by user
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    editedByUser?: string;
    /**
     * Email communication sequence email uuid
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    emailCommunicationSequenceEmailUuid?: string;
    /**
     * Email commseq UUID
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    emailCommunicationSequenceUuid?: string;
    /**
     * Email container cjson
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    emailContainerCjson?: string;
    /**
     * Timestamp the last time the container was modified.
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    emailContainerCjsonLastModifiedDts?: string;
    /**
     * Email template virtual path
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    emailTemplateVmPath?: string;
    /**
     * Filter profile equation json
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    filterProfileEquationJson?: string;
    /**
     * Individually render
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    individuallyRender?: boolean;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof EmailCommseqEmail
     */
    libraryItemOid?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    merchantId?: string;
    /**
     * True if the content of this email is pending review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    pendingReview?: boolean;
    /**
     * Preview text
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    previewText?: string;
    /**
     * True if the content of this email was rejected during review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    rejected?: boolean;
    /**
     * True if the content of this email is requires review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    requiresReview?: boolean;
    /**
     * URL to screenshot in large form factor full page
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshotLargeFullUrl?: string;
    /**
     * URL to screenshot in large form factor viewport
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshotLargeViewportUrl?: string;
    /**
     * URL to screenshot in small form factor full page
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshotSmallFullUrl?: string;
    /**
     * URL to screenshot in small form factor viewport
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshotSmallViewportUrl?: string;
    /**
     * Smart sending
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    smartSending?: boolean;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseqEmail
     */
    storefrontOid?: number;
    /**
     * Subject
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    subject?: string;
    /**
     * Transactional email
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    transactionalEmail?: boolean;
    /**
     * Version
     * @type {number}
     * @memberof EmailCommseqEmail
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailResponse
 */
export interface EmailCommseqEmailResponse {
    /**
     * 
     * @type {EmailCommseqEmail}
     * @memberof EmailCommseqEmailResponse
     */
    email?: EmailCommseqEmail;
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqEmailResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailSendTestRequest
 */
export interface EmailCommseqEmailSendTestRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    cartId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    cartItemIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    espCommseqEmailUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    espCommseqStepUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    espCommseqUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    orderId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    pleaseReview?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    sendToAdditionalEmails?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    sendToLoggedInUser?: boolean;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailSendTestResponse
 */
export interface EmailCommseqEmailSendTestResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailsRequest
 */
export interface EmailCommseqEmailsRequest {
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqEmailsRequest
     */
    error?: Error;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqEmailsRequest
     */
    espCommseqEmailUuids?: Array<string>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailsRequest
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailsRequest
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailsRequest
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailsResponse
 */
export interface EmailCommseqEmailsResponse {
    /**
     * 
     * @type {Array<EmailCommseqEmail>}
     * @memberof EmailCommseqEmailsResponse
     */
    emails?: Array<EmailCommseqEmail>;
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqEmailsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcard
 */
export interface EmailCommseqPostcard {
    /**
     * Deleted
     * @type {boolean}
     * @memberof EmailCommseqPostcard
     */
    deleted?: boolean;
    /**
     * Edited by user
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    editedByUser?: string;
    /**
     * communication sequence postcard uuid
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    emailCommunicationSequencePostcardUuid?: string;
    /**
     * Filter profile equation json
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    filterProfileEquationJson?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    merchantId?: string;
    /**
     * Postcard back container cjson
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcardBackContainerCjson?: string;
    /**
     * Postcard back container uuid
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcardBackContainerUuid?: string;
    /**
     * Timestamp the last time the container was modified.
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcardContainerCjsonLastModifiedDts?: string;
    /**
     * Postcard front container cjson
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcardFrontContainerCjson?: string;
    /**
     * Postcard front container uuid
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcardFrontContainerUuid?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseqPostcard
     */
    storefrontOid?: number;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardResponse
 */
export interface EmailCommseqPostcardResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqPostcardResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqPostcardResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailCommseqPostcard}
     * @memberof EmailCommseqPostcardResponse
     */
    postcard?: EmailCommseqPostcard;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqPostcardResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqPostcardResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardSendTestRequest
 */
export interface EmailCommseqPostcardSendTestRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    cartId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    cartItemIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    espCommseqPostcardUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    espCommseqStepUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    espCommseqUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardSendTestResponse
 */
export interface EmailCommseqPostcardSendTestResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    backThumbnail?: string;
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    error?: Error;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    frontThumbnail?: string;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    renderedPdf?: string;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardsRequest
 */
export interface EmailCommseqPostcardsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqPostcardsRequest
     */
    espCommseqPostcardUuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardsResponse
 */
export interface EmailCommseqPostcardsResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqPostcardsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqPostcardsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailCommseqPostcard>}
     * @memberof EmailCommseqPostcardsResponse
     */
    postcards?: Array<EmailCommseqPostcard>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqPostcardsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqPostcardsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqResponse
 */
export interface EmailCommseqResponse {
    /**
     * 
     * @type {EmailCommseq}
     * @memberof EmailCommseqResponse
     */
    communicationSequence?: EmailCommseq;
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqStat
 */
export interface EmailCommseqStat {
    /**
     * Count of clicked emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    clickCount?: number;
    /**
     * Count of clicked emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    clickCountFormatted?: string;
    /**
     * Count of conversion
     * @type {number}
     * @memberof EmailCommseqStat
     */
    conversionCount?: number;
    /**
     * Count of conversions, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    conversionCountFormatted?: string;
    /**
     * Count of delivered emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    deliveredCount?: number;
    /**
     * Count of delivered emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    deliveredCountFormatted?: string;
    /**
     * UUID associated with the communication sequence
     * @type {string}
     * @memberof EmailCommseqStat
     */
    emailCommunicationSequenceUuid?: string;
    /**
     * Count of customers that finished the sequence
     * @type {number}
     * @memberof EmailCommseqStat
     */
    finishedCount?: number;
    /**
     * Count of customers that finished the sequence, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    finishedCountFormatted?: string;
    /**
     * Count of customers in progress
     * @type {number}
     * @memberof EmailCommseqStat
     */
    inProgressCount?: number;
    /**
     * Count of customers in progress, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    inProgressCountFormatted?: string;
    /**
     * Count of emails kicked
     * @type {number}
     * @memberof EmailCommseqStat
     */
    kickboxCount?: number;
    /**
     * Count of emails kicked, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    kickboxCountFormatted?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseqStat
     */
    merchantId?: string;
    /**
     * Count of opened emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    openCount?: number;
    /**
     * Count of opened emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    openCountFormatted?: string;
    /**
     * Count of orders
     * @type {number}
     * @memberof EmailCommseqStat
     */
    orderCount?: number;
    /**
     * Count of orders, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    orderCountFormatted?: string;
    /**
     * Count of emails permanently bounced
     * @type {number}
     * @memberof EmailCommseqStat
     */
    permanentBounceCount?: number;
    /**
     * Count of emails permanently bounced, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    permanentBounceCountFormatted?: string;
    /**
     * Profit
     * @type {number}
     * @memberof EmailCommseqStat
     */
    profit?: number;
    /**
     * Profit, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    profitFormatted?: string;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailCommseqStat
     */
    revenue?: number;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    revenueFormatted?: string;
    /**
     * Count of emails sent
     * @type {number}
     * @memberof EmailCommseqStat
     */
    sendCount?: number;
    /**
     * Count of emails sent, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    sendCountFormatted?: string;
    /**
     * Count of skipped emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    skippedCount?: number;
    /**
     * Count of skipped emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    skippedCountFormatted?: string;
    /**
     * Count of emails classified as spam
     * @type {number}
     * @memberof EmailCommseqStat
     */
    spamCount?: number;
    /**
     * Count of emails classified as spam, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    spamCountFormatted?: string;
    /**
     * Count of customers that started the sequence
     * @type {number}
     * @memberof EmailCommseqStat
     */
    startedCount?: number;
    /**
     * Count of customers that started the sequence, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    startedCountFormatted?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseqStat
     */
    storefrontOid?: number;
    /**
     * Count of unsubscribes caused
     * @type {number}
     * @memberof EmailCommseqStat
     */
    unsubscribeCount?: number;
    /**
     * Count of unsubscribes caused, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    unsubscribeCountFormatted?: string;
    /**
     * Count of views
     * @type {number}
     * @memberof EmailCommseqStat
     */
    viewCount?: number;
    /**
     * Count of views, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    viewCountFormatted?: string;
}

/**
 * 
 * @export
 * @interface EmailCommseqStatResponse
 */
export interface EmailCommseqStatResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqStatResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqStatResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailCommseqStat}
     * @memberof EmailCommseqStatResponse
     */
    stats?: EmailCommseqStat;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqStatResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqStatResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqStep
 */
export interface EmailCommseqStep {
    /**
     * Array of child steps for the alternate path
     * @type {Array<EmailCommseqStep>}
     * @memberof EmailCommseqStep
     */
    altChildEmailCommunicationSequenceSteps?: Array<EmailCommseqStep>;
    /**
     * Array of child steps
     * @type {Array<EmailCommseqStep>}
     * @memberof EmailCommseqStep
     */
    childEmailCommunicationSequenceSteps?: Array<EmailCommseqStep>;
    /**
     * Email commseq step UUID
     * @type {string}
     * @memberof EmailCommseqStep
     */
    emailCommunicationSequenceStepUuid?: string;
    /**
     * True if the content of the email associated with this step is pending review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqStep
     */
    emailPendingReview?: boolean;
    /**
     * True if the content of the email associated with this step was rejected during review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqStep
     */
    emailRejected?: boolean;
    /**
     * True if the content of the email associated with this step requires review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqStep
     */
    emailRequiresReview?: boolean;
    /**
     * Filter profile equation JSON
     * @type {string}
     * @memberof EmailCommseqStep
     */
    filterProfileEquationJson?: string;
    /**
     * Internal merchant notes
     * @type {string}
     * @memberof EmailCommseqStep
     */
    merchantNotes?: string;
    /**
     * Arbitrary Configuration for a step
     * @type {string}
     * @memberof EmailCommseqStep
     */
    stepConfigJson?: string;
    /**
     * Type of step
     * @type {string}
     * @memberof EmailCommseqStep
     */
    type?: EmailCommseqStep.TypeEnum;
}

/**
 * @export
 * @namespace EmailCommseqStep
 */
export namespace EmailCommseqStep {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Begin = <any> 'begin',
        Wait = <any> 'wait',
        Email = <any> 'email',
        Merge = <any> 'merge',
        Condition = <any> 'condition',
        End = <any> 'end'
    }
}

/**
 * 
 * @export
 * @interface EmailCommseqsResponse
 */
export interface EmailCommseqsResponse {
    /**
     * 
     * @type {Array<EmailCommseq>}
     * @memberof EmailCommseqsResponse
     */
    communicationSequences?: Array<EmailCommseq>;
    /**
     * 
     * @type {Error}
     * @memberof EmailCommseqsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCustomer
 */
export interface EmailCustomer {
    /**
     * True if the customer is flagged as active within StoreFront Communications
     * @type {boolean}
     * @memberof EmailCustomer
     */
    active?: boolean;
    /**
     * Email
     * @type {string}
     * @memberof EmailCustomer
     */
    email?: string;
    /**
     * Email customer UUID
     * @type {string}
     * @memberof EmailCustomer
     */
    emailCustomerUuid?: string;
    /**
     * First name
     * @type {string}
     * @memberof EmailCustomer
     */
    firstName?: string;
    /**
     * True if the customer has globally unsubscribed from all communication.
     * @type {boolean}
     * @memberof EmailCustomer
     */
    globalUnsubscribe?: boolean;
    /**
     * Last interaction
     * @type {string}
     * @memberof EmailCustomer
     */
    lastInteractionDts?: string;
    /**
     * Last name
     * @type {string}
     * @memberof EmailCustomer
     */
    lastName?: string;
    /**
     * UUIDs of the lists they are subscribed to
     * @type {Array<string>}
     * @memberof EmailCustomer
     */
    listUuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailCustomerEditorUrlResponse
 */
export interface EmailCustomerEditorUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailCustomerEditorUrlResponse
     */
    editorUrl?: string;
    /**
     * 
     * @type {Error}
     * @memberof EmailCustomerEditorUrlResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCustomerEditorUrlResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCustomerEditorUrlResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCustomerEditorUrlResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCustomersResponse
 */
export interface EmailCustomersResponse {
    /**
     * Customers on the page
     * @type {Array<EmailCustomer>}
     * @memberof EmailCustomersResponse
     */
    customers?: Array<EmailCustomer>;
    /**
     * Page number (one based offset)
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    pageNumber?: number;
    /**
     * Number of records per page
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    pageSize?: number;
    /**
     * Total customers
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    totalCustomers?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface EmailDashboardActivity
 */
export interface EmailDashboardActivity {
    /**
     * Type of action such as add, remove, subscribe, unsubscribe
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    action?: string;
    /**
     * Date/time of the activity
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    activityDts?: string;
    /**
     * List or segment name
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    destinationName?: string;
    /**
     * List or segment uuid
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    destinationUuid?: string;
    /**
     * Email address
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    email?: string;
    /**
     * true if activity is related to list
     * @type {boolean}
     * @memberof EmailDashboardActivity
     */
    isList?: boolean;
    /**
     * true if activity is related to segment
     * @type {boolean}
     * @memberof EmailDashboardActivity
     */
    isSegment?: boolean;
}

/**
 * 
 * @export
 * @interface EmailDashboardActivityResponse
 */
export interface EmailDashboardActivityResponse {
    /**
     * 
     * @type {Array<EmailDashboardActivity>}
     * @memberof EmailDashboardActivityResponse
     */
    activity?: Array<EmailDashboardActivity>;
    /**
     * 
     * @type {Error}
     * @memberof EmailDashboardActivityResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailDashboardActivityResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailDashboardActivityResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailDashboardActivityResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailDashboardStatsResponse
 */
export interface EmailDashboardStatsResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailDashboardStatsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailDashboardStatsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailStat>}
     * @memberof EmailDashboardStatsResponse
     */
    stats?: Array<EmailStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailDashboardStatsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailDashboardStatsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailDomain
 */
export interface EmailDomain {
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    comment?: string;
    /**
     * 
     * @type {Array<VerificationRecord>}
     * @memberof EmailDomain
     */
    dkim?: Array<VerificationRecord>;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    dkimStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    domain?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    espDomainUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    identityStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    merchantId?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    startDkimDts?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    startIdentityDts?: string;
    /**
     * 
     * @type {VerificationRecord}
     * @memberof EmailDomain
     */
    verification?: VerificationRecord;
}

/**
 * 
 * @export
 * @interface EmailEditorTokenResponse
 */
export interface EmailEditorTokenResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailEditorTokenResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailEditorTokenResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailEditorTokenResponse
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmailEditorTokenResponse
     */
    token?: string;
    /**
     * 
     * @type {Warning}
     * @memberof EmailEditorTokenResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlow
 */
export interface EmailFlow {
    /**
     * True if a customer may be enrolled in this flow multiple times
     * @type {boolean}
     * @memberof EmailFlow
     */
    allowMultipleConcurrentEnrollments?: boolean;
    /**
     * True if the flow is currently performing a back population.
     * @type {boolean}
     * @memberof EmailFlow
     */
    backPopulating?: boolean;
    /**
     * Click rate of emails, formatted
     * @type {string}
     * @memberof EmailFlow
     */
    clickRateFormatted?: string;
    /**
     * Created date
     * @type {string}
     * @memberof EmailFlow
     */
    createdDts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailFlow
     */
    deleted?: boolean;
    /**
     * Email communication sequence UUID
     * @type {string}
     * @memberof EmailFlow
     */
    emailCommunicationSequenceUuid?: string;
    /**
     * Email flow UUID
     * @type {string}
     * @memberof EmailFlow
     */
    emailFlowUuid?: string;
    /**
     * True if the customer should end the flow once they purchase
     * @type {boolean}
     * @memberof EmailFlow
     */
    endOnceCustomerPurchases?: boolean;
    /**
     * Number of enrolled customers.
     * @type {number}
     * @memberof EmailFlow
     */
    enrolledCustomers?: number;
    /**
     * Username of sending email
     * @type {string}
     * @memberof EmailFlow
     */
    espDomainUser?: string;
    /**
     * UUID of sending domain
     * @type {string}
     * @memberof EmailFlow
     */
    espDomainUuid?: string;
    /**
     * Friendly name of the sending email
     * @type {string}
     * @memberof EmailFlow
     */
    espFriendlyName?: string;
    /**
     * File profile equation json
     * @type {string}
     * @memberof EmailFlow
     */
    filterProfileEquationJson?: string;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof EmailFlow
     */
    libraryItemOid?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailFlow
     */
    merchantId?: string;
    /**
     * Name of email flow
     * @type {string}
     * @memberof EmailFlow
     */
    name?: string;
    /**
     * Open rate of emails, formatted
     * @type {string}
     * @memberof EmailFlow
     */
    openRateFormatted?: string;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailFlow
     */
    revenueFormatted?: string;
    /**
     * URL to a large full length screenshot
     * @type {string}
     * @memberof EmailFlow
     */
    screenshotLargeFullUrl?: string;
    /**
     * Status of the campaign of draft, archived, active, and inactive
     * @type {string}
     * @memberof EmailFlow
     */
    status?: string;
    /**
     * Timestamp when the last status change happened
     * @type {string}
     * @memberof EmailFlow
     */
    statusDts?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailFlow
     */
    storefrontOid?: number;
    /**
     * Trigger parameter
     * @type {string}
     * @memberof EmailFlow
     */
    triggerParameter?: string;
    /**
     * Trigger parameter name
     * @type {string}
     * @memberof EmailFlow
     */
    triggerParameterName?: string;
    /**
     * Trigger type
     * @type {string}
     * @memberof EmailFlow
     */
    triggerType?: string;
}

/**
 * 
 * @export
 * @interface EmailFlowBackPopulateRequest
 */
export interface EmailFlowBackPopulateRequest {
    /**
     * The age of the orders that should be considered for order triggers.
     * @type {number}
     * @memberof EmailFlowBackPopulateRequest
     */
    orderDaysOld?: number;
    /**
     * True if the age of the event should be considered when reducing the initial flow wait step
     * @type {boolean}
     * @memberof EmailFlowBackPopulateRequest
     */
    relativeToEvent?: boolean;
}

/**
 * 
 * @export
 * @interface EmailFlowBackPopulateResponse
 */
export interface EmailFlowBackPopulateResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailFlowBackPopulateResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowBackPopulateResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowBackPopulateResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowBackPopulateResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlowResponse
 */
export interface EmailFlowResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailFlowResponse
     */
    error?: Error;
    /**
     * 
     * @type {EmailFlow}
     * @memberof EmailFlowResponse
     */
    flow?: EmailFlow;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlowsResponse
 */
export interface EmailFlowsResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailFlowsResponse
     */
    error?: Error;
    /**
     * 
     * @type {Array<EmailFlow>}
     * @memberof EmailFlowsResponse
     */
    flows?: Array<EmailFlow>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailGlobalSettings
 */
export interface EmailGlobalSettings {
    /**
     * 
     * @type {boolean}
     * @memberof EmailGlobalSettings
     */
    dedicatedIp?: boolean;
}

/**
 * 
 * @export
 * @interface EmailGlobalSettingsResponse
 */
export interface EmailGlobalSettingsResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailGlobalSettingsResponse
     */
    error?: Error;
    /**
     * 
     * @type {EmailGlobalSettings}
     * @memberof EmailGlobalSettingsResponse
     */
    globalSettings?: EmailGlobalSettings;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailGlobalSettingsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailGlobalSettingsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailGlobalSettingsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailGlobalUnsubscribeRequest
 */
export interface EmailGlobalUnsubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailGlobalUnsubscribeRequest
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface EmailGlobalUnsubscribeResponse
 */
export interface EmailGlobalUnsubscribeResponse {
    /**
     * 
     * @type {number}
     * @memberof EmailGlobalUnsubscribeResponse
     */
    listsUnsubscribed?: number;
}

/**
 * 
 * @export
 * @interface EmailHistogramPropertyNamesResponse
 */
export interface EmailHistogramPropertyNamesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailHistogramPropertyNamesResponse
     */
    propertyNames?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailHistogramPropertyValuesResponse
 */
export interface EmailHistogramPropertyValuesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailHistogramPropertyValuesResponse
     */
    propertyValues?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailList
 */
export interface EmailList {
    /**
     * True if the current user has the rights to download this list.
     * @type {boolean}
     * @memberof EmailList
     */
    allowCsvDownload?: boolean;
    /**
     * Created date
     * @type {string}
     * @memberof EmailList
     */
    createdDts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailList
     */
    deleted?: boolean;
    /**
     * Email list UUID
     * @type {string}
     * @memberof EmailList
     */
    emailListUuid?: string;
    /**
     * Count of members in this list
     * @type {number}
     * @memberof EmailList
     */
    memberCount?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailList
     */
    merchantId?: string;
    /**
     * Name of email list
     * @type {string}
     * @memberof EmailList
     */
    name?: string;
    /**
     * Description of list shown to customer.
     * @type {string}
     * @memberof EmailList
     */
    publicDescription?: string;
    /**
     * True if this list is public
     * @type {boolean}
     * @memberof EmailList
     */
    publicList?: boolean;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailList
     */
    storefrontOid?: number;
    /**
     * Details on the flows or campaigns that use this list.
     * @type {Array<EmailListSegmentUsedBy>}
     * @memberof EmailList
     */
    usedBy?: Array<EmailListSegmentUsedBy>;
}

/**
 * 
 * @export
 * @interface EmailListArchiveResponse
 */
export interface EmailListArchiveResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailListArchiveResponse
     */
    error?: Error;
    /**
     * 
     * @type {boolean}
     * @memberof EmailListArchiveResponse
     */
    listInUse?: boolean;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListArchiveResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListArchiveResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListArchiveResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailListCustomer
 */
export interface EmailListCustomer {
    /**
     * Added timestamp
     * @type {string}
     * @memberof EmailListCustomer
     */
    addDts?: string;
    /**
     * Email
     * @type {string}
     * @memberof EmailListCustomer
     */
    email?: string;
    /**
     * Email customer UUID
     * @type {string}
     * @memberof EmailListCustomer
     */
    emailCustomerUuid?: string;
    /**
     * Email list member UUID
     * @type {string}
     * @memberof EmailListCustomer
     */
    emailListMemberUuid?: string;
}

/**
 * 
 * @export
 * @interface EmailListCustomersResponse
 */
export interface EmailListCustomersResponse {
    /**
     * Customers on the page
     * @type {Array<EmailListCustomer>}
     * @memberof EmailListCustomersResponse
     */
    customers?: Array<EmailListCustomer>;
    /**
     * Page number (one based offset)
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    pageNumber?: number;
    /**
     * Number of records per page
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    pageSize?: number;
    /**
     * Total customers
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    totalCustomers?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface EmailListResponse
 */
export interface EmailListResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailListResponse
     */
    error?: Error;
    /**
     * 
     * @type {EmailList}
     * @memberof EmailListResponse
     */
    list?: EmailList;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailListSegmentMembership
 */
export interface EmailListSegmentMembership {
    /**
     * UUID identifying this email list or null if this is a segment
     * @type {string}
     * @memberof EmailListSegmentMembership
     */
    emailListUuid?: string;
    /**
     * UUID identifying this email segment or null if this is a list
     * @type {string}
     * @memberof EmailListSegmentMembership
     */
    emailSegmentUuid?: string;
    /**
     * true if customers from this list/segment is excluded from membership
     * @type {boolean}
     * @memberof EmailListSegmentMembership
     */
    exclude?: boolean;
    /**
     * Name of this email list or segment
     * @type {string}
     * @memberof EmailListSegmentMembership
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EmailListSegmentUsedBy
 */
export interface EmailListSegmentUsedBy {
    /**
     * Email campaign UUID
     * @type {string}
     * @memberof EmailListSegmentUsedBy
     */
    emailCampaignUuid?: string;
    /**
     * Email flow UUID
     * @type {string}
     * @memberof EmailListSegmentUsedBy
     */
    emailFlowUuid?: string;
    /**
     * Name of the list or segment.
     * @type {string}
     * @memberof EmailListSegmentUsedBy
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EmailListSubscribeResponse
 */
export interface EmailListSubscribeResponse {
    /**
     * 
     * @type {number}
     * @memberof EmailListSubscribeResponse
     */
    added?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailListSubscribeResponse
     */
    memberCount?: number;
}

/**
 * 
 * @export
 * @interface EmailListsResponse
 */
export interface EmailListsResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailListsResponse
     */
    error?: Error;
    /**
     * 
     * @type {Array<EmailList>}
     * @memberof EmailListsResponse
     */
    lists?: Array<EmailList>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailOrder
 */
export interface EmailOrder {
    /**
     * email
     * @type {string}
     * @memberof EmailOrder
     */
    email?: string;
    /**
     * order_dts
     * @type {string}
     * @memberof EmailOrder
     */
    orderDts?: string;
    /**
     * order_id
     * @type {string}
     * @memberof EmailOrder
     */
    orderId?: string;
    /**
     * 
     * @type {Currency}
     * @memberof EmailOrder
     */
    total?: Currency;
}

/**
 * 
 * @export
 * @interface EmailOrdersResponse
 */
export interface EmailOrdersResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailOrdersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailOrdersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailOrder>}
     * @memberof EmailOrdersResponse
     */
    orders?: Array<EmailOrder>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailOrdersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailOrdersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailPerformance
 */
export interface EmailPerformance {
    /**
     * Active customers.  The value will be -1 if calculation is pending.
     * @type {number}
     * @memberof EmailPerformance
     */
    activeCustomers?: number;
    /**
     * Actual customers that they have regardless of active state.  The value will be -1 if calculation is pending.
     * @type {number}
     * @memberof EmailPerformance
     */
    actualCustomers?: number;
    /**
     * Bounce count
     * @type {number}
     * @memberof EmailPerformance
     */
    bounceCount?: number;
    /**
     * bounce percentage rate based upon our look back window.  This should be under five percent or the account will be paused for sending.
     * @type {number}
     * @memberof EmailPerformance
     */
    bouncePercentage?: number;
    /**
     * bounce percentage rate (formatted) based upon our look back window.  This should be under five percent or the account will be paused for sending.
     * @type {string}
     * @memberof EmailPerformance
     */
    bouncePercentageFormatted?: string;
    /**
     * 
     * @type {EmailPerformanceCustomerHistogram}
     * @memberof EmailPerformance
     */
    customerHistogram?: EmailPerformanceCustomerHistogram;
    /**
     * Daily statistics used for charting
     * @type {Array<EmailPerformanceDaily>}
     * @memberof EmailPerformance
     */
    dailyStats?: Array<EmailPerformanceDaily>;
    /**
     * Delivered count
     * @type {number}
     * @memberof EmailPerformance
     */
    deliveredCount?: number;
    /**
     * Maximum active customers allowed under their billing plan
     * @type {number}
     * @memberof EmailPerformance
     */
    maxActiveCustomers?: number;
    /**
     * Max emails per day
     * @type {number}
     * @memberof EmailPerformance
     */
    maxEmailsPerDay?: number;
    /**
     * Max emails per hour
     * @type {number}
     * @memberof EmailPerformance
     */
    maxEmailsPerHour?: number;
    /**
     * Max emails per month
     * @type {number}
     * @memberof EmailPerformance
     */
    maxEmailsPerMonth?: number;
    /**
     * True if campaign/flow emails are paused due to spam complaints.
     * @type {boolean}
     * @memberof EmailPerformance
     */
    pausedForSpam?: boolean;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailPerformance
     */
    revenue?: number;
    /**
     * Sent emails last 24 hours
     * @type {number}
     * @memberof EmailPerformance
     */
    sentEmailsPerDay?: number;
    /**
     * Sent emails last hour
     * @type {number}
     * @memberof EmailPerformance
     */
    sentEmailsPerHour?: number;
    /**
     * Sent emails last 31 days
     * @type {number}
     * @memberof EmailPerformance
     */
    sentEmailsPerMonth?: number;
    /**
     * Total sequence (campaign/flow) emails sent
     * @type {number}
     * @memberof EmailPerformance
     */
    sequenceSendCount?: number;
    /**
     * Spam complaints
     * @type {number}
     * @memberof EmailPerformance
     */
    spamCount?: number;
    /**
     * Spam percentage rate based upon our look back window.  This should be under one half a percent or the account will be paused for sending.
     * @type {number}
     * @memberof EmailPerformance
     */
    spamPercentage?: number;
    /**
     * Spam percentage rate (formatted) based upon our look back window.  This should be under one half a percent or the account will be paused for sending.
     * @type {string}
     * @memberof EmailPerformance
     */
    spamPercentageFormatted?: string;
    /**
     * Total transactions emails sent
     * @type {number}
     * @memberof EmailPerformance
     */
    transactionalSendCount?: number;
}

/**
 * 
 * @export
 * @interface EmailPerformanceCustomerHistogram
 */
export interface EmailPerformanceCustomerHistogram {
    /**
     * Periods (newest to oldest)
     * @type {Array<EmailPerformanceCustomerHistogramPeriod>}
     * @memberof EmailPerformanceCustomerHistogram
     */
    periods?: Array<EmailPerformanceCustomerHistogramPeriod>;
}

/**
 * 
 * @export
 * @interface EmailPerformanceCustomerHistogramPeriod
 */
export interface EmailPerformanceCustomerHistogramPeriod {
    /**
     * Active customers last active in this period
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    active?: number;
    /**
     * Inactive customers last active in this period
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    inactive?: number;
    /**
     * Month (1 = January)
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    month?: number;
    /**
     * Total customers last active in this period
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    total?: number;
    /**
     * Year (four digits)
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    year?: number;
}

/**
 * 
 * @export
 * @interface EmailPerformanceDaily
 */
export interface EmailPerformanceDaily {
    /**
     * Bounce count
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    bounceCount?: number;
    /**
     * Delivered count
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    deliveredCount?: number;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    revenue?: number;
    /**
     * Total sequence (campaign/flow) emails sent
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    sequenceSendCount?: number;
    /**
     * Spam complaints
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    spamCount?: number;
    /**
     * The date that these statistcs are for
     * @type {string}
     * @memberof EmailPerformanceDaily
     */
    statDts?: string;
    /**
     * Total transactions emails sent
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    transactionalSendCount?: number;
}

/**
 * 
 * @export
 * @interface EmailPerformanceResponse
 */
export interface EmailPerformanceResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailPerformanceResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailPerformanceResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailPerformance}
     * @memberof EmailPerformanceResponse
     */
    performance?: EmailPerformance;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailPerformanceResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailPerformanceResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailPlan
 */
export interface EmailPlan {
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    additionalCustomers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    additionalEmails?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlan
     */
    allowListImport?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlan
     */
    allowTrackingEmails?: boolean;
    /**
     * 
     * @type {Array<EmailPlanAdditional>}
     * @memberof EmailPlan
     */
    customerTiers?: Array<EmailPlanAdditional>;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    initialSendingLimits?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    planCustomers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    planEmails?: number;
    /**
     * 
     * @type {string}
     * @memberof EmailPlan
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailPlan
     */
    planNameFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    requireOrderWithinLastDays?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    revenuePercent?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    spamPercentLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    totalCustomers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    totalEmails?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    upgradeTo?: number;
}

/**
 * 
 * @export
 * @interface EmailPlanAdditional
 */
export interface EmailPlanAdditional {
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlanAdditional
     */
    canDowngrade?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlanAdditional
     */
    canUpgrade?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EmailPlanAdditional
     */
    cost?: number;
    /**
     * 
     * @type {string}
     * @memberof EmailPlanAdditional
     */
    costFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof EmailPlanAdditional
     */
    customers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlanAdditional
     */
    emails?: number;
}

/**
 * 
 * @export
 * @interface EmailPlanResponse
 */
export interface EmailPlanResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailPlanResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailPlanResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailPlan}
     * @memberof EmailPlanResponse
     */
    plan?: EmailPlan;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailPlanResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailPlanResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailPostcardStat
 */
export interface EmailPostcardStat {
    /**
     * Count of clicked emails
     * @type {number}
     * @memberof EmailPostcardStat
     */
    clickCount?: number;
    /**
     * Count of clicked emails, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    clickCountFormatted?: string;
    /**
     * Count of conversions
     * @type {number}
     * @memberof EmailPostcardStat
     */
    conversionCount?: number;
    /**
     * Count of conversions, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    conversionCountFormatted?: string;
    /**
     * Count of delivered emails
     * @type {number}
     * @memberof EmailPostcardStat
     */
    deliveredCount?: number;
    /**
     * Count of delivered emails, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    deliveredCountFormatted?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailPostcardStat
     */
    merchantId?: string;
    /**
     * List or segment name
     * @type {string}
     * @memberof EmailPostcardStat
     */
    name?: string;
    /**
     * Count of orders
     * @type {number}
     * @memberof EmailPostcardStat
     */
    orderCount?: number;
    /**
     * Count of orders, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    orderCountFormatted?: string;
    /**
     * Profit
     * @type {number}
     * @memberof EmailPostcardStat
     */
    profit?: number;
    /**
     * Profit, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    profitFormatted?: string;
    /**
     * Count of return to sender
     * @type {number}
     * @memberof EmailPostcardStat
     */
    returnToSenderCount?: number;
    /**
     * Count of return to sender, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    returnToSenderCountFormatted?: string;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailPostcardStat
     */
    revenue?: number;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    revenueFormatted?: string;
    /**
     * Count of emails sent
     * @type {number}
     * @memberof EmailPostcardStat
     */
    sendCount?: number;
    /**
     * Count of emails sent, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    sendCountFormatted?: string;
    /**
     * Count of skipped emails
     * @type {number}
     * @memberof EmailPostcardStat
     */
    skippedCount?: number;
    /**
     * Count of skipped emails, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    skippedCountFormatted?: string;
    /**
     * Count of emails classified as spam
     * @type {number}
     * @memberof EmailPostcardStat
     */
    spamCount?: number;
    /**
     * Count of emails classified as spam, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    spamCountFormatted?: string;
    /**
     * Campaign, Flow or None (for anything else)
     * @type {string}
     * @memberof EmailPostcardStat
     */
    statType?: string;
    /**
     * Status of campaign or flow
     * @type {string}
     * @memberof EmailPostcardStat
     */
    status?: string;
    /**
     * Status dts of campaign or flow
     * @type {string}
     * @memberof EmailPostcardStat
     */
    statusDts?: string;
    /**
     * 
     * @type {Array<EmailPostcardStat>}
     * @memberof EmailPostcardStat
     */
    steps?: Array<EmailPostcardStat>;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailPostcardStat
     */
    storefrontOid?: number;
    /**
     * Count of emails classified as unsubscribe
     * @type {number}
     * @memberof EmailPostcardStat
     */
    unsubscribeCount?: number;
    /**
     * Count of emails classified as unsubscribe, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    unsubscribeCountFormatted?: string;
    /**
     * List or segment uuid
     * @type {string}
     * @memberof EmailPostcardStat
     */
    uuid?: string;
    /**
     * Count of views
     * @type {number}
     * @memberof EmailPostcardStat
     */
    viewCount?: number;
    /**
     * Count of views, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    viewCountFormatted?: string;
}

/**
 * 
 * @export
 * @interface EmailSegment
 */
export interface EmailSegment {
    /**
     * True if the current user has the rights to download this segment.
     * @type {boolean}
     * @memberof EmailSegment
     */
    allowCsvDownload?: boolean;
    /**
     * True if this StoreFront has the Facebook Analytics app connected and supports them
     * @type {boolean}
     * @memberof EmailSegment
     */
    allowFacebookAudiences?: boolean;
    /**
     * Created date
     * @type {string}
     * @memberof EmailSegment
     */
    createdDts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailSegment
     */
    deleted?: boolean;
    /**
     * Email segment UUID
     * @type {string}
     * @memberof EmailSegment
     */
    emailSegmentUuid?: string;
    /**
     * True if you want to sync to a facebook custom audience
     * @type {boolean}
     * @memberof EmailSegment
     */
    facebookCustomAudience?: boolean;
    /**
     * File profile equation json
     * @type {string}
     * @memberof EmailSegment
     */
    filterProfileEquationJson?: string;
    /**
     * Count of members in this segment
     * @type {number}
     * @memberof EmailSegment
     */
    memberCount?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailSegment
     */
    merchantId?: string;
    /**
     * Name of email segment
     * @type {string}
     * @memberof EmailSegment
     */
    name?: string;
    /**
     * Rank settings json
     * @type {string}
     * @memberof EmailSegment
     */
    rankJson?: string;
    /**
     * True if a rebuild is required because some part of the segment has changed
     * @type {boolean}
     * @memberof EmailSegment
     */
    rebuildRequired?: boolean;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailSegment
     */
    storefrontOid?: number;
    /**
     * Details on the flows or campaigns that use this list.
     * @type {Array<EmailListSegmentUsedBy>}
     * @memberof EmailSegment
     */
    usedBy?: Array<EmailListSegmentUsedBy>;
}

/**
 * 
 * @export
 * @interface EmailSegmentArchiveResponse
 */
export interface EmailSegmentArchiveResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailSegmentArchiveResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentArchiveResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof EmailSegmentArchiveResponse
     */
    segmentInUse?: boolean;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentArchiveResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentArchiveResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSegmentCustomer
 */
export interface EmailSegmentCustomer {
    /**
     * Added timestamp
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    addDts?: string;
    /**
     * Email
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    email?: string;
    /**
     * Email customer UUID
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    emailCustomerUuid?: string;
    /**
     * Email segment member UUID
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    emailSegmentMemberUuid?: string;
}

/**
 * 
 * @export
 * @interface EmailSegmentCustomersResponse
 */
export interface EmailSegmentCustomersResponse {
    /**
     * Customers on the page
     * @type {Array<EmailSegmentCustomer>}
     * @memberof EmailSegmentCustomersResponse
     */
    customers?: Array<EmailSegmentCustomer>;
    /**
     * Page number (one based offset)
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    pageNumber?: number;
    /**
     * Number of records per page
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    pageSize?: number;
    /**
     * Total customers
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    totalCustomers?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface EmailSegmentDownloadPrepareResponse
 */
export interface EmailSegmentDownloadPrepareResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    emailSegmentRebuildUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    emailSegmentUuid?: string;
    /**
     * 
     * @type {Error}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {number}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    percentageComplete?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    proceed?: boolean;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSegmentResponse
 */
export interface EmailSegmentResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailSegmentResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailSegment}
     * @memberof EmailSegmentResponse
     */
    segment?: EmailSegment;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSegmentsResponse
 */
export interface EmailSegmentsResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailSegmentsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailSegment>}
     * @memberof EmailSegmentsResponse
     */
    segments?: Array<EmailSegment>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSendingDomainResponse
 */
export interface EmailSendingDomainResponse {
    /**
     * 
     * @type {EmailDomain}
     * @memberof EmailSendingDomainResponse
     */
    domain?: EmailDomain;
    /**
     * 
     * @type {Error}
     * @memberof EmailSendingDomainResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSendingDomainResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSendingDomainResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSendingDomainResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSendingDomainsResponse
 */
export interface EmailSendingDomainsResponse {
    /**
     * 
     * @type {Array<EmailDomain>}
     * @memberof EmailSendingDomainsResponse
     */
    domains?: Array<EmailDomain>;
    /**
     * 
     * @type {Error}
     * @memberof EmailSendingDomainsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSendingDomainsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSendingDomainsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSendingDomainsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSettings
 */
export interface EmailSettings {
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    marketingEspDomainUser?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    marketingEspDomainUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    marketingEspFriendlyName?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcardFromAddress1?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcardFromAddress2?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcardFromCity?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcardFromName?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcardFromPostalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcardFromState?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    transactionalEspDomainUser?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    transactionalEspDomainUuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    transactionalEspFriendlyName?: string;
}

/**
 * 
 * @export
 * @interface EmailSettingsResponse
 */
export interface EmailSettingsResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailSettingsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSettingsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailSettings}
     * @memberof EmailSettingsResponse
     */
    settings?: EmailSettings;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSettingsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSettingsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStat
 */
export interface EmailStat {
    /**
     * Count of clicked emails
     * @type {number}
     * @memberof EmailStat
     */
    clickCount?: number;
    /**
     * Count of clicked emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    clickCountFormatted?: string;
    /**
     * Count of conversions
     * @type {number}
     * @memberof EmailStat
     */
    conversionCount?: number;
    /**
     * Count of conversions, formatted
     * @type {string}
     * @memberof EmailStat
     */
    conversionCountFormatted?: string;
    /**
     * True if campaign/flow has been archived
     * @type {boolean}
     * @memberof EmailStat
     */
    deleted?: boolean;
    /**
     * Count of delivered emails
     * @type {number}
     * @memberof EmailStat
     */
    deliveredCount?: number;
    /**
     * Count of delivered emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    deliveredCountFormatted?: string;
    /**
     * Count of emails kicked
     * @type {number}
     * @memberof EmailStat
     */
    kickboxCount?: number;
    /**
     * Count of emails kicked, formatted
     * @type {string}
     * @memberof EmailStat
     */
    kickboxCountFormatted?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailStat
     */
    merchantId?: string;
    /**
     * List or segment name
     * @type {string}
     * @memberof EmailStat
     */
    name?: string;
    /**
     * Count of opened emails
     * @type {number}
     * @memberof EmailStat
     */
    openCount?: number;
    /**
     * Count of opened emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    openCountFormatted?: string;
    /**
     * Count of orders
     * @type {number}
     * @memberof EmailStat
     */
    orderCount?: number;
    /**
     * Count of orders, formatted
     * @type {string}
     * @memberof EmailStat
     */
    orderCountFormatted?: string;
    /**
     * Count of emails permanently bounced
     * @type {number}
     * @memberof EmailStat
     */
    permanentBounceCount?: number;
    /**
     * Count of emails permanently bounced, formatted
     * @type {string}
     * @memberof EmailStat
     */
    permanentBounceCountFormatted?: string;
    /**
     * Profit
     * @type {number}
     * @memberof EmailStat
     */
    profit?: number;
    /**
     * Profit, formatted
     * @type {string}
     * @memberof EmailStat
     */
    profitFormatted?: string;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailStat
     */
    revenue?: number;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailStat
     */
    revenueFormatted?: string;
    /**
     * Count of emails sent
     * @type {number}
     * @memberof EmailStat
     */
    sendCount?: number;
    /**
     * Count of emails sent, formatted
     * @type {string}
     * @memberof EmailStat
     */
    sendCountFormatted?: string;
    /**
     * Count of skipped emails
     * @type {number}
     * @memberof EmailStat
     */
    skippedCount?: number;
    /**
     * Count of skipped emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    skippedCountFormatted?: string;
    /**
     * Count of emails classified as spam
     * @type {number}
     * @memberof EmailStat
     */
    spamCount?: number;
    /**
     * Count of emails classified as spam, formatted
     * @type {string}
     * @memberof EmailStat
     */
    spamCountFormatted?: string;
    /**
     * Campaign, Flow or None (for anything else)
     * @type {string}
     * @memberof EmailStat
     */
    statType?: string;
    /**
     * Status of campaign or flow
     * @type {string}
     * @memberof EmailStat
     */
    status?: string;
    /**
     * Status dts of campaign or flow
     * @type {string}
     * @memberof EmailStat
     */
    statusDts?: string;
    /**
     * Step UUID if the statistics are at the step/email level
     * @type {string}
     * @memberof EmailStat
     */
    stepUuid?: string;
    /**
     * 
     * @type {Array<EmailStat>}
     * @memberof EmailStat
     */
    steps?: Array<EmailStat>;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailStat
     */
    storefrontOid?: number;
    /**
     * Count of emails classified as unsubscribe
     * @type {number}
     * @memberof EmailStat
     */
    unsubscribeCount?: number;
    /**
     * Count of emails classified as unsubscribe, formatted
     * @type {string}
     * @memberof EmailStat
     */
    unsubscribeCountFormatted?: string;
    /**
     * List/Segment uuid, or Flow/Campaign uuid depending on level of stat aggregation.
     * @type {string}
     * @memberof EmailStat
     */
    uuid?: string;
    /**
     * Count of views
     * @type {number}
     * @memberof EmailStat
     */
    viewCount?: number;
    /**
     * Count of views, formatted
     * @type {string}
     * @memberof EmailStat
     */
    viewCountFormatted?: string;
}

/**
 * 
 * @export
 * @interface EmailStatPostcardSummaryRequest
 */
export interface EmailStatPostcardSummaryRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStatPostcardSummaryRequest
     */
    commseqPostcardUuids?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof EmailStatPostcardSummaryRequest
     */
    days?: number;
}

/**
 * 
 * @export
 * @interface EmailStatPostcardSummaryResponse
 */
export interface EmailStatPostcardSummaryResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailStatPostcardSummaryResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailStatPostcardSummaryResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailPostcardStat>}
     * @memberof EmailStatPostcardSummaryResponse
     */
    stats?: Array<EmailPostcardStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailStatPostcardSummaryResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailStatPostcardSummaryResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStatSummaryRequest
 */
export interface EmailStatSummaryRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStatSummaryRequest
     */
    commseqEmailUuids?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStatSummaryRequest
     */
    commseqStepUuids?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof EmailStatSummaryRequest
     */
    days?: number;
}

/**
 * 
 * @export
 * @interface EmailStatSummaryResponse
 */
export interface EmailStatSummaryResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailStatSummaryResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailStatSummaryResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailStat>}
     * @memberof EmailStatSummaryResponse
     */
    stats?: Array<EmailStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailStatSummaryResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailStatSummaryResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStepStat
 */
export interface EmailStepStat {
    /**
     * conversion count (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    leftConversionCount?: number;
    /**
     * conversion count formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    leftConversionCountFormatted?: string;
    /**
     * customer count (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    leftCustomerCount?: number;
    /**
     * customer count formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    leftCustomerCountFormatted?: string;
    /**
     * order count (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    leftOrderCount?: number;
    /**
     * order count formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    leftOrderCountFormatted?: string;
    /**
     * profit (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    leftProfit?: number;
    /**
     * profit formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    leftProfitFormatted?: string;
    /**
     * revenue (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    leftRevenue?: number;
    /**
     * revenue formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    leftRevenueFormatted?: string;
    /**
     * conversion count (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    rightConversionCount?: number;
    /**
     * conversion count formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    rightConversionCountFormatted?: string;
    /**
     * customer count (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    rightCustomerCount?: number;
    /**
     * customer count formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    rightCustomerCountFormatted?: string;
    /**
     * order count (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    rightOrderCount?: number;
    /**
     * order count formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    rightOrderCountFormatted?: string;
    /**
     * profit (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    rightProfit?: number;
    /**
     * profit formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    rightProfitFormatted?: string;
    /**
     * revenue (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    rightRevenue?: number;
    /**
     * revenue formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    rightRevenueFormatted?: string;
}

/**
 * 
 * @export
 * @interface EmailStepStatRequest
 */
export interface EmailStepStatRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStepStatRequest
     */
    commseqStepUuids?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof EmailStepStatRequest
     */
    days?: number;
}

/**
 * 
 * @export
 * @interface EmailStepStatResponse
 */
export interface EmailStepStatResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailStepStatResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailStepStatResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailStepStat>}
     * @memberof EmailStepStatResponse
     */
    stats?: Array<EmailStepStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailStepStatResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailStepStatResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStepWaitingRequest
 */
export interface EmailStepWaitingRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStepWaitingRequest
     */
    commseqStepUuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailStepWaitingResponse
 */
export interface EmailStepWaitingResponse {
    /**
     * 
     * @type {Array<StepWaiting>}
     * @memberof EmailStepWaitingResponse
     */
    stepWaitings?: Array<StepWaiting>;
}

/**
 * 
 * @export
 * @interface EmailTemplate
 */
export interface EmailTemplate {
    /**
     * Container cjson
     * @type {string}
     * @memberof EmailTemplate
     */
    containerCjson?: string;
    /**
     * Description of email template
     * @type {string}
     * @memberof EmailTemplate
     */
    description?: string;
    /**
     * Email template oid
     * @type {number}
     * @memberof EmailTemplate
     */
    emailTemplateOid?: number;
    /**
     * Email Template VM Path
     * @type {string}
     * @memberof EmailTemplate
     */
    emailTemplateVmPath?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailTemplate
     */
    merchantId?: string;
    /**
     * Name of email template
     * @type {string}
     * @memberof EmailTemplate
     */
    name?: string;
    /**
     * Amazon key for preview png image
     * @type {string}
     * @memberof EmailTemplate
     */
    previewAmazonListingKey?: string;
    /**
     * Sort order (optional)
     * @type {number}
     * @memberof EmailTemplate
     */
    sortOrder?: number;
    /**
     * StoreFront oid
     * @type {number}
     * @memberof EmailTemplate
     */
    storefrontOid?: number;
    /**
     * True if this email template is system-wide,false if merchant specific
     * @type {boolean}
     * @memberof EmailTemplate
     */
    system?: boolean;
    /**
     * Trigger type
     * @type {string}
     * @memberof EmailTemplate
     */
    triggerType?: string;
}

/**
 * 
 * @export
 * @interface EmailTemplatesResponse
 */
export interface EmailTemplatesResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailTemplatesResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailTemplatesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailTemplatesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<EmailTemplate>}
     * @memberof EmailTemplatesResponse
     */
    templates?: Array<EmailTemplate>;
    /**
     * 
     * @type {Warning}
     * @memberof EmailTemplatesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyList
 */
export interface EmailThirdPartyList {
    /**
     * id
     * @type {string}
     * @memberof EmailThirdPartyList
     */
    id?: string;
    /**
     * name
     * @type {string}
     * @memberof EmailThirdPartyList
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyListImportRequest
 */
export interface EmailThirdPartyListImportRequest {
    /**
     * providers
     * @type {Array<EmailThirdPartyProvider>}
     * @memberof EmailThirdPartyListImportRequest
     */
    providers?: Array<EmailThirdPartyProvider>;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyProvider
 */
export interface EmailThirdPartyProvider {
    /**
     * URL to the settings screen to connect.  Null if the provider is already connected.
     * @type {string}
     * @memberof EmailThirdPartyProvider
     */
    connectUrl?: string;
    /**
     * list_count
     * @type {number}
     * @memberof EmailThirdPartyProvider
     */
    listCount?: number;
    /**
     * lists
     * @type {Array<EmailThirdPartyList>}
     * @memberof EmailThirdPartyProvider
     */
    lists?: Array<EmailThirdPartyList>;
    /**
     * logo_url
     * @type {string}
     * @memberof EmailThirdPartyProvider
     */
    logoUrl?: string;
    /**
     * name
     * @type {string}
     * @memberof EmailThirdPartyProvider
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyProvidersResponse
 */
export interface EmailThirdPartyProvidersResponse {
    /**
     * 
     * @type {Error}
     * @memberof EmailThirdPartyProvidersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailThirdPartyProvidersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailThirdPartyProvider>}
     * @memberof EmailThirdPartyProvidersResponse
     */
    providers?: Array<EmailThirdPartyProvider>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailThirdPartyProvidersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailThirdPartyProvidersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Error}
     * @memberof ErrorResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ErrorResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ErrorResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ErrorResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * Contained ID where the experiment element was located
     * @type {string}
     * @memberof Experiment
     */
    containerId?: string;
    /**
     * Duration in days
     * @type {number}
     * @memberof Experiment
     */
    durationDays?: number;
    /**
     * End date/time
     * @type {string}
     * @memberof Experiment
     */
    endDts?: string;
    /**
     * Whether or not traffic is equally weighted or shifts over time during the experiment
     * @type {boolean}
     * @memberof Experiment
     */
    equalWeighting?: boolean;
    /**
     * The type of experiment
     * @type {string}
     * @memberof Experiment
     */
    experimentType?: string;
    /**
     * Experiment id
     * @type {string}
     * @memberof Experiment
     */
    id?: string;
    /**
     * Experiment name
     * @type {string}
     * @memberof Experiment
     */
    name?: string;
    /**
     * Notes about the experiment
     * @type {string}
     * @memberof Experiment
     */
    notes?: string;
    /**
     * Objective that is being optimized
     * @type {string}
     * @memberof Experiment
     */
    objective?: string;
    /**
     * Objective parameter (such as event name) that is being optimized
     * @type {string}
     * @memberof Experiment
     */
    objectiveParameter?: string;
    /**
     * Type of optimization
     * @type {string}
     * @memberof Experiment
     */
    optimizationType?: string;
    /**
     * Total number of sessions in the experiment
     * @type {number}
     * @memberof Experiment
     */
    sessionCount?: number;
    /**
     * Start date/time
     * @type {string}
     * @memberof Experiment
     */
    startDts?: string;
    /**
     * Status of the experiment
     * @type {string}
     * @memberof Experiment
     */
    status?: Experiment.StatusEnum;
    /**
     * Storefront Experiment Oid
     * @type {number}
     * @memberof Experiment
     */
    storefrontExperimentOid?: number;
    /**
     * Storefront oid
     * @type {number}
     * @memberof Experiment
     */
    storefrontOid?: number;
    /**
     * URI the experiment was started on
     * @type {string}
     * @memberof Experiment
     */
    uri?: string;
    /**
     * Variations being tested in the experiment
     * @type {Array<ExperimentVariation>}
     * @memberof Experiment
     */
    variations?: Array<ExperimentVariation>;
}

/**
 * @export
 * @namespace Experiment
 */
export namespace Experiment {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Running = <any> 'Running',
        Ended = <any> 'Ended',
        Deleted = <any> 'Deleted'
    }
}

/**
 * 
 * @export
 * @interface ExperimentResponse
 */
export interface ExperimentResponse {
    /**
     * 
     * @type {Error}
     * @memberof ExperimentResponse
     */
    error?: Error;
    /**
     * 
     * @type {Experiment}
     * @memberof ExperimentResponse
     */
    experiment?: Experiment;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ExperimentResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ExperimentResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ExperimentResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ExperimentVariation
 */
export interface ExperimentVariation {
    /**
     * Total add to cart count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    addToCartCount?: number;
    /**
     * Average duration seconds per session for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    averageDurationSeconds?: number;
    /**
     * Average objective value per session for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    averageObjectivePerSession?: number;
    /**
     * Average order value for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    averageOrderValue?: number;
    /**
     * Total bounce count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    bounceCount?: number;
    /**
     * Conversion rate for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    conversionRate?: number;
    /**
     * Total number of seconds spent on the site for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    durationSecondsSum?: number;
    /**
     * Total event ocunt for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    eventCount?: number;
    /**
     * Total initiate checkout count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    initiateCheckoutCount?: number;
    /**
     * Total order count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    orderCount?: number;
    /**
     * Percentage of the traffic the variation originally started out with
     * @type {number}
     * @memberof ExperimentVariation
     */
    originalTrafficPercentage?: number;
    /**
     * Total page view count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    pageViewCount?: number;
    /**
     * Total revenue for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    revenue?: number;
    /**
     * Total sessions for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    sessionCount?: number;
    /**
     * Percentage of the traffic this variation is currently receiving
     * @type {number}
     * @memberof ExperimentVariation
     */
    trafficPercentage?: number;
    /**
     * Url of the variation if this experiment is a url experiment.
     * @type {string}
     * @memberof ExperimentVariation
     */
    url?: string;
    /**
     * Name of the variation
     * @type {string}
     * @memberof ExperimentVariation
     */
    variationName?: string;
    /**
     * Variation number
     * @type {number}
     * @memberof ExperimentVariation
     */
    variationNumber?: number;
    /**
     * True if this variation has been declared the winner
     * @type {boolean}
     * @memberof ExperimentVariation
     */
    winner?: boolean;
}

/**
 * 
 * @export
 * @interface ExperimentsResponse
 */
export interface ExperimentsResponse {
    /**
     * 
     * @type {Error}
     * @memberof ExperimentsResponse
     */
    error?: Error;
    /**
     * 
     * @type {Array<Experiment>}
     * @memberof ExperimentsResponse
     */
    experiments?: Array<Experiment>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ExperimentsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ExperimentsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ExperimentsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface FulfillmentInventory
 */
export interface FulfillmentInventory {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentInventory
     */
    itemId?: string;
    /**
     * 
     * @type {number}
     * @memberof FulfillmentInventory
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface FulfillmentShipment
 */
export interface FulfillmentShipment {
    /**
     * Fees charged by the fulfillment company other than the shipping cost to process the order.
     * @type {number}
     * @memberof FulfillmentShipment
     */
    fulfillmentFee?: number;
    /**
     * Order ID that was shipped
     * @type {string}
     * @memberof FulfillmentShipment
     */
    orderId?: string;
    /**
     * The cost of the packaging used to sent this shipment
     * @type {number}
     * @memberof FulfillmentShipment
     */
    packageCost?: number;
    /**
     * The actual total cost of shipping this order
     * @type {number}
     * @memberof FulfillmentShipment
     */
    shippingCost?: number;
    /**
     * Tracking numbers associated with the shipment
     * @type {Array<string>}
     * @memberof FulfillmentShipment
     */
    trackingNumbers?: Array<string>;
}

/**
 * 
 * @export
 * @interface GeocodeRequest
 */
export interface GeocodeRequest {
    /**
     * address
     * @type {string}
     * @memberof GeocodeRequest
     */
    address?: string;
    /**
     * city
     * @type {string}
     * @memberof GeocodeRequest
     */
    city?: string;
    /**
     * country_code
     * @type {string}
     * @memberof GeocodeRequest
     */
    countryCode?: string;
    /**
     * postal_code
     * @type {string}
     * @memberof GeocodeRequest
     */
    postalCode?: string;
    /**
     * state
     * @type {string}
     * @memberof GeocodeRequest
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface GeocodeResponse
 */
export interface GeocodeResponse {
    /**
     * 
     * @type {Error}
     * @memberof GeocodeResponse
     */
    error?: Error;
    /**
     * 
     * @type {number}
     * @memberof GeocodeResponse
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof GeocodeResponse
     */
    longitude?: number;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GeocodeResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof GeocodeResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof GeocodeResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * The unique object identifier (oid for short) for this group
     * @type {number}
     * @memberof Group
     */
    groupOid?: number;
    /**
     * The name of this group.
     * @type {string}
     * @memberof Group
     */
    name?: string;
    /**
     * A list of notifications the user receives.
     * @type {Array<Notification>}
     * @memberof Group
     */
    notifications?: Array<Notification>;
    /**
     * A list of permissions the user enjoys for accessing the backend of UltraCart.
     * @type {Array<Permission>}
     * @memberof Group
     */
    permissions?: Array<Permission>;
    /**
     * A list of users that belong to this group.
     * @type {Array<GroupUserMembership>}
     * @memberof Group
     */
    users?: Array<GroupUserMembership>;
}

/**
 * 
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * 
     * @type {Error}
     * @memberof GroupResponse
     */
    error?: Error;
    /**
     * 
     * @type {Group}
     * @memberof GroupResponse
     */
    group?: Group;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GroupResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof GroupResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof GroupResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface GroupUserMembership
 */
export interface GroupUserMembership {
    /**
     * The email for this user.
     * @type {string}
     * @memberof GroupUserMembership
     */
    email?: string;
    /**
     * The full name for this user.
     * @type {string}
     * @memberof GroupUserMembership
     */
    fullName?: string;
    /**
     * The login for this user.
     * @type {string}
     * @memberof GroupUserMembership
     */
    login?: string;
    /**
     * True if this user belongs to the parent group, false otherwise.
     * @type {boolean}
     * @memberof GroupUserMembership
     */
    member?: boolean;
    /**
     * The user id for this user.
     * @type {number}
     * @memberof GroupUserMembership
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface GroupsResponse
 */
export interface GroupsResponse {
    /**
     * 
     * @type {Error}
     * @memberof GroupsResponse
     */
    error?: Error;
    /**
     * 
     * @type {Array<Group>}
     * @memberof GroupsResponse
     */
    groups?: Array<Group>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GroupsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof GroupsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof GroupsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface HTTPHeader
 */
export interface HTTPHeader {
    /**
     * Name of the HTTP header
     * @type {string}
     * @memberof HTTPHeader
     */
    name?: string;
    /**
     * Value of the HTTP header
     * @type {string}
     * @memberof HTTPHeader
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {ItemAccounting}
     * @memberof Item
     */
    accounting?: ItemAccounting;
    /**
     * 
     * @type {ItemAmember}
     * @memberof Item
     */
    amember?: ItemAmember;
    /**
     * 
     * @type {ItemAutoOrder}
     * @memberof Item
     */
    autoOrder?: ItemAutoOrder;
    /**
     * 
     * @type {ItemCCBill}
     * @memberof Item
     */
    ccbill?: ItemCCBill;
    /**
     * Channel Partner Item Mapping
     * @type {Array<ItemChannelPartnerMapping>}
     * @memberof Item
     */
    channelPartnerMappings?: Array<ItemChannelPartnerMapping>;
    /**
     * 
     * @type {ItemChargeback}
     * @memberof Item
     */
    chargeback?: ItemChargeback;
    /**
     * 
     * @type {ItemCheckout}
     * @memberof Item
     */
    checkout?: ItemCheckout;
    /**
     * 
     * @type {ItemContent}
     * @memberof Item
     */
    content?: ItemContent;
    /**
     * Date/time of creation
     * @type {string}
     * @memberof Item
     */
    creationDts?: string;
    /**
     * Description of the item up to 500 characters.
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * Description translated text instance id
     * @type {number}
     * @memberof Item
     */
    descriptionTranslatedTextInstanceOid?: number;
    /**
     * 
     * @type {ItemDigitalDelivery}
     * @memberof Item
     */
    digitalDelivery?: ItemDigitalDelivery;
    /**
     * 
     * @type {ItemEbay}
     * @memberof Item
     */
    ebay?: ItemEbay;
    /**
     * 
     * @type {ItemEmailNotifications}
     * @memberof Item
     */
    emailNotifications?: ItemEmailNotifications;
    /**
     * 
     * @type {ItemEnrollment123}
     * @memberof Item
     */
    enrollment123?: ItemEnrollment123;
    /**
     * 
     * @type {ItemGiftCertificate}
     * @memberof Item
     */
    giftCertificate?: ItemGiftCertificate;
    /**
     * 
     * @type {ItemGoogleProductSearch}
     * @memberof Item
     */
    googleProductSearch?: ItemGoogleProductSearch;
    /**
     * 
     * @type {ItemIdentifiers}
     * @memberof Item
     */
    identifiers?: ItemIdentifiers;
    /**
     * True if this item is inactive and can not be purchased
     * @type {boolean}
     * @memberof Item
     */
    inactive?: boolean;
    /**
     * 
     * @type {ItemInstantPaymentNotifications}
     * @memberof Item
     */
    instantPaymentNotifications?: ItemInstantPaymentNotifications;
    /**
     * 
     * @type {ItemInternal}
     * @memberof Item
     */
    internal?: ItemInternal;
    /**
     * True if this item is a kit
     * @type {boolean}
     * @memberof Item
     */
    kit?: boolean;
    /**
     * True if this item can only be usd as a kit component
     * @type {boolean}
     * @memberof Item
     */
    kitComponentOnly?: boolean;
    /**
     * 
     * @type {ItemKitDefinition}
     * @memberof Item
     */
    kitDefinition?: ItemKitDefinition;
    /**
     * Date/time of last modification
     * @type {string}
     * @memberof Item
     */
    lastModifiedDts?: string;
    /**
     * UltraCart merchant ID owning item
     * @type {string}
     * @memberof Item
     */
    merchantId?: string;
    /**
     * Unique item id assigned to this item
     * @type {string}
     * @memberof Item
     */
    merchantItemId?: string;
    /**
     * Unique object identifier for this item
     * @type {number}
     * @memberof Item
     */
    merchantItemOid?: number;
    /**
     * Options
     * @type {Array<ItemOption>}
     * @memberof Item
     */
    options?: Array<ItemOption>;
    /**
     * Parent category of the item.  Zero indicates the root folder.
     * @type {number}
     * @memberof Item
     */
    parentCategoryId?: number;
    /**
     * Parent category path.  / indicates the root folder.
     * @type {string}
     * @memberof Item
     */
    parentCategoryPath?: string;
    /**
     * 
     * @type {ItemPaymentProcessing}
     * @memberof Item
     */
    paymentProcessing?: ItemPaymentProcessing;
    /**
     * 
     * @type {ItemPhysical}
     * @memberof Item
     */
    physical?: ItemPhysical;
    /**
     * 
     * @type {ItemPricing}
     * @memberof Item
     */
    pricing?: ItemPricing;
    /**
     * Properties
     * @type {Array<ItemProperty>}
     * @memberof Item
     */
    properties?: Array<ItemProperty>;
    /**
     * 
     * @type {ItemRealtimePricing}
     * @memberof Item
     */
    realtimePricing?: ItemRealtimePricing;
    /**
     * Number of days to recommend replenishment after.  Null is not configured.  Set to zero to disable.
     * @type {number}
     * @memberof Item
     */
    recommendReplenishmentDays?: number;
    /**
     * 
     * @type {ItemRelated}
     * @memberof Item
     */
    related?: ItemRelated;
    /**
     * 
     * @type {ItemReporting}
     * @memberof Item
     */
    reporting?: ItemReporting;
    /**
     * 
     * @type {ItemRestriction}
     * @memberof Item
     */
    restriction?: ItemRestriction;
    /**
     * 
     * @type {ItemRevguard}
     * @memberof Item
     */
    revguard?: ItemRevguard;
    /**
     * 
     * @type {ItemReviews}
     * @memberof Item
     */
    reviews?: ItemReviews;
    /**
     * 
     * @type {ItemSalesforce}
     * @memberof Item
     */
    salesforce?: ItemSalesforce;
    /**
     * 
     * @type {ItemShipping}
     * @memberof Item
     */
    shipping?: ItemShipping;
    /**
     * 
     * @type {ItemTags}
     * @memberof Item
     */
    tags?: ItemTags;
    /**
     * 
     * @type {ItemTax}
     * @memberof Item
     */
    tax?: ItemTax;
    /**
     * 3rd Party Email Marketing
     * @type {Array<ItemThirdPartyEmailMarketing>}
     * @memberof Item
     */
    thirdPartyEmailMarketing?: Array<ItemThirdPartyEmailMarketing>;
    /**
     * Variant Items
     * @type {Array<ItemVariantItem>}
     * @memberof Item
     */
    variantItems?: Array<ItemVariantItem>;
    /**
     * Variations
     * @type {Array<ItemVariation>}
     * @memberof Item
     */
    variations?: Array<ItemVariation>;
    /**
     * 
     * @type {ItemWishlistMember}
     * @memberof Item
     */
    wishlistMember?: ItemWishlistMember;
}

/**
 * 
 * @export
 * @interface ItemAccounting
 */
export interface ItemAccounting {
    /**
     * QuickBooks item name if different than the item id
     * @type {string}
     * @memberof ItemAccounting
     */
    accountingCode?: string;
    /**
     * QuickBooks class if you are classifying items on your invoices/receipts
     * @type {string}
     * @memberof ItemAccounting
     */
    qbClass?: string;
}

/**
 * 
 * @export
 * @interface ItemAmember
 */
export interface ItemAmember {
    /**
     * The number of days that the customer should be given access to the item
     * @type {number}
     * @memberof ItemAmember
     */
    amemberPaymentDurationDays?: number;
    /**
     * A-member product id give customer access to when they purchase this item
     * @type {string}
     * @memberof ItemAmember
     */
    amemberProductId?: string;
}

/**
 * 
 * @export
 * @interface ItemAutoOrder
 */
export interface ItemAutoOrder {
    /**
     * Amount to try and authorize for the future rebill
     * @type {number}
     * @memberof ItemAutoOrder
     */
    authFutureAmount?: number;
    /**
     * Amount to try and test authorize
     * @type {number}
     * @memberof ItemAutoOrder
     */
    authTestAmount?: number;
    /**
     * Item id to attempt charging the customer for if they cancel
     * @type {string}
     * @memberof ItemAutoOrder
     */
    autoOrderCancelItemId?: string;
    /**
     * Item object identifier to attempt charging the customer for if they cancel
     * @type {number}
     * @memberof ItemAutoOrder
     */
    autoOrderCancelItemOid?: number;
    /**
     * List of downgrade items presented to customer service representatives
     * @type {Array<string>}
     * @memberof ItemAutoOrder
     */
    autoOrderDowngradeItems?: Array<string>;
    /**
     * True if the rebill processing of this item is paused
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    autoOrderPaused?: boolean;
    /**
     * The user selectable schedules that are available
     * @type {Array<string>}
     * @memberof ItemAutoOrder
     */
    autoOrderSchedules?: Array<string>;
    /**
     * List of upgrade items presented to customer service representatives
     * @type {Array<string>}
     * @memberof ItemAutoOrder
     */
    autoOrderUpgradeItems?: Array<string>;
    /**
     * True if this item uses a fixed upsell step schedule
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    autoOrderUpsell?: boolean;
    /**
     * Do not send the easy cancel email to the customer
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    autoOrderUpsellNoEasyCancel?: boolean;
    /**
     * Limit the purchase of this item to one per customer
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    autoOrderUpsellOnePerCustomer?: boolean;
    /**
     * True if this item can be automatically ordered by the customer
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    autoOrderable?: boolean;
    /**
     * True if other auto orders for this customer should be canceled when this item is ordered
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    cancelOtherAutoOrders?: boolean;
    /**
     * True if the customer should be given free shipping
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    freeShippingAutoOrder?: boolean;
    /**
     * True if other auto orders for this customer should refunded if this item is refunded.
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    refundOtherAutoOrders?: boolean;
    /**
     * The rebill steps if this auto order is an upsell
     * @type {Array<ItemAutoOrderStep>}
     * @memberof ItemAutoOrder
     */
    steps?: Array<ItemAutoOrderStep>;
}

/**
 * 
 * @export
 * @interface ItemAutoOrderStep
 */
export interface ItemAutoOrderStep {
    /**
     * If the schedule is arbitrary, then this is the number of days
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    arbitraryScheduleDays?: number;
    /**
     * Arbitrary unit cost used to override the regular item cost
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    arbitraryUnitCost?: number;
    /**
     * Arbitrary unit costs schedules for more advanced discounting by rebill attempt
     * @type {Array<ItemAutoOrderStepArbitraryUnitCostSchedule>}
     * @memberof ItemAutoOrderStep
     */
    arbitraryUnitCostSchedules?: Array<ItemAutoOrderStepArbitraryUnitCostSchedule>;
    /**
     * Grand-father pricing configuration if the rebill schedule has changed over time
     * @type {Array<ItemAutoOrderStepGrandfatherPricing>}
     * @memberof ItemAutoOrderStep
     */
    grandfatherPricing?: Array<ItemAutoOrderStepGrandfatherPricing>;
    /**
     * Managed by (defaults to UltraCart)
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    managedBy?: string;
    /**
     * Number of days to pause
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    pauseDays?: number;
    /**
     * Wait for this step to happen until the specified date
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    pauseUntilDate?: string;
    /**
     * If set, a pre-shipment notice is sent to the customer this many days in advance
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    preshipmentNoticeDays?: number;
    /**
     * Item id to rebill
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    recurringMerchantItemId?: string;
    /**
     * Item object identifier to rebill
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    recurringMerchantItemOid?: number;
    /**
     * Number of times to rebill.  Last step can be null for infinite
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    repeatCount?: number;
    /**
     * Frequency of the rebill
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    schedule?: string;
    /**
     * Email list name to subscribe the customer to when the rebill occurs
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    subscribeEmailListName?: string;
    /**
     * Email list identifier to subscribe the customer to when this rebill occurs
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    subscribeEmailListOid?: number;
    /**
     * Type of step (item or pause)
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    type?: ItemAutoOrderStep.TypeEnum;
}

/**
 * @export
 * @namespace ItemAutoOrderStep
 */
export namespace ItemAutoOrderStep {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Item = <any> 'item',
        Pause = <any> 'pause'
    }
}

/**
 * 
 * @export
 * @interface ItemAutoOrderStepArbitraryUnitCostSchedule
 */
export interface ItemAutoOrderStepArbitraryUnitCostSchedule {
    /**
     * Arbitrary unit cost
     * @type {number}
     * @memberof ItemAutoOrderStepArbitraryUnitCostSchedule
     */
    arbitraryUnitCost?: number;
    /**
     * Retry days
     * @type {number}
     * @memberof ItemAutoOrderStepArbitraryUnitCostSchedule
     */
    retryDays?: number;
}

/**
 * 
 * @export
 * @interface ItemAutoOrderStepGrandfatherPricing
 */
export interface ItemAutoOrderStepGrandfatherPricing {
    /**
     * On or before date
     * @type {string}
     * @memberof ItemAutoOrderStepGrandfatherPricing
     */
    onOrBeforeDate?: string;
    /**
     * Unit cost
     * @type {number}
     * @memberof ItemAutoOrderStepGrandfatherPricing
     */
    unitCost?: number;
}

/**
 * 
 * @export
 * @interface ItemCCBill
 */
export interface ItemCCBill {
    /**
     * Allowed currencies
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbillAllowedCurrencies?: string;
    /**
     * Allowed types
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbillAllowedTypes?: string;
    /**
     * Currency code
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbillCurrencyCode?: string;
    /**
     * Form name
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbillFormName?: string;
    /**
     * Sub-account id
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbillSubaccountId?: string;
    /**
     * Subscription type id
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbillSubscriptionTypeId?: string;
}

/**
 * 
 * @export
 * @interface ItemChannelPartnerMapping
 */
export interface ItemChannelPartnerMapping {
    /**
     * Barcode UA (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcodeUa?: string;
    /**
     * Barcode UC (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcodeUc?: string;
    /**
     * Barcode UI (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcodeUi?: string;
    /**
     * Barcode UK (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcodeUk?: string;
    /**
     * Buyer catalog number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    buyerCatalogNumber?: string;
    /**
     * Buyer DPCI (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    buyerDpci?: string;
    /**
     * Buyer item number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    buyerItemNumber?: string;
    /**
     * Channel partner code
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    channelPartnerCode?: string;
    /**
     * Channel partner object identifier
     * @type {number}
     * @memberof ItemChannelPartnerMapping
     */
    channelPartnerOid?: number;
    /**
     * From Item ID
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    fromItemId?: string;
    /**
     * From SKU
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    fromSku?: string;
    /**
     * Mutually defined number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    mutuallyDefinedNumber?: string;
    /**
     * Ratio (Channel Partner)
     * @type {number}
     * @memberof ItemChannelPartnerMapping
     */
    quantityRatioCp?: number;
    /**
     * Ratio (UltraCart)
     * @type {number}
     * @memberof ItemChannelPartnerMapping
     */
    quantityRatioUc?: number;
    /**
     * SKU
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    sku?: string;
    /**
     * Unit of measure
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    unitOfMeasure?: string;
    /**
     * Vendor number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    vendorNumber?: string;
    /**
     * Vendor style number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    vendorStyleNumber?: string;
}

/**
 * 
 * @export
 * @interface ItemChargeback
 */
export interface ItemChargeback {
    /**
     * Addendums
     * @type {Array<ItemChargebackAddendum>}
     * @memberof ItemChargeback
     */
    addendums?: Array<ItemChargebackAddendum>;
    /**
     * Adjustment requests
     * @type {Array<ItemChargebackAdjustmentRequest>}
     * @memberof ItemChargeback
     */
    adjustmentRequests?: Array<ItemChargebackAdjustmentRequest>;
}

/**
 * 
 * @export
 * @interface ItemChargebackAddendum
 */
export interface ItemChargebackAddendum {
    /**
     * Chargeback addendum object identifier
     * @type {number}
     * @memberof ItemChargebackAddendum
     */
    chargebackAddendumOid?: number;
    /**
     * Description
     * @type {string}
     * @memberof ItemChargebackAddendum
     */
    description?: string;
    /**
     * Size of the file
     * @type {number}
     * @memberof ItemChargebackAddendum
     */
    fileSize?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof ItemChargebackAddendum
     */
    pages?: number;
}

/**
 * 
 * @export
 * @interface ItemChargebackAdjustmentRequest
 */
export interface ItemChargebackAdjustmentRequest {
    /**
     * Chargeback adjustment request object identifier
     * @type {number}
     * @memberof ItemChargebackAdjustmentRequest
     */
    chargebackAdjustmentRequestOid?: number;
    /**
     * Description
     * @type {string}
     * @memberof ItemChargebackAdjustmentRequest
     */
    description?: string;
    /**
     * Reason code
     * @type {string}
     * @memberof ItemChargebackAdjustmentRequest
     */
    reasonCode?: string;
}

/**
 * 
 * @export
 * @interface ItemCheckout
 */
export interface ItemCheckout {
    /**
     * True to suppress buySAFE (deprecated)
     * @type {boolean}
     * @memberof ItemCheckout
     */
    suppressBuysafe?: boolean;
    /**
     * Terms for purchasing this item
     * @type {string}
     * @memberof ItemCheckout
     */
    terms?: string;
    /**
     * Terms translated text instance identifier
     * @type {number}
     * @memberof ItemCheckout
     */
    termsTranslatedTextInstanceOid?: number;
}

/**
 * 
 * @export
 * @interface ItemContent
 */
export interface ItemContent {
    /**
     * StoreFront assignments
     * @type {Array<ItemContentAssignment>}
     * @memberof ItemContent
     */
    assignments?: Array<ItemContentAssignment>;
    /**
     * StoreFront attributes
     * @type {Array<ItemContentAttribute>}
     * @memberof ItemContent
     */
    attributes?: Array<ItemContentAttribute>;
    /**
     * Custom Thank You URL
     * @type {string}
     * @memberof ItemContent
     */
    customThankYouUrl?: string;
    /**
     * Exclude from search
     * @type {boolean}
     * @memberof ItemContent
     */
    excludeFromSearch?: boolean;
    /**
     * Exclude from the top sellers list in the StoreFront
     * @type {boolean}
     * @memberof ItemContent
     */
    excludeFromTopSellers?: boolean;
    /**
     * Extended description (max 2000 characters)
     * @type {string}
     * @memberof ItemContent
     */
    extendedDescription?: string;
    /**
     * Extneded description text translation instance identifier
     * @type {number}
     * @memberof ItemContent
     */
    extendedDescriptionTranslatedTextInstanceOid?: number;
    /**
     * Multimedia
     * @type {Array<ItemContentMultimedia>}
     * @memberof ItemContent
     */
    multimedia?: Array<ItemContentMultimedia>;
    /**
     * True if the item is new
     * @type {boolean}
     * @memberof ItemContent
     */
    newItem?: boolean;
    /**
     * The date the item should no longer be considered new
     * @type {string}
     * @memberof ItemContent
     */
    newItemEnd?: string;
    /**
     * The date the item should start being considered new
     * @type {string}
     * @memberof ItemContent
     */
    newItemStart?: string;
    /**
     * Legacy view URL (not used by StoreFronts)
     * @type {string}
     * @memberof ItemContent
     */
    viewUrl?: string;
}

/**
 * 
 * @export
 * @interface ItemContentAssignment
 */
export interface ItemContentAssignment {
    /**
     * Page (group) object identifier
     * @type {number}
     * @memberof ItemContentAssignment
     */
    groupOid?: number;
    /**
     * Page (group) path
     * @type {string}
     * @memberof ItemContentAssignment
     */
    groupPath?: string;
    /**
     * StoreFront host name
     * @type {string}
     * @memberof ItemContentAssignment
     */
    host?: string;
    /**
     * Sort order (optional)
     * @type {number}
     * @memberof ItemContentAssignment
     */
    sortOrder?: number;
    /**
     * URL part if the item id is not used
     * @type {string}
     * @memberof ItemContentAssignment
     */
    urlPart?: string;
}

/**
 * 
 * @export
 * @interface ItemContentAttribute
 */
export interface ItemContentAttribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof ItemContentAttribute
     */
    name?: string;
    /**
     * Attribute translated text instance identifier
     * @type {number}
     * @memberof ItemContentAttribute
     */
    translatedTextInstanceOid?: number;
    /**
     * Attribute type
     * @type {string}
     * @memberof ItemContentAttribute
     */
    type?: string;
    /**
     * Attribute value
     * @type {string}
     * @memberof ItemContentAttribute
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemContentMultimedia
 */
export interface ItemContentMultimedia {
    /**
     * URL where the image can be downloaded from the cloud
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    cloudUrl?: string;
    /**
     * Expiration date of the cloud URL
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    cloudUrlExpiration?: string;
    /**
     * Code assigned to the file
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    code?: string;
    /**
     * Description
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    description?: string;
    /**
     * True to exclude from multimedia gallery
     * @type {boolean}
     * @memberof ItemContentMultimedia
     */
    excludeFromGallery?: boolean;
    /**
     * File name
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    fileName?: string;
    /**
     * Height of the image
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    height?: number;
    /**
     * Item multimedia object identifier
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    merchantItemMultimediaOid?: number;
    /**
     * True if the multimedia is an orphan of the active StoreFront themes
     * @type {boolean}
     * @memberof ItemContentMultimedia
     */
    orphan?: boolean;
    /**
     * True if the object is a place holder that can be populated
     * @type {boolean}
     * @memberof ItemContentMultimedia
     */
    placeholder?: boolean;
    /**
     * Temporary multimedia object identifier assigned if uploading new multimedia
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    tempMultimediaOid?: number;
    /**
     * Thumbnails of this image
     * @type {Array<ItemContentMultimediaThumbnail>}
     * @memberof ItemContentMultimedia
     */
    thumbnails?: Array<ItemContentMultimediaThumbnail>;
    /**
     * Type of file
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    type?: ItemContentMultimedia.TypeEnum;
    /**
     * URL to download file (on new multimedia record this can be a URL for UltraCart to fetch)
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    url?: string;
    /**
     * Width of the image
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    width?: number;
}

/**
 * @export
 * @namespace ItemContentMultimedia
 */
export namespace ItemContentMultimedia {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}

/**
 * 
 * @export
 * @interface ItemContentMultimediaThumbnail
 */
export interface ItemContentMultimediaThumbnail {
    /**
     * Height of the thumbnail
     * @type {number}
     * @memberof ItemContentMultimediaThumbnail
     */
    height?: number;
    /**
     * HTTP URL to view the thumbnail
     * @type {string}
     * @memberof ItemContentMultimediaThumbnail
     */
    httpUrl?: string;
    /**
     * HTTPS URL to view the thumbnail
     * @type {string}
     * @memberof ItemContentMultimediaThumbnail
     */
    httpsUrl?: string;
    /**
     * True if PNG, false if JPEG
     * @type {boolean}
     * @memberof ItemContentMultimediaThumbnail
     */
    pngFormat?: boolean;
    /**
     * True if the thumbnail is square
     * @type {boolean}
     * @memberof ItemContentMultimediaThumbnail
     */
    square?: boolean;
    /**
     * Width of the thumbnail
     * @type {number}
     * @memberof ItemContentMultimediaThumbnail
     */
    width?: number;
}

/**
 * 
 * @export
 * @interface ItemDigitalDelivery
 */
export interface ItemDigitalDelivery {
    /**
     * Description of the activation code
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activationCodeDescription?: string;
    /**
     * The number of activation codes whcih should generate a warning email
     * @type {number}
     * @memberof ItemDigitalDelivery
     */
    activationCodeLowWarning?: number;
    /**
     * The URL to retrieve activation codes from in real-time
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activationCodeRealtimeUrl?: string;
    /**
     * Shared secret used when communicating with the real-time URL
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activationCodeSharedSecret?: string;
    /**
     * Type of activation code
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activationCodeType?: string;
    /**
     * Digital items that customer can download when this item is purchased
     * @type {Array<ItemDigitalItem>}
     * @memberof ItemDigitalDelivery
     */
    digitalItems?: Array<ItemDigitalItem>;
}

/**
 * 
 * @export
 * @interface ItemDigitalItem
 */
export interface ItemDigitalItem {
    /**
     * File creation date
     * @type {string}
     * @memberof ItemDigitalItem
     */
    creationDts?: string;
    /**
     * Description of the digital item
     * @type {string}
     * @memberof ItemDigitalItem
     */
    description?: string;
    /**
     * File size
     * @type {number}
     * @memberof ItemDigitalItem
     */
    fileSize?: number;
    /**
     * Mime type associated with the file
     * @type {string}
     * @memberof ItemDigitalItem
     */
    mimeType?: string;
    /**
     * Original filename
     * @type {string}
     * @memberof ItemDigitalItem
     */
    originalFilename?: string;
}

/**
 * 
 * @export
 * @interface ItemEbay
 */
export interface ItemEbay {
    /**
     * True if the item is active for listing
     * @type {boolean}
     * @memberof ItemEbay
     */
    active?: boolean;
    /**
     * e-Bay category ID
     * @type {number}
     * @memberof ItemEbay
     */
    categoryId?: number;
    /**
     * Answers to category specific questions
     * @type {Array<ItemEbayCategorySpecific>}
     * @memberof ItemEbay
     */
    categorySpecifics?: Array<ItemEbayCategorySpecific>;
    /**
     * Description of the condition (e-Bay constant)
     * @type {string}
     * @memberof ItemEbay
     */
    conditionDescription?: string;
    /**
     * Numerical ID of the condition (e-Bay constant)
     * @type {number}
     * @memberof ItemEbay
     */
    conditionId?: number;
    /**
     * Number of consecutive failures trying to list this item
     * @type {number}
     * @memberof ItemEbay
     */
    consecutiveFailures?: number;
    /**
     * e-Bay Store category 1
     * @type {number}
     * @memberof ItemEbay
     */
    customCategory1?: number;
    /**
     * e-Bay Store category 2
     * @type {number}
     * @memberof ItemEbay
     */
    customCategory2?: number;
    /**
     * Maximum number of days it will take to ship the item
     * @type {number}
     * @memberof ItemEbay
     */
    dispatchTimeMax?: number;
    /**
     * Domestic 1 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic1AdditionalCost?: number;
    /**
     * Domestic 1 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic1FirstCost?: number;
    /**
     * Domestic 2 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic2AdditionalCost?: number;
    /**
     * Domestic 2 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic2FirstCost?: number;
    /**
     * Domestic 3 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic3AdditionalCost?: number;
    /**
     * Domestic 3 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic3FirstCost?: number;
    /**
     * Domestic 4 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic4AdditionalCost?: number;
    /**
     * Domestic 4 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic4FirstCost?: number;
    /**
     * If listed, this is the e-Bay auction id
     * @type {string}
     * @memberof ItemEbay
     */
    ebayAuctionId?: string;
    /**
     * e-Bay specific inventory
     * @type {number}
     * @memberof ItemEbay
     */
    ebaySpecificInventory?: number;
    /**
     * The template name to use hwen rendering the e-Bay listing
     * @type {string}
     * @memberof ItemEbay
     */
    ebayTemplateName?: string;
    /**
     * The template object identifier to use when rendering the e-Bay listing
     * @type {number}
     * @memberof ItemEbay
     */
    ebayTemplateOid?: number;
    /**
     * Date/time of the auction end
     * @type {string}
     * @memberof ItemEbay
     */
    endTime?: string;
    /**
     * True if item receives free shipping
     * @type {boolean}
     * @memberof ItemEbay
     */
    freeShipping?: boolean;
    /**
     * The method that is free for free shipping
     * @type {string}
     * @memberof ItemEbay
     */
    freeShippingMethod?: string;
    /**
     * International 1 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international1AdditionalCost?: number;
    /**
     * International 1 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international1FirstCost?: number;
    /**
     * International 2 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international2AdditionalCost?: number;
    /**
     * International 2 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international2FirstCost?: number;
    /**
     * International 3 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international3AdditionalCost?: number;
    /**
     * International 3 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international3FirstCost?: number;
    /**
     * International 4 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international4AdditionalCost?: number;
    /**
     * International 4 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international4FirstCost?: number;
    /**
     * Date/time of the last status check
     * @type {string}
     * @memberof ItemEbay
     */
    lastStatusDts?: string;
    /**
     * Current listing dispatch time maximum
     * @type {number}
     * @memberof ItemEbay
     */
    listedDispatchTimeMax?: number;
    /**
     * The template object identifier used for the listing
     * @type {number}
     * @memberof ItemEbay
     */
    listedEbayTemplateOid?: number;
    /**
     * Date/time of the listing
     * @type {string}
     * @memberof ItemEbay
     */
    listingDts?: string;
    /**
     * The duration of the listing
     * @type {string}
     * @memberof ItemEbay
     */
    listingDuration?: string;
    /**
     * Price to list the item at
     * @type {number}
     * @memberof ItemEbay
     */
    listingPrice?: number;
    /**
     * The price to list the item at if different than the regular UltraCart item price
     * @type {number}
     * @memberof ItemEbay
     */
    listingPriceOverride?: number;
    /**
     * The type of e-Bay listing
     * @type {string}
     * @memberof ItemEbay
     */
    listingType?: string;
    /**
     * 
     * @type {ItemEbayMarketPlaceAnalysis}
     * @memberof ItemEbay
     */
    marketplaceAnalysis?: ItemEbayMarketPlaceAnalysis;
    /**
     * True if marketplace analysis should be performed
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplaceAnalysisPerform?: boolean;
    /**
     * Marketplace FVF percentage
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceFinalValueFeePercentage?: number;
    /**
     * Date/time of the marketplace analysis last check
     * @type {string}
     * @memberof ItemEbay
     */
    marketplaceLastCheckDts?: string;
    /**
     * True if we are the lowest offer in the marketplace
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplaceLowest?: boolean;
    /**
     * True if another seller is violating MAP
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplaceMapViolation?: boolean;
    /**
     * Marketplace multiplier
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceMultiplier?: number;
    /**
     * Marketplace other price
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOtherPrice?: number;
    /**
     * Marketplace other seller
     * @type {string}
     * @memberof ItemEbay
     */
    marketplaceOtherSeller?: string;
    /**
     * Marketplace other shipping
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOtherShipping?: number;
    /**
     * Marketplace other total
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOtherTotal?: number;
    /**
     * Marketplace our additional profit potential
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOurAdditionalProfitPotential?: number;
    /**
     * Marketplace our price
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOurPrice?: number;
    /**
     * Marketplace our profit
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOurProfit?: number;
    /**
     * Marketplace our shipping
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOurShipping?: number;
    /**
     * Marketplace our total
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOurTotal?: number;
    /**
     * Marketplace overhead
     * @type {number}
     * @memberof ItemEbay
     */
    marketplaceOverhead?: number;
    /**
     * True if our listing is profitable to sell
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplaceProfitable?: boolean;
    /**
     * Date/time for the next attempt to list
     * @type {string}
     * @memberof ItemEbay
     */
    nextAttemptDts?: string;
    /**
     * The next listing duration to use when the current listing ends.
     * @type {string}
     * @memberof ItemEbay
     */
    nextListingDuration?: string;
    /**
     * True if the item should not qualify for promotional shipping
     * @type {boolean}
     * @memberof ItemEbay
     */
    noPromotionalShipping?: boolean;
    /**
     * Packaging and handling costs
     * @type {number}
     * @memberof ItemEbay
     */
    packagingHandlingCosts?: number;
    /**
     * Previous e-Bay auction id
     * @type {string}
     * @memberof ItemEbay
     */
    previousEbayAuctionId?: string;
    /**
     * Quantity available of the item
     * @type {number}
     * @memberof ItemEbay
     */
    quantity?: number;
    /**
     * Reserve price
     * @type {number}
     * @memberof ItemEbay
     */
    reservePrice?: number;
    /**
     * How to send the item dimensions and weights to e-Bay
     * @type {string}
     * @memberof ItemEbay
     */
    sendDimensionsAndWeight?: string;
    /**
     * Date/time of the auction start
     * @type {string}
     * @memberof ItemEbay
     */
    startTime?: string;
    /**
     * Status of the item's listing
     * @type {string}
     * @memberof ItemEbay
     */
    status?: string;
    /**
     * Typical number of days it will take to ship the item
     * @type {number}
     * @memberof ItemEbay
     */
    targetDispatchTimeMax?: number;
}

/**
 * 
 * @export
 * @interface ItemEbayCategorySpecific
 */
export interface ItemEbayCategorySpecific {
    /**
     * Name of the category specification field
     * @type {string}
     * @memberof ItemEbayCategorySpecific
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof ItemEbayCategorySpecific
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemEbayMarketListing
 */
export interface ItemEbayMarketListing {
    /**
     * Auction ID
     * @type {string}
     * @memberof ItemEbayMarketListing
     */
    auctionId?: string;
    /**
     * Price
     * @type {number}
     * @memberof ItemEbayMarketListing
     */
    price?: number;
    /**
     * Seller
     * @type {string}
     * @memberof ItemEbayMarketListing
     */
    seller?: string;
    /**
     * Shipping
     * @type {number}
     * @memberof ItemEbayMarketListing
     */
    shipping?: number;
    /**
     * Total
     * @type {number}
     * @memberof ItemEbayMarketListing
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface ItemEbayMarketPlaceAnalysis
 */
export interface ItemEbayMarketPlaceAnalysis {
    /**
     * Adjusted price
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    adjustedPrice?: number;
    /**
     * Adjusted shipping
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    adjustedShipping?: number;
    /**
     * Adjusted total
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    adjustedTotal?: number;
    /**
     * Cost of goods sold
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    cogs?: number;
    /**
     * Final value fee
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    finalValueFee?: number;
    /**
     * Minimum advertised price
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    minimumAdvertisedPrice?: number;
    /**
     * Other listings
     * @type {Array<ItemEbayMarketListing>}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    otherListings?: Array<ItemEbayMarketListing>;
    /**
     * 
     * @type {ItemEbayMarketListing}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    ourListing?: ItemEbayMarketListing;
    /**
     * Overhead
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    overhead?: number;
    /**
     * Profit potential
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    profitPotential?: number;
}

/**
 * 
 * @export
 * @interface ItemEmailNotifications
 */
export interface ItemEmailNotifications {
    /**
     * Skip receipt email to customer
     * @type {boolean}
     * @memberof ItemEmailNotifications
     */
    skipReceipt?: boolean;
    /**
     * Skip shipment notification to customer
     * @type {boolean}
     * @memberof ItemEmailNotifications
     */
    skipShipmentNotification?: boolean;
}

/**
 * 
 * @export
 * @interface ItemEnrollment123
 */
export interface ItemEnrollment123 {
    /**
     * Enrolment 123 product code
     * @type {string}
     * @memberof ItemEnrollment123
     */
    enrollment123ProductCode?: string;
}

/**
 * 
 * @export
 * @interface ItemGiftCertificate
 */
export interface ItemGiftCertificate {
    /**
     * True if the purchase of this item generates a gift certificate
     * @type {boolean}
     * @memberof ItemGiftCertificate
     */
    giftCertificate?: boolean;
    /**
     * The number of days that the gift certificate is good for (optional)
     * @type {number}
     * @memberof ItemGiftCertificate
     */
    giftCertificateExpirationDays?: number;
}

/**
 * 
 * @export
 * @interface ItemGoogleProductSearch
 */
export interface ItemGoogleProductSearch {
    /**
     * Adwords grouping
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwordsGrouping?: string;
    /**
     * Adwords label 1
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwordsLabel1?: string;
    /**
     * Adwords label 2
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwordsLabel2?: string;
    /**
     * Adwords label 3
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwordsLabel3?: string;
    /**
     * Adwords label 4
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwordsLabel4?: string;
    /**
     * Adwords label 5
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwordsLabel5?: string;
    /**
     * Age group
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    ageGroup?: string;
    /**
     * Available at physical store
     * @type {boolean}
     * @memberof ItemGoogleProductSearch
     */
    availableAtPhysicalStore?: boolean;
    /**
     * Book - author
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    bookAuthor?: string;
    /**
     * Book - format
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    bookFormat?: string;
    /**
     * Bood - ISBN
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    bookIsbn?: string;
    /**
     * Book - publisher
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    bookPublisher?: string;
    /**
     * Category description
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    categoryDescription?: string;
    /**
     * Color
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    color?: string;
    /**
     * Condition
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    condition?: string;
    /**
     * Custom label 0
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    customLabel0?: string;
    /**
     * Custom label 1
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    customLabel1?: string;
    /**
     * Custom label 2
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    customLabel2?: string;
    /**
     * Custom label 3
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    customLabel3?: string;
    /**
     * Custom label 4
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    customLabel4?: string;
    /**
     * Gender
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    gender?: string;
    /**
     * Google product category
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    googleProductCategory?: string;
    /**
     * Music - artist
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    musicArtist?: string;
    /**
     * Music - format
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    musicFormat?: string;
    /**
     * Music - release date
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    musicReleaseDate?: string;
    /**
     * Omit from feed
     * @type {boolean}
     * @memberof ItemGoogleProductSearch
     */
    omitFromFeed?: boolean;
    /**
     * Product type
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    productType?: string;
    /**
     * Promotion ID 1
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId1?: string;
    /**
     * Promotion ID 10
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId10?: string;
    /**
     * Promotion ID 2
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId2?: string;
    /**
     * Promotion ID 3
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId3?: string;
    /**
     * Promotion ID 4
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId4?: string;
    /**
     * Promotion ID 5
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId5?: string;
    /**
     * Promotion ID 6
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId6?: string;
    /**
     * Promotion ID 7
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId7?: string;
    /**
     * Promotion ID 8
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId8?: string;
    /**
     * Promotion ID 9
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotionId9?: string;
    /**
     * Search date/time
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    searchDts?: string;
    /**
     * Search lowest price
     * @type {number}
     * @memberof ItemGoogleProductSearch
     */
    searchLowestPrice?: number;
    /**
     * Search lowest URL
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    searchLowestUrl?: string;
    /**
     * Search position
     * @type {number}
     * @memberof ItemGoogleProductSearch
     */
    searchPosition?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    shippingLabel?: string;
    /**
     * Size
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    size?: string;
    /**
     * Video - director
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    videoDirector?: string;
    /**
     * Video - format
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    videoFormat?: string;
    /**
     * Video - rating
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    videoRating?: string;
    /**
     * Video - release date
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    videoReleaseDate?: string;
    /**
     * Video - starring
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    videoStarring?: string;
}

/**
 * 
 * @export
 * @interface ItemIdentifiers
 */
export interface ItemIdentifiers {
    /**
     * Barcode
     * @type {string}
     * @memberof ItemIdentifiers
     */
    barcode?: string;
    /**
     * Manufacturer Name
     * @type {string}
     * @memberof ItemIdentifiers
     */
    manufacturerName?: string;
    /**
     * Manufacturer SKU
     * @type {string}
     * @memberof ItemIdentifiers
     */
    manufacturerSku?: string;
    /**
     * UNSPSC
     * @type {string}
     * @memberof ItemIdentifiers
     */
    unspsc?: string;
}

/**
 * 
 * @export
 * @interface ItemInstantPaymentNotification
 */
export interface ItemInstantPaymentNotification {
    /**
     * True for HTTP POST instead of GET
     * @type {boolean}
     * @memberof ItemInstantPaymentNotification
     */
    postOperation?: boolean;
    /**
     * Successful response text
     * @type {string}
     * @memberof ItemInstantPaymentNotification
     */
    successfulResponseText?: string;
    /**
     * URL
     * @type {string}
     * @memberof ItemInstantPaymentNotification
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ItemInstantPaymentNotifications
 */
export interface ItemInstantPaymentNotifications {
    /**
     * Notifications
     * @type {Array<ItemInstantPaymentNotification>}
     * @memberof ItemInstantPaymentNotifications
     */
    notifications?: Array<ItemInstantPaymentNotification>;
}

/**
 * 
 * @export
 * @interface ItemInternal
 */
export interface ItemInternal {
    /**
     * Memo
     * @type {string}
     * @memberof ItemInternal
     */
    memo?: string;
}

/**
 * 
 * @export
 * @interface ItemKitComponent
 */
export interface ItemKitComponent {
    /**
     * Component item cost
     * @type {number}
     * @memberof ItemKitComponent
     */
    componentCost?: number;
    /**
     * Component item description
     * @type {string}
     * @memberof ItemKitComponent
     */
    componentDescription?: string;
    /**
     * Component item ID
     * @type {string}
     * @memberof ItemKitComponent
     */
    componentMerchantItemId?: string;
    /**
     * Component item object identifier
     * @type {number}
     * @memberof ItemKitComponent
     */
    componentMerchantItemOid?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof ItemKitComponent
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemKitDefinition
 */
export interface ItemKitDefinition {
    /**
     * Components
     * @type {Array<ItemKitComponent>}
     * @memberof ItemKitDefinition
     */
    components?: Array<ItemKitComponent>;
}

/**
 * 
 * @export
 * @interface ItemOption
 */
export interface ItemOption {
    /**
     * Cost if specified
     * @type {number}
     * @memberof ItemOption
     */
    costIfSpecified?: number;
    /**
     * Cost per letter
     * @type {number}
     * @memberof ItemOption
     */
    costPerLetter?: number;
    /**
     * Cost per line
     * @type {number}
     * @memberof ItemOption
     */
    costPerLine?: number;
    /**
     * Ignore this option on the order if the default value is selected
     * @type {boolean}
     * @memberof ItemOption
     */
    ignoreIfDefault?: boolean;
    /**
     * Label
     * @type {string}
     * @memberof ItemOption
     */
    label?: string;
    /**
     * Label translated text instance ID
     * @type {number}
     * @memberof ItemOption
     */
    labelTranslatedTextInstanceOid?: number;
    /**
     * Name
     * @type {string}
     * @memberof ItemOption
     */
    name?: string;
    /**
     * Name translated text instance ID
     * @type {number}
     * @memberof ItemOption
     */
    nameTranslatedTextInstanceOid?: number;
    /**
     * One time fee
     * @type {boolean}
     * @memberof ItemOption
     */
    oneTimeFee?: boolean;
    /**
     * Option object identifier
     * @type {number}
     * @memberof ItemOption
     */
    optionOid?: number;
    /**
     * True if the customer is required to specify an answer
     * @type {boolean}
     * @memberof ItemOption
     */
    required?: boolean;
    /**
     * True if this is a system option
     * @type {boolean}
     * @memberof ItemOption
     */
    systemOption?: boolean;
    /**
     * Type of option
     * @type {string}
     * @memberof ItemOption
     */
    type?: ItemOption.TypeEnum;
    /**
     * Values
     * @type {Array<ItemOptionValue>}
     * @memberof ItemOption
     */
    values?: Array<ItemOptionValue>;
}

/**
 * @export
 * @namespace ItemOption
 */
export namespace ItemOption {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Dropdown = <any> 'dropdown',
        FileAttachment = <any> 'file attachment',
        Fixed = <any> 'fixed',
        Hidden = <any> 'hidden',
        Multiline = <any> 'multiline',
        Radio = <any> 'radio',
        Single = <any> 'single'
    }
}

/**
 * 
 * @export
 * @interface ItemOptionValue
 */
export interface ItemOptionValue {
    /**
     * Additional dimensions application
     * @type {string}
     * @memberof ItemOptionValue
     */
    additionalDimensionApplication?: ItemOptionValue.AdditionalDimensionApplicationEnum;
    /**
     * Additional items to add to the order if this value is selected
     * @type {Array<ItemOptionValueAdditionalItem>}
     * @memberof ItemOptionValue
     */
    additionalItems?: Array<ItemOptionValueAdditionalItem>;
    /**
     * Cost change
     * @type {number}
     * @memberof ItemOptionValue
     */
    costChange?: number;
    /**
     * True if default value
     * @type {boolean}
     * @memberof ItemOptionValue
     */
    defaultValue?: boolean;
    /**
     * Digital items to allow the customer to download if this option value is selected
     * @type {Array<ItemOptionValueDigitalItem>}
     * @memberof ItemOptionValue
     */
    digitalItems?: Array<ItemOptionValueDigitalItem>;
    /**
     * 
     * @type {Distance}
     * @memberof ItemOptionValue
     */
    height?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof ItemOptionValue
     */
    length?: Distance;
    /**
     * Multimedia object identifier associated with this option value
     * @type {number}
     * @memberof ItemOptionValue
     */
    merchantItemMultimediaOid?: number;
    /**
     * Option value object identifier
     * @type {number}
     * @memberof ItemOptionValue
     */
    optionValueOid?: number;
    /**
     * Percentage cost change
     * @type {number}
     * @memberof ItemOptionValue
     */
    percentCostChange?: number;
    /**
     * Translated text instance id
     * @type {number}
     * @memberof ItemOptionValue
     */
    translatedTextInstanceOid?: number;
    /**
     * Value
     * @type {string}
     * @memberof ItemOptionValue
     */
    value?: string;
    /**
     * 
     * @type {Weight}
     * @memberof ItemOptionValue
     */
    weightChange?: Weight;
    /**
     * Percentage weight change
     * @type {number}
     * @memberof ItemOptionValue
     */
    weightChangePercent?: number;
    /**
     * 
     * @type {Distance}
     * @memberof ItemOptionValue
     */
    width?: Distance;
}

/**
 * @export
 * @namespace ItemOptionValue
 */
export namespace ItemOptionValue {
    /**
     * @export
     * @enum {string}
     */
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}

/**
 * 
 * @export
 * @interface ItemOptionValueAdditionalItem
 */
export interface ItemOptionValueAdditionalItem {
    /**
     * Additional item id
     * @type {string}
     * @memberof ItemOptionValueAdditionalItem
     */
    additionalMerchantItemId?: string;
    /**
     * Additional item object identifier
     * @type {number}
     * @memberof ItemOptionValueAdditionalItem
     */
    additionalMerchantItemOid?: number;
}

/**
 * 
 * @export
 * @interface ItemOptionValueDigitalItem
 */
export interface ItemOptionValueDigitalItem {
    /**
     * Digital item object identifier
     * @type {number}
     * @memberof ItemOptionValueDigitalItem
     */
    digitalItemOid?: number;
    /**
     * Original filename
     * @type {string}
     * @memberof ItemOptionValueDigitalItem
     */
    originalFilename?: string;
}

/**
 * 
 * @export
 * @interface ItemPaymentProcessing
 */
export interface ItemPaymentProcessing {
    /**
     * True if prepaid cards should be blocked from buying this item
     * @type {boolean}
     * @memberof ItemPaymentProcessing
     */
    blockPrepaid?: boolean;
    /**
     * Credit card transaction type
     * @type {string}
     * @memberof ItemPaymentProcessing
     */
    creditCardTransactionType?: string;
    /**
     * True if no real-time charge should be performed on this item.
     * @type {boolean}
     * @memberof ItemPaymentProcessing
     */
    noRealtimeCharge?: boolean;
    /**
     * Payment method validity
     * @type {Array<string>}
     * @memberof ItemPaymentProcessing
     */
    paymentMethodValidity?: Array<string>;
    /**
     * Rotating transaction gateway codes
     * @type {Array<string>}
     * @memberof ItemPaymentProcessing
     */
    rotatingTransactionGatewayCodes?: Array<string>;
}

/**
 * 
 * @export
 * @interface ItemPhysical
 */
export interface ItemPhysical {
    /**
     * 
     * @type {Distance}
     * @memberof ItemPhysical
     */
    height?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof ItemPhysical
     */
    length?: Distance;
    /**
     * 
     * @type {Weight}
     * @memberof ItemPhysical
     */
    weight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof ItemPhysical
     */
    width?: Distance;
}

/**
 * 
 * @export
 * @interface ItemPricing
 */
export interface ItemPricing {
    /**
     * Allow arbitrary cost
     * @type {boolean}
     * @memberof ItemPricing
     */
    allowArbitraryCost?: boolean;
    /**
     * Arbitrary cost velocity code
     * @type {string}
     * @memberof ItemPricing
     */
    arbitraryCostVelocityCode?: string;
    /**
     * Cost if customer selects to receive item on auto order.  Set to zero to delete.
     * @type {number}
     * @memberof ItemPricing
     */
    autoOrderCost?: number;
    /**
     * Automatic pricing tier name
     * @type {string}
     * @memberof ItemPricing
     */
    automaticPricingTierName?: string;
    /**
     * Automatic pricing tier object identifier
     * @type {number}
     * @memberof ItemPricing
     */
    automaticPricingTierOid?: number;
    /**
     * Cost of goods sold
     * @type {number}
     * @memberof ItemPricing
     */
    cogs?: number;
    /**
     * Cost
     * @type {number}
     * @memberof ItemPricing
     */
    cost?: number;
    /**
     * Currency code
     * @type {string}
     * @memberof ItemPricing
     */
    currencyCode?: string;
    /**
     * Manufacturer suggested retail price
     * @type {number}
     * @memberof ItemPricing
     */
    manufacturerSuggestedRetailPrice?: number;
    /**
     * Maximum arbitrary cost
     * @type {number}
     * @memberof ItemPricing
     */
    maximumArbitraryCost?: number;
    /**
     * Minimum advertised price
     * @type {number}
     * @memberof ItemPricing
     */
    minimumAdvertisedPrice?: number;
    /**
     * Minimum arbitrary cost
     * @type {number}
     * @memberof ItemPricing
     */
    minimumArbitraryCost?: number;
    /**
     * Mix and match group
     * @type {string}
     * @memberof ItemPricing
     */
    mixAndMatchGroup?: string;
    /**
     * Mix and match group object identifier
     * @type {number}
     * @memberof ItemPricing
     */
    mixAndMatchGroupOid?: number;
    /**
     * Sale cost
     * @type {number}
     * @memberof ItemPricing
     */
    saleCost?: number;
    /**
     * Sale end
     * @type {string}
     * @memberof ItemPricing
     */
    saleEnd?: string;
    /**
     * Sale start
     * @type {string}
     * @memberof ItemPricing
     */
    saleStart?: string;
    /**
     * Tiers
     * @type {Array<ItemPricingTier>}
     * @memberof ItemPricing
     */
    tiers?: Array<ItemPricingTier>;
}

/**
 * 
 * @export
 * @interface ItemPricingTier
 */
export interface ItemPricingTier {
    /**
     * True if this is the default tier
     * @type {boolean}
     * @memberof ItemPricingTier
     */
    defaultTier?: boolean;
    /**
     * Discounts
     * @type {Array<ItemPricingTierDiscount>}
     * @memberof ItemPricingTier
     */
    discounts?: Array<ItemPricingTierDiscount>;
    /**
     * 
     * @type {ItemPricingTierLimit}
     * @memberof ItemPricingTier
     */
    limit?: ItemPricingTierLimit;
    /**
     * Pricing tier name
     * @type {string}
     * @memberof ItemPricingTier
     */
    name?: string;
    /**
     * Pricing tier object identifier
     * @type {number}
     * @memberof ItemPricingTier
     */
    pricingTierOid?: number;
}

/**
 * 
 * @export
 * @interface ItemPricingTierDiscount
 */
export interface ItemPricingTierDiscount {
    /**
     * Cost
     * @type {number}
     * @memberof ItemPricingTierDiscount
     */
    cost?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof ItemPricingTierDiscount
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemPricingTierLimit
 */
export interface ItemPricingTierLimit {
    /**
     * Cumulative order limit
     * @type {number}
     * @memberof ItemPricingTierLimit
     */
    cumulativeOrderLimit?: number;
    /**
     * Individual order limit
     * @type {number}
     * @memberof ItemPricingTierLimit
     */
    individualOrderLimit?: number;
    /**
     * Multiple quantity
     * @type {number}
     * @memberof ItemPricingTierLimit
     */
    multipleQuantity?: number;
}

/**
 * 
 * @export
 * @interface ItemProperty
 */
export interface ItemProperty {
    /**
     * Expiration of the property
     * @type {string}
     * @memberof ItemProperty
     */
    expirationDts?: string;
    /**
     * Property name
     * @type {string}
     * @memberof ItemProperty
     */
    name?: string;
    /**
     * Property value
     * @type {string}
     * @memberof ItemProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemRealtimePricing
 */
export interface ItemRealtimePricing {
    /**
     * Real-time pricing provider parameters
     * @type {string}
     * @memberof ItemRealtimePricing
     */
    realtimePricingParameter?: string;
    /**
     * Real-time pricing provider name
     * @type {string}
     * @memberof ItemRealtimePricing
     */
    realtimePricingProvider?: string;
    /**
     * Real-time pricing provide object identifier
     * @type {number}
     * @memberof ItemRealtimePricing
     */
    realtimePricingProviderOid?: number;
}

/**
 * 
 * @export
 * @interface ItemRelated
 */
export interface ItemRelated {
    /**
     * True to suppress system calculated relationships
     * @type {boolean}
     * @memberof ItemRelated
     */
    noSystemCalculatedRelatedItems?: boolean;
    /**
     * Not relatable
     * @type {boolean}
     * @memberof ItemRelated
     */
    notRelatable?: boolean;
    /**
     * Related items
     * @type {Array<ItemRelatedItem>}
     * @memberof ItemRelated
     */
    relatedItems?: Array<ItemRelatedItem>;
}

/**
 * 
 * @export
 * @interface ItemRelatedItem
 */
export interface ItemRelatedItem {
    /**
     * Related item id
     * @type {string}
     * @memberof ItemRelatedItem
     */
    relatedMerchantItemId?: string;
    /**
     * Related item object identifier
     * @type {number}
     * @memberof ItemRelatedItem
     */
    relatedMerchantItemOid?: number;
    /**
     * Relationship type
     * @type {string}
     * @memberof ItemRelatedItem
     */
    type?: ItemRelatedItem.TypeEnum;
}

/**
 * @export
 * @namespace ItemRelatedItem
 */
export namespace ItemRelatedItem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        System = <any> 'System',
        UserDefined = <any> 'UserDefined'
    }
}

/**
 * 
 * @export
 * @interface ItemReporting
 */
export interface ItemReporting {
    /**
     * Report as an upsell
     * @type {boolean}
     * @memberof ItemReporting
     */
    reportAsUpsell?: boolean;
    /**
     * Report pickable quantities
     * @type {Array<number>}
     * @memberof ItemReporting
     */
    reportPickableQuantities?: Array<number>;
}

/**
 * 
 * @export
 * @interface ItemResponse
 */
export interface ItemResponse {
    /**
     * 
     * @type {Error}
     * @memberof ItemResponse
     */
    error?: Error;
    /**
     * 
     * @type {Item}
     * @memberof ItemResponse
     */
    item?: Item;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ItemResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ItemResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ItemResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ItemRestriction
 */
export interface ItemRestriction {
    /**
     * Exclude coupons
     * @type {boolean}
     * @memberof ItemRestriction
     */
    excludeCoupon?: boolean;
    /**
     * Exclude from free promotion
     * @type {boolean}
     * @memberof ItemRestriction
     */
    excludeFromFreePromotion?: boolean;
    /**
     * Items
     * @type {Array<ItemRestrictionItem>}
     * @memberof ItemRestriction
     */
    items?: Array<ItemRestrictionItem>;
    /**
     * Maximum quantity
     * @type {number}
     * @memberof ItemRestriction
     */
    maximumQuantity?: number;
    /**
     * Minimum quantity (defaults to 1)
     * @type {number}
     * @memberof ItemRestriction
     */
    minimumQuantity?: number;
    /**
     * Multiple of quantity
     * @type {number}
     * @memberof ItemRestriction
     */
    multipleQuantity?: number;
    /**
     * One per customer
     * @type {boolean}
     * @memberof ItemRestriction
     */
    onePerCustomer?: boolean;
    /**
     * Purchase separately
     * @type {boolean}
     * @memberof ItemRestriction
     */
    purchaseSeparately?: boolean;
}

/**
 * 
 * @export
 * @interface ItemRestrictionItem
 */
export interface ItemRestrictionItem {
    /**
     * Restrict item id
     * @type {string}
     * @memberof ItemRestrictionItem
     */
    restrictMerchantItemId?: string;
    /**
     * Restrict item object identifier
     * @type {number}
     * @memberof ItemRestrictionItem
     */
    restrictMerchantItemOid?: number;
    /**
     * Restriction type
     * @type {string}
     * @memberof ItemRestrictionItem
     */
    type?: ItemRestrictionItem.TypeEnum;
}

/**
 * @export
 * @namespace ItemRestrictionItem
 */
export namespace ItemRestrictionItem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CanNotBePurchasedWith = <any> 'can not be purchased with',
        CanOnlyBePurchasedWith = <any> 'can only be purchased with',
        MustBePurchasedWith = <any> 'must be purchased with'
    }
}

/**
 * 
 * @export
 * @interface ItemRevguard
 */
export interface ItemRevguard {
    /**
     * Canceled CSR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguardCanceledCsrPromptGroup?: number;
    /**
     * IVR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguardCanceledIvrPromptGroup?: number;
    /**
     * Canceled web prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguardCanceledWebPromptGroup?: number;
    /**
     * Client brand
     * @type {number}
     * @memberof ItemRevguard
     */
    revguardClientBrand?: number;
    /**
     * CSR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguardCsrPromptGroup?: number;
    /**
     * IVR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguardIvrPromptGroup?: number;
    /**
     * Web prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguardWebPromptGroup?: number;
}

/**
 * 
 * @export
 * @interface ItemReviews
 */
export interface ItemReviews {
    /**
     * True if the item has an approved review
     * @type {boolean}
     * @memberof ItemReviews
     */
    hasApprovedReview?: boolean;
    /**
     * True if the item has a review
     * @type {boolean}
     * @memberof ItemReviews
     */
    hasReview?: boolean;
    /**
     * Number of approved reviews
     * @type {number}
     * @memberof ItemReviews
     */
    reviewCount?: number;
    /**
     * Overall score of reviews
     * @type {number}
     * @memberof ItemReviews
     */
    reviewOverall?: number;
    /**
     * Review template name
     * @type {string}
     * @memberof ItemReviews
     */
    reviewTemplateName?: string;
    /**
     * Review template object identifier
     * @type {number}
     * @memberof ItemReviews
     */
    reviewTemplateOid?: number;
    /**
     * True if the item is reviewable
     * @type {boolean}
     * @memberof ItemReviews
     */
    reviewable?: boolean;
}

/**
 * 
 * @export
 * @interface ItemSalesforce
 */
export interface ItemSalesforce {
    /**
     * Salesforce.com pricebook id
     * @type {string}
     * @memberof ItemSalesforce
     */
    sfdcPricebookId?: string;
    /**
     * Salesforce.com product id
     * @type {string}
     * @memberof ItemSalesforce
     */
    sfdcProductId?: string;
}

/**
 * 
 * @export
 * @interface ItemShipping
 */
export interface ItemShipping {
    /**
     * Allow back order
     * @type {boolean}
     * @memberof ItemShipping
     */
    allowBackOrder?: boolean;
    /**
     * Fulfillment by Amazon.com
     * @type {boolean}
     * @memberof ItemShipping
     */
    amazonFba?: boolean;
    /**
     * Case inner packs
     * @type {number}
     * @memberof ItemShipping
     */
    caseInnerPacks?: number;
    /**
     * Case units
     * @type {number}
     * @memberof ItemShipping
     */
    caseUnits?: number;
    /**
     * Cases
     * @type {Array<ItemShippingCase>}
     * @memberof ItemShipping
     */
    cases?: Array<ItemShippingCase>;
    /**
     * This item is on pre-order
     * @type {boolean}
     * @memberof ItemShipping
     */
    collectSerialNumbers?: boolean;
    /**
     * Country code of origin for customs forms.  (ISO-3166 two letter code)
     * @type {string}
     * @memberof ItemShipping
     */
    countryCodeOfOrigin?: string;
    /**
     * Customs description
     * @type {string}
     * @memberof ItemShipping
     */
    customsDescription?: string;
    /**
     * Customs value
     * @type {number}
     * @memberof ItemShipping
     */
    customsValue?: number;
    /**
     * Delivery on Friday
     * @type {boolean}
     * @memberof ItemShipping
     */
    deliveryOnFriday?: boolean;
    /**
     * Delivery on Monday
     * @type {boolean}
     * @memberof ItemShipping
     */
    deliveryOnMonday?: boolean;
    /**
     * Delivery on Saturday
     * @type {boolean}
     * @memberof ItemShipping
     */
    deliveryOnSaturday?: boolean;
    /**
     * Delivery on Sunday
     * @type {boolean}
     * @memberof ItemShipping
     */
    deliveryOnSunday?: boolean;
    /**
     * Delivery on Thursday
     * @type {boolean}
     * @memberof ItemShipping
     */
    deliveryOnThursday?: boolean;
    /**
     * Delivery on Tuesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    deliveryOnTuesday?: boolean;
    /**
     * Delivery on Wednesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    deliveryOnWednesday?: boolean;
    /**
     * Destination markups
     * @type {Array<ItemShippingDestinationMarkup>}
     * @memberof ItemShipping
     */
    destinationMarkups?: Array<ItemShippingDestinationMarkup>;
    /**
     * Destination restrictions
     * @type {Array<ItemShippingDestinationRestriction>}
     * @memberof ItemShipping
     */
    destinationRestrictions?: Array<ItemShippingDestinationRestriction>;
    /**
     * Distribution centers
     * @type {Array<ItemShippingDistributionCenter>}
     * @memberof ItemShipping
     */
    distributionCenters?: Array<ItemShippingDistributionCenter>;
    /**
     * Estimated time of arrival
     * @type {string}
     * @memberof ItemShipping
     */
    eta?: string;
    /**
     * Qualifies for free shipping
     * @type {boolean}
     * @memberof ItemShipping
     */
    freeShipping?: boolean;
    /**
     * Freight class
     * @type {string}
     * @memberof ItemShipping
     */
    freightClass?: string;
    /**
     * Hazardous material
     * @type {boolean}
     * @memberof ItemShipping
     */
    hazmat?: boolean;
    /**
     * True if this item is made to order
     * @type {boolean}
     * @memberof ItemShipping
     */
    madeToOrder?: boolean;
    /**
     * Number of days lead time it takes to make the item before ite can ship
     * @type {number}
     * @memberof ItemShipping
     */
    madeToOrderLeadTime?: number;
    /**
     * Maximum days allowed in transit
     * @type {number}
     * @memberof ItemShipping
     */
    maxDaysTimeInTransit?: number;
    /**
     * Methods
     * @type {Array<ItemShippingMethod>}
     * @memberof ItemShipping
     */
    methods?: Array<ItemShippingMethod>;
    /**
     * No shipping discounts
     * @type {boolean}
     * @memberof ItemShipping
     */
    noShippingDiscount?: boolean;
    /**
     * Package requirements
     * @type {Array<ItemShippingPackageRequirement>}
     * @memberof ItemShipping
     */
    packageRequirements?: Array<ItemShippingPackageRequirement>;
    /**
     * Perishable class name
     * @type {string}
     * @memberof ItemShipping
     */
    perishableClassName?: string;
    /**
     * Perishable class object identifier
     * @type {number}
     * @memberof ItemShipping
     */
    perishableClassOid?: number;
    /**
     * This item is on pre-order
     * @type {boolean}
     * @memberof ItemShipping
     */
    preorder?: boolean;
    /**
     * True to require customer to select a delivery date
     * @type {boolean}
     * @memberof ItemShipping
     */
    requireDeliveryDate?: boolean;
    /**
     * Restrict shipment on Friday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrictShipmentOnFriday?: boolean;
    /**
     * Restrict shipment on Monday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrictShipmentOnMonday?: boolean;
    /**
     * Restrict shipment on Saturday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrictShipmentOnSaturday?: boolean;
    /**
     * Restrict shipment on Sunday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrictShipmentOnSunday?: boolean;
    /**
     * Restrict shipment on Thursday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrictShipmentOnThursday?: boolean;
    /**
     * Restrict shipment on Tuesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrictShipmentOnTuesday?: boolean;
    /**
     * Restrict shipment on Wednesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrictShipmentOnWednesday?: boolean;
    /**
     * Ship this item in a separate box
     * @type {boolean}
     * @memberof ItemShipping
     */
    shipSeparately?: boolean;
    /**
     * 
     * @type {Weight}
     * @memberof ItemShipping
     */
    shipSeparatelyAdditionalWeight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof ItemShipping
     */
    shipSeparatelyHeight?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof ItemShipping
     */
    shipSeparatelyLength?: Distance;
    /**
     * Ship separately package special type
     * @type {string}
     * @memberof ItemShipping
     */
    shipSeparatelyPackageSpecialType?: string;
    /**
     * 
     * @type {Distance}
     * @memberof ItemShipping
     */
    shipSeparatelyWidth?: Distance;
    /**
     * Special product type (USPS Media Mail)
     * @type {string}
     * @memberof ItemShipping
     */
    specialProductType?: string;
    /**
     * Track inventory
     * @type {boolean}
     * @memberof ItemShipping
     */
    trackInventory?: boolean;
}

/**
 * 
 * @export
 * @interface ItemShippingCase
 */
export interface ItemShippingCase {
    /**
     * Case label
     * @type {string}
     * @memberof ItemShippingCase
     */
    caseLabel?: string;
    /**
     * Case item id
     * @type {string}
     * @memberof ItemShippingCase
     */
    caseMerchantItemId?: string;
    /**
     * Case item object identifier
     * @type {number}
     * @memberof ItemShippingCase
     */
    caseMerchantItemOid?: number;
    /**
     * Case quantity
     * @type {number}
     * @memberof ItemShippingCase
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemShippingDestinationMarkup
 */
export interface ItemShippingDestinationMarkup {
    /**
     * Country code (ISO-3166 two letter)
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    countryCode?: string;
    /**
     * Flat fee
     * @type {number}
     * @memberof ItemShippingDestinationMarkup
     */
    flatFee?: number;
    /**
     * Per item
     * @type {number}
     * @memberof ItemShippingDestinationMarkup
     */
    perItem?: number;
    /**
     * Postal code
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    postalCode?: string;
    /**
     * Shipping method
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    shippingMethod?: string;
    /**
     * State
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface ItemShippingDestinationRestriction
 */
export interface ItemShippingDestinationRestriction {
    /**
     * Country code (ISO-3166 two letter)
     * @type {string}
     * @memberof ItemShippingDestinationRestriction
     */
    countryCode?: string;
    /**
     * State
     * @type {string}
     * @memberof ItemShippingDestinationRestriction
     */
    state?: string;
    /**
     * Validity
     * @type {string}
     * @memberof ItemShippingDestinationRestriction
     */
    validity?: ItemShippingDestinationRestriction.ValidityEnum;
}

/**
 * @export
 * @namespace ItemShippingDestinationRestriction
 */
export namespace ItemShippingDestinationRestriction {
    /**
     * @export
     * @enum {string}
     */
    export enum ValidityEnum {
        ValidOnlyFor = <any> 'valid only for',
        InvalidFor = <any> 'invalid for'
    }
}

/**
 * 
 * @export
 * @interface ItemShippingDistributionCenter
 */
export interface ItemShippingDistributionCenter {
    /**
     * Allocated to placed orders
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    allocatedToPlacedOrders?: number;
    /**
     * Allocated to shopping carts
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    allocatedToShoppingCarts?: number;
    /**
     * Available to allocate
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    availableToAllocate?: number;
    /**
     * Desired inventory level
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    desiredInventoryLevel?: number;
    /**
     * Distribution center code
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    distributionCenterCode?: string;
    /**
     * Distribution center object identifier
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    distributionCenterOid?: number;
    /**
     * Estimated time of arrival
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    eta?: string;
    /**
     * True if this distribution center handles this item
     * @type {boolean}
     * @memberof ItemShippingDistributionCenter
     */
    handles?: boolean;
    /**
     * Inventory level
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    inventoryLevel?: number;
    /**
     * Maximum back-order
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    maximumBackorder?: number;
    /**
     * Reorder inventory level (triggers notification)
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    reorderInventoryLevel?: number;
    /**
     * SKU
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    sku?: string;
    /**
     * Stock picking location
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    stockPickingLocation?: string;
}

/**
 * 
 * @export
 * @interface ItemShippingMethod
 */
export interface ItemShippingMethod {
    /**
     * Cost
     * @type {number}
     * @memberof ItemShippingMethod
     */
    cost?: number;
    /**
     * Each additional item markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    eachAdditionalItemMarkup?: number;
    /**
     * Filter to this method if available
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    filterToIfAvailable?: boolean;
    /**
     * First item markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    firstItemMarkup?: number;
    /**
     * Fixed shipping cost
     * @type {number}
     * @memberof ItemShippingMethod
     */
    fixedShippingCost?: number;
    /**
     * Flat fee markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    flatFeeMarkup?: number;
    /**
     * Free shipping
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    freeShipping?: boolean;
    /**
     * Per item fee markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    perItemFeeMarkup?: number;
    /**
     * Percentage markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    percentageMarkup?: number;
    /**
     * Percentage of item markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    percentageOfItemMarkup?: number;
    /**
     * Relax restrictions on upsell
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    relaxRestrictionsOnUpsell?: boolean;
    /**
     * Shipping method name
     * @type {string}
     * @memberof ItemShippingMethod
     */
    shippingMethod?: string;
    /**
     * Shipping method object identifier
     * @type {number}
     * @memberof ItemShippingMethod
     */
    shippingMethodOid?: number;
    /**
     * Shipping method validity
     * @type {string}
     * @memberof ItemShippingMethod
     */
    shippingMethodValidity?: ItemShippingMethod.ShippingMethodValidityEnum;
    /**
     * Signature required
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    signatureRequired?: boolean;
}

/**
 * @export
 * @namespace ItemShippingMethod
 */
export namespace ItemShippingMethod {
    /**
     * @export
     * @enum {string}
     */
    export enum ShippingMethodValidityEnum {
        InvalidFor = <any> 'invalid for',
        ValidFor = <any> 'valid for',
        ValidOnlyFor = <any> 'valid only for'
    }
}

/**
 * 
 * @export
 * @interface ItemShippingPackageRequirement
 */
export interface ItemShippingPackageRequirement {
    /**
     * Package name
     * @type {string}
     * @memberof ItemShippingPackageRequirement
     */
    packageName?: string;
    /**
     * Package object identifier
     * @type {number}
     * @memberof ItemShippingPackageRequirement
     */
    packageOid?: number;
}

/**
 * 
 * @export
 * @interface ItemTag
 */
export interface ItemTag {
    /**
     * tag_tpe
     * @type {string}
     * @memberof ItemTag
     */
    tagType?: ItemTag.TagTypeEnum;
    /**
     * tag_value
     * @type {string}
     * @memberof ItemTag
     */
    tagValue?: string;
}

/**
 * @export
 * @namespace ItemTag
 */
export namespace ItemTag {
    /**
     * @export
     * @enum {string}
     */
    export enum TagTypeEnum {
        Item = <any> 'item',
        Order = <any> 'order',
        Customer = <any> 'customer'
    }
}

/**
 * 
 * @export
 * @interface ItemTags
 */
export interface ItemTags {
    /**
     * tags
     * @type {Array<ItemTag>}
     * @memberof ItemTags
     */
    tags?: Array<ItemTag>;
}

/**
 * 
 * @export
 * @interface ItemTax
 */
export interface ItemTax {
    /**
     * Exemptions
     * @type {Array<ItemTaxExemption>}
     * @memberof ItemTax
     */
    exemptions?: Array<ItemTaxExemption>;
    /**
     * True if tax free
     * @type {boolean}
     * @memberof ItemTax
     */
    taxFree?: boolean;
    /**
     * Taxable cost if different than regular cost
     * @type {number}
     * @memberof ItemTax
     */
    taxableCost?: number;
}

/**
 * 
 * @export
 * @interface ItemTaxExemption
 */
export interface ItemTaxExemption {
    /**
     * City
     * @type {string}
     * @memberof ItemTaxExemption
     */
    city?: string;
    /**
     * Country code (ISO-3166 two letter)
     * @type {string}
     * @memberof ItemTaxExemption
     */
    countryCode?: string;
    /**
     * County
     * @type {string}
     * @memberof ItemTaxExemption
     */
    county?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof ItemTaxExemption
     */
    postalCode?: string;
    /**
     * State code
     * @type {string}
     * @memberof ItemTaxExemption
     */
    stateCode?: string;
}

/**
 * 
 * @export
 * @interface ItemThirdPartyEmailMarketing
 */
export interface ItemThirdPartyEmailMarketing {
    /**
     * Add tags
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    addTags?: Array<string>;
    /**
     * Provider name
     * @type {string}
     * @memberof ItemThirdPartyEmailMarketing
     */
    providerName?: ItemThirdPartyEmailMarketing.ProviderNameEnum;
    /**
     * Remove tags
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    removeTags?: Array<string>;
    /**
     * Subscribe to lists
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    subscribeLists?: Array<string>;
    /**
     * Unsubscribe from lists
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    unsubscribeLists?: Array<string>;
}

/**
 * @export
 * @namespace ItemThirdPartyEmailMarketing
 */
export namespace ItemThirdPartyEmailMarketing {
    /**
     * @export
     * @enum {string}
     */
    export enum ProviderNameEnum {
        ActiveCampaign = <any> 'ActiveCampaign',
        AWeber = <any> 'AWeber',
        CampaignMonitor = <any> 'Campaign Monitor',
        ConstantContact = <any> 'ConstantContact',
        Emma = <any> 'Emma',
        GetResponse = <any> 'GetResponse',
        IContact = <any> 'iContact',
        Klaviyo = <any> 'Klaviyo',
        Lyris = <any> 'Lyris',
        LyrisHQ = <any> 'LyrisHQ',
        MailChimp = <any> 'MailChimp',
        SilverPop = <any> 'SilverPop'
    }
}

/**
 * 
 * @export
 * @interface ItemVariantItem
 */
export interface ItemVariantItem {
    /**
     * Description
     * @type {string}
     * @memberof ItemVariantItem
     */
    description?: string;
    /**
     * Multimedia object identifier
     * @type {number}
     * @memberof ItemVariantItem
     */
    merchantItemMultimediaOid?: number;
    /**
     * Variant item id
     * @type {string}
     * @memberof ItemVariantItem
     */
    variantMerchantItemId?: string;
    /**
     * Variant item object identifier
     * @type {number}
     * @memberof ItemVariantItem
     */
    variantMerchantItemOid?: number;
    /**
     * Variation options
     * @type {Array<string>}
     * @memberof ItemVariantItem
     */
    variationOptions?: Array<string>;
    /**
     * Variations
     * @type {Array<string>}
     * @memberof ItemVariantItem
     */
    variations?: Array<string>;
}

/**
 * 
 * @export
 * @interface ItemVariation
 */
export interface ItemVariation {
    /**
     * Default text
     * @type {string}
     * @memberof ItemVariation
     */
    defaultText?: string;
    /**
     * Default text translated text instance id
     * @type {number}
     * @memberof ItemVariation
     */
    defaultTextTranslatedTextInstanceOid?: number;
    /**
     * Name
     * @type {string}
     * @memberof ItemVariation
     */
    name?: string;
    /**
     * Name translated text instance id
     * @type {number}
     * @memberof ItemVariation
     */
    nameTranslatedTextInstanceOid?: number;
    /**
     * Options
     * @type {Array<ItemVariationOption>}
     * @memberof ItemVariation
     */
    options?: Array<ItemVariationOption>;
}

/**
 * 
 * @export
 * @interface ItemVariationOption
 */
export interface ItemVariationOption {
    /**
     * True if default option
     * @type {boolean}
     * @memberof ItemVariationOption
     */
    defaultOption?: boolean;
    /**
     * Multimedia object identifier
     * @type {number}
     * @memberof ItemVariationOption
     */
    merchantItemMultimediaOid?: number;
    /**
     * Translated text instance id
     * @type {number}
     * @memberof ItemVariationOption
     */
    translatedTextInstanceOid?: number;
    /**
     * Value
     * @type {string}
     * @memberof ItemVariationOption
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemWishlistMember
 */
export interface ItemWishlistMember {
    /**
     * WishList Member instance description
     * @type {string}
     * @memberof ItemWishlistMember
     */
    wishlistMemberInstanceDescription?: string;
    /**
     * WishList Member instance object identifier
     * @type {number}
     * @memberof ItemWishlistMember
     */
    wishlistMemberInstanceOid?: number;
    /**
     * WishList Member SKU
     * @type {string}
     * @memberof ItemWishlistMember
     */
    wishlistMemberSku?: string;
}

/**
 * 
 * @export
 * @interface ItemsRequest
 */
export interface ItemsRequest {
    /**
     * items
     * @type {Array<Item>}
     * @memberof ItemsRequest
     */
    items?: Array<Item>;
}

/**
 * 
 * @export
 * @interface ItemsResponse
 */
export interface ItemsResponse {
    /**
     * 
     * @type {Error}
     * @memberof ItemsResponse
     */
    error?: Error;
    /**
     * items
     * @type {Array<Item>}
     * @memberof ItemsResponse
     */
    items?: Array<Item>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ItemsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ItemsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ItemsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface KeyValue
 */
export interface KeyValue {
    /**
     * Optional description of the lookup value
     * @type {string}
     * @memberof KeyValue
     */
    description?: string;
    /**
     * The key or id of this lookup value
     * @type {string}
     * @memberof KeyValue
     */
    key?: string;
    /**
     * The value of this lookup value
     * @type {string}
     * @memberof KeyValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface LibraryFilterValues
 */
export interface LibraryFilterValues {
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    categories?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    industries?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    styles?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    types?: Array<string>;
}

/**
 * 
 * @export
 * @interface LibraryFilterValuesResponse
 */
export interface LibraryFilterValuesResponse {
    /**
     * 
     * @type {Error}
     * @memberof LibraryFilterValuesResponse
     */
    error?: Error;
    /**
     * 
     * @type {LibraryFilterValues}
     * @memberof LibraryFilterValuesResponse
     */
    filterValues?: LibraryFilterValues;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LibraryFilterValuesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LibraryFilterValuesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof LibraryFilterValuesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface LibraryItem
 */
export interface LibraryItem {
    /**
     * 
     * @type {Array<LibraryItemAsset>}
     * @memberof LibraryItem
     */
    assets?: Array<LibraryItemAsset>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryItem
     */
    categories?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    contentType?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryItem
     */
    industries?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof LibraryItem
     */
    libraryItemOid?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    merchantId?: string;
    /**
     * If this is a public item and the merchant has already purchased it, this is their version.  If not yet purchased, this will be zero.  This value will only be populated during a searchPublicItems() call.
     * @type {number}
     * @memberof LibraryItem
     */
    myPurchasedVersion?: number;
    /**
     * This id points to the original object that was added to the library. For flows and campaigns, this is a uuid string.  For upsells, it is an oid integer.  For transactional_emails, it is an email name.
     * @type {string}
     * @memberof LibraryItem
     */
    originalObjectId?: string;
    /**
     * The price of the published item.  Null for any private library items.
     * @type {number}
     * @memberof LibraryItem
     */
    price?: number;
    /**
     * The formatted price of the published item.  Null for any private library items.
     * @type {string}
     * @memberof LibraryItem
     */
    priceFormatted?: string;
    /**
     * True if this library item is a published item (not source)
     * @type {boolean}
     * @memberof LibraryItem
     */
    published?: boolean;
    /**
     * The timestamp of the last published version
     * @type {any}
     * @memberof LibraryItem
     */
    publishedDts?: any;
    /**
     * The source item used to publish this item.  This allows for comparisons between source and published
     * @type {number}
     * @memberof LibraryItem
     */
    publishedFromLibraryItemOid?: number;
    /**
     * The source version when this item was published.  This allows for out-of-date alerts to be shown when there is a difference between source and published
     * @type {number}
     * @memberof LibraryItem
     */
    publishedVersion?: number;
    /**
     * True if this library item has been purchased
     * @type {boolean}
     * @memberof LibraryItem
     */
    purchased?: boolean;
    /**
     * The published item that was purchased to make this item.  This allows for comparisons between published and purchased
     * @type {number}
     * @memberof LibraryItem
     */
    purchasedFromLibraryItemOid?: number;
    /**
     * The published version when this item was purchased.  This allows for out-of-date alerts to be shown when there is a difference between published and purchased
     * @type {number}
     * @memberof LibraryItem
     */
    purchasedVersion?: number;
    /**
     * Any published library reviewed by UltraCart staff for malicious or inappropriate content will have this flag set to true.  This is always false for non-published items
     * @type {boolean}
     * @memberof LibraryItem
     */
    rejected?: boolean;
    /**
     * Any rejected published item will have this field populated with the reason.
     * @type {string}
     * @memberof LibraryItem
     */
    rejectedReason?: string;
    /**
     * Any published library items must be reviewed by UltraCart staff for malicious content.  This flag shows the status of that review.  This is always false for non-published items
     * @type {boolean}
     * @memberof LibraryItem
     */
    reviewed?: boolean;
    /**
     * This is the timestamp for a published items formal review by UltraCart staff for malicious content.
     * @type {any}
     * @memberof LibraryItem
     */
    reviewedDts?: any;
    /**
     * 
     * @type {Array<LibraryItemScreenshot>}
     * @memberof LibraryItem
     */
    screenshots?: Array<LibraryItemScreenshot>;
    /**
     * 
     * @type {Array<LibraryItemAccount>}
     * @memberof LibraryItem
     */
    shareWithAccounts?: Array<LibraryItemAccount>;
    /**
     * 
     * @type {Array<LibraryItemEmail>}
     * @memberof LibraryItem
     */
    shareWithOtherEmails?: Array<LibraryItemEmail>;
    /**
     * True if this item is shared from another merchant account
     * @type {boolean}
     * @memberof LibraryItem
     */
    shared?: boolean;
    /**
     * True if this library item has been published
     * @type {boolean}
     * @memberof LibraryItem
     */
    source?: boolean;
    /**
     * This oid points to the published library item, if there is one.
     * @type {number}
     * @memberof LibraryItem
     */
    sourceToLibraryItemOid?: number;
    /**
     * The version of this item.  Increment every time the item is saved.
     * @type {number}
     * @memberof LibraryItem
     */
    sourceVersion?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    style?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryItem
     */
    timesPurchased?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemAccount
 */
export interface LibraryItemAccount {
    /**
     * 
     * @type {number}
     * @memberof LibraryItemAccount
     */
    libraryItemAccountOid?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryItemAccount
     */
    libraryItemOid?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAccount
     */
    otherMerchantId?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemAsset
 */
export interface LibraryItemAsset {
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAsset
     */
    mimeType?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAsset
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemEmail
 */
export interface LibraryItemEmail {
    /**
     * 
     * @type {string}
     * @memberof LibraryItemEmail
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryItemEmail
     */
    libraryItemEmailOid?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryItemEmail
     */
    libraryItemOid?: number;
}

/**
 * 
 * @export
 * @interface LibraryItemQuery
 */
export interface LibraryItemQuery {
    /**
     * Category
     * @type {string}
     * @memberof LibraryItemQuery
     */
    category?: string;
    /**
     * Library item content type such as flow, campaign, cjson, email, or transactional_email
     * @type {string}
     * @memberof LibraryItemQuery
     */
    contentType?: string;
    /**
     * Description of library item
     * @type {string}
     * @memberof LibraryItemQuery
     */
    description?: string;
    /**
     * Industry
     * @type {string}
     * @memberof LibraryItemQuery
     */
    industry?: string;
    /**
     * Maximum price
     * @type {number}
     * @memberof LibraryItemQuery
     */
    priceHigh?: number;
    /**
     * Minimum price
     * @type {number}
     * @memberof LibraryItemQuery
     */
    priceLow?: number;
    /**
     * Minimum published date/time
     * @type {string}
     * @memberof LibraryItemQuery
     */
    publishedDtsBegin?: string;
    /**
     * Maximum published date/time
     * @type {string}
     * @memberof LibraryItemQuery
     */
    publishedDtsEnd?: string;
    /**
     * Boolean, true if this library item has been published and is the master copy of that published work
     * @type {boolean}
     * @memberof LibraryItemQuery
     */
    sourceOfPublished?: boolean;
    /**
     * Library item style
     * @type {string}
     * @memberof LibraryItemQuery
     */
    style?: string;
    /**
     * Title of the library item
     * @type {string}
     * @memberof LibraryItemQuery
     */
    title?: string;
    /**
     * Library item type such as header, footer, shipping block, etc
     * @type {string}
     * @memberof LibraryItemQuery
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemResponse
 */
export interface LibraryItemResponse {
    /**
     * 
     * @type {Error}
     * @memberof LibraryItemResponse
     */
    error?: Error;
    /**
     * 
     * @type {LibraryItem}
     * @memberof LibraryItemResponse
     */
    libraryItem?: LibraryItem;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LibraryItemResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LibraryItemResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof LibraryItemResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface LibraryItemScreenshot
 */
export interface LibraryItemScreenshot {
    /**
     * 
     * @type {boolean}
     * @memberof LibraryItemScreenshot
     */
    defaultUrl?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LibraryItemScreenshot
     */
    screenshotUrl?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemsResponse
 */
export interface LibraryItemsResponse {
    /**
     * 
     * @type {Error}
     * @memberof LibraryItemsResponse
     */
    error?: Error;
    /**
     * Library items
     * @type {Array<LibraryItem>}
     * @memberof LibraryItemsResponse
     */
    items?: Array<LibraryItem>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LibraryItemsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LibraryItemsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof LibraryItemsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface LinkedAccount
 */
export interface LinkedAccount {
    /**
     * The company name of this linked account.
     * @type {string}
     * @memberof LinkedAccount
     */
    company?: string;
    /**
     * A merchant id that is linked to this account.
     * @type {string}
     * @memberof LinkedAccount
     */
    merchantId?: string;
    /**
     * If true, this user configuration (permissions, notifications, everything) is cascaded to this linked account.
     * @type {boolean}
     * @memberof LinkedAccount
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface ListSegmentMembership
 */
export interface ListSegmentMembership {
    /**
     * 
     * @type {string}
     * @memberof ListSegmentMembership
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSegmentMembership
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSegmentMembership
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface LookupRequest
 */
export interface LookupRequest {
    /**
     * 
     * @type {string}
     * @memberof LookupRequest
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof LookupRequest
     */
    matches?: string;
    /**
     * 
     * @type {number}
     * @memberof LookupRequest
     */
    maxHits?: number;
    /**
     * 
     * @type {number}
     * @memberof LookupRequest
     */
    storefrontOid?: number;
    /**
     * 
     * @type {string}
     * @memberof LookupRequest
     */
    subcategory?: string;
}

/**
 * 
 * @export
 * @interface LookupResponse
 */
export interface LookupResponse {
    /**
     * 
     * @type {Error}
     * @memberof LookupResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LookupResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LookupResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof LookupResponse
     */
    values?: Array<KeyValue>;
    /**
     * 
     * @type {Warning}
     * @memberof LookupResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    allTime?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    allTimeFormatted?: string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    last30?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    last30Formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    prior30?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    prior30Formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A technical message meant to be read by a developer
     * @type {string}
     * @memberof ModelError
     */
    developerMessage?: string;
    /**
     * HTTP status code
     * @type {string}
     * @memberof ModelError
     */
    errorCode?: string;
    /**
     * Additional information often a link to additional documentation
     * @type {string}
     * @memberof ModelError
     */
    moreInfo?: string;
    /**
     * An end-user friendly message suitable for display to the customer
     * @type {string}
     * @memberof ModelError
     */
    userMessage?: string;
}

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * True if this notification can be filtered to only send for one or more distribution centers.
     * @type {boolean}
     * @memberof Notification
     */
    canFilterByDistributionCenters?: boolean;
    /**
     * True if this notification can include an affiliate information.
     * @type {boolean}
     * @memberof Notification
     */
    canIncludeAffiliate?: boolean;
    /**
     * True if this notification can include an order attachment.
     * @type {boolean}
     * @memberof Notification
     */
    canIncludeOrder?: boolean;
    /**
     * True if this notification can include a plain text rendering of an order directly within an email.  Some desire this over an attachment
     * @type {boolean}
     * @memberof Notification
     */
    canIncludeOrderPlainText?: boolean;
    /**
     * If this notification supports it, this list of distribution center CODES will filter the notification to just those distribution centers.
     * @type {Array<string>}
     * @memberof Notification
     */
    distributionCenterFilters?: Array<string>;
    /**
     * If true, and this notification supports it, affiliate information will be attached to all notifications of this type
     * @type {boolean}
     * @memberof Notification
     */
    includeAffiliate?: boolean;
    /**
     * If true, and this notification supports it, the order will be attached to all notifications of this type
     * @type {boolean}
     * @memberof Notification
     */
    includeOrder?: boolean;
    /**
     * If true, and this notification supports it, a plain text order will be directly inserted into all notifications of this type
     * @type {boolean}
     * @memberof Notification
     */
    includeOrderPlainText?: boolean;
    /**
     * The name of this notification.
     * @type {string}
     * @memberof Notification
     */
    name?: string;
    /**
     * A group for this notification.  This name is only used for visual grouping within interfaces.
     * @type {string}
     * @memberof Notification
     */
    notificationGroup?: string;
    /**
     * True if this user wishes to receive this email notification.
     * @type {boolean}
     * @memberof Notification
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface OauthRevokeSuccessResponse
 */
export interface OauthRevokeSuccessResponse {
    /**
     * Message confirming revocation of credentials
     * @type {string}
     * @memberof OauthRevokeSuccessResponse
     */
    message?: string;
    /**
     * True if revoke was successful
     * @type {boolean}
     * @memberof OauthRevokeSuccessResponse
     */
    successful?: boolean;
}

/**
 * 
 * @export
 * @interface OauthTokenResponse
 */
export interface OauthTokenResponse {
    /**
     * Access token to use in OAuth authenticated API call
     * @type {string}
     * @memberof OauthTokenResponse
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthTokenResponse
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthTokenResponse
     */
    errorDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthTokenResponse
     */
    errorUri?: string;
    /**
     * The number of seconds since issuance when the access token will expire and need to be refreshed using the refresh token
     * @type {string}
     * @memberof OauthTokenResponse
     */
    expiresIn?: string;
    /**
     * The refresh token that should be used to fetch a new access token when the expiration occurs
     * @type {string}
     * @memberof OauthTokenResponse
     */
    refreshToken?: string;
    /**
     * The scope of permissions associated with teh access token
     * @type {string}
     * @memberof OauthTokenResponse
     */
    scope?: string;
    /**
     * Type of token
     * @type {string}
     * @memberof OauthTokenResponse
     */
    tokenType?: OauthTokenResponse.TokenTypeEnum;
}

/**
 * @export
 * @namespace OauthTokenResponse
 */
export namespace OauthTokenResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TokenTypeEnum {
        Bearer = <any> 'bearer'
    }
}

/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Affiliates if any were associated with the order.  The first one in the array sent the order and each subsequent affiliate is the recruiter that earns a downline commission.
     * @type {Array<OrderAffiliate>}
     * @memberof Order
     */
    affiliates?: Array<OrderAffiliate>;
    /**
     * 
     * @type {OrderAutoOrder}
     * @memberof Order
     */
    autoOrder?: OrderAutoOrder;
    /**
     * 
     * @type {OrderBilling}
     * @memberof Order
     */
    billing?: OrderBilling;
    /**
     * 
     * @type {OrderBuysafe}
     * @memberof Order
     */
    buysafe?: OrderBuysafe;
    /**
     * 
     * @type {OrderChannelPartner}
     * @memberof Order
     */
    channelPartner?: OrderChannelPartner;
    /**
     * 
     * @type {OrderCheckout}
     * @memberof Order
     */
    checkout?: OrderCheckout;
    /**
     * Coupons
     * @type {Array<OrderCoupon>}
     * @memberof Order
     */
    coupons?: Array<OrderCoupon>;
    /**
     * Date/time that the order was created
     * @type {string}
     * @memberof Order
     */
    creationDts?: string;
    /**
     * Currency code that the customer used if different than the merchant's base currency code
     * @type {string}
     * @memberof Order
     */
    currencyCode?: string;
    /**
     * Current stage that the order is in.
     * @type {string}
     * @memberof Order
     */
    currentStage?: Order.CurrentStageEnum;
    /**
     * 
     * @type {Customer}
     * @memberof Order
     */
    customerProfile?: Customer;
    /**
     * 
     * @type {OrderDigitalOrder}
     * @memberof Order
     */
    digitalOrder?: OrderDigitalOrder;
    /**
     * 
     * @type {OrderEdi}
     * @memberof Order
     */
    edi?: OrderEdi;
    /**
     * Exchange rate at the time the order was placed if currency code is different than the base currency
     * @type {number}
     * @memberof Order
     */
    exchangeRate?: number;
    /**
     * 
     * @type {OrderFraudScore}
     * @memberof Order
     */
    fraudScore?: OrderFraudScore;
    /**
     * 
     * @type {OrderGift}
     * @memberof Order
     */
    gift?: OrderGift;
    /**
     * 
     * @type {OrderGiftCertificate}
     * @memberof Order
     */
    giftCertificate?: OrderGiftCertificate;
    /**
     * 
     * @type {OrderInternal}
     * @memberof Order
     */
    internal?: OrderInternal;
    /**
     * Items
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    items?: Array<OrderItem>;
    /**
     * Three letter ISO-639 language code used by the customer during the checkout if different than the default language
     * @type {string}
     * @memberof Order
     */
    languageIsoCode?: string;
    /**
     * 
     * @type {OrderLinkedShipment}
     * @memberof Order
     */
    linkedShipment?: OrderLinkedShipment;
    /**
     * 
     * @type {OrderMarketing}
     * @memberof Order
     */
    marketing?: OrderMarketing;
    /**
     * UltraCart merchant ID owning this order
     * @type {string}
     * @memberof Order
     */
    merchantId?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof Order
     */
    orderId?: string;
    /**
     * 
     * @type {OrderPayment}
     * @memberof Order
     */
    payment?: OrderPayment;
    /**
     * Properties, available only through update, not through insert due to the nature of how properties are handled internally
     * @type {Array<OrderProperty>}
     * @memberof Order
     */
    properties?: Array<OrderProperty>;
    /**
     * 
     * @type {OrderQuote}
     * @memberof Order
     */
    quote?: OrderQuote;
    /**
     * If the order was refunded, the date/time that the last refund occurred
     * @type {string}
     * @memberof Order
     */
    refundDts?: string;
    /**
     * If the order was rejected, the date/time that the rejection occurred
     * @type {string}
     * @memberof Order
     */
    rejectDts?: string;
    /**
     * 
     * @type {OrderSalesforce}
     * @memberof Order
     */
    salesforce?: OrderSalesforce;
    /**
     * 
     * @type {OrderShipping}
     * @memberof Order
     */
    shipping?: OrderShipping;
    /**
     * 
     * @type {OrderSummary}
     * @memberof Order
     */
    summary?: OrderSummary;
    /**
     * tags, available only through update, not through insert due to the nature of how tags are handled internally
     * @type {Array<OrderTag>}
     * @memberof Order
     */
    tags?: Array<OrderTag>;
    /**
     * 
     * @type {OrderTaxes}
     * @memberof Order
     */
    taxes?: OrderTaxes;
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown',
        PreOrdered = <any> 'Pre-ordered'
    }
}

/**
 * 
 * @export
 * @interface OrderAffiliate
 */
export interface OrderAffiliate {
    /**
     * Affiliate ID
     * @type {number}
     * @memberof OrderAffiliate
     */
    affiliateOid?: number;
    /**
     * Ledger entries associated with all the commissions earned on this order
     * @type {Array<OrderAffiliateLedger>}
     * @memberof OrderAffiliate
     */
    ledgerEntries?: Array<OrderAffiliateLedger>;
    /**
     * Sub identifier provided by the affiliate on the click that generated this order
     * @type {string}
     * @memberof OrderAffiliate
     */
    subId?: string;
}

/**
 * 
 * @export
 * @interface OrderAffiliateLedger
 */
export interface OrderAffiliateLedger {
    /**
     * UltraCart user name that assigned this commission if manually assigned
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    assignedByUser?: string;
    /**
     * Item ID that this ledger record is associated with
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    itemId?: string;
    /**
     * Tier number of this affiliate in the commission calculation
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    tierNumber?: number;
    /**
     * Amount of the transaction
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    transactionAmount?: number;
    /**
     * The amount that has been paid so far on the transaction
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    transactionAmountPaid?: number;
    /**
     * The date/time that the affiliate ledger was generated for the transaction
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    transactionDts?: string;
    /**
     * Details of the transaction suitable for display to the affiliate
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    transactionMemo?: string;
    /**
     * The percentage earned on the transaction
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    transactionPercentage?: number;
    /**
     * The state of the transaction
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    transactionState?: OrderAffiliateLedger.TransactionStateEnum;
}

/**
 * @export
 * @namespace OrderAffiliateLedger
 */
export namespace OrderAffiliateLedger {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}

/**
 * 
 * @export
 * @interface OrderAutoOrder
 */
export interface OrderAutoOrder {
    /**
     * Unique code assigned to this auto order
     * @type {string}
     * @memberof OrderAutoOrder
     */
    autoOrderCode?: string;
    /**
     * Auto order object identifier
     * @type {number}
     * @memberof OrderAutoOrder
     */
    autoOrderOid?: number;
    /**
     * Cancel this auto order after X additional rebills
     * @type {number}
     * @memberof OrderAutoOrder
     */
    cancelAfterNextXOrders?: number;
    /**
     * True if the auto order was canceled because the customer purchased a downgrade item
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    cancelDowngrade?: boolean;
    /**
     * True if the auto order was canceled because the customer purchased an upgrade item
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    cancelUpgrade?: boolean;
    /**
     * The user that canceled the auto order
     * @type {string}
     * @memberof OrderAutoOrder
     */
    canceledByUser?: string;
    /**
     * The date/time that the auto order was canceled
     * @type {string}
     * @memberof OrderAutoOrder
     */
    canceledDts?: string;
    /**
     * True if the auto order ran successfully to completion
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    completed?: boolean;
    /**
     * The number of credit card attempts that have taken place
     * @type {number}
     * @memberof OrderAutoOrder
     */
    creditCardAttempt?: number;
    /**
     * The date/time the auto order was disabled due to failed rebills
     * @type {string}
     * @memberof OrderAutoOrder
     */
    disabledDts?: string;
    /**
     * True if this auto order is enabled
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    enabled?: boolean;
    /**
     * The reason this auto order failed during the last rebill attempt
     * @type {string}
     * @memberof OrderAutoOrder
     */
    failureReason?: string;
    /**
     * The items that are setup to rebill
     * @type {Array<AutoOrderItem>}
     * @memberof OrderAutoOrder
     */
    items?: Array<AutoOrderItem>;
    /**
     * The next time that the auto order will be attempted for processing
     * @type {string}
     * @memberof OrderAutoOrder
     */
    nextAttempt?: string;
    /**
     * The original order id that this auto order is associated with.
     * @type {string}
     * @memberof OrderAutoOrder
     */
    originalOrderId?: string;
    /**
     * Override the affiliate id given credit for rebills of this auto order
     * @type {number}
     * @memberof OrderAutoOrder
     */
    overrideAffiliateId?: number;
    /**
     * Rebill orders that have taken place on this auto order
     * @type {Array<Order>}
     * @memberof OrderAutoOrder
     */
    rebillOrders?: Array<Order>;
    /**
     * The RTG code associated with this order for future rebills
     * @type {string}
     * @memberof OrderAutoOrder
     */
    rotatingTransactionGatewayCode?: string;
    /**
     * The status of the auto order
     * @type {string}
     * @memberof OrderAutoOrder
     */
    status?: OrderAutoOrder.StatusEnum;
}

/**
 * @export
 * @namespace OrderAutoOrder
 */
export namespace OrderAutoOrder {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}

/**
 * 
 * @export
 * @interface OrderBilling
 */
export interface OrderBilling {
    /**
     * Address line 1
     * @type {string}
     * @memberof OrderBilling
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof OrderBilling
     */
    address2?: string;
    /**
     * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
     * @type {Array<string>}
     * @memberof OrderBilling
     */
    ccEmails?: Array<string>;
    /**
     * City
     * @type {string}
     * @memberof OrderBilling
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof OrderBilling
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof OrderBilling
     */
    countryCode?: string;
    /**
     * Day time phone
     * @type {string}
     * @memberof OrderBilling
     */
    dayPhone?: string;
    /**
     * Day time phone (E164 format)
     * @type {string}
     * @memberof OrderBilling
     */
    dayPhoneE164?: string;
    /**
     * Email
     * @type {string}
     * @memberof OrderBilling
     */
    email?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof OrderBilling
     */
    eveningPhone?: string;
    /**
     * First name
     * @type {string}
     * @memberof OrderBilling
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof OrderBilling
     */
    lastName?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof OrderBilling
     */
    postalCode?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof OrderBilling
     */
    stateRegion?: string;
    /**
     * Title
     * @type {string}
     * @memberof OrderBilling
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface OrderBuysafe
 */
export interface OrderBuysafe {
    /**
     * True if a buySAFE bond was available for purchase on this order
     * @type {boolean}
     * @memberof OrderBuysafe
     */
    buysafeBondAvailable?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderBuysafe
     */
    buysafeBondCost?: Currency;
    /**
     * True if the buySAFE bond was free for this order
     * @type {boolean}
     * @memberof OrderBuysafe
     */
    buysafeBondFree?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderBuysafe
     */
    buysafeBondRefunded?: Currency;
    /**
     * True if the buySAFE bond was wanted by the customer
     * @type {boolean}
     * @memberof OrderBuysafe
     */
    buysafeBondWanted?: boolean;
    /**
     * Shopping cart ID associated with the buySAFE bond
     * @type {string}
     * @memberof OrderBuysafe
     */
    buysafeShoppingCartId?: string;
}

/**
 * 
 * @export
 * @interface OrderByTokenQuery
 */
export interface OrderByTokenQuery {
    /**
     * Order Token
     * @type {string}
     * @memberof OrderByTokenQuery
     */
    orderToken?: string;
}

/**
 * 
 * @export
 * @interface OrderChannelPartner
 */
export interface OrderChannelPartner {
    /**
     * If true, any purchase order submitted is automatically approved
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    autoApprovePurchaseOrder?: boolean;
    /**
     * The code of the channel partner
     * @type {string}
     * @memberof OrderChannelPartner
     */
    channelPartnerCode?: string;
    /**
     * Additional data provided by the channel partner, read-only
     * @type {string}
     * @memberof OrderChannelPartner
     */
    channelPartnerData?: string;
    /**
     * Channel partner object identifier, read-only and available on existing channel orders only.
     * @type {number}
     * @memberof OrderChannelPartner
     */
    channelPartnerOid?: number;
    /**
     * The order ID assigned by the channel partner for this order
     * @type {string}
     * @memberof OrderChannelPartner
     */
    channelPartnerOrderId?: string;
    /**
     * Indicates this order should be placed in Account Receivable for later payment processing
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    noRealtimePaymentProcessing?: boolean;
    /**
     * Indicates this order was already paid for via a channel purchase and no payment collection should be attempted
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    skipPaymentProcessing?: boolean;
    /**
     * Instructs UltraCart to skip shipping department and mark this order as fully complete.  Set this flag if you have already shipped product for this order.
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    storeCompleted?: boolean;
    /**
     * If true, any failed payment will place the order in Accounts Receivable rather than rejecting it.
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    storeIfPaymentDeclines?: boolean;
    /**
     * Any warnings are raised as errors and halt the import of the order
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    treatWarningsAsErrors?: boolean;
}

/**
 * 
 * @export
 * @interface OrderCheckout
 */
export interface OrderCheckout {
    /**
     * Comments from the customer.  Rarely used on the single page checkout.
     * @type {string}
     * @memberof OrderCheckout
     */
    comments?: string;
    /**
     * Custom field 1
     * @type {string}
     * @memberof OrderCheckout
     */
    customField1?: string;
    /**
     * Custom field 2
     * @type {string}
     * @memberof OrderCheckout
     */
    customField2?: string;
    /**
     * Custom field 3
     * @type {string}
     * @memberof OrderCheckout
     */
    customField3?: string;
    /**
     * Custom field 4
     * @type {string}
     * @memberof OrderCheckout
     */
    customField4?: string;
    /**
     * Custom field 5
     * @type {string}
     * @memberof OrderCheckout
     */
    customField5?: string;
    /**
     * Custom field 6
     * @type {string}
     * @memberof OrderCheckout
     */
    customField6?: string;
    /**
     * Custom field 7
     * @type {string}
     * @memberof OrderCheckout
     */
    customField7?: string;
    /**
     * IP address of the customer when placing the order
     * @type {string}
     * @memberof OrderCheckout
     */
    customerIpAddress?: string;
    /**
     * Screen branding theme code associated with the order (legacy checkout)
     * @type {string}
     * @memberof OrderCheckout
     */
    screenBrandingThemeCode?: string;
    /**
     * StoreFront host name associated with the order
     * @type {string}
     * @memberof OrderCheckout
     */
    storefrontHostName?: string;
    /**
     * Upsell path code assigned during the checkout that the customer went through
     * @type {string}
     * @memberof OrderCheckout
     */
    upsellPathCode?: string;
}

/**
 * 
 * @export
 * @interface OrderCoupon
 */
export interface OrderCoupon {
    /**
     * QuickBooks accounting code for this coupon
     * @type {string}
     * @memberof OrderCoupon
     */
    accountingCode?: string;
    /**
     * Whether or not the coupon was automatically applied to the order
     * @type {boolean}
     * @memberof OrderCoupon
     */
    automaticallyApplied?: boolean;
    /**
     * Coupon code configured by the merchant.  Will differ if the customer used a one time coupon code generated off this base coupon
     * @type {string}
     * @memberof OrderCoupon
     */
    baseCouponCode?: string;
    /**
     * Coupon code entered by the customer
     * @type {string}
     * @memberof OrderCoupon
     */
    couponCode?: string;
}

/**
 * 
 * @export
 * @interface OrderDigitalItem
 */
export interface OrderDigitalItem {
    /**
     * File size
     * @type {number}
     * @memberof OrderDigitalItem
     */
    fileSize?: number;
    /**
     * Last download
     * @type {string}
     * @memberof OrderDigitalItem
     */
    lastDownload?: string;
    /**
     * IP address that performed the last download
     * @type {string}
     * @memberof OrderDigitalItem
     */
    lastDownloadIpAddress?: string;
    /**
     * Original file name
     * @type {string}
     * @memberof OrderDigitalItem
     */
    originalFilename?: string;
    /**
     * Item id associated with this item
     * @type {string}
     * @memberof OrderDigitalItem
     */
    productCode?: string;
    /**
     * Item description associated with this item
     * @type {string}
     * @memberof OrderDigitalItem
     */
    productDescription?: string;
    /**
     * Remaining number of downloads
     * @type {number}
     * @memberof OrderDigitalItem
     */
    remainingDownloads?: number;
    /**
     * URL that the customer can click to download the specific digital item
     * @type {string}
     * @memberof OrderDigitalItem
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface OrderDigitalOrder
 */
export interface OrderDigitalOrder {
    /**
     * Date/time that the digital order was created
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    creationDts?: string;
    /**
     * Expiration date/time of the digital order
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    expirationDts?: string;
    /**
     * Digital items associated with the digital order
     * @type {Array<OrderDigitalItem>}
     * @memberof OrderDigitalOrder
     */
    items?: Array<OrderDigitalItem>;
    /**
     * URL where the customer can go to and download their digital order content
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    url?: string;
    /**
     * URL ID is a unique code that is part of the URLs
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    urlId?: string;
}

/**
 * 
 * @export
 * @interface OrderEdi
 */
export interface OrderEdi {
    /**
     * Billing address identification code from the EDI order.  Typically DUNS or DUNS+4
     * @type {string}
     * @memberof OrderEdi
     */
    billToEdiCode?: string;
    /**
     * Department number associated with this EDI order
     * @type {string}
     * @memberof OrderEdi
     */
    ediDepartment?: string;
    /**
     * Internal vendor number associated with this EDI order
     * @type {string}
     * @memberof OrderEdi
     */
    ediInternalVendorNumber?: string;
    /**
     * Shipping address identification code from the EDI order.  Typically DUNS or DUNS+4
     * @type {string}
     * @memberof OrderEdi
     */
    shipToEdiCode?: string;
}

/**
 * 
 * @export
 * @interface OrderFormat
 */
export interface OrderFormat {
    /**
     * The context to generate the order view for.
     * @type {string}
     * @memberof OrderFormat
     */
    context?: string;
    /**
     * True to not link the email address to the order search
     * @type {boolean}
     * @memberof OrderFormat
     */
    dontLinkEmailToSearch?: boolean;
    /**
     * True to make the email address a clickable mailto link
     * @type {boolean}
     * @memberof OrderFormat
     */
    emailAsLink?: boolean;
    /**
     * Specify a distribution center oid to filter the items displayed to that particular distribution center.
     * @type {number}
     * @memberof OrderFormat
     */
    filterDistributionCenterOid?: number;
    /**
     * The container oid to filter items to.
     * @type {number}
     * @memberof OrderFormat
     */
    filterToItemsInContactOid?: number;
    /**
     * The desired format.
     * @type {string}
     * @memberof OrderFormat
     */
    format?: OrderFormat.FormatEnum;
    /**
     * True to ide the bill to address
     * @type {boolean}
     * @memberof OrderFormat
     */
    hideBillToAddress?: boolean;
    /**
     * True to hide price information
     * @type {boolean}
     * @memberof OrderFormat
     */
    hidePriceInformation?: boolean;
    /**
     * True to link file attachments for download
     * @type {boolean}
     * @memberof OrderFormat
     */
    linkFileAttachments?: boolean;
    /**
     * True to show contact information
     * @type {boolean}
     * @memberof OrderFormat
     */
    showContactInfo?: boolean;
    /**
     * True to show the order in the merchant currency
     * @type {boolean}
     * @memberof OrderFormat
     */
    showInMerchantCurrency?: boolean;
    /**
     * True to show internal information about the order
     * @type {boolean}
     * @memberof OrderFormat
     */
    showInternalInformation?: boolean;
    /**
     * True to show merchant notes
     * @type {boolean}
     * @memberof OrderFormat
     */
    showMerchantNotes?: boolean;
    /**
     * True to show non-sensitive payment information
     * @type {boolean}
     * @memberof OrderFormat
     */
    showNonSensitivePaymentInfo?: boolean;
    /**
     * True to show payment information
     * @type {boolean}
     * @memberof OrderFormat
     */
    showPaymentInfo?: boolean;
    /**
     * True to translate the order into the native language of the customer
     * @type {boolean}
     * @memberof OrderFormat
     */
    translate?: boolean;
}

/**
 * @export
 * @namespace OrderFormat
 */
export namespace OrderFormat {
    /**
     * @export
     * @enum {string}
     */
    export enum FormatEnum {
        Text = <any> 'text',
        Div = <any> 'div',
        Table = <any> 'table',
        Email = <any> 'email'
    }
}

/**
 * 
 * @export
 * @interface OrderFormatResponse
 */
export interface OrderFormatResponse {
    /**
     * The URLs to any stylesheets that need to be included to properly view the markup.
     * @type {Array<string>}
     * @memberof OrderFormatResponse
     */
    cssLinks?: Array<string>;
    /**
     * The formatted result of the order.  This will be HTML or text depending upon the requested format.
     * @type {string}
     * @memberof OrderFormatResponse
     */
    formattedResult?: string;
}

/**
 * 
 * @export
 * @interface OrderFraudScore
 */
export interface OrderFraudScore {
    /**
     * True if the IP address is a known anonymous proxy server
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    anonymousProxy?: boolean;
    /**
     * Whether the BIN (first six digits) matched the country
     * @type {string}
     * @memberof OrderFraudScore
     */
    binMatch?: OrderFraudScore.BinMatchEnum;
    /**
     * True if the email address belongs to a known credit card fraudster
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    carderEmail?: boolean;
    /**
     * Country code
     * @type {string}
     * @memberof OrderFraudScore
     */
    countryCode?: string;
    /**
     * Country code matches BIN country
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    countryMatch?: boolean;
    /**
     * Whether the customer's phone number is located in the area of the billing address
     * @type {string}
     * @memberof OrderFraudScore
     */
    customerPhoneInBillingLocation?: string;
    /**
     * Distance in kilometers between the IP address and the BIN
     * @type {number}
     * @memberof OrderFraudScore
     */
    distanceKm?: number;
    /**
     * True if the email address is for a free service like gmail.com
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    freeEmail?: boolean;
    /**
     * True if the customer is in a high risk country known for internet fraud
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    highRiskCountry?: boolean;
    /**
     * City associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ipCity?: string;
    /**
     * ISP that owns the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ipIsp?: string;
    /**
     * Approximate latitude associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ipLatitude?: string;
    /**
     * Approximate longitude associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ipLongitude?: string;
    /**
     * Organization that owns the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ipOrg?: string;
    /**
     * State/region associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ipRegion?: string;
    /**
     * Likelihood of the IP address being a proxy server
     * @type {number}
     * @memberof OrderFraudScore
     */
    proxyScore?: number;
    /**
     * Overall score.  This is the score that is compared to see if the order is rejected or held for review by the fraud filter rules.
     * @type {number}
     * @memberof OrderFraudScore
     */
    score?: number;
    /**
     * True if the address is a known ship forwarding company
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    shipForwarder?: boolean;
    /**
     * Likelihood of the email address being associated with a spammer
     * @type {number}
     * @memberof OrderFraudScore
     */
    spamScore?: number;
    /**
     * True if the IP address that placed the order is a transparent proxy server
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    transparentProxy?: boolean;
}

/**
 * @export
 * @namespace OrderFraudScore
 */
export namespace OrderFraudScore {
    /**
     * @export
     * @enum {string}
     */
    export enum BinMatchEnum {
        NA = <any> 'NA',
        No = <any> 'No',
        NotFound = <any> 'NotFound',
        Yes = <any> 'Yes'
    }
}

/**
 * 
 * @export
 * @interface OrderGift
 */
export interface OrderGift {
    /**
     * True if the order is a gift
     * @type {boolean}
     * @memberof OrderGift
     */
    gift?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    giftCharge?: Currency;
    /**
     * QuickBooks code for the gift charge
     * @type {string}
     * @memberof OrderGift
     */
    giftChargeAccountingCode?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    giftChargeRefunded?: Currency;
    /**
     * Email address of the gift recipient
     * @type {string}
     * @memberof OrderGift
     */
    giftEmail?: string;
    /**
     * Message to the gift recipient
     * @type {string}
     * @memberof OrderGift
     */
    giftMessage?: string;
    /**
     * QuickBooks code for the gift wrap charge
     * @type {string}
     * @memberof OrderGift
     */
    giftWrapAccountingCode?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    giftWrapCost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    giftWrapRefunded?: Currency;
    /**
     * Title of the gift wrap that the customer wants used
     * @type {string}
     * @memberof OrderGift
     */
    giftWrapTitle?: string;
}

/**
 * 
 * @export
 * @interface OrderGiftCertificate
 */
export interface OrderGiftCertificate {
    /**
     * 
     * @type {Currency}
     * @memberof OrderGiftCertificate
     */
    giftCertificateAmount?: Currency;
    /**
     * Gift certificate code used on the order
     * @type {string}
     * @memberof OrderGiftCertificate
     */
    giftCertificateCode?: string;
    /**
     * Gift certificate object identifier
     * @type {number}
     * @memberof OrderGiftCertificate
     */
    giftCertificateOid?: number;
}

/**
 * 
 * @export
 * @interface OrderInternal
 */
export interface OrderInternal {
    /**
     * True if the order has been exported to QuickBooks. If QuickBooks is not configured, then this will already be true
     * @type {boolean}
     * @memberof OrderInternal
     */
    exportedToAccounting?: boolean;
    /**
     * Merchant notes
     * @type {string}
     * @memberof OrderInternal
     */
    merchantNotes?: string;
    /**
     * If placed via the BEOE, this is the user that placed the order
     * @type {string}
     * @memberof OrderInternal
     */
    placedByUser?: string;
    /**
     * User that issued the refund
     * @type {string}
     * @memberof OrderInternal
     */
    refundByUser?: string;
    /**
     * Sales rep code associated with the order
     * @type {string}
     * @memberof OrderInternal
     */
    salesRepCode?: string;
}

/**
 * 
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * QuickBooks code
     * @type {string}
     * @memberof OrderItem
     */
    accountingCode?: string;
    /**
     * Activation codes assigned to this item
     * @type {Array<string>}
     * @memberof OrderItem
     */
    activationCodes?: Array<string>;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    arbitraryUnitCost?: Currency;
    /**
     * Date/time of the last rebill, used only during order insert to help project future rebills
     * @type {string}
     * @memberof OrderItem
     */
    autoOrderLastRebillDts?: string;
    /**
     * Auto order schedule, used only during inserts supplying the recurring schedule
     * @type {string}
     * @memberof OrderItem
     */
    autoOrderSchedule?: string;
    /**
     * Barcode
     * @type {string}
     * @memberof OrderItem
     */
    barcode?: string;
    /**
     * Channel partner item id if this order came through a channel partner and the channel partner item id was mapped to an internal item id
     * @type {string}
     * @memberof OrderItem
     */
    channelPartnerItemId?: string;
    /**
     * Cost of goods sold
     * @type {number}
     * @memberof OrderItem
     */
    cogs?: number;
    /**
     * Value of the kit component item
     * @type {number}
     * @memberof OrderItem
     */
    componentUnitValue?: number;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    cost?: Currency;
    /**
     * Country of origin (ISO-3166 two letter code)
     * @type {string}
     * @memberof OrderItem
     */
    countryCodeOfOrigin?: string;
    /**
     * Customs description
     * @type {string}
     * @memberof OrderItem
     */
    customsDescription?: string;
    /**
     * Description
     * @type {string}
     * @memberof OrderItem
     */
    description?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    discount?: Currency;
    /**
     * Discount quantity
     * @type {number}
     * @memberof OrderItem
     */
    discountQuantity?: number;
    /**
     * 
     * @type {Weight}
     * @memberof OrderItem
     */
    discountShippingWeight?: Weight;
    /**
     * Distribution center code responsible for shipping this item
     * @type {string}
     * @memberof OrderItem
     */
    distributionCenterCode?: string;
    /**
     * 
     * @type {OrderItemEdi}
     * @memberof OrderItem
     */
    edi?: OrderItemEdi;
    /**
     * True if this item is excluded from coupons
     * @type {boolean}
     * @memberof OrderItem
     */
    excludeCoupon?: boolean;
    /**
     * True if the item receives free shipping
     * @type {boolean}
     * @memberof OrderItem
     */
    freeShipping?: boolean;
    /**
     * Hazardous materials indicator
     * @type {boolean}
     * @memberof OrderItem
     */
    hazmat?: boolean;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItem
     */
    height?: Distance;
    /**
     * Item reference object identifier used to linked to auto order item record
     * @type {number}
     * @memberof OrderItem
     */
    itemReferenceOid?: number;
    /**
     * True if this item is a kit
     * @type {boolean}
     * @memberof OrderItem
     */
    kit?: boolean;
    /**
     * True if this item is a kit component
     * @type {boolean}
     * @memberof OrderItem
     */
    kitComponent?: boolean;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItem
     */
    length?: Distance;
    /**
     * Manufacturer SKU
     * @type {string}
     * @memberof OrderItem
     */
    manufacturerSku?: string;
    /**
     * Maximum days that the item can be in transit before spoilage (perishable products)
     * @type {number}
     * @memberof OrderItem
     */
    maxDaysTimeInTransit?: number;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderItem
     */
    merchantItemId?: string;
    /**
     * Mix and match group name
     * @type {string}
     * @memberof OrderItem
     */
    mixAndMatchGroupName?: string;
    /**
     * Mix and match group object identifier
     * @type {number}
     * @memberof OrderItem
     */
    mixAndMatchGroupOid?: number;
    /**
     * True if this item is excluded from shipping discounts
     * @type {boolean}
     * @memberof OrderItem
     */
    noShippingDiscount?: boolean;
    /**
     * Options
     * @type {Array<OrderItemOption>}
     * @memberof OrderItem
     */
    options?: Array<OrderItemOption>;
    /**
     * Packed by user
     * @type {string}
     * @memberof OrderItem
     */
    packedByUser?: string;
    /**
     * Perishable class of the item
     * @type {string}
     * @memberof OrderItem
     */
    perishableClass?: string;
    /**
     * Pricing tier that granted the particular price for this item if the customer profile had pricing tiers assigned
     * @type {string}
     * @memberof OrderItem
     */
    pricingTierName?: string;
    /**
     * Properties
     * @type {Array<OrderItemProperty>}
     * @memberof OrderItem
     */
    properties?: Array<OrderItemProperty>;
    /**
     * Quantity
     * @type {number}
     * @memberof OrderItem
     */
    quantity?: number;
    /**
     * Quantity refunded on this item (read only except refund operation)
     * @type {number}
     * @memberof OrderItem
     */
    quantityRefunded?: number;
    /**
     * QuickBooks class
     * @type {string}
     * @memberof OrderItem
     */
    quickbooksClass?: string;
    /**
     * True if this item ships in a separate box
     * @type {boolean}
     * @memberof OrderItem
     */
    shipSeparately?: boolean;
    /**
     * Shipped by user
     * @type {string}
     * @memberof OrderItem
     */
    shippedByUser?: string;
    /**
     * Date/time that this item was marked shipped
     * @type {string}
     * @memberof OrderItem
     */
    shippedDts?: string;
    /**
     * Special product type (USPS Media Mail)
     * @type {string}
     * @memberof OrderItem
     */
    specialProductType?: string;
    /**
     * Tags
     * @type {Array<OrderItemTag>}
     * @memberof OrderItem
     */
    tags?: Array<OrderItemTag>;
    /**
     * True if the item is tax free
     * @type {boolean}
     * @memberof OrderItem
     */
    taxFree?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    taxableCost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    totalCostWithDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    totalRefunded?: Currency;
    /**
     * Date/time that this item was transmitted to the distribution center
     * @type {string}
     * @memberof OrderItem
     */
    transmittedToDistributionCenterDts?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    unitCostWithDiscount?: Currency;
    /**
     * True if this item was added to the order as part of an upsell
     * @type {boolean}
     * @memberof OrderItem
     */
    upsell?: boolean;
    /**
     * 
     * @type {Weight}
     * @memberof OrderItem
     */
    weight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItem
     */
    width?: Distance;
}

/**
 * 
 * @export
 * @interface OrderItemEdi
 */
export interface OrderItemEdi {
    /**
     * Identification information receives on the EDI purchase order
     * @type {Array<OrderItemEdiIdentification>}
     * @memberof OrderItemEdi
     */
    identifications?: Array<OrderItemEdiIdentification>;
    /**
     * Lot information
     * @type {Array<OrderItemEdiLot>}
     * @memberof OrderItemEdi
     */
    lots?: Array<OrderItemEdiLot>;
}

/**
 * 
 * @export
 * @interface OrderItemEdiIdentification
 */
export interface OrderItemEdiIdentification {
    /**
     * Identification value
     * @type {string}
     * @memberof OrderItemEdiIdentification
     */
    identification?: string;
    /**
     * Quantity associated with this identifier
     * @type {number}
     * @memberof OrderItemEdiIdentification
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface OrderItemEdiLot
 */
export interface OrderItemEdiLot {
    /**
     * Log expiration
     * @type {string}
     * @memberof OrderItemEdiLot
     */
    lotExpiration?: string;
    /**
     * Lot number
     * @type {string}
     * @memberof OrderItemEdiLot
     */
    lotNumber?: string;
    /**
     * Lot quantity
     * @type {number}
     * @memberof OrderItemEdiLot
     */
    lotQuantity?: number;
}

/**
 * 
 * @export
 * @interface OrderItemOption
 */
export interface OrderItemOption {
    /**
     * How the additional dimensions are applied to the item.
     * @type {string}
     * @memberof OrderItemOption
     */
    additionalDimensionApplication?: OrderItemOption.AdditionalDimensionApplicationEnum;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItemOption
     */
    costChange?: Currency;
    /**
     * 
     * @type {OrderItemOptionFileAttachment}
     * @memberof OrderItemOption
     */
    fileAttachment?: OrderItemOptionFileAttachment;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItemOption
     */
    height?: Distance;
    /**
     * True if this option is hidden from display on the order
     * @type {boolean}
     * @memberof OrderItemOption
     */
    hidden?: boolean;
    /**
     * Label
     * @type {string}
     * @memberof OrderItemOption
     */
    label?: string;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItemOption
     */
    length?: Distance;
    /**
     * True if the cost associated with this option is a one time fee or multiplied by the quantity of the item
     * @type {boolean}
     * @memberof OrderItemOption
     */
    oneTimeFee?: boolean;
    /**
     * Value
     * @type {string}
     * @memberof OrderItemOption
     */
    value?: string;
    /**
     * 
     * @type {Weight}
     * @memberof OrderItemOption
     */
    weightChange?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItemOption
     */
    width?: Distance;
}

/**
 * @export
 * @namespace OrderItemOption
 */
export namespace OrderItemOption {
    /**
     * @export
     * @enum {string}
     */
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}

/**
 * 
 * @export
 * @interface OrderItemOptionFileAttachment
 */
export interface OrderItemOptionFileAttachment {
    /**
     * Expiration date/time
     * @type {string}
     * @memberof OrderItemOptionFileAttachment
     */
    expirationDts?: string;
    /**
     * File name
     * @type {string}
     * @memberof OrderItemOptionFileAttachment
     */
    fileName?: string;
    /**
     * Mime type
     * @type {string}
     * @memberof OrderItemOptionFileAttachment
     */
    mimeType?: string;
    /**
     * Size
     * @type {number}
     * @memberof OrderItemOptionFileAttachment
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface OrderItemProperty
 */
export interface OrderItemProperty {
    /**
     * True if this property is displayed to the customer
     * @type {boolean}
     * @memberof OrderItemProperty
     */
    display?: boolean;
    /**
     * The date/time that the property expires and is deleted
     * @type {string}
     * @memberof OrderItemProperty
     */
    expirationDts?: string;
    /**
     * Name
     * @type {string}
     * @memberof OrderItemProperty
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof OrderItemProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface OrderItemTag
 */
export interface OrderItemTag {
    /**
     * Tag Value
     * @type {string}
     * @memberof OrderItemTag
     */
    tagValue?: string;
}

/**
 * 
 * @export
 * @interface OrderLinkedShipment
 */
export interface OrderLinkedShipment {
    /**
     * True if this order has child linked shipments
     * @type {boolean}
     * @memberof OrderLinkedShipment
     */
    hasLinkedShipment?: boolean;
    /**
     * True if this order is linked to another parent order
     * @type {boolean}
     * @memberof OrderLinkedShipment
     */
    linkedShipment?: boolean;
    /**
     * The child linked shipment channel partner order ids
     * @type {Array<string>}
     * @memberof OrderLinkedShipment
     */
    linkedShipmentChannelPartnerOrderIds?: Array<string>;
    /**
     * The child linked shipment order ids
     * @type {Array<string>}
     * @memberof OrderLinkedShipment
     */
    linkedShipmentOrderIds?: Array<string>;
    /**
     * The parent order id that this one is linked to
     * @type {string}
     * @memberof OrderLinkedShipment
     */
    linkedShipmentToOrderId?: string;
}

/**
 * 
 * @export
 * @interface OrderMarketing
 */
export interface OrderMarketing {
    /**
     * Advertising source
     * @type {string}
     * @memberof OrderMarketing
     */
    advertisingSource?: string;
    /**
     * True if the customer has opted into mailing list subscription
     * @type {boolean}
     * @memberof OrderMarketing
     */
    mailingList?: boolean;
    /**
     * Referral code
     * @type {string}
     * @memberof OrderMarketing
     */
    referralCode?: string;
}

/**
 * 
 * @export
 * @interface OrderPayment
 */
export interface OrderPayment {
    /**
     * 
     * @type {OrderPaymentCheck}
     * @memberof OrderPayment
     */
    check?: OrderPaymentCheck;
    /**
     * 
     * @type {OrderPaymentCreditCard}
     * @memberof OrderPayment
     */
    creditCard?: OrderPaymentCreditCard;
    /**
     * 
     * @type {OrderPaymentECheck}
     * @memberof OrderPayment
     */
    echeck?: OrderPaymentECheck;
    /**
     * True if order has been held for fraud review
     * @type {boolean}
     * @memberof OrderPayment
     */
    holdForFraudReview?: boolean;
    /**
     * Date/time that the payment was successfully processed, for new orders, this field is only considered if channel_partner.skip_payment_processing is true
     * @type {string}
     * @memberof OrderPayment
     */
    paymentDts?: string;
    /**
     * Payment method
     * @type {string}
     * @memberof OrderPayment
     */
    paymentMethod?: OrderPayment.PaymentMethodEnum;
    /**
     * Payment method QuickBooks code
     * @type {string}
     * @memberof OrderPayment
     */
    paymentMethodAccountingCode?: string;
    /**
     * Payment method QuickBooks deposit account
     * @type {string}
     * @memberof OrderPayment
     */
    paymentMethodDepositToAccount?: string;
    /**
     * Payment status
     * @type {string}
     * @memberof OrderPayment
     */
    paymentStatus?: OrderPayment.PaymentStatusEnum;
    /**
     * 
     * @type {OrderPaymentPurchaseOrder}
     * @memberof OrderPayment
     */
    purchaseOrder?: OrderPaymentPurchaseOrder;
    /**
     * Rotating transaction gateway code used to process this order
     * @type {string}
     * @memberof OrderPayment
     */
    rotatingTransactionGatewayCode?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderPayment
     */
    surcharge?: Currency;
    /**
     * Surcharge accounting code
     * @type {string}
     * @memberof OrderPayment
     */
    surchargeAccountingCode?: string;
    /**
     * Surcharge transaction fee
     * @type {number}
     * @memberof OrderPayment
     */
    surchargeTransactionFee?: number;
    /**
     * Surcharge transaction percentage
     * @type {number}
     * @memberof OrderPayment
     */
    surchargeTransactionPercentage?: number;
    /**
     * True if this is a test order
     * @type {boolean}
     * @memberof OrderPayment
     */
    testOrder?: boolean;
    /**
     * Transactions associated with processing this payment
     * @type {Array<OrderPaymentTransaction>}
     * @memberof OrderPayment
     */
    transactions?: Array<OrderPaymentTransaction>;
}

/**
 * @export
 * @namespace OrderPayment
 */
export namespace OrderPayment {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        EBay = <any> 'eBay',
        ECheck = <any> 'eCheck',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer',
        Walmart = <any> 'Walmart'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentStatusEnum {
        Unprocessed = <any> 'Unprocessed',
        Authorized = <any> 'Authorized',
        CaptureFailed = <any> 'Capture Failed',
        Processed = <any> 'Processed',
        Declined = <any> 'Declined',
        Voided = <any> 'Voided',
        Refunded = <any> 'Refunded',
        Skipped = <any> 'Skipped'
    }
}

/**
 * 
 * @export
 * @interface OrderPaymentCheck
 */
export interface OrderPaymentCheck {
    /**
     * Check number
     * @type {string}
     * @memberof OrderPaymentCheck
     */
    checkNumber?: string;
}

/**
 * 
 * @export
 * @interface OrderPaymentCreditCard
 */
export interface OrderPaymentCreditCard {
    /**
     * Card authorization ticket
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    cardAuthTicket?: string;
    /**
     * Card authorization amount
     * @type {number}
     * @memberof OrderPaymentCreditCard
     */
    cardAuthorizationAmount?: number;
    /**
     * Card authorization date/time
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    cardAuthorizationDts?: string;
    /**
     * Card authorization reference number
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    cardAuthorizationReferenceNumber?: string;
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof OrderPaymentCreditCard
     */
    cardExpirationMonth?: number;
    /**
     * Card expiration year (Four digit year)
     * @type {number}
     * @memberof OrderPaymentCreditCard
     */
    cardExpirationYear?: number;
    /**
     * Card number (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    cardNumber?: string;
    /**
     * Card number token from hosted fields used to update the cart number
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    cardNumberToken?: string;
    /**
     * True if the card has been truncated
     * @type {boolean}
     * @memberof OrderPaymentCreditCard
     */
    cardNumberTruncated?: boolean;
    /**
     * Card type
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    cardType?: OrderPaymentCreditCard.CardTypeEnum;
    /**
     * Card verification number token from hosted fields, only for import/insert of new orders, completely ignored for updates, and always null/empty for queries
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    cardVerificationNumberToken?: string;
}

/**
 * @export
 * @namespace OrderPaymentCreditCard
 */
export namespace OrderPaymentCreditCard {
    /**
     * @export
     * @enum {string}
     */
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        JCB = <any> 'JCB',
        MasterCard = <any> 'MasterCard',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface OrderPaymentECheck
 */
export interface OrderPaymentECheck {
    /**
     * Bank routing code
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bankAbaCode?: string;
    /**
     * Bank account name
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bankAccountName?: string;
    /**
     * Bank account number (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bankAccountNumber?: string;
    /**
     * Bank account type
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bankAccountType?: OrderPaymentECheck.BankAccountTypeEnum;
    /**
     * Bank name
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bankName?: string;
    /**
     * Bank owner type
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bankOwnerType?: OrderPaymentECheck.BankOwnerTypeEnum;
    /**
     * Customer tax id (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    customerTaxId?: string;
    /**
     * Driver license date of birth
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    driversLicenseDob?: string;
    /**
     * Driver license number (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    driversLicenseNumber?: string;
    /**
     * Driver license state
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    driversLicenseState?: string;
}

/**
 * @export
 * @namespace OrderPaymentECheck
 */
export namespace OrderPaymentECheck {
    /**
     * @export
     * @enum {string}
     */
    export enum BankAccountTypeEnum {
        Checking = <any> 'Checking',
        Savings = <any> 'Savings'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum BankOwnerTypeEnum {
        Personal = <any> 'Personal',
        Business = <any> 'Business'
    }
}

/**
 * 
 * @export
 * @interface OrderPaymentPurchaseOrder
 */
export interface OrderPaymentPurchaseOrder {
    /**
     * Purchase order number
     * @type {string}
     * @memberof OrderPaymentPurchaseOrder
     */
    purchaseOrderNumber?: string;
}

/**
 * 
 * @export
 * @interface OrderPaymentTransaction
 */
export interface OrderPaymentTransaction {
    /**
     * Details
     * @type {Array<OrderPaymentTransactionDetail>}
     * @memberof OrderPaymentTransaction
     */
    details?: Array<OrderPaymentTransactionDetail>;
    /**
     * True if the transaction was successful
     * @type {boolean}
     * @memberof OrderPaymentTransaction
     */
    successful?: boolean;
    /**
     * Transaction gateway
     * @type {string}
     * @memberof OrderPaymentTransaction
     */
    transactionGateway?: string;
    /**
     * Transaction date/time
     * @type {string}
     * @memberof OrderPaymentTransaction
     */
    transactionTimestamp?: string;
}

/**
 * 
 * @export
 * @interface OrderPaymentTransactionDetail
 */
export interface OrderPaymentTransactionDetail {
    /**
     * Name
     * @type {string}
     * @memberof OrderPaymentTransactionDetail
     */
    name?: string;
    /**
     * Type
     * @type {string}
     * @memberof OrderPaymentTransactionDetail
     */
    type?: string;
    /**
     * Value
     * @type {string}
     * @memberof OrderPaymentTransactionDetail
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface OrderProcessPaymentRequest
 */
export interface OrderProcessPaymentRequest {
    /**
     * Card verification number token from hosted fields used during credit card transaction processing (optional)
     * @type {string}
     * @memberof OrderProcessPaymentRequest
     */
    cardVerificationNumberToken?: string;
}

/**
 * 
 * @export
 * @interface OrderProcessPaymentResponse
 */
export interface OrderProcessPaymentResponse {
    /**
     * 
     * @type {Error}
     * @memberof OrderProcessPaymentResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrderProcessPaymentResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {OrderPaymentTransaction}
     * @memberof OrderProcessPaymentResponse
     */
    paymentTransaction?: OrderPaymentTransaction;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrderProcessPaymentResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrderProcessPaymentResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface OrderProperty
 */
export interface OrderProperty {
    /**
     * True if this property is displayed to the customer
     * @type {boolean}
     * @memberof OrderProperty
     */
    display?: boolean;
    /**
     * The date/time that the property expires and is deleted
     * @type {string}
     * @memberof OrderProperty
     */
    expirationDts?: string;
    /**
     * Name
     * @type {string}
     * @memberof OrderProperty
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof OrderProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface OrderQuery
 */
export interface OrderQuery {
    /**
     * CC Email
     * @type {string}
     * @memberof OrderQuery
     */
    ccEmail?: string;
    /**
     * The code of the channel partner
     * @type {string}
     * @memberof OrderQuery
     */
    channelPartnerCode?: string;
    /**
     * The order ID assigned by the channel partner for this order
     * @type {string}
     * @memberof OrderQuery
     */
    channelPartnerOrderId?: string;
    /**
     * City
     * @type {string}
     * @memberof OrderQuery
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof OrderQuery
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof OrderQuery
     */
    countryCode?: string;
    /**
     * Date/time that the order was created
     * @type {string}
     * @memberof OrderQuery
     */
    creationDateBegin?: string;
    /**
     * Date/time that the order was created
     * @type {string}
     * @memberof OrderQuery
     */
    creationDateEnd?: string;
    /**
     * Current stage that the order is in.
     * @type {string}
     * @memberof OrderQuery
     */
    currentStage?: OrderQuery.CurrentStageEnum;
    /**
     * The customer profile to find associated orders for
     * @type {number}
     * @memberof OrderQuery
     */
    customerProfileOid?: number;
    /**
     * Email
     * @type {string}
     * @memberof OrderQuery
     */
    email?: string;
    /**
     * First name
     * @type {string}
     * @memberof OrderQuery
     */
    firstName?: string;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderQuery
     */
    itemId?: string;
    /**
     * Last name
     * @type {string}
     * @memberof OrderQuery
     */
    lastName?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof OrderQuery
     */
    orderId?: string;
    /**
     * Date/time that the order was successfully processed
     * @type {string}
     * @memberof OrderQuery
     */
    paymentDateBegin?: string;
    /**
     * Date/time that the order was successfully processed
     * @type {string}
     * @memberof OrderQuery
     */
    paymentDateEnd?: string;
    /**
     * Payment method
     * @type {string}
     * @memberof OrderQuery
     */
    paymentMethod?: OrderQuery.PaymentMethodEnum;
    /**
     * Phone
     * @type {string}
     * @memberof OrderQuery
     */
    phone?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof OrderQuery
     */
    postalCode?: string;
    /**
     * Purchase order number
     * @type {string}
     * @memberof OrderQuery
     */
    purchaseOrderNumber?: string;
    /**
     * Date/time that the order was refunded
     * @type {string}
     * @memberof OrderQuery
     */
    refundDateBegin?: string;
    /**
     * Date/time that the order was refunded
     * @type {string}
     * @memberof OrderQuery
     */
    refundDateEnd?: string;
    /**
     * RMA number
     * @type {string}
     * @memberof OrderQuery
     */
    rma?: string;
    /**
     * Screen branding theme code associated with the order (legacy checkout)
     * @type {string}
     * @memberof OrderQuery
     */
    screenBrandingThemeCode?: string;
    /**
     * Date/time that the order was shipping
     * @type {string}
     * @memberof OrderQuery
     */
    shipmentDateBegin?: string;
    /**
     * Date/time that the order was shipped
     * @type {string}
     * @memberof OrderQuery
     */
    shipmentDateEnd?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof OrderQuery
     */
    stateRegion?: string;
    /**
     * StoreFront host name associated with the order
     * @type {string}
     * @memberof OrderQuery
     */
    storefrontHostName?: string;
    /**
     * Total
     * @type {number}
     * @memberof OrderQuery
     */
    total?: number;
}

/**
 * @export
 * @namespace OrderQuery
 */
export namespace OrderQuery {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        ECheck = <any> 'eCheck',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer'
    }
}

/**
 * 
 * @export
 * @interface OrderQueryBatch
 */
export interface OrderQueryBatch {
    /**
     * Order IDs
     * @type {Array<string>}
     * @memberof OrderQueryBatch
     */
    orderIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface OrderQuote
 */
export interface OrderQuote {
    /**
     * Expiration of quote at date/time
     * @type {string}
     * @memberof OrderQuote
     */
    quoteExpirationDts?: string;
    /**
     * Quoted by user
     * @type {string}
     * @memberof OrderQuote
     */
    quotedBy?: string;
    /**
     * Quoted on date/time
     * @type {string}
     * @memberof OrderQuote
     */
    quotedDts?: string;
}

/**
 * 
 * @export
 * @interface OrderReplacement
 */
export interface OrderReplacement {
    /**
     * Additional merchant notes to append to the new order
     * @type {string}
     * @memberof OrderReplacement
     */
    additionalMerchantNotesNewOrder?: string;
    /**
     * Additional merchant notes to append to the original order
     * @type {string}
     * @memberof OrderReplacement
     */
    additionalMerchantNotesOriginalOrder?: string;
    /**
     * Custom field 1
     * @type {string}
     * @memberof OrderReplacement
     */
    customField1?: string;
    /**
     * Custom field 2
     * @type {string}
     * @memberof OrderReplacement
     */
    customField2?: string;
    /**
     * Custom field 3
     * @type {string}
     * @memberof OrderReplacement
     */
    customField3?: string;
    /**
     * Custom field 4
     * @type {string}
     * @memberof OrderReplacement
     */
    customField4?: string;
    /**
     * Custom field 5
     * @type {string}
     * @memberof OrderReplacement
     */
    customField5?: string;
    /**
     * Custom field 6
     * @type {string}
     * @memberof OrderReplacement
     */
    customField6?: string;
    /**
     * Custom field 7
     * @type {string}
     * @memberof OrderReplacement
     */
    customField7?: string;
    /**
     * Set to true if this replacement shipment should be free for the customer.
     * @type {boolean}
     * @memberof OrderReplacement
     */
    free?: boolean;
    /**
     * Set to true if you want to immediately charge the payment on this order, otherwise it will go to Accounts Receivable.
     * @type {boolean}
     * @memberof OrderReplacement
     */
    immediateCharge?: boolean;
    /**
     * Items to include in the replacement order
     * @type {Array<OrderReplacementItem>}
     * @memberof OrderReplacement
     */
    items?: Array<OrderReplacementItem>;
    /**
     * Original order id
     * @type {string}
     * @memberof OrderReplacement
     */
    originalOrderId?: string;
    /**
     * Shipping method to use.  If not specified or invalid then least cost shipping will take place.
     * @type {string}
     * @memberof OrderReplacement
     */
    shippingMethod?: string;
    /**
     * Set to true if you want to skip the payment as if it was successful.
     * @type {boolean}
     * @memberof OrderReplacement
     */
    skipPayment?: boolean;
}

/**
 * 
 * @export
 * @interface OrderReplacementItem
 */
export interface OrderReplacementItem {
    /**
     * Cost to charge the customer if specified.  If not specified then the default item cost is used.
     * @type {number}
     * @memberof OrderReplacementItem
     */
    arbitraryUnitCost?: number;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderReplacementItem
     */
    merchantItemId?: string;
    /**
     * Quantity
     * @type {number}
     * @memberof OrderReplacementItem
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface OrderReplacementResponse
 */
export interface OrderReplacementResponse {
    /**
     * 
     * @type {boolean}
     * @memberof OrderReplacementResponse
     */
    chargeSuccessful?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderReplacementResponse
     */
    errorMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReplacementResponse
     */
    feedback?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderReplacementResponse
     */
    free?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderReplacementResponse
     */
    orderId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderReplacementResponse
     */
    successful?: boolean;
}

/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {Error}
     * @memberof OrderResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrderResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Order}
     * @memberof OrderResponse
     */
    order?: Order;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrderResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrderResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface OrderSalesforce
 */
export interface OrderSalesforce {
    /**
     * Salesforce.com opportunity id
     * @type {string}
     * @memberof OrderSalesforce
     */
    salesforceOpportunityId?: string;
}

/**
 * 
 * @export
 * @interface OrderShipping
 */
export interface OrderShipping {
    /**
     * Address line 1
     * @type {string}
     * @memberof OrderShipping
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof OrderShipping
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof OrderShipping
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof OrderShipping
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof OrderShipping
     */
    countryCode?: string;
    /**
     * Day time phone
     * @type {string}
     * @memberof OrderShipping
     */
    dayPhone?: string;
    /**
     * Day time phone (E164 format)
     * @type {string}
     * @memberof OrderShipping
     */
    dayPhoneE164?: string;
    /**
     * Date the customer is requesting delivery on.  Typically used for perishable product delivery.
     * @type {string}
     * @memberof OrderShipping
     */
    deliveryDate?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof OrderShipping
     */
    eveningPhone?: string;
    /**
     * First name
     * @type {string}
     * @memberof OrderShipping
     */
    firstName?: string;
    /**
     * Last name
     * @type {string}
     * @memberof OrderShipping
     */
    lastName?: string;
    /**
     * If true, instructs UltraCart to apply the cheapest shipping method to this order.  Used only for channel partner order inserts.
     * @type {boolean}
     * @memberof OrderShipping
     */
    leastCostRoute?: boolean;
    /**
     * List of shipping methods to consider if least_code_route is true. Used only for channel parter order inserts.
     * @type {Array<string>}
     * @memberof OrderShipping
     */
    leastCostRouteShippingMethods?: Array<string>;
    /**
     * Lift gate requested (LTL shipping methods only)
     * @type {boolean}
     * @memberof OrderShipping
     */
    liftGate?: boolean;
    /**
     * Postal code
     * @type {string}
     * @memberof OrderShipping
     */
    postalCode?: string;
    /**
     * RMA number
     * @type {string}
     * @memberof OrderShipping
     */
    rma?: string;
    /**
     * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
     * @type {string}
     * @memberof OrderShipping
     */
    shipOnDate?: string;
    /**
     * True if the shipping address is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
     * @type {boolean}
     * @memberof OrderShipping
     */
    shipToResidential?: boolean;
    /**
     * Shipping 3rd party account number
     * @type {string}
     * @memberof OrderShipping
     */
    shipping3rdPartyAccountNumber?: string;
    /**
     * Date/time the order shipped on.  This date is set once the first shipment is sent to the customer.
     * @type {string}
     * @memberof OrderShipping
     */
    shippingDate?: string;
    /**
     * Shipping department status
     * @type {string}
     * @memberof OrderShipping
     */
    shippingDepartmentStatus?: string;
    /**
     * Shipping method
     * @type {string}
     * @memberof OrderShipping
     */
    shippingMethod?: string;
    /**
     * Shipping method accounting code
     * @type {string}
     * @memberof OrderShipping
     */
    shippingMethodAccountingCode?: string;
    /**
     * Special instructions from the customer regarding shipping
     * @type {string}
     * @memberof OrderShipping
     */
    specialInstructions?: string;
    /**
     * State
     * @type {string}
     * @memberof OrderShipping
     */
    stateRegion?: string;
    /**
     * Title
     * @type {string}
     * @memberof OrderShipping
     */
    title?: string;
    /**
     * Tracking number details
     * @type {Array<OrderTrackingNumberDetails>}
     * @memberof OrderShipping
     */
    trackingNumberDetails?: Array<OrderTrackingNumberDetails>;
    /**
     * Tracking numbers
     * @type {Array<string>}
     * @memberof OrderShipping
     */
    trackingNumbers?: Array<string>;
    /**
     * 
     * @type {Weight}
     * @memberof OrderShipping
     */
    weight?: Weight;
}

/**
 * 
 * @export
 * @interface OrderSummary
 */
export interface OrderSummary {
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    actualFulfillment?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    actualShipping?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    arbitraryShippingHandlingTotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    otherRefunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    shippingHandlingRefunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    shippingHandlingTotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    shippingHandlingTotalDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotalDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotalDiscountRefunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotalRefunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    tax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    taxRefunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    taxableSubtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    taxableSubtotalDiscount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    total?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    totalRefunded?: Currency;
}

/**
 * 
 * @export
 * @interface OrderTag
 */
export interface OrderTag {
    /**
     * Tag Value
     * @type {string}
     * @memberof OrderTag
     */
    tagValue?: string;
}

/**
 * 
 * @export
 * @interface OrderTaxes
 */
export interface OrderTaxes {
    /**
     * Arbitrary Tax, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
     * @type {number}
     * @memberof OrderTaxes
     */
    arbitraryTax?: number;
    /**
     * Arbitrary tax rate, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
     * @type {number}
     * @memberof OrderTaxes
     */
    arbitraryTaxRate?: number;
    /**
     * Arbitrary taxable subtotal, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
     * @type {number}
     * @memberof OrderTaxes
     */
    arbitraryTaxableSubtotal?: number;
    /**
     * QuickBooks tax city code
     * @type {string}
     * @memberof OrderTaxes
     */
    taxCityAccountingCode?: string;
    /**
     * QuickBooks tax country code
     * @type {string}
     * @memberof OrderTaxes
     */
    taxCountryAccountingCode?: string;
    /**
     * County used for tax calculation purposes (only in the United States)
     * @type {string}
     * @memberof OrderTaxes
     */
    taxCounty?: string;
    /**
     * QuickBooks tax county code
     * @type {string}
     * @memberof OrderTaxes
     */
    taxCountyAccountingCode?: string;
    /**
     * True if gift charge is taxed
     * @type {boolean}
     * @memberof OrderTaxes
     */
    taxGiftCharge?: boolean;
    /**
     * QuickBooks tax postal code code
     * @type {string}
     * @memberof OrderTaxes
     */
    taxPostalCodeAccountingCode?: string;
    /**
     * Tax rate, this is meaningless for updating an order.  For inserting a new order, if you need to override internal tax calculations, use the arbitrary fields.
     * @type {number}
     * @memberof OrderTaxes
     */
    taxRate?: number;
    /**
     * Tax rate at the city level
     * @type {number}
     * @memberof OrderTaxes
     */
    taxRateCity?: number;
    /**
     * Tax rate at the country level
     * @type {number}
     * @memberof OrderTaxes
     */
    taxRateCountry?: number;
    /**
     * Tax rate at the county level
     * @type {number}
     * @memberof OrderTaxes
     */
    taxRateCounty?: number;
    /**
     * Tax rate at the postal code level
     * @type {number}
     * @memberof OrderTaxes
     */
    taxRatePostalCode?: number;
    /**
     * Tax rate at the state level
     * @type {number}
     * @memberof OrderTaxes
     */
    taxRateState?: number;
    /**
     * True if shipping is taxed
     * @type {boolean}
     * @memberof OrderTaxes
     */
    taxShipping?: boolean;
    /**
     * QuickBooks tax state code
     * @type {string}
     * @memberof OrderTaxes
     */
    taxStateAccountingCode?: string;
}

/**
 * 
 * @export
 * @interface OrderTokenResponse
 */
export interface OrderTokenResponse {
    /**
     * 
     * @type {Error}
     * @memberof OrderTokenResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrderTokenResponse
     */
    metadata?: ResponseMetadata;
    /**
     * An order token that securely represents an order id
     * @type {string}
     * @memberof OrderTokenResponse
     */
    orderToken?: string;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrderTokenResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrderTokenResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface OrderTrackingNumberDetail
 */
export interface OrderTrackingNumberDetail {
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    eventLocalDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    eventLocalTime?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    subtag?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    subtagMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    tagDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    tagIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface OrderTrackingNumberDetails
 */
export interface OrderTrackingNumberDetails {
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    actualDeliveryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    actualDeliveryDateFormatted?: string;
    /**
     * 
     * @type {Array<OrderTrackingNumberDetail>}
     * @memberof OrderTrackingNumberDetails
     */
    details?: Array<OrderTrackingNumberDetail>;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    expectedDeliveryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    expectedDeliveryDateFormatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    mapUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    orderPlacedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    orderPlacedDateFormatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    paymentProcessedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    paymentProcessedDateFormatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    shippedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    shippedDateFormatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    shippingMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    statusDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    trackingNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    trackingUrl?: string;
}

/**
 * 
 * @export
 * @interface OrdersResponse
 */
export interface OrdersResponse {
    /**
     * 
     * @type {Error}
     * @memberof OrdersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrdersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * orders
     * @type {Array<Order>}
     * @memberof OrdersResponse
     */
    orders?: Array<Order>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrdersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrdersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * A group for this permission.  This name is only used for visual grouping within interfaces.
     * @type {string}
     * @memberof Permission
     */
    permissionGroup?: string;
    /**
     * The name of this permission.
     * @type {string}
     * @memberof Permission
     */
    permissionName?: string;
    /**
     * True if this user has this permission.
     * @type {boolean}
     * @memberof Permission
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface PricingTier
 */
export interface PricingTier {
    /**
     * Allow 3rd party billing
     * @type {boolean}
     * @memberof PricingTier
     */
    allow3rdPartyBilling?: boolean;
    /**
     * Allow COD
     * @type {boolean}
     * @memberof PricingTier
     */
    allowCod?: boolean;
    /**
     * Allow purchase order
     * @type {boolean}
     * @memberof PricingTier
     */
    allowPurchaseOrder?: boolean;
    /**
     * Allow quote request
     * @type {boolean}
     * @memberof PricingTier
     */
    allowQuoteRequest?: boolean;
    /**
     * 
     * @type {PricingTierNotification}
     * @memberof PricingTier
     */
    approvalNotification?: PricingTierNotification;
    /**
     * Auto approve COD
     * @type {boolean}
     * @memberof PricingTier
     */
    autoApproveCod?: boolean;
    /**
     * Auto approve purchase order
     * @type {boolean}
     * @memberof PricingTier
     */
    autoApprovePurchaseOrder?: boolean;
    /**
     * Default on wholesale signup
     * @type {boolean}
     * @memberof PricingTier
     */
    defaultOnWholesaleSignup?: boolean;
    /**
     * Default percentage discount
     * @type {number}
     * @memberof PricingTier
     */
    defaultPercentageDiscount?: number;
    /**
     * Default shipping method oid
     * @type {number}
     * @memberof PricingTier
     */
    defaultShippingMethodOid?: number;
    /**
     * Default tier
     * @type {boolean}
     * @memberof PricingTier
     */
    defaultTier?: boolean;
    /**
     * Display on wholesale signup
     * @type {boolean}
     * @memberof PricingTier
     */
    displayOnWholesaleSignup?: boolean;
    /**
     * Exclude from free promotion
     * @type {boolean}
     * @memberof PricingTier
     */
    excludeFromFreePromotion?: boolean;
    /**
     * Exempt shipping handling charge
     * @type {boolean}
     * @memberof PricingTier
     */
    exemptShippingHandlingCharge?: boolean;
    /**
     * Free shipping
     * @type {boolean}
     * @memberof PricingTier
     */
    freeShipping?: boolean;
    /**
     * Free shipping minimum
     * @type {number}
     * @memberof PricingTier
     */
    freeShippingMinimum?: number;
    /**
     * Maximum item count
     * @type {number}
     * @memberof PricingTier
     */
    maximumItemCount?: number;
    /**
     * Minimum item count
     * @type {number}
     * @memberof PricingTier
     */
    minimumItemCount?: number;
    /**
     * Minimum subtotal
     * @type {number}
     * @memberof PricingTier
     */
    minimumSubtotal?: number;
    /**
     * Name
     * @type {string}
     * @memberof PricingTier
     */
    name?: string;
    /**
     * No coupons
     * @type {boolean}
     * @memberof PricingTier
     */
    noCoupons?: boolean;
    /**
     * No free shipping
     * @type {boolean}
     * @memberof PricingTier
     */
    noFreeShipping?: boolean;
    /**
     * No realtime charge
     * @type {boolean}
     * @memberof PricingTier
     */
    noRealtimeCharge?: boolean;
    /**
     * Not valid when coupon present
     * @type {boolean}
     * @memberof PricingTier
     */
    notValidWhenCouponPresent?: boolean;
    /**
     * Pricing Tier Oid
     * @type {number}
     * @memberof PricingTier
     */
    pricingTierOid?: number;
    /**
     * Realtime percentage discount
     * @type {number}
     * @memberof PricingTier
     */
    realtimePercentageDiscount?: number;
    /**
     * 
     * @type {PricingTierNotification}
     * @memberof PricingTier
     */
    signupNotification?: PricingTierNotification;
    /**
     * Suppress buySAFE (deprecated)
     * @type {boolean}
     * @memberof PricingTier
     */
    suppressBuysafe?: boolean;
    /**
     * Suppress mailing list
     * @type {boolean}
     * @memberof PricingTier
     */
    suppressMailingList?: boolean;
    /**
     * Tax Exempt
     * @type {boolean}
     * @memberof PricingTier
     */
    taxExempt?: boolean;
    /**
     * Track separately
     * @type {boolean}
     * @memberof PricingTier
     */
    trackSeparately?: boolean;
}

/**
 * 
 * @export
 * @interface PricingTierNotification
 */
export interface PricingTierNotification {
    /**
     * Notification format
     * @type {string}
     * @memberof PricingTierNotification
     */
    format?: string;
    /**
     * Notification subject
     * @type {string}
     * @memberof PricingTierNotification
     */
    subject?: string;
    /**
     * Notification text
     * @type {string}
     * @memberof PricingTierNotification
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface PricingTiersResponse
 */
export interface PricingTiersResponse {
    /**
     * 
     * @type {Error}
     * @memberof PricingTiersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof PricingTiersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * pricing_tiers
     * @type {Array<PricingTier>}
     * @memberof PricingTiersResponse
     */
    pricingTiers?: Array<PricingTier>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof PricingTiersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof PricingTiersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface RegisterAffiliateClickRequest
 */
export interface RegisterAffiliateClickRequest {
    /**
     * Affiliate Id (must be specified if landing_page_url is not)
     * @type {number}
     * @memberof RegisterAffiliateClickRequest
     */
    affid?: number;
    /**
     * IP Address (must be specified for non-browser key authenticated)
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    ipAddress?: string;
    /**
     * Landing Page URL
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    landingPageUrl?: string;
    /**
     * Referrer URL (used for detecting invisible linking)
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    referrerUrl?: string;
    /**
     * Sub Id (optional value if affid is specified.
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    subid?: string;
    /**
     * User agent of the browser (must be specified for non-browser key authenticated)
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    userAgent?: string;
}

/**
 * 
 * @export
 * @interface RegisterAffiliateClickResponse
 */
export interface RegisterAffiliateClickResponse {
    /**
     * The cookie max age to use
     * @type {number}
     * @memberof RegisterAffiliateClickResponse
     */
    cookieMaxAge?: number;
    /**
     * The names of all the cookies to set on the browser
     * @type {Array<string>}
     * @memberof RegisterAffiliateClickResponse
     */
    cookieNames?: Array<string>;
    /**
     * The values of all the cookies to set on the browser
     * @type {Array<string>}
     * @memberof RegisterAffiliateClickResponse
     */
    cookieValues?: Array<string>;
    /**
     * True if a click was registered
     * @type {boolean}
     * @memberof RegisterAffiliateClickResponse
     */
    registered?: boolean;
}

/**
 * 
 * @export
 * @interface ResponseMetadata
 */
export interface ResponseMetadata {
    /**
     * Payload name
     * @type {string}
     * @memberof ResponseMetadata
     */
    payloadName?: string;
    /**
     * 
     * @type {ResultSet}
     * @memberof ResponseMetadata
     */
    resultSet?: ResultSet;
}

/**
 * 
 * @export
 * @interface ResultSet
 */
export interface ResultSet {
    /**
     * Number of results in this set
     * @type {number}
     * @memberof ResultSet
     */
    count?: number;
    /**
     * Maximum number of results that can be returned in a set
     * @type {number}
     * @memberof ResultSet
     */
    limit?: number;
    /**
     * True if there are more results to query
     * @type {boolean}
     * @memberof ResultSet
     */
    more?: boolean;
    /**
     * The next offset that you should query to retrieve more results
     * @type {number}
     * @memberof ResultSet
     */
    nextOffset?: number;
    /**
     * Offset of this result set (zero based)
     * @type {number}
     * @memberof ResultSet
     */
    offset?: number;
    /**
     * The total number of records in the result set.  May be null if the number is not known and the client should continue iterating as long as more is true.
     * @type {number}
     * @memberof ResultSet
     */
    totalRecords?: number;
}

/**
 * 
 * @export
 * @interface ScreenshotsResponse
 */
export interface ScreenshotsResponse {
    /**
     * 
     * @type {Error}
     * @memberof ScreenshotsResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenshotsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * List of screenshot urls related to the object (depends on which method was called).
     * @type {Array<string>}
     * @memberof ScreenshotsResponse
     */
    screenshots?: Array<string>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenshotsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenshotsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface SelfConfig
 */
export interface SelfConfig {
    /**
     * True if sales tax should be collected based on billing address instead of shipping address
     * @type {boolean}
     * @memberof SelfConfig
     */
    taxBilling?: boolean;
}

/**
 * 
 * @export
 * @interface SovosConfig
 */
export interface SovosConfig {
    /**
     * Sovos access key
     * @type {string}
     * @memberof SovosConfig
     */
    accessKey?: string;
    /**
     * True if this Sovos configuration is to estimate taxes only and not report placed orders to Sovos
     * @type {boolean}
     * @memberof SovosConfig
     */
    estimateOnly?: boolean;
    /**
     * Date/time of the connection test to Sovos
     * @type {string}
     * @memberof SovosConfig
     */
    lastTestDts?: string;
    /**
     * Sovos secret key
     * @type {string}
     * @memberof SovosConfig
     */
    secretKey?: string;
    /**
     * Send test orders through to Sovos.  The default is to not transmit test orders to Sovos.
     * @type {boolean}
     * @memberof SovosConfig
     */
    sendTestOrders?: boolean;
    /**
     * Test results of the last connection test to Sovos
     * @type {string}
     * @memberof SovosConfig
     */
    testResults?: string;
    /**
     * True if this Sovos configuration is currently undergoing user acceptance testing
     * @type {boolean}
     * @memberof SovosConfig
     */
    uat?: boolean;
}

/**
 * 
 * @export
 * @interface StateProvince
 */
export interface StateProvince {
    /**
     * abbreviation
     * @type {string}
     * @memberof StateProvince
     */
    abbreviation?: string;
    /**
     * name
     * @type {string}
     * @memberof StateProvince
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface StepWaiting
 */
export interface StepWaiting {
    /**
     * 
     * @type {string}
     * @memberof StepWaiting
     */
    commseqStepUuid?: string;
    /**
     * 
     * @type {number}
     * @memberof StepWaiting
     */
    numberWaiting?: number;
}

/**
 * 
 * @export
 * @interface TaxCity
 */
export interface TaxCity {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCity
     */
    accountingCode?: string;
    /**
     * City
     * @type {string}
     * @memberof TaxCity
     */
    city?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCity
     */
    cityOid?: number;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCity
     */
    countyOid?: number;
    /**
     * Flag instructing engine to not collect city tax for this city
     * @type {boolean}
     * @memberof TaxCity
     */
    dontCollectCity?: boolean;
    /**
     * Flag instructing engine to not collect postal code tax for this city
     * @type {boolean}
     * @memberof TaxCity
     */
    dontCollectPostalCode?: boolean;
    /**
     * Postal Codes within this city
     * @type {Array<TaxPostalCode>}
     * @memberof TaxCity
     */
    postalCodes?: Array<TaxPostalCode>;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCity
     */
    taxRate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCity
     */
    taxRateFormatted?: string;
}

/**
 * 
 * @export
 * @interface TaxCountry
 */
export interface TaxCountry {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCountry
     */
    accountingCode?: string;
    /**
     * Country code (2 characters
     * @type {string}
     * @memberof TaxCountry
     */
    countryCode?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCountry
     */
    countryOid?: number;
    /**
     * States (or regions or territories) within this country
     * @type {Array<TaxState>}
     * @memberof TaxCountry
     */
    states?: Array<TaxState>;
    /**
     * True if taxation within this jurisdiction should charge tax on gift charge
     * @type {boolean}
     * @memberof TaxCountry
     */
    taxGiftCharge?: boolean;
    /**
     * True if taxation within this jurisdiction should charge tax on gift wrap
     * @type {boolean}
     * @memberof TaxCountry
     */
    taxGiftWrap?: boolean;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCountry
     */
    taxRate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCountry
     */
    taxRateFormatted?: string;
    /**
     * True if taxation within this jurisdiction should charge tax on shipping
     * @type {boolean}
     * @memberof TaxCountry
     */
    taxShipping?: boolean;
}

/**
 * 
 * @export
 * @interface TaxCountryCode
 */
export interface TaxCountryCode {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCountryCode
     */
    accountingCode?: string;
    /**
     * Country code (2 characters
     * @type {string}
     * @memberof TaxCountryCode
     */
    countryCode?: string;
    /**
     * Country name
     * @type {string}
     * @memberof TaxCountryCode
     */
    countryName?: string;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCountryCode
     */
    taxRate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCountryCode
     */
    taxRateFormatted?: string;
}

/**
 * 
 * @export
 * @interface TaxCounty
 */
export interface TaxCounty {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCounty
     */
    accountingCode?: string;
    /**
     * Cities within this city
     * @type {Array<TaxCity>}
     * @memberof TaxCounty
     */
    cities?: Array<TaxCity>;
    /**
     * County
     * @type {string}
     * @memberof TaxCounty
     */
    county?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCounty
     */
    countyOid?: number;
    /**
     * Flag instructing engine to not collect city tax for this county
     * @type {boolean}
     * @memberof TaxCounty
     */
    dontCollectCity?: boolean;
    /**
     * Flag instructing engine to not collect county tax for this county
     * @type {boolean}
     * @memberof TaxCounty
     */
    dontCollectCounty?: boolean;
    /**
     * Flag instructing engine to not collect postal code tax for this county
     * @type {boolean}
     * @memberof TaxCounty
     */
    dontCollectPostalCode?: boolean;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCounty
     */
    stateOid?: number;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCounty
     */
    taxRate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCounty
     */
    taxRateFormatted?: string;
}

/**
 * 
 * @export
 * @interface TaxJarConfig
 */
export interface TaxJarConfig {
    /**
     * True if TaxJar is active for this merchant
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    active?: boolean;
    /**
     * TaxJar API key
     * @type {string}
     * @memberof TaxJarConfig
     */
    apiKey?: string;
    /**
     * True if this TaxJar configuration is to estimate taxes only and not report placed orders to TaxJar
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    estimateOnly?: boolean;
    /**
     * Send orders outside your nexus TaxJar.  The default is to not transmit outside orders to TaxJar to reduce API calls.  However, this will prevent TaxJar from dynamically creating new Nexus when thresholds are exceeded for a state.
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    sendOutsideNexus?: boolean;
    /**
     * Send test orders through to TaxJar.  The default is to not transmit test orders to TaxJar.
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    sendTestOrders?: boolean;
    /**
     * Use distribution center from address
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    useDistributionCenterFrom?: boolean;
}

/**
 * 
 * @export
 * @interface TaxPostalCode
 */
export interface TaxPostalCode {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxPostalCode
     */
    accountingCode?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxPostalCode
     */
    cityOid?: number;
    /**
     * Flag instructing engine to not collect postal code tax for this postal code
     * @type {boolean}
     * @memberof TaxPostalCode
     */
    dontCollectPostalCode?: boolean;
    /**
     * Postal Code (5 digits)
     * @type {string}
     * @memberof TaxPostalCode
     */
    postalCode?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxPostalCode
     */
    postalCodeOid?: number;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxPostalCode
     */
    taxRate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxPostalCode
     */
    taxRateFormatted?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderActivateResult
 */
export interface TaxProviderActivateResult {
    /**
     * 
     * @type {string}
     * @memberof TaxProviderActivateResult
     */
    details?: string;
    /**
     * True if the connection was successful
     * @type {boolean}
     * @memberof TaxProviderActivateResult
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface TaxProviderAvalara
 */
export interface TaxProviderAvalara {
    /**
     * 
     * @type {AvalaraConfig}
     * @memberof TaxProviderAvalara
     */
    configuration?: AvalaraConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderAvalara
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderAvalara
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderAvalara
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderAvalaraCompaniesResult
 */
export interface TaxProviderAvalaraCompaniesResult {
    /**
     * Tax companies configured by the merchant
     * @type {Array<TaxProviderAvalaraCompany>}
     * @memberof TaxProviderAvalaraCompaniesResult
     */
    companies?: Array<TaxProviderAvalaraCompany>;
}

/**
 * 
 * @export
 * @interface TaxProviderAvalaraCompany
 */
export interface TaxProviderAvalaraCompany {
    /**
     * Company code
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    companyCode?: string;
    /**
     * Company name
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    companyName?: string;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderAvalaraCompany
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderSelf
 */
export interface TaxProviderSelf {
    /**
     * 
     * @type {SelfConfig}
     * @memberof TaxProviderSelf
     */
    configuration?: SelfConfig;
    /**
     * Countries that collect sales tax
     * @type {Array<TaxCountry>}
     * @memberof TaxProviderSelf
     */
    countries?: Array<TaxCountry>;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderSelf
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderSelf
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderSelf
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderSelfCountriesResponse
 */
export interface TaxProviderSelfCountriesResponse {
    /**
     * countries
     * @type {Array<TaxCountryCode>}
     * @memberof TaxProviderSelfCountriesResponse
     */
    countries?: Array<TaxCountryCode>;
}

/**
 * 
 * @export
 * @interface TaxProviderSelfRegionsResponse
 */
export interface TaxProviderSelfRegionsResponse {
    /**
     * regions
     * @type {Array<TaxStateCode>}
     * @memberof TaxProviderSelfRegionsResponse
     */
    regions?: Array<TaxStateCode>;
}

/**
 * 
 * @export
 * @interface TaxProviderSovos
 */
export interface TaxProviderSovos {
    /**
     * 
     * @type {SovosConfig}
     * @memberof TaxProviderSovos
     */
    configuration?: SovosConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderSovos
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderSovos
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderSovos
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderTaxJar
 */
export interface TaxProviderTaxJar {
    /**
     * 
     * @type {TaxJarConfig}
     * @memberof TaxProviderTaxJar
     */
    configuration?: TaxJarConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderTaxJar
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderTaxJar
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderTaxJar
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderTestResult
 */
export interface TaxProviderTestResult {
    /**
     * 
     * @type {string}
     * @memberof TaxProviderTestResult
     */
    details?: string;
    /**
     * True if the connection was successful
     * @type {boolean}
     * @memberof TaxProviderTestResult
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface TaxProviderUltraCart
 */
export interface TaxProviderUltraCart {
    /**
     * 
     * @type {UltraCartConfig}
     * @memberof TaxProviderUltraCart
     */
    configuration?: UltraCartConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderUltraCart
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderUltraCart
     */
    selected?: boolean;
    /**
     * States in the union showing their management status
     * @type {Array<TaxProviderUltraCartState>}
     * @memberof TaxProviderUltraCart
     */
    states?: Array<TaxProviderUltraCartState>;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderUltraCart
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderUltraCartState
 */
export interface TaxProviderUltraCartState {
    /**
     * True if this state taxes are managed by UltraCart
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    enabled?: boolean;
    /**
     * State Code (2 digits)
     * @type {string}
     * @memberof TaxProviderUltraCartState
     */
    stateCode?: string;
    /**
     * Fully spelled out state name
     * @type {string}
     * @memberof TaxProviderUltraCartState
     */
    stateName?: string;
    /**
     * True if gift charges should be taxed in this state.
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    taxGiftCharge?: boolean;
    /**
     * True if gift wrap should be taxed in this state.
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    taxGiftWrap?: boolean;
    /**
     * State tax rate formatted for display
     * @type {string}
     * @memberof TaxProviderUltraCartState
     */
    taxRateFormatted?: string;
    /**
     * True if shipping should be taxed in this state.
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    taxShipping?: boolean;
}

/**
 * 
 * @export
 * @interface TaxProvidersResponse
 */
export interface TaxProvidersResponse {
    /**
     * 
     * @type {TaxProviderAvalara}
     * @memberof TaxProvidersResponse
     */
    avalara?: TaxProviderAvalara;
    /**
     * 
     * @type {Error}
     * @memberof TaxProvidersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TaxProvidersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {TaxProviderSelf}
     * @memberof TaxProvidersResponse
     */
    self?: TaxProviderSelf;
    /**
     * 
     * @type {TaxProviderSovos}
     * @memberof TaxProvidersResponse
     */
    sovos?: TaxProviderSovos;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TaxProvidersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {TaxProviderTaxJar}
     * @memberof TaxProvidersResponse
     */
    taxjar?: TaxProviderTaxJar;
    /**
     * 
     * @type {TaxProviderUltraCart}
     * @memberof TaxProvidersResponse
     */
    ultracart?: TaxProviderUltraCart;
    /**
     * 
     * @type {Warning}
     * @memberof TaxProvidersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TaxState
 */
export interface TaxState {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxState
     */
    accountingCode?: string;
    /**
     * Counties within this state
     * @type {Array<TaxCounty>}
     * @memberof TaxState
     */
    counties?: Array<TaxCounty>;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxState
     */
    countryOid?: number;
    /**
     * Flag instructing engine to not collect city tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dontCollectCity?: boolean;
    /**
     * Flag instructing engine to not collect county tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dontCollectCounty?: boolean;
    /**
     * Flag instructing engine to not collect postal code tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dontCollectPostalCode?: boolean;
    /**
     * Flag instructing engine to not collect state tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dontCollectState?: boolean;
    /**
     * State code
     * @type {string}
     * @memberof TaxState
     */
    stateCode?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxState
     */
    stateOid?: number;
    /**
     * True if taxation within this jurisdiction should charge tax on gift charge
     * @type {boolean}
     * @memberof TaxState
     */
    taxGiftCharge?: boolean;
    /**
     * True if taxation within this jurisdiction should charge tax on gift wrap
     * @type {boolean}
     * @memberof TaxState
     */
    taxGiftWrap?: boolean;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxState
     */
    taxRate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxState
     */
    taxRateFormatted?: string;
    /**
     * True if taxation within this jurisdiction should charge tax on shipping
     * @type {boolean}
     * @memberof TaxState
     */
    taxShipping?: boolean;
    /**
     * If true, use UltraCart managed rates for this state
     * @type {boolean}
     * @memberof TaxState
     */
    useUltracartManagedRates?: boolean;
}

/**
 * 
 * @export
 * @interface TaxStateCode
 */
export interface TaxStateCode {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxStateCode
     */
    accountingCode?: string;
    /**
     * State code (2 characters
     * @type {string}
     * @memberof TaxStateCode
     */
    stateCode?: string;
    /**
     * State name
     * @type {string}
     * @memberof TaxStateCode
     */
    stateName?: string;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxStateCode
     */
    taxRate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxStateCode
     */
    taxRateFormatted?: string;
}

/**
 * 
 * @export
 * @interface TempMultimedia
 */
export interface TempMultimedia {
    /**
     * Filename
     * @type {string}
     * @memberof TempMultimedia
     */
    filename?: string;
    /**
     * Height
     * @type {number}
     * @memberof TempMultimedia
     */
    height?: number;
    /**
     * Multimedia type
     * @type {string}
     * @memberof TempMultimedia
     */
    multimediaType?: TempMultimedia.MultimediaTypeEnum;
    /**
     * Size
     * @type {number}
     * @memberof TempMultimedia
     */
    size?: number;
    /**
     * Temporary multimedia object identifier
     * @type {number}
     * @memberof TempMultimedia
     */
    tempMultimediaOid?: number;
    /**
     * URL
     * @type {string}
     * @memberof TempMultimedia
     */
    url?: string;
    /**
     * Width
     * @type {number}
     * @memberof TempMultimedia
     */
    width?: number;
}

/**
 * @export
 * @namespace TempMultimedia
 */
export namespace TempMultimedia {
    /**
     * @export
     * @enum {string}
     */
    export enum MultimediaTypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Video = <any> 'Video'
    }
}

/**
 * 
 * @export
 * @interface TempMultimediaResponse
 */
export interface TempMultimediaResponse {
    /**
     * 
     * @type {Error}
     * @memberof TempMultimediaResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TempMultimediaResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TempMultimediaResponse
     */
    success?: boolean;
    /**
     * 
     * @type {TempMultimedia}
     * @memberof TempMultimediaResponse
     */
    tempMultimedia?: TempMultimedia;
    /**
     * 
     * @type {Warning}
     * @memberof TempMultimediaResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ThumbnailParametersRequest
 */
export interface ThumbnailParametersRequest {
    /**
     * 
     * @type {number}
     * @memberof ThumbnailParametersRequest
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailParametersRequest
     */
    pngFormat?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailParametersRequest
     */
    squareThumbnail?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailParametersRequest
     */
    webp?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ThumbnailParametersRequest
     */
    width?: number;
}

/**
 * 
 * @export
 * @interface ThumbnailParametersResponse
 */
export interface ThumbnailParametersResponse {
    /**
     * 
     * @type {Error}
     * @memberof ThumbnailParametersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ThumbnailParametersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ThumbnailParametersResponse
     */
    success?: boolean;
    /**
     * Suffix to append to the larger image URL to obtain the thumbnail
     * @type {string}
     * @memberof ThumbnailParametersResponse
     */
    thumbnailUrlSuffix?: string;
    /**
     * 
     * @type {Warning}
     * @memberof ThumbnailParametersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TransactionEmail
 */
export interface TransactionEmail {
    /**
     * Actual template contents
     * @type {string}
     * @memberof TransactionEmail
     */
    content?: string;
    /**
     * The uuid of the sending domain
     * @type {string}
     * @memberof TransactionEmail
     */
    espDomainUuid?: string;
    /**
     * Friendly from that will appear in customer email clients.
     * @type {string}
     * @memberof TransactionEmail
     */
    espFriendlyName?: string;
    /**
     * The username of the sending email.  This is not the full email.  Only the username which is everything before the @ sign.
     * @type {string}
     * @memberof TransactionEmail
     */
    espUser?: string;
    /**
     * An internal identifier used to aid in retrieving templates from the filesystem.
     * @type {boolean}
     * @memberof TransactionEmail
     */
    fileExists?: boolean;
    /**
     * File name
     * @type {string}
     * @memberof TransactionEmail
     */
    fileName?: string;
    /**
     * Group
     * @type {string}
     * @memberof TransactionEmail
     */
    group?: string;
    /**
     * Handlebar Variables available for email template
     * @type {Array<string>}
     * @memberof TransactionEmail
     */
    handlebarVariables?: Array<string>;
    /**
     * Invalid will be true if the template cannot compile
     * @type {boolean}
     * @memberof TransactionEmail
     */
    invalid?: boolean;
    /**
     * Last modified timestamp
     * @type {string}
     * @memberof TransactionEmail
     */
    lastModified?: string;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof TransactionEmail
     */
    libraryItemOid?: number;
    /**
     * Options that help govern how and when this template is used
     * @type {Array<TransactionEmailOption>}
     * @memberof TransactionEmail
     */
    options?: Array<TransactionEmailOption>;
    /**
     * directory path where template is stored in file system
     * @type {string}
     * @memberof TransactionEmail
     */
    path?: string;
    /**
     * Size of file in friendly description
     * @type {string}
     * @memberof TransactionEmail
     */
    size?: string;
    /**
     * Internal identifier used to store and retrieve template from filesystem
     * @type {number}
     * @memberof TransactionEmail
     */
    storeFrontFsDirectoryOid?: number;
    /**
     * Internal identifier used to store and retrieve template from filesystem
     * @type {number}
     * @memberof TransactionEmail
     */
    storeFrontFsFileOid?: number;
    /**
     * Subject
     * @type {string}
     * @memberof TransactionEmail
     */
    subject?: string;
    /**
     * Any syntax errors contained within the tempalate
     * @type {string}
     * @memberof TransactionEmail
     */
    syntaxErrors?: string;
    /**
     * Internal value used to locate the template in the filesystem
     * @type {string}
     * @memberof TransactionEmail
     */
    templatePathRelativePath?: string;
    /**
     * Theme relative path in the filesystem.
     * @type {string}
     * @memberof TransactionEmail
     */
    themeRelativePath?: string;
}

/**
 * 
 * @export
 * @interface TransactionEmailListResponse
 */
export interface TransactionEmailListResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionEmailListResponse
     */
    emailNames?: Array<string>;
    /**
     * 
     * @type {Error}
     * @memberof TransactionEmailListResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TransactionEmailListResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TransactionEmailListResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof TransactionEmailListResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TransactionEmailOption
 */
export interface TransactionEmailOption {
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionEmailOption
     */
    merchantEmailDeliveryOptionOid?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    merchantId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionEmailOption
     */
    selected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionEmailOption
     */
    storeFrontOid?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    templateDisplay?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    templateType?: string;
}

/**
 * 
 * @export
 * @interface TransactionEmailResponse
 */
export interface TransactionEmailResponse {
    /**
     * 
     * @type {TransactionEmail}
     * @memberof TransactionEmailResponse
     */
    email?: TransactionEmail;
    /**
     * 
     * @type {Error}
     * @memberof TransactionEmailResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TransactionEmailResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TransactionEmailResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof TransactionEmailResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface UltraCartConfig
 */
export interface UltraCartConfig {
    /**
     * True if sales tax should be collected based on billing address instead of shipping address
     * @type {boolean}
     * @memberof UltraCartConfig
     */
    taxBilling?: boolean;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * A list of IP addresses whitelisted for any user with API Access permission.  Without this list, each ip address must be authenticated by a user, which can be a pain for some servers.
     * @type {Array<string>}
     * @memberof User
     */
    apiIpAddressMasks?: Array<string>;
    /**
     * Supply a new FTP password using this field.  Password are stored using one-way encryption, so they are never available anywhere in the system.  The FTP password cannot be the same as the normal password.
     * @type {string}
     * @memberof User
     */
    changeFtpPasswordTo?: string;
    /**
     * Supply a new password using this field.  Password are stored using one-way encryption, so they are never available anywhere in the system.
     * @type {string}
     * @memberof User
     */
    changePasswordTo?: string;
    /**
     * Email address of user
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Full name of user.  This is used solely for human assistance and so the UltraCart staff knows who they are calling when there is a problem.
     * @type {string}
     * @memberof User
     */
    fullName?: string;
    /**
     * A list of groups for this merchant and whether or not this user is a member of those groups.
     * @type {Array<UserGroupMembership>}
     * @memberof User
     */
    groups?: Array<UserGroupMembership>;
    /**
     * A list of linked accounts and whether or not this user is mirrored to any of those accounts.
     * @type {Array<LinkedAccount>}
     * @memberof User
     */
    linkedAccounts?: Array<LinkedAccount>;
    /**
     * User name of user.  Must be unique across a merchant account.
     * @type {string}
     * @memberof User
     */
    login?: string;
    /**
     * A list of user logins over the past 90 days
     * @type {Array<UserLogin>}
     * @memberof User
     */
    loginHistories?: Array<UserLogin>;
    /**
     * A list of notifications the user receives.
     * @type {Array<Notification>}
     * @memberof User
     */
    notifications?: Array<Notification>;
    /**
     * OTP Serial Number such as Google Authenticator or Crypto Card.
     * @type {string}
     * @memberof User
     */
    otpSerialNumber?: string;
    /**
     * A list of permissions the user enjoys for accessing the backend of UltraCart.
     * @type {Array<Permission>}
     * @memberof User
     */
    permissions?: Array<Permission>;
    /**
     * Phone number of user.  Please supply a valid phone number.  When something breaks on your account, we need to be able to reach you.
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * User id is a unique identifier for this user
     * @type {number}
     * @memberof User
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface UserGroupMembership
 */
export interface UserGroupMembership {
    /**
     * 
     * @type {number}
     * @memberof UserGroupMembership
     */
    groupOid?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroupMembership
     */
    member?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserGroupMembership
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
    /**
     * IP Address
     * @type {string}
     * @memberof UserLogin
     */
    ipAddress?: string;
    /**
     * login
     * @type {string}
     * @memberof UserLogin
     */
    login?: string;
    /**
     * Login date/time
     * @type {string}
     * @memberof UserLogin
     */
    loginDts?: string;
    /**
     * User Agent
     * @type {string}
     * @memberof UserLogin
     */
    userAgent?: string;
}

/**
 * 
 * @export
 * @interface UserLoginsResponse
 */
export interface UserLoginsResponse {
    /**
     * 
     * @type {Error}
     * @memberof UserLoginsResponse
     */
    error?: Error;
    /**
     * Logins
     * @type {Array<UserLogin>}
     * @memberof UserLoginsResponse
     */
    logins?: Array<UserLogin>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UserLoginsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UserLoginsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof UserLoginsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {Error}
     * @memberof UserResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UserResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UserResponse
     */
    success?: boolean;
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    user?: User;
    /**
     * 
     * @type {Warning}
     * @memberof UserResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {Error}
     * @memberof UsersResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UsersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UsersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersResponse
     */
    users?: Array<User>;
    /**
     * 
     * @type {Warning}
     * @memberof UsersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface VerificationRecord
 */
export interface VerificationRecord {
    /**
     * 
     * @type {string}
     * @memberof VerificationRecord
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationRecord
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationRecord
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface Warning
 */
export interface Warning {
    /**
     * Additional information often a link to additional documentation
     * @type {string}
     * @memberof Warning
     */
    moreInfo?: string;
    /**
     * A technical message meant to be read by a developer
     * @type {string}
     * @memberof Warning
     */
    warningMessage?: string;
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Populated if webhook associated with an API user
     * @type {number}
     * @memberof Webhook
     */
    apiUserOid?: number;
    /**
     * Version of the API objects that are sent in notifications
     * @type {string}
     * @memberof Webhook
     */
    apiVersion?: Webhook.ApiVersionEnum;
    /**
     * 
     * @type {ApiUserApplicationProfile}
     * @memberof Webhook
     */
    applicationProfile?: ApiUserApplicationProfile;
    /**
     * The type of authentication this webhook will use when communicating with your server
     * @type {string}
     * @memberof Webhook
     */
    authenticationType?: Webhook.AuthenticationTypeEnum;
    /**
     * Basic authentication password
     * @type {string}
     * @memberof Webhook
     */
    basicPassword?: string;
    /**
     * Basic authentication user name
     * @type {string}
     * @memberof Webhook
     */
    basicUsername?: string;
    /**
     * The number of consecutive failures that have occurred trying to deliver notifications to the target server
     * @type {number}
     * @memberof Webhook
     */
    consecutiveFailures?: number;
    /**
     * True if the webhook has been disabled
     * @type {boolean}
     * @memberof Webhook
     */
    disabled?: boolean;
    /**
     * The categories of events.  Individual events and subscriptions are handled in the child objects.  _placeholders parameter effects the population of this on a retrieval.
     * @type {Array<WebhookEventCategory>}
     * @memberof Webhook
     */
    eventCategories?: Array<WebhookEventCategory>;
    /**
     * IAM Access Key for AWS SQS Delivery
     * @type {string}
     * @memberof Webhook
     */
    iamAccessKey?: string;
    /**
     * IAM Secret Key for AWS SQS Delivery
     * @type {string}
     * @memberof Webhook
     */
    iamSecretKey?: string;
    /**
     * The maximum number of events in the payload that UltraCart will deliver
     * @type {number}
     * @memberof Webhook
     */
    maximumEvents?: number;
    /**
     * The maximum size of the payload that UltraCart will deliver
     * @type {number}
     * @memberof Webhook
     */
    maximumSize?: number;
    /**
     * The UltraCart merchant ID that owns this webhook
     * @type {string}
     * @memberof Webhook
     */
    merchantId?: string;
    /**
     * The next time UltraCart will attempt delivery if failures have been occurring
     * @type {string}
     * @memberof Webhook
     */
    nextRetryAfter?: string;
    /**
     * The number of pending events for this webhook
     * @type {number}
     * @memberof Webhook
     */
    pending?: number;
    /**
     * The object identifier for this webhook
     * @type {number}
     * @memberof Webhook
     */
    webhookOid?: number;
    /**
     * The URL to deliver events to.  Must be HTTPS for customer related information.
     * @type {string}
     * @memberof Webhook
     */
    webhookUrl?: string;
}

/**
 * @export
 * @namespace Webhook
 */
export namespace Webhook {
    /**
     * @export
     * @enum {string}
     */
    export enum ApiVersionEnum {
        _20170301 = <any> '2017-03-01'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AuthenticationTypeEnum {
        None = <any> 'none',
        Basic = <any> 'basic'
    }
}

/**
 * 
 * @export
 * @interface WebhookEventCategory
 */
export interface WebhookEventCategory {
    /**
     * True if any events are subscribed to.
     * @type {boolean}
     * @memberof WebhookEventCategory
     */
    anySubscribed?: boolean;
    /**
     * Array of available expansion constants
     * @type {Array<string>}
     * @memberof WebhookEventCategory
     */
    availableExpansions?: Array<string>;
    /**
     * Name of the event category
     * @type {string}
     * @memberof WebhookEventCategory
     */
    eventCategory?: string;
    /**
     * The events within the category.  Individual subscription flags contained within the child object.
     * @type {Array<WebhookEventSubscription>}
     * @memberof WebhookEventCategory
     */
    events?: Array<WebhookEventSubscription>;
    /**
     * True if all the events within this category are subscribed.  This is a convenience flag to make user interfaces easier.
     * @type {boolean}
     * @memberof WebhookEventCategory
     */
    subscribed?: boolean;
}

/**
 * 
 * @export
 * @interface WebhookEventSubscription
 */
export interface WebhookEventSubscription {
    /**
     * Comment about the event to provide further clarification to the end user
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    comments?: string;
    /**
     * True if the event is deprecated.  See the API change log for details on when it will be discontinued.
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    deprecatedFlag?: boolean;
    /**
     * True if the event is discontinued.  See the API change log for details on migration details.
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    discontinuedFlag?: boolean;
    /**
     * Description of the event
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    eventDescription?: string;
    /**
     * Event name
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    eventName?: string;
    /**
     * The expand string for the notification object.  See the individual resource _expand documentation for valid values.
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    expansion?: string;
    /**
     * True if this is event is subscribed to
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    subscribed?: boolean;
    /**
     * True if the event can be triggered to reflow existing records
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    supportsReflow?: boolean;
    /**
     * The webhook event object identifier
     * @type {number}
     * @memberof WebhookEventSubscription
     */
    webhookEventOid?: number;
}

/**
 * 
 * @export
 * @interface WebhookLog
 */
export interface WebhookLog {
    /**
     * Date/time of delivery
     * @type {string}
     * @memberof WebhookLog
     */
    deliveryDts?: string;
    /**
     * Number of milliseconds to process the notification
     * @type {number}
     * @memberof WebhookLog
     */
    duration?: number;
    /**
     * Request payload (first 100,000 characters)
     * @type {string}
     * @memberof WebhookLog
     */
    request?: string;
    /**
     * Request headers sent to the server
     * @type {Array<HTTPHeader>}
     * @memberof WebhookLog
     */
    requestHeaders?: Array<HTTPHeader>;
    /**
     * Request id is a unique string that you can look up in the logs
     * @type {string}
     * @memberof WebhookLog
     */
    requestId?: string;
    /**
     * Response payload (first 100,000 characters)
     * @type {string}
     * @memberof WebhookLog
     */
    response?: string;
    /**
     * Response headers received from the server
     * @type {Array<HTTPHeader>}
     * @memberof WebhookLog
     */
    responseHeaders?: Array<HTTPHeader>;
    /**
     * HTTP status code received from the server
     * @type {number}
     * @memberof WebhookLog
     */
    statusCode?: number;
    /**
     * True if the delivery was successful
     * @type {boolean}
     * @memberof WebhookLog
     */
    success?: boolean;
    /**
     * URI of the webhook delivered to
     * @type {string}
     * @memberof WebhookLog
     */
    uri?: string;
}

/**
 * 
 * @export
 * @interface WebhookLogResponse
 */
export interface WebhookLogResponse {
    /**
     * 
     * @type {Error}
     * @memberof WebhookLogResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookLogResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookLogResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookLogResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {WebhookLog}
     * @memberof WebhookLogResponse
     */
    webhookLog?: WebhookLog;
}

/**
 * 
 * @export
 * @interface WebhookLogSummariesResponse
 */
export interface WebhookLogSummariesResponse {
    /**
     * 
     * @type {Error}
     * @memberof WebhookLogSummariesResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookLogSummariesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookLogSummariesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookLogSummariesResponse
     */
    warning?: Warning;
    /**
     * Webhook log summaries
     * @type {Array<WebhookLogSummary>}
     * @memberof WebhookLogSummariesResponse
     */
    webhookLogSummaries?: Array<WebhookLogSummary>;
}

/**
 * 
 * @export
 * @interface WebhookLogSummary
 */
export interface WebhookLogSummary {
    /**
     * Date/time of the delivery
     * @type {string}
     * @memberof WebhookLogSummary
     */
    deliveryDts?: string;
    /**
     * Request id
     * @type {string}
     * @memberof WebhookLogSummary
     */
    requestId?: string;
    /**
     * True if the notification was successful
     * @type {boolean}
     * @memberof WebhookLogSummary
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * 
     * @type {Error}
     * @memberof WebhookResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookResponse
     */
    webhook?: Webhook;
}

/**
 * 
 * @export
 * @interface WebhookSampleRequest
 */
export interface WebhookSampleRequest {
    /**
     * Request
     * @type {string}
     * @memberof WebhookSampleRequest
     */
    request?: string;
    /**
     * Request headers
     * @type {Array<HTTPHeader>}
     * @memberof WebhookSampleRequest
     */
    requestHeaders?: Array<HTTPHeader>;
    /**
     * Request id
     * @type {string}
     * @memberof WebhookSampleRequest
     */
    requestId?: string;
    /**
     * URI to send request to
     * @type {string}
     * @memberof WebhookSampleRequest
     */
    uri?: string;
}

/**
 * 
 * @export
 * @interface WebhookSampleRequestResponse
 */
export interface WebhookSampleRequestResponse {
    /**
     * 
     * @type {Error}
     * @memberof WebhookSampleRequestResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookSampleRequestResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookSampleRequestResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookSampleRequestResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {WebhookSampleRequest}
     * @memberof WebhookSampleRequestResponse
     */
    webhookSampleRequest?: WebhookSampleRequest;
}

/**
 * 
 * @export
 * @interface WebhooksResponse
 */
export interface WebhooksResponse {
    /**
     * 
     * @type {Error}
     * @memberof WebhooksResponse
     */
    error?: Error;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhooksResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhooksResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhooksResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhooksResponse
     */
    webhooks?: Array<Webhook>;
}

/**
 * 
 * @export
 * @interface Weight
 */
export interface Weight {
    /**
     * Unit of measure
     * @type {string}
     * @memberof Weight
     */
    uom?: Weight.UomEnum;
    /**
     * Weight
     * @type {number}
     * @memberof Weight
     */
    value?: number;
}

/**
 * @export
 * @namespace Weight
 */
export namespace Weight {
    /**
     * @export
     * @enum {string}
     */
    export enum UomEnum {
        KG = <any> 'KG',
        LB = <any> 'LB',
        OZ = <any> 'OZ'
    }
}


/**
 * AffiliateApi - fetch parameter creator
 * @export
 */
export const AffiliateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve clicks
         * @param {AffiliateClickQuery} clickQuery Click query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicksByQuery(clickQuery: AffiliateClickQuery, limit?: number, offset?: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'clickQuery' is not null or undefined
            if (clickQuery === null || clickQuery === undefined) {
                throw new RequiredError('clickQuery','Required parameter clickQuery was null or undefined when calling getClicksByQuery.');
            }
            const localVarPath = `/affiliate/clicks/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AffiliateClickQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(clickQuery || {}) : (clickQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve ledger entries
         * @param {AffiliateLedgerQuery} ledgerQuery Ledger query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLedgersByQuery(ledgerQuery: AffiliateLedgerQuery, limit?: number, offset?: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'ledgerQuery' is not null or undefined
            if (ledgerQuery === null || ledgerQuery === undefined) {
                throw new RequiredError('ledgerQuery','Required parameter ledgerQuery was null or undefined when calling getLedgersByQuery.');
            }
            const localVarPath = `/affiliate/ledgers/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AffiliateLedgerQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ledgerQuery || {}) : (ledgerQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AffiliateApi - functional programming interface
 * @export
 */
export const AffiliateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve clicks
         * @param {AffiliateClickQuery} clickQuery Click query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicksByQuery(clickQuery: AffiliateClickQuery, limit?: number, offset?: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AffiliateClicksResponse> {
            const localVarFetchArgs = AffiliateApiFetchParamCreator(configuration).getClicksByQuery(clickQuery, limit, offset, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve ledger entries
         * @param {AffiliateLedgerQuery} ledgerQuery Ledger query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLedgersByQuery(ledgerQuery: AffiliateLedgerQuery, limit?: number, offset?: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AffiliateLedgersResponse> {
            const localVarFetchArgs = AffiliateApiFetchParamCreator(configuration).getLedgersByQuery(ledgerQuery, limit, offset, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AffiliateApi - factory interface
 * @export
 */
export const AffiliateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve clicks
         * @param {AffiliateClickQuery} clickQuery Click query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicksByQuery(clickQuery: AffiliateClickQuery, limit?: number, offset?: number, expand?: string, options?: any) {
            return AffiliateApiFp(configuration).getClicksByQuery(clickQuery, limit, offset, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve ledger entries
         * @param {AffiliateLedgerQuery} ledgerQuery Ledger query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLedgersByQuery(ledgerQuery: AffiliateLedgerQuery, limit?: number, offset?: number, expand?: string, options?: any) {
            return AffiliateApiFp(configuration).getLedgersByQuery(ledgerQuery, limit, offset, expand, options)(fetch, basePath);
        },
    };
};

/**
 * AffiliateApi - interface
 * @export
 * @interface AffiliateApi
 */
export interface AffiliateApiInterface {
    /**
     * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve clicks
     * @param {AffiliateClickQuery} clickQuery Click query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApiInterface
     */
    getClicksByQuery(clickQuery: AffiliateClickQuery, limit?: number, offset?: number, expand?: string, options?: any): Promise<AffiliateClicksResponse>;

    /**
     * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve ledger entries
     * @param {AffiliateLedgerQuery} ledgerQuery Ledger query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApiInterface
     */
    getLedgersByQuery(ledgerQuery: AffiliateLedgerQuery, limit?: number, offset?: number, expand?: string, options?: any): Promise<AffiliateLedgersResponse>;

}

/**
 * AffiliateApi - object-oriented interface
 * @export
 * @class AffiliateApi
 * @extends {BaseAPI}
 */
export class AffiliateApi extends BaseAPI implements AffiliateApiInterface {
    /**
     * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve clicks
     * @param {AffiliateClickQuery} clickQuery Click query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApi
     */
    public getClicksByQuery(clickQuery: AffiliateClickQuery, limit?: number, offset?: number, expand?: string, options?: any) {
        return AffiliateApiFp(this.configuration).getClicksByQuery(clickQuery, limit, offset, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve ledger entries
     * @param {AffiliateLedgerQuery} ledgerQuery Ledger query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApi
     */
    public getLedgersByQuery(ledgerQuery: AffiliateLedgerQuery, limit?: number, offset?: number, expand?: string, options?: any) {
        return AffiliateApiFp(this.configuration).getLedgersByQuery(ledgerQuery, limit, offset, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * AutoOrderApi - fetch parameter creator
 * @export
 */
export const AutoOrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a single auto order using the specified auto order oid. 
         * @summary Retrieve an auto order
         * @param {number} autoOrderOid The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrder(autoOrderOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'autoOrderOid' is not null or undefined
            if (autoOrderOid === null || autoOrderOid === undefined) {
                throw new RequiredError('autoOrderOid','Required parameter autoOrderOid was null or undefined when calling getAutoOrder.');
            }
            const localVarPath = `/auto_order/auto_orders/{auto_order_oid}`
                .replace(`{${"auto_order_oid"}}`, encodeURIComponent(String(autoOrderOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order
         * @param {string} autoOrderCode The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByCode(autoOrderCode: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'autoOrderCode' is not null or undefined
            if (autoOrderCode === null || autoOrderCode === undefined) {
                throw new RequiredError('autoOrderCode','Required parameter autoOrderCode was null or undefined when calling getAutoOrderByCode.');
            }
            const localVarPath = `/auto_order/auto_orders/code/{auto_order_code}`
                .replace(`{${"auto_order_code"}}`, encodeURIComponent(String(autoOrderCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order
         * @param {string} referenceOrderId The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByReferenceOrderId(referenceOrderId: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'referenceOrderId' is not null or undefined
            if (referenceOrderId === null || referenceOrderId === undefined) {
                throw new RequiredError('referenceOrderId','Required parameter referenceOrderId was null or undefined when calling getAutoOrderByReferenceOrderId.');
            }
            const localVarPath = `/auto_order/auto_orders/reference_order_id/{reference_order_id}`
                .replace(`{${"reference_order_id"}}`, encodeURIComponent(String(referenceOrderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {string} [autoOrderCode] Auto order code
         * @param {string} [originalOrderId] Original order id
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [company] Company
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [countryCode] Country code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [originalOrderDateBegin] Original order date begin
         * @param {string} [originalOrderDateEnd] Original order date end
         * @param {string} [nextShipmentDateBegin] Next shipment date begin
         * @param {string} [nextShipmentDateEnd] Next shipment date end
         * @param {string} [cardType] Card type
         * @param {string} [itemId] Item ID
         * @param {string} [status] Status
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch auto orders that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrders(autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/auto_order/auto_orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (autoOrderCode !== undefined) {
                localVarQueryParameter['auto_order_code'] = autoOrderCode;
            }

            if (originalOrderId !== undefined) {
                localVarQueryParameter['original_order_id'] = originalOrderId;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (company !== undefined) {
                localVarQueryParameter['company'] = company;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (postalCode !== undefined) {
                localVarQueryParameter['postal_code'] = postalCode;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (originalOrderDateBegin !== undefined) {
                localVarQueryParameter['original_order_date_begin'] = originalOrderDateBegin;
            }

            if (originalOrderDateEnd !== undefined) {
                localVarQueryParameter['original_order_date_end'] = originalOrderDateEnd;
            }

            if (nextShipmentDateBegin !== undefined) {
                localVarQueryParameter['next_shipment_date_begin'] = nextShipmentDateBegin;
            }

            if (nextShipmentDateEnd !== undefined) {
                localVarQueryParameter['next_shipment_date_end'] = nextShipmentDateEnd;
            }

            if (cardType !== undefined) {
                localVarQueryParameter['card_type'] = cardType;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['_since'] = since;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve auto order batch
         * @param {AutoOrderQueryBatch} autoOrderBatch Auto order batch
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersBatch(autoOrderBatch: AutoOrderQueryBatch, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'autoOrderBatch' is not null or undefined
            if (autoOrderBatch === null || autoOrderBatch === undefined) {
                throw new RequiredError('autoOrderBatch','Required parameter autoOrderBatch was null or undefined when calling getAutoOrdersBatch.');
            }
            const localVarPath = `/auto_order/auto_orders/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrderQueryBatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(autoOrderBatch || {}) : (autoOrderBatch || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {AutoOrderQuery} autoOrderQuery Auto order query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersByQuery(autoOrderQuery: AutoOrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'autoOrderQuery' is not null or undefined
            if (autoOrderQuery === null || autoOrderQuery === undefined) {
                throw new RequiredError('autoOrderQuery','Required parameter autoOrderQuery was null or undefined when calling getAutoOrdersByQuery.');
            }
            const localVarPath = `/auto_order/auto_orders/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrderQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(autoOrderQuery || {}) : (autoOrderQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an auto order on the UltraCart account. 
         * @summary Update an auto order
         * @param {AutoOrder} autoOrder Auto order to update
         * @param {number} autoOrderOid The auto order oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrder(autoOrder: AutoOrder, autoOrderOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'autoOrder' is not null or undefined
            if (autoOrder === null || autoOrder === undefined) {
                throw new RequiredError('autoOrder','Required parameter autoOrder was null or undefined when calling updateAutoOrder.');
            }
            // verify required parameter 'autoOrderOid' is not null or undefined
            if (autoOrderOid === null || autoOrderOid === undefined) {
                throw new RequiredError('autoOrderOid','Required parameter autoOrderOid was null or undefined when calling updateAutoOrder.');
            }
            const localVarPath = `/auto_order/auto_orders/{auto_order_oid}`
                .replace(`{${"auto_order_oid"}}`, encodeURIComponent(String(autoOrderOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(autoOrder || {}) : (autoOrder || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple auto orders on the UltraCart account. 
         * @summary Update multiple auto orders
         * @param {AutoOrdersRequest} autoOrdersRequest Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrdersBatch(autoOrdersRequest: AutoOrdersRequest, expand?: string, placeholders?: boolean, async?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'autoOrdersRequest' is not null or undefined
            if (autoOrdersRequest === null || autoOrdersRequest === undefined) {
                throw new RequiredError('autoOrdersRequest','Required parameter autoOrdersRequest was null or undefined when calling updateAutoOrdersBatch.');
            }
            const localVarPath = `/auto_order/auto_orders/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            if (async !== undefined) {
                localVarQueryParameter['_async'] = async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrdersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(autoOrdersRequest || {}) : (autoOrdersRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoOrderApi - functional programming interface
 * @export
 */
export const AutoOrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves a single auto order using the specified auto order oid. 
         * @summary Retrieve an auto order
         * @param {number} autoOrderOid The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrder(autoOrderOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrder(autoOrderOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order
         * @param {string} autoOrderCode The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByCode(autoOrderCode: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrderByCode(autoOrderCode, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order
         * @param {string} referenceOrderId The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByReferenceOrderId(referenceOrderId: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrderByReferenceOrderId(referenceOrderId, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {string} [autoOrderCode] Auto order code
         * @param {string} [originalOrderId] Original order id
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [company] Company
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [countryCode] Country code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [originalOrderDateBegin] Original order date begin
         * @param {string} [originalOrderDateEnd] Original order date end
         * @param {string} [nextShipmentDateBegin] Next shipment date begin
         * @param {string} [nextShipmentDateEnd] Next shipment date end
         * @param {string} [cardType] Card type
         * @param {string} [itemId] Item ID
         * @param {string} [status] Status
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch auto orders that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrders(autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrders(autoOrderCode, originalOrderId, firstName, lastName, company, city, state, postalCode, countryCode, phone, email, originalOrderDateBegin, originalOrderDateEnd, nextShipmentDateBegin, nextShipmentDateEnd, cardType, itemId, status, limit, offset, since, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve auto order batch
         * @param {AutoOrderQueryBatch} autoOrderBatch Auto order batch
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersBatch(autoOrderBatch: AutoOrderQueryBatch, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrdersBatch(autoOrderBatch, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {AutoOrderQuery} autoOrderQuery Auto order query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersByQuery(autoOrderQuery: AutoOrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrdersByQuery(autoOrderQuery, limit, offset, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an auto order on the UltraCart account. 
         * @summary Update an auto order
         * @param {AutoOrder} autoOrder Auto order to update
         * @param {number} autoOrderOid The auto order oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrder(autoOrder: AutoOrder, autoOrderOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).updateAutoOrder(autoOrder, autoOrderOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update multiple auto orders on the UltraCart account. 
         * @summary Update multiple auto orders
         * @param {AutoOrdersRequest} autoOrdersRequest Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrdersBatch(autoOrdersRequest: AutoOrdersRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).updateAutoOrdersBatch(autoOrdersRequest, expand, placeholders, async, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AutoOrderApi - factory interface
 * @export
 */
export const AutoOrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves a single auto order using the specified auto order oid. 
         * @summary Retrieve an auto order
         * @param {number} autoOrderOid The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrder(autoOrderOid: number, expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrder(autoOrderOid, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order
         * @param {string} autoOrderCode The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByCode(autoOrderCode: string, expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrderByCode(autoOrderCode, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order
         * @param {string} referenceOrderId The auto order oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByReferenceOrderId(referenceOrderId: string, expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrderByReferenceOrderId(referenceOrderId, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {string} [autoOrderCode] Auto order code
         * @param {string} [originalOrderId] Original order id
         * @param {string} [firstName] First name
         * @param {string} [lastName] Last name
         * @param {string} [company] Company
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postalCode] Postal code
         * @param {string} [countryCode] Country code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [originalOrderDateBegin] Original order date begin
         * @param {string} [originalOrderDateEnd] Original order date end
         * @param {string} [nextShipmentDateBegin] Next shipment date begin
         * @param {string} [nextShipmentDateEnd] Next shipment date end
         * @param {string} [cardType] Card type
         * @param {string} [itemId] Item ID
         * @param {string} [status] Status
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch auto orders that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrders(autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrders(autoOrderCode, originalOrderId, firstName, lastName, company, city, state, postalCode, countryCode, phone, email, originalOrderDateBegin, originalOrderDateEnd, nextShipmentDateBegin, nextShipmentDateEnd, cardType, itemId, status, limit, offset, since, sort, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve auto order batch
         * @param {AutoOrderQueryBatch} autoOrderBatch Auto order batch
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersBatch(autoOrderBatch: AutoOrderQueryBatch, expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrdersBatch(autoOrderBatch, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {AutoOrderQuery} autoOrderQuery Auto order query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersByQuery(autoOrderQuery: AutoOrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrdersByQuery(autoOrderQuery, limit, offset, sort, expand, options)(fetch, basePath);
        },
        /**
         * Update an auto order on the UltraCart account. 
         * @summary Update an auto order
         * @param {AutoOrder} autoOrder Auto order to update
         * @param {number} autoOrderOid The auto order oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrder(autoOrder: AutoOrder, autoOrderOid: number, expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).updateAutoOrder(autoOrder, autoOrderOid, expand, options)(fetch, basePath);
        },
        /**
         * Update multiple auto orders on the UltraCart account. 
         * @summary Update multiple auto orders
         * @param {AutoOrdersRequest} autoOrdersRequest Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrdersBatch(autoOrdersRequest: AutoOrdersRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any) {
            return AutoOrderApiFp(configuration).updateAutoOrdersBatch(autoOrdersRequest, expand, placeholders, async, options)(fetch, basePath);
        },
    };
};

/**
 * AutoOrderApi - interface
 * @export
 * @interface AutoOrderApi
 */
export interface AutoOrderApiInterface {
    /**
     * Retrieves a single auto order using the specified auto order oid. 
     * @summary Retrieve an auto order
     * @param {number} autoOrderOid The auto order oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrder(autoOrderOid: number, expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order
     * @param {string} autoOrderCode The auto order oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrderByCode(autoOrderCode: string, expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order
     * @param {string} referenceOrderId The auto order oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrderByReferenceOrderId(referenceOrderId: string, expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param {string} [autoOrderCode] Auto order code
     * @param {string} [originalOrderId] Original order id
     * @param {string} [firstName] First name
     * @param {string} [lastName] Last name
     * @param {string} [company] Company
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postalCode] Postal code
     * @param {string} [countryCode] Country code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [originalOrderDateBegin] Original order date begin
     * @param {string} [originalOrderDateEnd] Original order date end
     * @param {string} [nextShipmentDateBegin] Next shipment date begin
     * @param {string} [nextShipmentDateEnd] Next shipment date end
     * @param {string} [cardType] Card type
     * @param {string} [itemId] Item ID
     * @param {string} [status] Status
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch auto orders that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrders(autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): Promise<AutoOrdersResponse>;

    /**
     * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve auto order batch
     * @param {AutoOrderQueryBatch} autoOrderBatch Auto order batch
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrdersBatch(autoOrderBatch: AutoOrderQueryBatch, expand?: string, options?: any): Promise<AutoOrdersResponse>;

    /**
     * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param {AutoOrderQuery} autoOrderQuery Auto order query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrdersByQuery(autoOrderQuery: AutoOrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): Promise<AutoOrdersResponse>;

    /**
     * Update an auto order on the UltraCart account. 
     * @summary Update an auto order
     * @param {AutoOrder} autoOrder Auto order to update
     * @param {number} autoOrderOid The auto order oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    updateAutoOrder(autoOrder: AutoOrder, autoOrderOid: number, expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Update multiple auto orders on the UltraCart account. 
     * @summary Update multiple auto orders
     * @param {AutoOrdersRequest} autoOrdersRequest Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    updateAutoOrdersBatch(autoOrdersRequest: AutoOrdersRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any): Promise<AutoOrdersResponse>;

}

/**
 * AutoOrderApi - object-oriented interface
 * @export
 * @class AutoOrderApi
 * @extends {BaseAPI}
 */
export class AutoOrderApi extends BaseAPI implements AutoOrderApiInterface {
    /**
     * Retrieves a single auto order using the specified auto order oid. 
     * @summary Retrieve an auto order
     * @param {number} autoOrderOid The auto order oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrder(autoOrderOid: number, expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrder(autoOrderOid, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order
     * @param {string} autoOrderCode The auto order oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrderByCode(autoOrderCode: string, expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrderByCode(autoOrderCode, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order
     * @param {string} referenceOrderId The auto order oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrderByReferenceOrderId(referenceOrderId: string, expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrderByReferenceOrderId(referenceOrderId, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param {string} [autoOrderCode] Auto order code
     * @param {string} [originalOrderId] Original order id
     * @param {string} [firstName] First name
     * @param {string} [lastName] Last name
     * @param {string} [company] Company
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postalCode] Postal code
     * @param {string} [countryCode] Country code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [originalOrderDateBegin] Original order date begin
     * @param {string} [originalOrderDateEnd] Original order date end
     * @param {string} [nextShipmentDateBegin] Next shipment date begin
     * @param {string} [nextShipmentDateEnd] Next shipment date end
     * @param {string} [cardType] Card type
     * @param {string} [itemId] Item ID
     * @param {string} [status] Status
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch auto orders that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrders(autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrders(autoOrderCode, originalOrderId, firstName, lastName, company, city, state, postalCode, countryCode, phone, email, originalOrderDateBegin, originalOrderDateEnd, nextShipmentDateBegin, nextShipmentDateEnd, cardType, itemId, status, limit, offset, since, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve auto order batch
     * @param {AutoOrderQueryBatch} autoOrderBatch Auto order batch
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrdersBatch(autoOrderBatch: AutoOrderQueryBatch, expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrdersBatch(autoOrderBatch, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param {AutoOrderQuery} autoOrderQuery Auto order query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrdersByQuery(autoOrderQuery: AutoOrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrdersByQuery(autoOrderQuery, limit, offset, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update an auto order on the UltraCart account. 
     * @summary Update an auto order
     * @param {AutoOrder} autoOrder Auto order to update
     * @param {number} autoOrderOid The auto order oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public updateAutoOrder(autoOrder: AutoOrder, autoOrderOid: number, expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).updateAutoOrder(autoOrder, autoOrderOid, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update multiple auto orders on the UltraCart account. 
     * @summary Update multiple auto orders
     * @param {AutoOrdersRequest} autoOrdersRequest Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public updateAutoOrdersBatch(autoOrdersRequest: AutoOrdersRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any) {
        return AutoOrderApiFp(this.configuration).updateAutoOrdersBatch(autoOrdersRequest, expand, placeholders, async, options)(this.fetch, this.basePath);
    }

}

/**
 * ChargebackApi - fetch parameter creator
 * @export
 */
export const ChargebackApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a chargeback on the UltraCart account. 
         * @summary Delete a chargeback
         * @param {number} chargebackDisputeOid The chargeback_dispute_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChargeback(chargebackDisputeOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'chargebackDisputeOid' is not null or undefined
            if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
                throw new RequiredError('chargebackDisputeOid','Required parameter chargebackDisputeOid was null or undefined when calling deleteChargeback.');
            }
            const localVarPath = `/chargeback/chargebacks/{chargeback_dispute_oid}`
                .replace(`{${"chargeback_dispute_oid"}}`, encodeURIComponent(String(chargebackDisputeOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single chargeback using the specified chargeback dispute oid. 
         * @summary Retrieve a chargeback
         * @param {number} chargebackDisputeOid The chargeback dispute oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDispute(chargebackDisputeOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'chargebackDisputeOid' is not null or undefined
            if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
                throw new RequiredError('chargebackDisputeOid','Required parameter chargebackDisputeOid was null or undefined when calling getChargebackDispute.');
            }
            const localVarPath = `/chargeback/chargebacks/{chargeback_dispute_oid}`
                .replace(`{${"chargeback_dispute_oid"}}`, encodeURIComponent(String(chargebackDisputeOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve chargebacks
         * @param {string} [orderId] Order Id
         * @param {string} [caseNumber] Case number
         * @param {string} [status] Status
         * @param {string} [expirationDtsStart] Expiration dts start
         * @param {string} [expirationDtsEnd] Expiration dts end
         * @param {string} [chargebackDtsStart] Chargeback dts start
         * @param {string} [chargebackDtsEnd] Chargeback dts end
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch chargebacks that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDisputes(orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/chargeback/chargebacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['order_id'] = orderId;
            }

            if (caseNumber !== undefined) {
                localVarQueryParameter['case_number'] = caseNumber;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (expirationDtsStart !== undefined) {
                localVarQueryParameter['expiration_dts_start'] = expirationDtsStart;
            }

            if (expirationDtsEnd !== undefined) {
                localVarQueryParameter['expiration_dts_end'] = expirationDtsEnd;
            }

            if (chargebackDtsStart !== undefined) {
                localVarQueryParameter['chargeback_dts_start'] = chargebackDtsStart;
            }

            if (chargebackDtsEnd !== undefined) {
                localVarQueryParameter['chargeback_dts_end'] = chargebackDtsEnd;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['_since'] = since;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a chargeback on the UltraCart account. 
         * @summary Insert a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertChargeback(chargeback: ChargebackDispute, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'chargeback' is not null or undefined
            if (chargeback === null || chargeback === undefined) {
                throw new RequiredError('chargeback','Required parameter chargeback was null or undefined when calling insertChargeback.');
            }
            const localVarPath = `/chargeback/chargebacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackDispute" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(chargeback || {}) : (chargeback || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a chargeback on the UltraCart account. 
         * @summary Update a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to update
         * @param {number} chargebackDisputeOid The chargeback_dispute_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChargeback(chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'chargeback' is not null or undefined
            if (chargeback === null || chargeback === undefined) {
                throw new RequiredError('chargeback','Required parameter chargeback was null or undefined when calling updateChargeback.');
            }
            // verify required parameter 'chargebackDisputeOid' is not null or undefined
            if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
                throw new RequiredError('chargebackDisputeOid','Required parameter chargebackDisputeOid was null or undefined when calling updateChargeback.');
            }
            const localVarPath = `/chargeback/chargebacks/{chargeback_dispute_oid}`
                .replace(`{${"chargeback_dispute_oid"}}`, encodeURIComponent(String(chargebackDisputeOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackDispute" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(chargeback || {}) : (chargeback || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargebackApi - functional programming interface
 * @export
 */
export const ChargebackApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a chargeback on the UltraCart account. 
         * @summary Delete a chargeback
         * @param {number} chargebackDisputeOid The chargeback_dispute_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChargeback(chargebackDisputeOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).deleteChargeback(chargebackDisputeOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single chargeback using the specified chargeback dispute oid. 
         * @summary Retrieve a chargeback
         * @param {number} chargebackDisputeOid The chargeback dispute oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDispute(chargebackDisputeOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).getChargebackDispute(chargebackDisputeOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve chargebacks
         * @param {string} [orderId] Order Id
         * @param {string} [caseNumber] Case number
         * @param {string} [status] Status
         * @param {string} [expirationDtsStart] Expiration dts start
         * @param {string} [expirationDtsEnd] Expiration dts end
         * @param {string} [chargebackDtsStart] Chargeback dts start
         * @param {string} [chargebackDtsEnd] Chargeback dts end
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch chargebacks that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDisputes(orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputesResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).getChargebackDisputes(orderId, caseNumber, status, expirationDtsStart, expirationDtsEnd, chargebackDtsStart, chargebackDtsEnd, limit, offset, since, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a chargeback on the UltraCart account. 
         * @summary Insert a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertChargeback(chargeback: ChargebackDispute, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).insertChargeback(chargeback, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a chargeback on the UltraCart account. 
         * @summary Update a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to update
         * @param {number} chargebackDisputeOid The chargeback_dispute_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChargeback(chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).updateChargeback(chargeback, chargebackDisputeOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChargebackApi - factory interface
 * @export
 */
export const ChargebackApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a chargeback on the UltraCart account. 
         * @summary Delete a chargeback
         * @param {number} chargebackDisputeOid The chargeback_dispute_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChargeback(chargebackDisputeOid: number, options?: any) {
            return ChargebackApiFp(configuration).deleteChargeback(chargebackDisputeOid, options)(fetch, basePath);
        },
        /**
         * Retrieves a single chargeback using the specified chargeback dispute oid. 
         * @summary Retrieve a chargeback
         * @param {number} chargebackDisputeOid The chargeback dispute oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDispute(chargebackDisputeOid: number, expand?: string, options?: any) {
            return ChargebackApiFp(configuration).getChargebackDispute(chargebackDisputeOid, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve chargebacks
         * @param {string} [orderId] Order Id
         * @param {string} [caseNumber] Case number
         * @param {string} [status] Status
         * @param {string} [expirationDtsStart] Expiration dts start
         * @param {string} [expirationDtsEnd] Expiration dts end
         * @param {string} [chargebackDtsStart] Chargeback dts start
         * @param {string} [chargebackDtsEnd] Chargeback dts end
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch chargebacks that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDisputes(orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
            return ChargebackApiFp(configuration).getChargebackDisputes(orderId, caseNumber, status, expirationDtsStart, expirationDtsEnd, chargebackDtsStart, chargebackDtsEnd, limit, offset, since, sort, expand, options)(fetch, basePath);
        },
        /**
         * Insert a chargeback on the UltraCart account. 
         * @summary Insert a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertChargeback(chargeback: ChargebackDispute, expand?: string, options?: any) {
            return ChargebackApiFp(configuration).insertChargeback(chargeback, expand, options)(fetch, basePath);
        },
        /**
         * Update a chargeback on the UltraCart account. 
         * @summary Update a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to update
         * @param {number} chargebackDisputeOid The chargeback_dispute_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChargeback(chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string, options?: any) {
            return ChargebackApiFp(configuration).updateChargeback(chargeback, chargebackDisputeOid, expand, options)(fetch, basePath);
        },
    };
};

/**
 * ChargebackApi - interface
 * @export
 * @interface ChargebackApi
 */
export interface ChargebackApiInterface {
    /**
     * Delete a chargeback on the UltraCart account. 
     * @summary Delete a chargeback
     * @param {number} chargebackDisputeOid The chargeback_dispute_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    deleteChargeback(chargebackDisputeOid: number, options?: any): Promise<ChargebackDisputeResponse>;

    /**
     * Retrieves a single chargeback using the specified chargeback dispute oid. 
     * @summary Retrieve a chargeback
     * @param {number} chargebackDisputeOid The chargeback dispute oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    getChargebackDispute(chargebackDisputeOid: number, expand?: string, options?: any): Promise<ChargebackDisputeResponse>;

    /**
     * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve chargebacks
     * @param {string} [orderId] Order Id
     * @param {string} [caseNumber] Case number
     * @param {string} [status] Status
     * @param {string} [expirationDtsStart] Expiration dts start
     * @param {string} [expirationDtsEnd] Expiration dts end
     * @param {string} [chargebackDtsStart] Chargeback dts start
     * @param {string} [chargebackDtsEnd] Chargeback dts end
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch chargebacks that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    getChargebackDisputes(orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): Promise<ChargebackDisputesResponse>;

    /**
     * Insert a chargeback on the UltraCart account. 
     * @summary Insert a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    insertChargeback(chargeback: ChargebackDispute, expand?: string, options?: any): Promise<ChargebackDisputeResponse>;

    /**
     * Update a chargeback on the UltraCart account. 
     * @summary Update a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to update
     * @param {number} chargebackDisputeOid The chargeback_dispute_oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    updateChargeback(chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string, options?: any): Promise<ChargebackDisputeResponse>;

}

/**
 * ChargebackApi - object-oriented interface
 * @export
 * @class ChargebackApi
 * @extends {BaseAPI}
 */
export class ChargebackApi extends BaseAPI implements ChargebackApiInterface {
    /**
     * Delete a chargeback on the UltraCart account. 
     * @summary Delete a chargeback
     * @param {number} chargebackDisputeOid The chargeback_dispute_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public deleteChargeback(chargebackDisputeOid: number, options?: any) {
        return ChargebackApiFp(this.configuration).deleteChargeback(chargebackDisputeOid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single chargeback using the specified chargeback dispute oid. 
     * @summary Retrieve a chargeback
     * @param {number} chargebackDisputeOid The chargeback dispute oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public getChargebackDispute(chargebackDisputeOid: number, expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).getChargebackDispute(chargebackDisputeOid, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve chargebacks
     * @param {string} [orderId] Order Id
     * @param {string} [caseNumber] Case number
     * @param {string} [status] Status
     * @param {string} [expirationDtsStart] Expiration dts start
     * @param {string} [expirationDtsEnd] Expiration dts end
     * @param {string} [chargebackDtsStart] Chargeback dts start
     * @param {string} [chargebackDtsEnd] Chargeback dts end
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch chargebacks that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public getChargebackDisputes(orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).getChargebackDisputes(orderId, caseNumber, status, expirationDtsStart, expirationDtsEnd, chargebackDtsStart, chargebackDtsEnd, limit, offset, since, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Insert a chargeback on the UltraCart account. 
     * @summary Insert a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public insertChargeback(chargeback: ChargebackDispute, expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).insertChargeback(chargeback, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update a chargeback on the UltraCart account. 
     * @summary Update a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to update
     * @param {number} chargebackDisputeOid The chargeback_dispute_oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public updateChargeback(chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).updateChargeback(chargeback, chargebackDisputeOid, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutApi - fetch parameter creator
 * @export
 */
export const CheckoutApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
         * @summary City/State for Zip
         * @param {Cart} cart Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityState(cart: Cart, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling cityState.');
            }
            const localVarPath = `/checkout/city_state`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
         * @summary Finalize Order
         * @param {CartFinalizeOrderRequest} finalizeRequest Finalize request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeOrder(finalizeRequest: CartFinalizeOrderRequest, options: any = {}): FetchArgs {
            // verify required parameter 'finalizeRequest' is not null or undefined
            if (finalizeRequest === null || finalizeRequest === undefined) {
                throw new RequiredError('finalizeRequest','Required parameter finalizeRequest was null or undefined when calling finalizeOrder.');
            }
            const localVarPath = `/checkout/cart/finalizeOrder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartFinalizeOrderRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(finalizeRequest || {}) : (finalizeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Affirm checkout object for the specified cart_id parameter. 
         * @summary Get affirm checkout (by cart id)
         * @param {string} cartId Cart ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffirmCheckout(cartId: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling getAffirmCheckout.');
            }
            const localVarPath = `/checkout/cart/{cart_id}/affirmCheckout`
                .replace(`{${"cart_id"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup the allowed countries for this merchant id 
         * @summary Allowed countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedCountries(options: any = {}): FetchArgs {
            const localVarPath = `/checkout/allowedCountries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
         * @summary Get cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/checkout/cart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a cart specified by the cart_id parameter. 
         * @summary Get cart (by cart id)
         * @param {string} cartId Cart ID to retrieve
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByCartId(cartId: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cartId' is not null or undefined
            if (cartId === null || cartId === undefined) {
                throw new RequiredError('cartId','Required parameter cartId was null or undefined when calling getCartByCartId.');
            }
            const localVarPath = `/checkout/cart/{cart_id}`
                .replace(`{${"cart_id"}}`, encodeURIComponent(String(cartId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a cart specified by the return code parameter. 
         * @summary Get cart (by return code)
         * @param {string} returnCode Return code to lookup cart ID by
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnCode(returnCode: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'returnCode' is not null or undefined
            if (returnCode === null || returnCode === undefined) {
                throw new RequiredError('returnCode','Required parameter returnCode was null or undefined when calling getCartByReturnCode.');
            }
            const localVarPath = `/checkout/return/{return_code}`
                .replace(`{${"return_code"}}`, encodeURIComponent(String(returnCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup a state/province list for a given country code 
         * @summary Get state/province list for a country code
         * @param {string} countryCode Two letter ISO country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProvincesForCountry(countryCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling getStateProvincesForCountry.');
            }
            const localVarPath = `/checkout/stateProvincesForCountry/{country_code}`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm or finalization of the order (including upsell processing). 
         * @summary Handoff cart
         * @param {CheckoutHandoffRequest} handoffRequest Handoff request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoffCart(handoffRequest: CheckoutHandoffRequest, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'handoffRequest' is not null or undefined
            if (handoffRequest === null || handoffRequest === undefined) {
                throw new RequiredError('handoffRequest','Required parameter handoffRequest was null or undefined when calling handoffCart.');
            }
            const localVarPath = `/checkout/cart/handoff`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutHandoffRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(handoffRequest || {}) : (handoffRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login in to the customer profile specified by cart.billing.email and password 
         * @summary Profile login
         * @param {CartProfileLoginRequest} loginRequest Login request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: CartProfileLoginRequest, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'loginRequest' is not null or undefined
            if (loginRequest === null || loginRequest === undefined) {
                throw new RequiredError('loginRequest','Required parameter loginRequest was null or undefined when calling login.');
            }
            const localVarPath = `/checkout/cart/profile/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartProfileLoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(loginRequest || {}) : (loginRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log the cart out of the current profile.  No error will occur if they are not logged in. 
         * @summary Profile logout
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(cart: Cart, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling logout.');
            }
            const localVarPath = `/checkout/cart/profile/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
         * @summary Profile registration
         * @param {CartProfileRegisterRequest} registerRequest Register request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: CartProfileRegisterRequest, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'registerRequest' is not null or undefined
            if (registerRequest === null || registerRequest === undefined) {
                throw new RequiredError('registerRequest','Required parameter registerRequest was null or undefined when calling register.');
            }
            const localVarPath = `/checkout/cart/profile/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartProfileRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(registerRequest || {}) : (registerRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
         * @summary Register affiliate click
         * @param {RegisterAffiliateClickRequest} registerAffiliateClickRequest Register affiliate click request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAffiliateClick(registerAffiliateClickRequest: RegisterAffiliateClickRequest, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'registerAffiliateClickRequest' is not null or undefined
            if (registerAffiliateClickRequest === null || registerAffiliateClickRequest === undefined) {
                throw new RequiredError('registerAffiliateClickRequest','Required parameter registerAffiliateClickRequest was null or undefined when calling registerAffiliateClick.');
            }
            const localVarPath = `/checkout/affiliateClick/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterAffiliateClickRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(registerAffiliateClickRequest || {}) : (registerAffiliateClickRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForCart(cart: Cart, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling relatedItemsForCart.');
            }
            const localVarPath = `/checkout/related_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items (specific item)
         * @param {string} itemId Item ID to retrieve related items for
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForItem(itemId: string, cart: Cart, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling relatedItemsForItem.');
            }
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling relatedItemsForItem.');
            }
            const localVarPath = `/checkout/relatedItems/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
         * @summary Setup Browser Application
         * @param {CheckoutSetupBrowserKeyRequest} browserKeyRequest Setup browser key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupBrowserKey(browserKeyRequest: CheckoutSetupBrowserKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'browserKeyRequest' is not null or undefined
            if (browserKeyRequest === null || browserKeyRequest === undefined) {
                throw new RequiredError('browserKeyRequest','Required parameter browserKeyRequest was null or undefined when calling setupBrowserKey.');
            }
            const localVarPath = `/checkout/browser_key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutSetupBrowserKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(browserKeyRequest || {}) : (browserKeyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the cart. 
         * @summary Update cart
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(cart: Cart, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling updateCart.');
            }
            const localVarPath = `/checkout/cart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
         * @summary Validate
         * @param {CartValidationRequest} validationRequest Validation request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCart(validationRequest: CartValidationRequest, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'validationRequest' is not null or undefined
            if (validationRequest === null || validationRequest === undefined) {
                throw new RequiredError('validationRequest','Required parameter validationRequest was null or undefined when calling validateCart.');
            }
            const localVarPath = `/checkout/cart/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartValidationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(validationRequest || {}) : (validationRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutApi - functional programming interface
 * @export
 */
export const CheckoutApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
         * @summary City/State for Zip
         * @param {Cart} cart Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityState(cart: Cart, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CityStateZip> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).cityState(cart, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
         * @summary Finalize Order
         * @param {CartFinalizeOrderRequest} finalizeRequest Finalize request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeOrder(finalizeRequest: CartFinalizeOrderRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartFinalizeOrderResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).finalizeOrder(finalizeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a Affirm checkout object for the specified cart_id parameter. 
         * @summary Get affirm checkout (by cart id)
         * @param {string} cartId Cart ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffirmCheckout(cartId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartAffirmCheckoutResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getAffirmCheckout(cartId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lookup the allowed countries for this merchant id 
         * @summary Allowed countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedCountries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutAllowedCountriesResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getAllowedCountries(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
         * @summary Get cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getCart(expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a cart specified by the cart_id parameter. 
         * @summary Get cart (by cart id)
         * @param {string} cartId Cart ID to retrieve
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByCartId(cartId: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getCartByCartId(cartId, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a cart specified by the return code parameter. 
         * @summary Get cart (by return code)
         * @param {string} returnCode Return code to lookup cart ID by
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnCode(returnCode: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getCartByReturnCode(returnCode, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lookup a state/province list for a given country code 
         * @summary Get state/province list for a country code
         * @param {string} countryCode Two letter ISO country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProvincesForCountry(countryCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutStateProvinceResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getStateProvincesForCountry(countryCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm or finalization of the order (including upsell processing). 
         * @summary Handoff cart
         * @param {CheckoutHandoffRequest} handoffRequest Handoff request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoffCart(handoffRequest: CheckoutHandoffRequest, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutHandoffResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).handoffCart(handoffRequest, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Login in to the customer profile specified by cart.billing.email and password 
         * @summary Profile login
         * @param {CartProfileLoginRequest} loginRequest Login request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: CartProfileLoginRequest, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartProfileLoginResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).login(loginRequest, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Log the cart out of the current profile.  No error will occur if they are not logged in. 
         * @summary Profile logout
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(cart: Cart, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).logout(cart, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
         * @summary Profile registration
         * @param {CartProfileRegisterRequest} registerRequest Register request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: CartProfileRegisterRequest, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartProfileRegisterResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).register(registerRequest, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
         * @summary Register affiliate click
         * @param {RegisterAffiliateClickRequest} registerAffiliateClickRequest Register affiliate click request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAffiliateClick(registerAffiliateClickRequest: RegisterAffiliateClickRequest, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegisterAffiliateClickResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).registerAffiliateClick(registerAffiliateClickRequest, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForCart(cart: Cart, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).relatedItemsForCart(cart, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items (specific item)
         * @param {string} itemId Item ID to retrieve related items for
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForItem(itemId: string, cart: Cart, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).relatedItemsForItem(itemId, cart, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
         * @summary Setup Browser Application
         * @param {CheckoutSetupBrowserKeyRequest} browserKeyRequest Setup browser key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupBrowserKey(browserKeyRequest: CheckoutSetupBrowserKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutSetupBrowserKeyResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).setupBrowserKey(browserKeyRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the cart. 
         * @summary Update cart
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(cart: Cart, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).updateCart(cart, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
         * @summary Validate
         * @param {CartValidationRequest} validationRequest Validation request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCart(validationRequest: CartValidationRequest, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartValidationResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).validateCart(validationRequest, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutApi - factory interface
 * @export
 */
export const CheckoutApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
         * @summary City/State for Zip
         * @param {Cart} cart Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityState(cart: Cart, options?: any) {
            return CheckoutApiFp(configuration).cityState(cart, options)(fetch, basePath);
        },
        /**
         * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
         * @summary Finalize Order
         * @param {CartFinalizeOrderRequest} finalizeRequest Finalize request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeOrder(finalizeRequest: CartFinalizeOrderRequest, options?: any) {
            return CheckoutApiFp(configuration).finalizeOrder(finalizeRequest, options)(fetch, basePath);
        },
        /**
         * Get a Affirm checkout object for the specified cart_id parameter. 
         * @summary Get affirm checkout (by cart id)
         * @param {string} cartId Cart ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffirmCheckout(cartId: string, options?: any) {
            return CheckoutApiFp(configuration).getAffirmCheckout(cartId, options)(fetch, basePath);
        },
        /**
         * Lookup the allowed countries for this merchant id 
         * @summary Allowed countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedCountries(options?: any) {
            return CheckoutApiFp(configuration).getAllowedCountries(options)(fetch, basePath);
        },
        /**
         * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
         * @summary Get cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(expand?: string, options?: any) {
            return CheckoutApiFp(configuration).getCart(expand, options)(fetch, basePath);
        },
        /**
         * Get a cart specified by the cart_id parameter. 
         * @summary Get cart (by cart id)
         * @param {string} cartId Cart ID to retrieve
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByCartId(cartId: string, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).getCartByCartId(cartId, expand, options)(fetch, basePath);
        },
        /**
         * Get a cart specified by the return code parameter. 
         * @summary Get cart (by return code)
         * @param {string} returnCode Return code to lookup cart ID by
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnCode(returnCode: string, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).getCartByReturnCode(returnCode, expand, options)(fetch, basePath);
        },
        /**
         * Lookup a state/province list for a given country code 
         * @summary Get state/province list for a country code
         * @param {string} countryCode Two letter ISO country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProvincesForCountry(countryCode: string, options?: any) {
            return CheckoutApiFp(configuration).getStateProvincesForCountry(countryCode, options)(fetch, basePath);
        },
        /**
         * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm or finalization of the order (including upsell processing). 
         * @summary Handoff cart
         * @param {CheckoutHandoffRequest} handoffRequest Handoff request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoffCart(handoffRequest: CheckoutHandoffRequest, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).handoffCart(handoffRequest, expand, options)(fetch, basePath);
        },
        /**
         * Login in to the customer profile specified by cart.billing.email and password 
         * @summary Profile login
         * @param {CartProfileLoginRequest} loginRequest Login request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: CartProfileLoginRequest, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).login(loginRequest, expand, options)(fetch, basePath);
        },
        /**
         * Log the cart out of the current profile.  No error will occur if they are not logged in. 
         * @summary Profile logout
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(cart: Cart, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).logout(cart, expand, options)(fetch, basePath);
        },
        /**
         * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
         * @summary Profile registration
         * @param {CartProfileRegisterRequest} registerRequest Register request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: CartProfileRegisterRequest, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).register(registerRequest, expand, options)(fetch, basePath);
        },
        /**
         * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
         * @summary Register affiliate click
         * @param {RegisterAffiliateClickRequest} registerAffiliateClickRequest Register affiliate click request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAffiliateClick(registerAffiliateClickRequest: RegisterAffiliateClickRequest, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).registerAffiliateClick(registerAffiliateClickRequest, expand, options)(fetch, basePath);
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForCart(cart: Cart, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).relatedItemsForCart(cart, expand, options)(fetch, basePath);
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items (specific item)
         * @param {string} itemId Item ID to retrieve related items for
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForItem(itemId: string, cart: Cart, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).relatedItemsForItem(itemId, cart, expand, options)(fetch, basePath);
        },
        /**
         * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
         * @summary Setup Browser Application
         * @param {CheckoutSetupBrowserKeyRequest} browserKeyRequest Setup browser key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupBrowserKey(browserKeyRequest: CheckoutSetupBrowserKeyRequest, options?: any) {
            return CheckoutApiFp(configuration).setupBrowserKey(browserKeyRequest, options)(fetch, basePath);
        },
        /**
         * Update the cart. 
         * @summary Update cart
         * @param {Cart} cart Cart
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(cart: Cart, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).updateCart(cart, expand, options)(fetch, basePath);
        },
        /**
         * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
         * @summary Validate
         * @param {CartValidationRequest} validationRequest Validation request
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCart(validationRequest: CartValidationRequest, expand?: string, options?: any) {
            return CheckoutApiFp(configuration).validateCart(validationRequest, expand, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutApi - interface
 * @export
 * @interface CheckoutApi
 */
export interface CheckoutApiInterface {
    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @summary City/State for Zip
     * @param {Cart} cart Cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    cityState(cart: Cart, options?: any): Promise<CityStateZip>;

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @summary Finalize Order
     * @param {CartFinalizeOrderRequest} finalizeRequest Finalize request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    finalizeOrder(finalizeRequest: CartFinalizeOrderRequest, options?: any): Promise<CartFinalizeOrderResponse>;

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * @summary Get affirm checkout (by cart id)
     * @param {string} cartId Cart ID to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getAffirmCheckout(cartId: string, options?: any): Promise<CartAffirmCheckoutResponse>;

    /**
     * Lookup the allowed countries for this merchant id 
     * @summary Allowed countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getAllowedCountries(options?: any): Promise<CheckoutAllowedCountriesResponse>;

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @summary Get cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCart(expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Get a cart specified by the cart_id parameter. 
     * @summary Get cart (by cart id)
     * @param {string} cartId Cart ID to retrieve
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByCartId(cartId: string, expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Get a cart specified by the return code parameter. 
     * @summary Get cart (by return code)
     * @param {string} returnCode Return code to lookup cart ID by
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByReturnCode(returnCode: string, expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Lookup a state/province list for a given country code 
     * @summary Get state/province list for a country code
     * @param {string} countryCode Two letter ISO country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getStateProvincesForCountry(countryCode: string, options?: any): Promise<CheckoutStateProvinceResponse>;

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm or finalization of the order (including upsell processing). 
     * @summary Handoff cart
     * @param {CheckoutHandoffRequest} handoffRequest Handoff request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    handoffCart(handoffRequest: CheckoutHandoffRequest, expand?: string, options?: any): Promise<CheckoutHandoffResponse>;

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * @summary Profile login
     * @param {CartProfileLoginRequest} loginRequest Login request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    login(loginRequest: CartProfileLoginRequest, expand?: string, options?: any): Promise<CartProfileLoginResponse>;

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @summary Profile logout
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    logout(cart: Cart, expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @summary Profile registration
     * @param {CartProfileRegisterRequest} registerRequest Register request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    register(registerRequest: CartProfileRegisterRequest, expand?: string, options?: any): Promise<CartProfileRegisterResponse>;

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * @summary Register affiliate click
     * @param {RegisterAffiliateClickRequest} registerAffiliateClickRequest Register affiliate click request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    registerAffiliateClick(registerAffiliateClickRequest: RegisterAffiliateClickRequest, expand?: string, options?: any): Promise<RegisterAffiliateClickResponse>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    relatedItemsForCart(cart: Cart, expand?: string, options?: any): Promise<ItemsResponse>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items (specific item)
     * @param {string} itemId Item ID to retrieve related items for
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    relatedItemsForItem(itemId: string, cart: Cart, expand?: string, options?: any): Promise<ItemsResponse>;

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @summary Setup Browser Application
     * @param {CheckoutSetupBrowserKeyRequest} browserKeyRequest Setup browser key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    setupBrowserKey(browserKeyRequest: CheckoutSetupBrowserKeyRequest, options?: any): Promise<CheckoutSetupBrowserKeyResponse>;

    /**
     * Update the cart. 
     * @summary Update cart
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    updateCart(cart: Cart, expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @summary Validate
     * @param {CartValidationRequest} validationRequest Validation request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    validateCart(validationRequest: CartValidationRequest, expand?: string, options?: any): Promise<CartValidationResponse>;

}

/**
 * CheckoutApi - object-oriented interface
 * @export
 * @class CheckoutApi
 * @extends {BaseAPI}
 */
export class CheckoutApi extends BaseAPI implements CheckoutApiInterface {
    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @summary City/State for Zip
     * @param {Cart} cart Cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public cityState(cart: Cart, options?: any) {
        return CheckoutApiFp(this.configuration).cityState(cart, options)(this.fetch, this.basePath);
    }

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @summary Finalize Order
     * @param {CartFinalizeOrderRequest} finalizeRequest Finalize request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public finalizeOrder(finalizeRequest: CartFinalizeOrderRequest, options?: any) {
        return CheckoutApiFp(this.configuration).finalizeOrder(finalizeRequest, options)(this.fetch, this.basePath);
    }

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * @summary Get affirm checkout (by cart id)
     * @param {string} cartId Cart ID to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getAffirmCheckout(cartId: string, options?: any) {
        return CheckoutApiFp(this.configuration).getAffirmCheckout(cartId, options)(this.fetch, this.basePath);
    }

    /**
     * Lookup the allowed countries for this merchant id 
     * @summary Allowed countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getAllowedCountries(options?: any) {
        return CheckoutApiFp(this.configuration).getAllowedCountries(options)(this.fetch, this.basePath);
    }

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @summary Get cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getCart(expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).getCart(expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get a cart specified by the cart_id parameter. 
     * @summary Get cart (by cart id)
     * @param {string} cartId Cart ID to retrieve
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getCartByCartId(cartId: string, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).getCartByCartId(cartId, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get a cart specified by the return code parameter. 
     * @summary Get cart (by return code)
     * @param {string} returnCode Return code to lookup cart ID by
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getCartByReturnCode(returnCode: string, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).getCartByReturnCode(returnCode, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Lookup a state/province list for a given country code 
     * @summary Get state/province list for a country code
     * @param {string} countryCode Two letter ISO country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getStateProvincesForCountry(countryCode: string, options?: any) {
        return CheckoutApiFp(this.configuration).getStateProvincesForCountry(countryCode, options)(this.fetch, this.basePath);
    }

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm or finalization of the order (including upsell processing). 
     * @summary Handoff cart
     * @param {CheckoutHandoffRequest} handoffRequest Handoff request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public handoffCart(handoffRequest: CheckoutHandoffRequest, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).handoffCart(handoffRequest, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * @summary Profile login
     * @param {CartProfileLoginRequest} loginRequest Login request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public login(loginRequest: CartProfileLoginRequest, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).login(loginRequest, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @summary Profile logout
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public logout(cart: Cart, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).logout(cart, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @summary Profile registration
     * @param {CartProfileRegisterRequest} registerRequest Register request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public register(registerRequest: CartProfileRegisterRequest, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).register(registerRequest, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * @summary Register affiliate click
     * @param {RegisterAffiliateClickRequest} registerAffiliateClickRequest Register affiliate click request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public registerAffiliateClick(registerAffiliateClickRequest: RegisterAffiliateClickRequest, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).registerAffiliateClick(registerAffiliateClickRequest, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public relatedItemsForCart(cart: Cart, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).relatedItemsForCart(cart, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items (specific item)
     * @param {string} itemId Item ID to retrieve related items for
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public relatedItemsForItem(itemId: string, cart: Cart, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).relatedItemsForItem(itemId, cart, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @summary Setup Browser Application
     * @param {CheckoutSetupBrowserKeyRequest} browserKeyRequest Setup browser key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public setupBrowserKey(browserKeyRequest: CheckoutSetupBrowserKeyRequest, options?: any) {
        return CheckoutApiFp(this.configuration).setupBrowserKey(browserKeyRequest, options)(this.fetch, this.basePath);
    }

    /**
     * Update the cart. 
     * @summary Update cart
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public updateCart(cart: Cart, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).updateCart(cart, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @summary Validate
     * @param {CartValidationRequest} validationRequest Validation request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public validateCart(validationRequest: CartValidationRequest, expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).validateCart(validationRequest, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * CouponApi - fetch parameter creator
 * @export
 */
export const CouponApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a coupon on the UltraCart account. 
         * @summary Delete a coupon
         * @param {number} couponOid The coupon_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(couponOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'couponOid' is not null or undefined
            if (couponOid === null || couponOid === undefined) {
                throw new RequiredError('couponOid','Required parameter couponOid was null or undefined when calling deleteCoupon.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(couponOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate one time codes for a coupon 
         * @summary Generates one time codes for a coupon
         * @param {number} couponOid The coupon oid to generate codes.
         * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCouponCodes(couponOid: number, couponCodesRequest: CouponCodesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'couponOid' is not null or undefined
            if (couponOid === null || couponOid === undefined) {
                throw new RequiredError('couponOid','Required parameter couponOid was null or undefined when calling generateCouponCodes.');
            }
            // verify required parameter 'couponCodesRequest' is not null or undefined
            if (couponCodesRequest === null || couponCodesRequest === undefined) {
                throw new RequiredError('couponCodesRequest','Required parameter couponCodesRequest was null or undefined when calling generateCouponCodes.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}/generate_codes`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(couponOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponCodesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(couponCodesRequest || {}) : (couponCodesRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate one time codes by merchant code 
         * @summary Generates one time codes by merchant code
         * @param {string} merchantCode The merchant code to generate one time codes.
         * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOneTimeCodesByMerchantCode(merchantCode: string, couponCodesRequest: CouponCodesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'merchantCode' is not null or undefined
            if (merchantCode === null || merchantCode === undefined) {
                throw new RequiredError('merchantCode','Required parameter merchantCode was null or undefined when calling generateOneTimeCodesByMerchantCode.');
            }
            // verify required parameter 'couponCodesRequest' is not null or undefined
            if (couponCodesRequest === null || couponCodesRequest === undefined) {
                throw new RequiredError('couponCodesRequest','Required parameter couponCodesRequest was null or undefined when calling generateOneTimeCodesByMerchantCode.');
            }
            const localVarPath = `/coupon/coupons/merchant_code/{merchant_code}/generate_codes`
                .replace(`{${"merchant_code"}}`, encodeURIComponent(String(merchantCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponCodesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(couponCodesRequest || {}) : (couponCodesRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single coupon using the specified coupon profile oid. 
         * @summary Retrieve a coupon
         * @param {number} couponOid The coupon oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(couponOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'couponOid' is not null or undefined
            if (couponOid === null || couponOid === undefined) {
                throw new RequiredError('couponOid','Required parameter couponOid was null or undefined when calling getCoupon.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(couponOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single coupon using the specified merchant code. 
         * @summary Retrieve a coupon by merchant code
         * @param {string} merchantCode The coupon merchant code to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponByMerchantCode(merchantCode: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'merchantCode' is not null or undefined
            if (merchantCode === null || merchantCode === undefined) {
                throw new RequiredError('merchantCode','Required parameter merchantCode was null or undefined when calling getCouponByMerchantCode.');
            }
            const localVarPath = `/coupon/coupons/merchant_code/{merchant_code}`
                .replace(`{${"merchant_code"}}`, encodeURIComponent(String(merchantCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons
         * @param {string} [merchantCode] Merchant code
         * @param {string} [description] Description
         * @param {string} [couponType] Coupon type
         * @param {string} [startDateBegin] Start date begin
         * @param {string} [startDateEnd] Start date end
         * @param {string} [expirationDateBegin] Expiration date begin
         * @param {string} [expirationDateEnd] Expiration date end
         * @param {number} [affiliateOid] Affiliate oid
         * @param {boolean} [excludeExpired] Exclude expired
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupons(merchantCode?: string, description?: string, couponType?: string, startDateBegin?: string, startDateEnd?: string, expirationDateBegin?: string, expirationDateEnd?: string, affiliateOid?: number, excludeExpired?: boolean, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/coupon/coupons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (merchantCode !== undefined) {
                localVarQueryParameter['merchant_code'] = merchantCode;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (couponType !== undefined) {
                localVarQueryParameter['coupon_type'] = couponType;
            }

            if (startDateBegin !== undefined) {
                localVarQueryParameter['start_date_begin'] = startDateBegin;
            }

            if (startDateEnd !== undefined) {
                localVarQueryParameter['start_date_end'] = startDateEnd;
            }

            if (expirationDateBegin !== undefined) {
                localVarQueryParameter['expiration_date_begin'] = expirationDateBegin;
            }

            if (expirationDateEnd !== undefined) {
                localVarQueryParameter['expiration_date_end'] = expirationDateEnd;
            }

            if (affiliateOid !== undefined) {
                localVarQueryParameter['affiliate_oid'] = affiliateOid;
            }

            if (excludeExpired !== undefined) {
                localVarQueryParameter['exclude_expired'] = excludeExpired;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons by query
         * @param {CouponQuery} couponQuery Coupon query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponsByQuery(couponQuery: CouponQuery, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'couponQuery' is not null or undefined
            if (couponQuery === null || couponQuery === undefined) {
                throw new RequiredError('couponQuery','Required parameter couponQuery was null or undefined when calling getCouponsByQuery.');
            }
            const localVarPath = `/coupon/coupons/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(couponQuery || {}) : (couponQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve values needed for a coupon editor 
         * @summary Retrieve values needed for a coupon editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options: any = {}): FetchArgs {
            const localVarPath = `/coupon/editor_values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a coupon on the UltraCart account. 
         * @summary Insert a coupon
         * @param {Coupon} coupon Coupon to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupon(coupon: Coupon, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'coupon' is not null or undefined
            if (coupon === null || coupon === undefined) {
                throw new RequiredError('coupon','Required parameter coupon was null or undefined when calling insertCoupon.');
            }
            const localVarPath = `/coupon/coupons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Coupon" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon || {}) : (coupon || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a coupon on the UltraCart account. 
         * @summary Update a coupon
         * @param {Coupon} coupon Coupon to update
         * @param {number} couponOid The coupon_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(coupon: Coupon, couponOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'coupon' is not null or undefined
            if (coupon === null || coupon === undefined) {
                throw new RequiredError('coupon','Required parameter coupon was null or undefined when calling updateCoupon.');
            }
            // verify required parameter 'couponOid' is not null or undefined
            if (couponOid === null || couponOid === undefined) {
                throw new RequiredError('couponOid','Required parameter couponOid was null or undefined when calling updateCoupon.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(couponOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Coupon" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon || {}) : (coupon || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponApi - functional programming interface
 * @export
 */
export const CouponApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a coupon on the UltraCart account. 
         * @summary Delete a coupon
         * @param {number} couponOid The coupon_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(couponOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).deleteCoupon(couponOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate one time codes for a coupon 
         * @summary Generates one time codes for a coupon
         * @param {number} couponOid The coupon oid to generate codes.
         * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCouponCodes(couponOid: number, couponCodesRequest: CouponCodesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponCodesResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).generateCouponCodes(couponOid, couponCodesRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate one time codes by merchant code 
         * @summary Generates one time codes by merchant code
         * @param {string} merchantCode The merchant code to generate one time codes.
         * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOneTimeCodesByMerchantCode(merchantCode: string, couponCodesRequest: CouponCodesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponCodesResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).generateOneTimeCodesByMerchantCode(merchantCode, couponCodesRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single coupon using the specified coupon profile oid. 
         * @summary Retrieve a coupon
         * @param {number} couponOid The coupon oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(couponOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCoupon(couponOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single coupon using the specified merchant code. 
         * @summary Retrieve a coupon by merchant code
         * @param {string} merchantCode The coupon merchant code to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponByMerchantCode(merchantCode: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCouponByMerchantCode(merchantCode, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons
         * @param {string} [merchantCode] Merchant code
         * @param {string} [description] Description
         * @param {string} [couponType] Coupon type
         * @param {string} [startDateBegin] Start date begin
         * @param {string} [startDateEnd] Start date end
         * @param {string} [expirationDateBegin] Expiration date begin
         * @param {string} [expirationDateEnd] Expiration date end
         * @param {number} [affiliateOid] Affiliate oid
         * @param {boolean} [excludeExpired] Exclude expired
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupons(merchantCode?: string, description?: string, couponType?: string, startDateBegin?: string, startDateEnd?: string, expirationDateBegin?: string, expirationDateEnd?: string, affiliateOid?: number, excludeExpired?: boolean, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCoupons(merchantCode, description, couponType, startDateBegin, startDateEnd, expirationDateBegin, expirationDateEnd, affiliateOid, excludeExpired, limit, offset, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons by query
         * @param {CouponQuery} couponQuery Coupon query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponsByQuery(couponQuery: CouponQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCouponsByQuery(couponQuery, limit, offset, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve values needed for a coupon editor 
         * @summary Retrieve values needed for a coupon editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponEditorValues> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getEditorValues(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a coupon on the UltraCart account. 
         * @summary Insert a coupon
         * @param {Coupon} coupon Coupon to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupon(coupon: Coupon, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).insertCoupon(coupon, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a coupon on the UltraCart account. 
         * @summary Update a coupon
         * @param {Coupon} coupon Coupon to update
         * @param {number} couponOid The coupon_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(coupon: Coupon, couponOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).updateCoupon(coupon, couponOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CouponApi - factory interface
 * @export
 */
export const CouponApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a coupon on the UltraCart account. 
         * @summary Delete a coupon
         * @param {number} couponOid The coupon_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(couponOid: number, options?: any) {
            return CouponApiFp(configuration).deleteCoupon(couponOid, options)(fetch, basePath);
        },
        /**
         * Generate one time codes for a coupon 
         * @summary Generates one time codes for a coupon
         * @param {number} couponOid The coupon oid to generate codes.
         * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCouponCodes(couponOid: number, couponCodesRequest: CouponCodesRequest, options?: any) {
            return CouponApiFp(configuration).generateCouponCodes(couponOid, couponCodesRequest, options)(fetch, basePath);
        },
        /**
         * Generate one time codes by merchant code 
         * @summary Generates one time codes by merchant code
         * @param {string} merchantCode The merchant code to generate one time codes.
         * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOneTimeCodesByMerchantCode(merchantCode: string, couponCodesRequest: CouponCodesRequest, options?: any) {
            return CouponApiFp(configuration).generateOneTimeCodesByMerchantCode(merchantCode, couponCodesRequest, options)(fetch, basePath);
        },
        /**
         * Retrieves a single coupon using the specified coupon profile oid. 
         * @summary Retrieve a coupon
         * @param {number} couponOid The coupon oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(couponOid: number, expand?: string, options?: any) {
            return CouponApiFp(configuration).getCoupon(couponOid, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single coupon using the specified merchant code. 
         * @summary Retrieve a coupon by merchant code
         * @param {string} merchantCode The coupon merchant code to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponByMerchantCode(merchantCode: string, expand?: string, options?: any) {
            return CouponApiFp(configuration).getCouponByMerchantCode(merchantCode, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons
         * @param {string} [merchantCode] Merchant code
         * @param {string} [description] Description
         * @param {string} [couponType] Coupon type
         * @param {string} [startDateBegin] Start date begin
         * @param {string} [startDateEnd] Start date end
         * @param {string} [expirationDateBegin] Expiration date begin
         * @param {string} [expirationDateEnd] Expiration date end
         * @param {number} [affiliateOid] Affiliate oid
         * @param {boolean} [excludeExpired] Exclude expired
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupons(merchantCode?: string, description?: string, couponType?: string, startDateBegin?: string, startDateEnd?: string, expirationDateBegin?: string, expirationDateEnd?: string, affiliateOid?: number, excludeExpired?: boolean, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
            return CouponApiFp(configuration).getCoupons(merchantCode, description, couponType, startDateBegin, startDateEnd, expirationDateBegin, expirationDateEnd, affiliateOid, excludeExpired, limit, offset, sort, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons by query
         * @param {CouponQuery} couponQuery Coupon query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponsByQuery(couponQuery: CouponQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
            return CouponApiFp(configuration).getCouponsByQuery(couponQuery, limit, offset, sort, expand, options)(fetch, basePath);
        },
        /**
         * Retrieve values needed for a coupon editor 
         * @summary Retrieve values needed for a coupon editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options?: any) {
            return CouponApiFp(configuration).getEditorValues(options)(fetch, basePath);
        },
        /**
         * Insert a coupon on the UltraCart account. 
         * @summary Insert a coupon
         * @param {Coupon} coupon Coupon to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupon(coupon: Coupon, expand?: string, options?: any) {
            return CouponApiFp(configuration).insertCoupon(coupon, expand, options)(fetch, basePath);
        },
        /**
         * Update a coupon on the UltraCart account. 
         * @summary Update a coupon
         * @param {Coupon} coupon Coupon to update
         * @param {number} couponOid The coupon_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(coupon: Coupon, couponOid: number, expand?: string, options?: any) {
            return CouponApiFp(configuration).updateCoupon(coupon, couponOid, expand, options)(fetch, basePath);
        },
    };
};

/**
 * CouponApi - interface
 * @export
 * @interface CouponApi
 */
export interface CouponApiInterface {
    /**
     * Delete a coupon on the UltraCart account. 
     * @summary Delete a coupon
     * @param {number} couponOid The coupon_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    deleteCoupon(couponOid: number, options?: any): Promise<CouponResponse>;

    /**
     * Generate one time codes for a coupon 
     * @summary Generates one time codes for a coupon
     * @param {number} couponOid The coupon oid to generate codes.
     * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    generateCouponCodes(couponOid: number, couponCodesRequest: CouponCodesRequest, options?: any): Promise<CouponCodesResponse>;

    /**
     * Generate one time codes by merchant code 
     * @summary Generates one time codes by merchant code
     * @param {string} merchantCode The merchant code to generate one time codes.
     * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    generateOneTimeCodesByMerchantCode(merchantCode: string, couponCodesRequest: CouponCodesRequest, options?: any): Promise<CouponCodesResponse>;

    /**
     * Retrieves a single coupon using the specified coupon profile oid. 
     * @summary Retrieve a coupon
     * @param {number} couponOid The coupon oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCoupon(couponOid: number, expand?: string, options?: any): Promise<CouponResponse>;

    /**
     * Retrieves a single coupon using the specified merchant code. 
     * @summary Retrieve a coupon by merchant code
     * @param {string} merchantCode The coupon merchant code to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCouponByMerchantCode(merchantCode: string, expand?: string, options?: any): Promise<CouponResponse>;

    /**
     * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons
     * @param {string} [merchantCode] Merchant code
     * @param {string} [description] Description
     * @param {string} [couponType] Coupon type
     * @param {string} [startDateBegin] Start date begin
     * @param {string} [startDateEnd] Start date end
     * @param {string} [expirationDateBegin] Expiration date begin
     * @param {string} [expirationDateEnd] Expiration date end
     * @param {number} [affiliateOid] Affiliate oid
     * @param {boolean} [excludeExpired] Exclude expired
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCoupons(merchantCode?: string, description?: string, couponType?: string, startDateBegin?: string, startDateEnd?: string, expirationDateBegin?: string, expirationDateEnd?: string, affiliateOid?: number, excludeExpired?: boolean, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): Promise<CouponsResponse>;

    /**
     * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons by query
     * @param {CouponQuery} couponQuery Coupon query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCouponsByQuery(couponQuery: CouponQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): Promise<CouponsResponse>;

    /**
     * Retrieve values needed for a coupon editor 
     * @summary Retrieve values needed for a coupon editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getEditorValues(options?: any): Promise<CouponEditorValues>;

    /**
     * Insert a coupon on the UltraCart account. 
     * @summary Insert a coupon
     * @param {Coupon} coupon Coupon to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    insertCoupon(coupon: Coupon, expand?: string, options?: any): Promise<CouponResponse>;

    /**
     * Update a coupon on the UltraCart account. 
     * @summary Update a coupon
     * @param {Coupon} coupon Coupon to update
     * @param {number} couponOid The coupon_oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    updateCoupon(coupon: Coupon, couponOid: number, expand?: string, options?: any): Promise<CouponResponse>;

}

/**
 * CouponApi - object-oriented interface
 * @export
 * @class CouponApi
 * @extends {BaseAPI}
 */
export class CouponApi extends BaseAPI implements CouponApiInterface {
    /**
     * Delete a coupon on the UltraCart account. 
     * @summary Delete a coupon
     * @param {number} couponOid The coupon_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public deleteCoupon(couponOid: number, options?: any) {
        return CouponApiFp(this.configuration).deleteCoupon(couponOid, options)(this.fetch, this.basePath);
    }

    /**
     * Generate one time codes for a coupon 
     * @summary Generates one time codes for a coupon
     * @param {number} couponOid The coupon oid to generate codes.
     * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public generateCouponCodes(couponOid: number, couponCodesRequest: CouponCodesRequest, options?: any) {
        return CouponApiFp(this.configuration).generateCouponCodes(couponOid, couponCodesRequest, options)(this.fetch, this.basePath);
    }

    /**
     * Generate one time codes by merchant code 
     * @summary Generates one time codes by merchant code
     * @param {string} merchantCode The merchant code to generate one time codes.
     * @param {CouponCodesRequest} couponCodesRequest Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public generateOneTimeCodesByMerchantCode(merchantCode: string, couponCodesRequest: CouponCodesRequest, options?: any) {
        return CouponApiFp(this.configuration).generateOneTimeCodesByMerchantCode(merchantCode, couponCodesRequest, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single coupon using the specified coupon profile oid. 
     * @summary Retrieve a coupon
     * @param {number} couponOid The coupon oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCoupon(couponOid: number, expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCoupon(couponOid, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single coupon using the specified merchant code. 
     * @summary Retrieve a coupon by merchant code
     * @param {string} merchantCode The coupon merchant code to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCouponByMerchantCode(merchantCode: string, expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCouponByMerchantCode(merchantCode, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons
     * @param {string} [merchantCode] Merchant code
     * @param {string} [description] Description
     * @param {string} [couponType] Coupon type
     * @param {string} [startDateBegin] Start date begin
     * @param {string} [startDateEnd] Start date end
     * @param {string} [expirationDateBegin] Expiration date begin
     * @param {string} [expirationDateEnd] Expiration date end
     * @param {number} [affiliateOid] Affiliate oid
     * @param {boolean} [excludeExpired] Exclude expired
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCoupons(merchantCode?: string, description?: string, couponType?: string, startDateBegin?: string, startDateEnd?: string, expirationDateBegin?: string, expirationDateEnd?: string, affiliateOid?: number, excludeExpired?: boolean, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCoupons(merchantCode, description, couponType, startDateBegin, startDateEnd, expirationDateBegin, expirationDateEnd, affiliateOid, excludeExpired, limit, offset, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons by query
     * @param {CouponQuery} couponQuery Coupon query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCouponsByQuery(couponQuery: CouponQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCouponsByQuery(couponQuery, limit, offset, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve values needed for a coupon editor 
     * @summary Retrieve values needed for a coupon editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getEditorValues(options?: any) {
        return CouponApiFp(this.configuration).getEditorValues(options)(this.fetch, this.basePath);
    }

    /**
     * Insert a coupon on the UltraCart account. 
     * @summary Insert a coupon
     * @param {Coupon} coupon Coupon to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public insertCoupon(coupon: Coupon, expand?: string, options?: any) {
        return CouponApiFp(this.configuration).insertCoupon(coupon, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update a coupon on the UltraCart account. 
     * @summary Update a coupon
     * @param {Coupon} coupon Coupon to update
     * @param {number} couponOid The coupon_oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public updateCoupon(coupon: Coupon, couponOid: number, expand?: string, options?: any) {
        return CouponApiFp(this.configuration).updateCoupon(coupon, couponOid, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerApi - fetch parameter creator
 * @export
 */
export const CustomerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a customer on the UltraCart account. 
         * @summary Delete a customer
         * @param {number} customerProfileOid The customer_profile_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerProfileOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerProfileOid' is not null or undefined
            if (customerProfileOid === null || customerProfileOid === undefined) {
                throw new RequiredError('customerProfileOid','Required parameter customerProfileOid was null or undefined when calling deleteCustomer.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customerProfileOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single customer using the specified customer profile oid. 
         * @summary Retrieve a customer
         * @param {number} customerProfileOid The customer oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerProfileOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerProfileOid' is not null or undefined
            if (customerProfileOid === null || customerProfileOid === undefined) {
                throw new RequiredError('customerProfileOid','Required parameter customerProfileOid was null or undefined when calling getCustomer.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customerProfileOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers
         * @param {string} [email] Email
         * @param {string} [qbClass] Quickbooks class
         * @param {string} [quickbooksCode] Quickbooks code
         * @param {string} [lastModifiedDtsStart] Last modified date start
         * @param {string} [lastModifiedDtsEnd] Last modified date end
         * @param {string} [signupDtsStart] Signup date start
         * @param {string} [signupDtsEnd] Signup date end
         * @param {string} [billingFirstName] Billing first name
         * @param {string} [billingLastName] Billing last name
         * @param {string} [billingCompany] Billing company
         * @param {string} [billingCity] Billing city
         * @param {string} [billingState] Billing state
         * @param {string} [billingPostalCode] Billing postal code
         * @param {string} [billingCountryCode] Billing country code
         * @param {string} [billingDayPhone] Billing day phone
         * @param {string} [billingEveningPhone] Billing evening phone
         * @param {string} [shippingFirstName] Shipping first name
         * @param {string} [shippingLastName] Shipping last name
         * @param {string} [shippingCompany] Shipping company
         * @param {string} [shippingCity] Shipping city
         * @param {string} [shippingState] Shipping state
         * @param {string} [shippingPostalCode] Shipping postal code
         * @param {string} [shippingCountryCode] Shipping country code
         * @param {string} [shippingDayPhone] Shipping day phone
         * @param {string} [shippingEveningPhone] Shipping evening phone
         * @param {number} [pricingTierOid] Pricing tier oid
         * @param {string} [pricingTierName] Pricing tier name
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/customer/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (qbClass !== undefined) {
                localVarQueryParameter['qb_class'] = qbClass;
            }

            if (quickbooksCode !== undefined) {
                localVarQueryParameter['quickbooks_code'] = quickbooksCode;
            }

            if (lastModifiedDtsStart !== undefined) {
                localVarQueryParameter['last_modified_dts_start'] = lastModifiedDtsStart;
            }

            if (lastModifiedDtsEnd !== undefined) {
                localVarQueryParameter['last_modified_dts_end'] = lastModifiedDtsEnd;
            }

            if (signupDtsStart !== undefined) {
                localVarQueryParameter['signup_dts_start'] = signupDtsStart;
            }

            if (signupDtsEnd !== undefined) {
                localVarQueryParameter['signup_dts_end'] = signupDtsEnd;
            }

            if (billingFirstName !== undefined) {
                localVarQueryParameter['billing_first_name'] = billingFirstName;
            }

            if (billingLastName !== undefined) {
                localVarQueryParameter['billing_last_name'] = billingLastName;
            }

            if (billingCompany !== undefined) {
                localVarQueryParameter['billing_company'] = billingCompany;
            }

            if (billingCity !== undefined) {
                localVarQueryParameter['billing_city'] = billingCity;
            }

            if (billingState !== undefined) {
                localVarQueryParameter['billing_state'] = billingState;
            }

            if (billingPostalCode !== undefined) {
                localVarQueryParameter['billing_postal_code'] = billingPostalCode;
            }

            if (billingCountryCode !== undefined) {
                localVarQueryParameter['billing_country_code'] = billingCountryCode;
            }

            if (billingDayPhone !== undefined) {
                localVarQueryParameter['billing_day_phone'] = billingDayPhone;
            }

            if (billingEveningPhone !== undefined) {
                localVarQueryParameter['billing_evening_phone'] = billingEveningPhone;
            }

            if (shippingFirstName !== undefined) {
                localVarQueryParameter['shipping_first_name'] = shippingFirstName;
            }

            if (shippingLastName !== undefined) {
                localVarQueryParameter['shipping_last_name'] = shippingLastName;
            }

            if (shippingCompany !== undefined) {
                localVarQueryParameter['shipping_company'] = shippingCompany;
            }

            if (shippingCity !== undefined) {
                localVarQueryParameter['shipping_city'] = shippingCity;
            }

            if (shippingState !== undefined) {
                localVarQueryParameter['shipping_state'] = shippingState;
            }

            if (shippingPostalCode !== undefined) {
                localVarQueryParameter['shipping_postal_code'] = shippingPostalCode;
            }

            if (shippingCountryCode !== undefined) {
                localVarQueryParameter['shipping_country_code'] = shippingCountryCode;
            }

            if (shippingDayPhone !== undefined) {
                localVarQueryParameter['shipping_day_phone'] = shippingDayPhone;
            }

            if (shippingEveningPhone !== undefined) {
                localVarQueryParameter['shipping_evening_phone'] = shippingEveningPhone;
            }

            if (pricingTierOid !== undefined) {
                localVarQueryParameter['pricing_tier_oid'] = pricingTierOid;
            }

            if (pricingTierName !== undefined) {
                localVarQueryParameter['pricing_tier_name'] = pricingTierName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['_since'] = since;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers by query
         * @param {CustomerQuery} customerQuery Customer query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByQuery(customerQuery: CustomerQuery, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerQuery' is not null or undefined
            if (customerQuery === null || customerQuery === undefined) {
                throw new RequiredError('customerQuery','Required parameter customerQuery was null or undefined when calling getCustomersByQuery.');
            }
            const localVarPath = `/customer/customers/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['_since'] = since;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customerQuery || {}) : (customerQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
         * @summary Retrieve customers for DataTables plugin
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersForDataTables(expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/customer/customers/dataTables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve values needed for a customer profile editor. 
         * @summary Retrieve values needed for a customer profile editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options: any = {}): FetchArgs {
            const localVarPath = `/customer/editor_values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all email lists across all storefronts 
         * @summary Retrieve all email lists across all storefronts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(options: any = {}): FetchArgs {
            const localVarPath = `/customer/email_lists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a customer on the UltraCart account. 
         * @summary Insert a customer
         * @param {Customer} customer Customer to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCustomer(customer: Customer, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customer' is not null or undefined
            if (customer === null || customer === undefined) {
                throw new RequiredError('customer','Required parameter customer was null or undefined when calling insertCustomer.');
            }
            const localVarPath = `/customer/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customer || {}) : (customer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer on the UltraCart account. 
         * @summary Update a customer
         * @param {Customer} customer Customer to update
         * @param {number} customerProfileOid The customer_profile_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customer: Customer, customerProfileOid: number, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customer' is not null or undefined
            if (customer === null || customer === undefined) {
                throw new RequiredError('customer','Required parameter customer was null or undefined when calling updateCustomer.');
            }
            // verify required parameter 'customerProfileOid' is not null or undefined
            if (customerProfileOid === null || customerProfileOid === undefined) {
                throw new RequiredError('customerProfileOid','Required parameter customerProfileOid was null or undefined when calling updateCustomer.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customerProfileOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customer || {}) : (customer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update email list subscriptions for a customer 
         * @summary Update email list subscriptions for a customer
         * @param {number} customerProfileOid The customer profile oid
         * @param {CustomerEmailListChanges} listChanges List changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerEmailLists(customerProfileOid: number, listChanges: CustomerEmailListChanges, options: any = {}): FetchArgs {
            // verify required parameter 'customerProfileOid' is not null or undefined
            if (customerProfileOid === null || customerProfileOid === undefined) {
                throw new RequiredError('customerProfileOid','Required parameter customerProfileOid was null or undefined when calling updateCustomerEmailLists.');
            }
            // verify required parameter 'listChanges' is not null or undefined
            if (listChanges === null || listChanges === undefined) {
                throw new RequiredError('listChanges','Required parameter listChanges was null or undefined when calling updateCustomerEmailLists.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}/email_lists`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customerProfileOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerEmailListChanges" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(listChanges || {}) : (listChanges || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a customer on the UltraCart account. 
         * @summary Delete a customer
         * @param {number} customerProfileOid The customer_profile_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerProfileOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).deleteCustomer(customerProfileOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single customer using the specified customer profile oid. 
         * @summary Retrieve a customer
         * @param {number} customerProfileOid The customer oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerProfileOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomer(customerProfileOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers
         * @param {string} [email] Email
         * @param {string} [qbClass] Quickbooks class
         * @param {string} [quickbooksCode] Quickbooks code
         * @param {string} [lastModifiedDtsStart] Last modified date start
         * @param {string} [lastModifiedDtsEnd] Last modified date end
         * @param {string} [signupDtsStart] Signup date start
         * @param {string} [signupDtsEnd] Signup date end
         * @param {string} [billingFirstName] Billing first name
         * @param {string} [billingLastName] Billing last name
         * @param {string} [billingCompany] Billing company
         * @param {string} [billingCity] Billing city
         * @param {string} [billingState] Billing state
         * @param {string} [billingPostalCode] Billing postal code
         * @param {string} [billingCountryCode] Billing country code
         * @param {string} [billingDayPhone] Billing day phone
         * @param {string} [billingEveningPhone] Billing evening phone
         * @param {string} [shippingFirstName] Shipping first name
         * @param {string} [shippingLastName] Shipping last name
         * @param {string} [shippingCompany] Shipping company
         * @param {string} [shippingCity] Shipping city
         * @param {string} [shippingState] Shipping state
         * @param {string} [shippingPostalCode] Shipping postal code
         * @param {string} [shippingCountryCode] Shipping country code
         * @param {string} [shippingDayPhone] Shipping day phone
         * @param {string} [shippingEveningPhone] Shipping evening phone
         * @param {number} [pricingTierOid] Pricing tier oid
         * @param {string} [pricingTierName] Pricing tier name
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomersResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomers(email, qbClass, quickbooksCode, lastModifiedDtsStart, lastModifiedDtsEnd, signupDtsStart, signupDtsEnd, billingFirstName, billingLastName, billingCompany, billingCity, billingState, billingPostalCode, billingCountryCode, billingDayPhone, billingEveningPhone, shippingFirstName, shippingLastName, shippingCompany, shippingCity, shippingState, shippingPostalCode, shippingCountryCode, shippingDayPhone, shippingEveningPhone, pricingTierOid, pricingTierName, limit, offset, since, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers by query
         * @param {CustomerQuery} customerQuery Customer query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByQuery(customerQuery: CustomerQuery, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomersResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomersByQuery(customerQuery, limit, offset, since, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
         * @summary Retrieve customers for DataTables plugin
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersForDataTables(expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DataTablesServerSideResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomersForDataTables(expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve values needed for a customer profile editor. 
         * @summary Retrieve values needed for a customer profile editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerEditorValues> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getEditorValues(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all email lists across all storefronts 
         * @summary Retrieve all email lists across all storefronts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListsResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getEmailLists(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a customer on the UltraCart account. 
         * @summary Insert a customer
         * @param {Customer} customer Customer to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCustomer(customer: Customer, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).insertCustomer(customer, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a customer on the UltraCart account. 
         * @summary Update a customer
         * @param {Customer} customer Customer to update
         * @param {number} customerProfileOid The customer_profile_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customer: Customer, customerProfileOid: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).updateCustomer(customer, customerProfileOid, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update email list subscriptions for a customer 
         * @summary Update email list subscriptions for a customer
         * @param {number} customerProfileOid The customer profile oid
         * @param {CustomerEmailListChanges} listChanges List changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerEmailLists(customerProfileOid: number, listChanges: CustomerEmailListChanges, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerEmailListChanges> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).updateCustomerEmailLists(customerProfileOid, listChanges, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a customer on the UltraCart account. 
         * @summary Delete a customer
         * @param {number} customerProfileOid The customer_profile_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerProfileOid: number, options?: any) {
            return CustomerApiFp(configuration).deleteCustomer(customerProfileOid, options)(fetch, basePath);
        },
        /**
         * Retrieves a single customer using the specified customer profile oid. 
         * @summary Retrieve a customer
         * @param {number} customerProfileOid The customer oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerProfileOid: number, expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomer(customerProfileOid, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers
         * @param {string} [email] Email
         * @param {string} [qbClass] Quickbooks class
         * @param {string} [quickbooksCode] Quickbooks code
         * @param {string} [lastModifiedDtsStart] Last modified date start
         * @param {string} [lastModifiedDtsEnd] Last modified date end
         * @param {string} [signupDtsStart] Signup date start
         * @param {string} [signupDtsEnd] Signup date end
         * @param {string} [billingFirstName] Billing first name
         * @param {string} [billingLastName] Billing last name
         * @param {string} [billingCompany] Billing company
         * @param {string} [billingCity] Billing city
         * @param {string} [billingState] Billing state
         * @param {string} [billingPostalCode] Billing postal code
         * @param {string} [billingCountryCode] Billing country code
         * @param {string} [billingDayPhone] Billing day phone
         * @param {string} [billingEveningPhone] Billing evening phone
         * @param {string} [shippingFirstName] Shipping first name
         * @param {string} [shippingLastName] Shipping last name
         * @param {string} [shippingCompany] Shipping company
         * @param {string} [shippingCity] Shipping city
         * @param {string} [shippingState] Shipping state
         * @param {string} [shippingPostalCode] Shipping postal code
         * @param {string} [shippingCountryCode] Shipping country code
         * @param {string} [shippingDayPhone] Shipping day phone
         * @param {string} [shippingEveningPhone] Shipping evening phone
         * @param {number} [pricingTierOid] Pricing tier oid
         * @param {string} [pricingTierName] Pricing tier name
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomers(email, qbClass, quickbooksCode, lastModifiedDtsStart, lastModifiedDtsEnd, signupDtsStart, signupDtsEnd, billingFirstName, billingLastName, billingCompany, billingCity, billingState, billingPostalCode, billingCountryCode, billingDayPhone, billingEveningPhone, shippingFirstName, shippingLastName, shippingCompany, shippingCity, shippingState, shippingPostalCode, shippingCountryCode, shippingDayPhone, shippingEveningPhone, pricingTierOid, pricingTierName, limit, offset, since, sort, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers by query
         * @param {CustomerQuery} customerQuery Customer query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByQuery(customerQuery: CustomerQuery, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomersByQuery(customerQuery, limit, offset, since, sort, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
         * @summary Retrieve customers for DataTables plugin
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersForDataTables(expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomersForDataTables(expand, options)(fetch, basePath);
        },
        /**
         * Retrieve values needed for a customer profile editor. 
         * @summary Retrieve values needed for a customer profile editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options?: any) {
            return CustomerApiFp(configuration).getEditorValues(options)(fetch, basePath);
        },
        /**
         * Retrieve all email lists across all storefronts 
         * @summary Retrieve all email lists across all storefronts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(options?: any) {
            return CustomerApiFp(configuration).getEmailLists(options)(fetch, basePath);
        },
        /**
         * Insert a customer on the UltraCart account. 
         * @summary Insert a customer
         * @param {Customer} customer Customer to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCustomer(customer: Customer, expand?: string, options?: any) {
            return CustomerApiFp(configuration).insertCustomer(customer, expand, options)(fetch, basePath);
        },
        /**
         * Update a customer on the UltraCart account. 
         * @summary Update a customer
         * @param {Customer} customer Customer to update
         * @param {number} customerProfileOid The customer_profile_oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customer: Customer, customerProfileOid: number, expand?: string, options?: any) {
            return CustomerApiFp(configuration).updateCustomer(customer, customerProfileOid, expand, options)(fetch, basePath);
        },
        /**
         * Update email list subscriptions for a customer 
         * @summary Update email list subscriptions for a customer
         * @param {number} customerProfileOid The customer profile oid
         * @param {CustomerEmailListChanges} listChanges List changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerEmailLists(customerProfileOid: number, listChanges: CustomerEmailListChanges, options?: any) {
            return CustomerApiFp(configuration).updateCustomerEmailLists(customerProfileOid, listChanges, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerApi - interface
 * @export
 * @interface CustomerApi
 */
export interface CustomerApiInterface {
    /**
     * Delete a customer on the UltraCart account. 
     * @summary Delete a customer
     * @param {number} customerProfileOid The customer_profile_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    deleteCustomer(customerProfileOid: number, options?: any): Promise<CustomerResponse>;

    /**
     * Retrieves a single customer using the specified customer profile oid. 
     * @summary Retrieve a customer
     * @param {number} customerProfileOid The customer oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomer(customerProfileOid: number, expand?: string, options?: any): Promise<CustomerResponse>;

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers
     * @param {string} [email] Email
     * @param {string} [qbClass] Quickbooks class
     * @param {string} [quickbooksCode] Quickbooks code
     * @param {string} [lastModifiedDtsStart] Last modified date start
     * @param {string} [lastModifiedDtsEnd] Last modified date end
     * @param {string} [signupDtsStart] Signup date start
     * @param {string} [signupDtsEnd] Signup date end
     * @param {string} [billingFirstName] Billing first name
     * @param {string} [billingLastName] Billing last name
     * @param {string} [billingCompany] Billing company
     * @param {string} [billingCity] Billing city
     * @param {string} [billingState] Billing state
     * @param {string} [billingPostalCode] Billing postal code
     * @param {string} [billingCountryCode] Billing country code
     * @param {string} [billingDayPhone] Billing day phone
     * @param {string} [billingEveningPhone] Billing evening phone
     * @param {string} [shippingFirstName] Shipping first name
     * @param {string} [shippingLastName] Shipping last name
     * @param {string} [shippingCompany] Shipping company
     * @param {string} [shippingCity] Shipping city
     * @param {string} [shippingState] Shipping state
     * @param {string} [shippingPostalCode] Shipping postal code
     * @param {string} [shippingCountryCode] Shipping country code
     * @param {string} [shippingDayPhone] Shipping day phone
     * @param {string} [shippingEveningPhone] Shipping evening phone
     * @param {number} [pricingTierOid] Pricing tier oid
     * @param {string} [pricingTierName] Pricing tier name
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomers(email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): Promise<CustomersResponse>;

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers by query
     * @param {CustomerQuery} customerQuery Customer query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomersByQuery(customerQuery: CustomerQuery, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any): Promise<CustomersResponse>;

    /**
     * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
     * @summary Retrieve customers for DataTables plugin
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomersForDataTables(expand?: string, options?: any): Promise<DataTablesServerSideResponse>;

    /**
     * Retrieve values needed for a customer profile editor. 
     * @summary Retrieve values needed for a customer profile editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getEditorValues(options?: any): Promise<CustomerEditorValues>;

    /**
     * Retrieve all email lists across all storefronts 
     * @summary Retrieve all email lists across all storefronts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getEmailLists(options?: any): Promise<EmailListsResponse>;

    /**
     * Insert a customer on the UltraCart account. 
     * @summary Insert a customer
     * @param {Customer} customer Customer to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    insertCustomer(customer: Customer, expand?: string, options?: any): Promise<CustomerResponse>;

    /**
     * Update a customer on the UltraCart account. 
     * @summary Update a customer
     * @param {Customer} customer Customer to update
     * @param {number} customerProfileOid The customer_profile_oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    updateCustomer(customer: Customer, customerProfileOid: number, expand?: string, options?: any): Promise<CustomerResponse>;

    /**
     * Update email list subscriptions for a customer 
     * @summary Update email list subscriptions for a customer
     * @param {number} customerProfileOid The customer profile oid
     * @param {CustomerEmailListChanges} listChanges List changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    updateCustomerEmailLists(customerProfileOid: number, listChanges: CustomerEmailListChanges, options?: any): Promise<CustomerEmailListChanges>;

}

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI implements CustomerApiInterface {
    /**
     * Delete a customer on the UltraCart account. 
     * @summary Delete a customer
     * @param {number} customerProfileOid The customer_profile_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public deleteCustomer(customerProfileOid: number, options?: any) {
        return CustomerApiFp(this.configuration).deleteCustomer(customerProfileOid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single customer using the specified customer profile oid. 
     * @summary Retrieve a customer
     * @param {number} customerProfileOid The customer oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomer(customerProfileOid: number, expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomer(customerProfileOid, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers
     * @param {string} [email] Email
     * @param {string} [qbClass] Quickbooks class
     * @param {string} [quickbooksCode] Quickbooks code
     * @param {string} [lastModifiedDtsStart] Last modified date start
     * @param {string} [lastModifiedDtsEnd] Last modified date end
     * @param {string} [signupDtsStart] Signup date start
     * @param {string} [signupDtsEnd] Signup date end
     * @param {string} [billingFirstName] Billing first name
     * @param {string} [billingLastName] Billing last name
     * @param {string} [billingCompany] Billing company
     * @param {string} [billingCity] Billing city
     * @param {string} [billingState] Billing state
     * @param {string} [billingPostalCode] Billing postal code
     * @param {string} [billingCountryCode] Billing country code
     * @param {string} [billingDayPhone] Billing day phone
     * @param {string} [billingEveningPhone] Billing evening phone
     * @param {string} [shippingFirstName] Shipping first name
     * @param {string} [shippingLastName] Shipping last name
     * @param {string} [shippingCompany] Shipping company
     * @param {string} [shippingCity] Shipping city
     * @param {string} [shippingState] Shipping state
     * @param {string} [shippingPostalCode] Shipping postal code
     * @param {string} [shippingCountryCode] Shipping country code
     * @param {string} [shippingDayPhone] Shipping day phone
     * @param {string} [shippingEveningPhone] Shipping evening phone
     * @param {number} [pricingTierOid] Pricing tier oid
     * @param {string} [pricingTierName] Pricing tier name
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomers(email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomers(email, qbClass, quickbooksCode, lastModifiedDtsStart, lastModifiedDtsEnd, signupDtsStart, signupDtsEnd, billingFirstName, billingLastName, billingCompany, billingCity, billingState, billingPostalCode, billingCountryCode, billingDayPhone, billingEveningPhone, shippingFirstName, shippingLastName, shippingCompany, shippingCity, shippingState, shippingPostalCode, shippingCountryCode, shippingDayPhone, shippingEveningPhone, pricingTierOid, pricingTierName, limit, offset, since, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers by query
     * @param {CustomerQuery} customerQuery Customer query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomersByQuery(customerQuery: CustomerQuery, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomersByQuery(customerQuery, limit, offset, since, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
     * @summary Retrieve customers for DataTables plugin
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomersForDataTables(expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomersForDataTables(expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve values needed for a customer profile editor. 
     * @summary Retrieve values needed for a customer profile editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getEditorValues(options?: any) {
        return CustomerApiFp(this.configuration).getEditorValues(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all email lists across all storefronts 
     * @summary Retrieve all email lists across all storefronts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getEmailLists(options?: any) {
        return CustomerApiFp(this.configuration).getEmailLists(options)(this.fetch, this.basePath);
    }

    /**
     * Insert a customer on the UltraCart account. 
     * @summary Insert a customer
     * @param {Customer} customer Customer to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public insertCustomer(customer: Customer, expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).insertCustomer(customer, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update a customer on the UltraCart account. 
     * @summary Update a customer
     * @param {Customer} customer Customer to update
     * @param {number} customerProfileOid The customer_profile_oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public updateCustomer(customer: Customer, customerProfileOid: number, expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).updateCustomer(customer, customerProfileOid, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update email list subscriptions for a customer 
     * @summary Update email list subscriptions for a customer
     * @param {number} customerProfileOid The customer profile oid
     * @param {CustomerEmailListChanges} listChanges List changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public updateCustomerEmailLists(customerProfileOid: number, listChanges: CustomerEmailListChanges, options?: any) {
        return CustomerApiFp(this.configuration).updateCustomerEmailLists(customerProfileOid, listChanges, options)(this.fetch, this.basePath);
    }

}

/**
 * FulfillmentApi - fetch parameter creator
 * @export
 */
export const FulfillmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
         * @summary Acknowledge receipt of orders.
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeOrders(distributionCenterCode: string, orderIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'distributionCenterCode' is not null or undefined
            if (distributionCenterCode === null || distributionCenterCode === undefined) {
                throw new RequiredError('distributionCenterCode','Required parameter distributionCenterCode was null or undefined when calling acknowledgeOrders.');
            }
            // verify required parameter 'orderIds' is not null or undefined
            if (orderIds === null || orderIds === undefined) {
                throw new RequiredError('orderIds','Required parameter orderIds was null or undefined when calling acknowledgeOrders.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/acknowledgements`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distributionCenterCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(orderIds || {}) : (orderIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
         * @summary Retrieve orders queued up for this distribution center.
         * @param {string} distributionCenterCode Distribution center code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenterOrders(distributionCenterCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'distributionCenterCode' is not null or undefined
            if (distributionCenterCode === null || distributionCenterCode === undefined) {
                throw new RequiredError('distributionCenterCode','Required parameter distributionCenterCode was null or undefined when calling getDistributionCenterOrders.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/orders`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distributionCenterCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the distribution centers that this user has access to. 
         * @summary Retrieve distribution centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenters(options: any = {}): FetchArgs {
            const localVarPath = `/fulfillment/distribution_centers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store the tracking information and mark the order shipped for this distribution center. 
         * @summary Mark orders as shipped
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipOrders(distributionCenterCode: string, shipments: Array<FulfillmentShipment>, options: any = {}): FetchArgs {
            // verify required parameter 'distributionCenterCode' is not null or undefined
            if (distributionCenterCode === null || distributionCenterCode === undefined) {
                throw new RequiredError('distributionCenterCode','Required parameter distributionCenterCode was null or undefined when calling shipOrders.');
            }
            // verify required parameter 'shipments' is not null or undefined
            if (shipments === null || shipments === undefined) {
                throw new RequiredError('shipments','Required parameter shipments was null or undefined when calling shipOrders.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/shipments`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distributionCenterCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FulfillmentShipment&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(shipments || {}) : (shipments || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the inventory for items associated with this distribution center 
         * @summary Update inventory
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(distributionCenterCode: string, inventories: Array<FulfillmentInventory>, options: any = {}): FetchArgs {
            // verify required parameter 'distributionCenterCode' is not null or undefined
            if (distributionCenterCode === null || distributionCenterCode === undefined) {
                throw new RequiredError('distributionCenterCode','Required parameter distributionCenterCode was null or undefined when calling updateInventory.');
            }
            // verify required parameter 'inventories' is not null or undefined
            if (inventories === null || inventories === undefined) {
                throw new RequiredError('inventories','Required parameter inventories was null or undefined when calling updateInventory.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/inventory`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distributionCenterCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FulfillmentInventory&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inventories || {}) : (inventories || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FulfillmentApi - functional programming interface
 * @export
 */
export const FulfillmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
         * @summary Acknowledge receipt of orders.
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeOrders(distributionCenterCode: string, orderIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).acknowledgeOrders(distributionCenterCode, orderIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
         * @summary Retrieve orders queued up for this distribution center.
         * @param {string} distributionCenterCode Distribution center code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenterOrders(distributionCenterCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).getDistributionCenterOrders(distributionCenterCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the distribution centers that this user has access to. 
         * @summary Retrieve distribution centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenters(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DistributionCentersResponse> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).getDistributionCenters(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store the tracking information and mark the order shipped for this distribution center. 
         * @summary Mark orders as shipped
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipOrders(distributionCenterCode: string, shipments: Array<FulfillmentShipment>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).shipOrders(distributionCenterCode, shipments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the inventory for items associated with this distribution center 
         * @summary Update inventory
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(distributionCenterCode: string, inventories: Array<FulfillmentInventory>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).updateInventory(distributionCenterCode, inventories, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FulfillmentApi - factory interface
 * @export
 */
export const FulfillmentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
         * @summary Acknowledge receipt of orders.
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeOrders(distributionCenterCode: string, orderIds: Array<string>, options?: any) {
            return FulfillmentApiFp(configuration).acknowledgeOrders(distributionCenterCode, orderIds, options)(fetch, basePath);
        },
        /**
         * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
         * @summary Retrieve orders queued up for this distribution center.
         * @param {string} distributionCenterCode Distribution center code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenterOrders(distributionCenterCode: string, options?: any) {
            return FulfillmentApiFp(configuration).getDistributionCenterOrders(distributionCenterCode, options)(fetch, basePath);
        },
        /**
         * Retrieves the distribution centers that this user has access to. 
         * @summary Retrieve distribution centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenters(options?: any) {
            return FulfillmentApiFp(configuration).getDistributionCenters(options)(fetch, basePath);
        },
        /**
         * Store the tracking information and mark the order shipped for this distribution center. 
         * @summary Mark orders as shipped
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipOrders(distributionCenterCode: string, shipments: Array<FulfillmentShipment>, options?: any) {
            return FulfillmentApiFp(configuration).shipOrders(distributionCenterCode, shipments, options)(fetch, basePath);
        },
        /**
         * Update the inventory for items associated with this distribution center 
         * @summary Update inventory
         * @param {string} distributionCenterCode Distribution center code
         * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(distributionCenterCode: string, inventories: Array<FulfillmentInventory>, options?: any) {
            return FulfillmentApiFp(configuration).updateInventory(distributionCenterCode, inventories, options)(fetch, basePath);
        },
    };
};

/**
 * FulfillmentApi - interface
 * @export
 * @interface FulfillmentApi
 */
export interface FulfillmentApiInterface {
    /**
     * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
     * @summary Acknowledge receipt of orders.
     * @param {string} distributionCenterCode Distribution center code
     * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    acknowledgeOrders(distributionCenterCode: string, orderIds: Array<string>, options?: any): Promise<{}>;

    /**
     * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
     * @summary Retrieve orders queued up for this distribution center.
     * @param {string} distributionCenterCode Distribution center code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    getDistributionCenterOrders(distributionCenterCode: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieves the distribution centers that this user has access to. 
     * @summary Retrieve distribution centers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    getDistributionCenters(options?: any): Promise<DistributionCentersResponse>;

    /**
     * Store the tracking information and mark the order shipped for this distribution center. 
     * @summary Mark orders as shipped
     * @param {string} distributionCenterCode Distribution center code
     * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    shipOrders(distributionCenterCode: string, shipments: Array<FulfillmentShipment>, options?: any): Promise<{}>;

    /**
     * Update the inventory for items associated with this distribution center 
     * @summary Update inventory
     * @param {string} distributionCenterCode Distribution center code
     * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    updateInventory(distributionCenterCode: string, inventories: Array<FulfillmentInventory>, options?: any): Promise<{}>;

}

/**
 * FulfillmentApi - object-oriented interface
 * @export
 * @class FulfillmentApi
 * @extends {BaseAPI}
 */
export class FulfillmentApi extends BaseAPI implements FulfillmentApiInterface {
    /**
     * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
     * @summary Acknowledge receipt of orders.
     * @param {string} distributionCenterCode Distribution center code
     * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public acknowledgeOrders(distributionCenterCode: string, orderIds: Array<string>, options?: any) {
        return FulfillmentApiFp(this.configuration).acknowledgeOrders(distributionCenterCode, orderIds, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
     * @summary Retrieve orders queued up for this distribution center.
     * @param {string} distributionCenterCode Distribution center code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getDistributionCenterOrders(distributionCenterCode: string, options?: any) {
        return FulfillmentApiFp(this.configuration).getDistributionCenterOrders(distributionCenterCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the distribution centers that this user has access to. 
     * @summary Retrieve distribution centers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getDistributionCenters(options?: any) {
        return FulfillmentApiFp(this.configuration).getDistributionCenters(options)(this.fetch, this.basePath);
    }

    /**
     * Store the tracking information and mark the order shipped for this distribution center. 
     * @summary Mark orders as shipped
     * @param {string} distributionCenterCode Distribution center code
     * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public shipOrders(distributionCenterCode: string, shipments: Array<FulfillmentShipment>, options?: any) {
        return FulfillmentApiFp(this.configuration).shipOrders(distributionCenterCode, shipments, options)(this.fetch, this.basePath);
    }

    /**
     * Update the inventory for items associated with this distribution center 
     * @summary Update inventory
     * @param {string} distributionCenterCode Distribution center code
     * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public updateInventory(distributionCenterCode: string, inventories: Array<FulfillmentInventory>, options?: any) {
        return FulfillmentApiFp(this.configuration).updateInventory(distributionCenterCode, inventories, options)(this.fetch, this.basePath);
    }

}

/**
 * ItemApi - fetch parameter creator
 * @export
 */
export const ItemApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an item on the UltraCart account. 
         * @summary Delete an item
         * @param {number} merchantItemOid The item oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(merchantItemOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'merchantItemOid' is not null or undefined
            if (merchantItemOid === null || merchantItemOid === undefined) {
                throw new RequiredError('merchantItemOid','Required parameter merchantItemOid was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/item/items/{merchant_item_oid}`
                .replace(`{${"merchant_item_oid"}}`, encodeURIComponent(String(merchantItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single item using the specified item oid. 
         * @summary Retrieve an item
         * @param {number} merchantItemOid The item oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(merchantItemOid: number, expand?: string, placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'merchantItemOid' is not null or undefined
            if (merchantItemOid === null || merchantItemOid === undefined) {
                throw new RequiredError('merchantItemOid','Required parameter merchantItemOid was null or undefined when calling getItem.');
            }
            const localVarPath = `/item/items/{merchant_item_oid}`
                .replace(`{${"merchant_item_oid"}}`, encodeURIComponent(String(merchantItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single item using the specified item id. 
         * @summary Retrieve an item by item id
         * @param {string} merchantItemId The item id to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByMerchantItemId(merchantItemId: string, expand?: string, placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'merchantItemId' is not null or undefined
            if (merchantItemId === null || merchantItemId === undefined) {
                throw new RequiredError('merchantItemId','Required parameter merchantItemId was null or undefined when calling getItemByMerchantItemId.');
            }
            const localVarPath = `/item/items/merchant_item_id/{merchant_item_id}`
                .replace(`{${"merchant_item_id"}}`, encodeURIComponent(String(merchantItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve items
         * @param {number} [parentCategoryId] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
         * @param {string} [parentCategoryPath] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
         * @param {number} [limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch items that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/item/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (parentCategoryId !== undefined) {
                localVarQueryParameter['parent_category_id'] = parentCategoryId;
            }

            if (parentCategoryPath !== undefined) {
                localVarQueryParameter['parent_category_path'] = parentCategoryPath;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['_since'] = since;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingTiers(expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/item/pricing_tiers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new item on the UltraCart account. 
         * @summary Create an item
         * @param {Item} item Item to create
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertItem(item: Item, expand?: string, placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling insertItem.');
            }
            const localVarPath = `/item/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Item" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item || {}) : (item || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a new item on the UltraCart account. 
         * @summary Update an item
         * @param {Item} item Item to update
         * @param {number} merchantItemOid The item oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling updateItem.');
            }
            // verify required parameter 'merchantItemOid' is not null or undefined
            if (merchantItemOid === null || merchantItemOid === undefined) {
                throw new RequiredError('merchantItemOid','Required parameter merchantItemOid was null or undefined when calling updateItem.');
            }
            const localVarPath = `/item/items/{merchant_item_oid}`
                .replace(`{${"merchant_item_oid"}}`, encodeURIComponent(String(merchantItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Item" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item || {}) : (item || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple item on the UltraCart account. 
         * @summary Update multiple items
         * @param {ItemsRequest} itemsRequest Items to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItems(itemsRequest: ItemsRequest, expand?: string, placeholders?: boolean, async?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'itemsRequest' is not null or undefined
            if (itemsRequest === null || itemsRequest === undefined) {
                throw new RequiredError('itemsRequest','Required parameter itemsRequest was null or undefined when calling updateItems.');
            }
            const localVarPath = `/item/items/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            if (async !== undefined) {
                localVarQueryParameter['_async'] = async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemsRequest || {}) : (itemsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
         * @summary Upload an image to the temporary multimedia.
         * @param {any} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryMultimedia(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadTemporaryMultimedia.');
            }
            const localVarPath = `/item/temp_multimedia`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete an item on the UltraCart account. 
         * @summary Delete an item
         * @param {number} merchantItemOid The item oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(merchantItemOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).deleteItem(merchantItemOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single item using the specified item oid. 
         * @summary Retrieve an item
         * @param {number} merchantItemOid The item oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getItem(merchantItemOid, expand, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single item using the specified item id. 
         * @summary Retrieve an item by item id
         * @param {string} merchantItemId The item id to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByMerchantItemId(merchantItemId: string, expand?: string, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getItemByMerchantItemId(merchantItemId, expand, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve items
         * @param {number} [parentCategoryId] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
         * @param {string} [parentCategoryPath] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
         * @param {number} [limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch items that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getItems(parentCategoryId, parentCategoryPath, limit, offset, since, sort, expand, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingTiers(expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PricingTiersResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getPricingTiers(expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new item on the UltraCart account. 
         * @summary Create an item
         * @param {Item} item Item to create
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertItem(item: Item, expand?: string, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).insertItem(item, expand, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a new item on the UltraCart account. 
         * @summary Update an item
         * @param {Item} item Item to update
         * @param {number} merchantItemOid The item oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).updateItem(item, merchantItemOid, expand, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update multiple item on the UltraCart account. 
         * @summary Update multiple items
         * @param {ItemsRequest} itemsRequest Items to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItems(itemsRequest: ItemsRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).updateItems(itemsRequest, expand, placeholders, async, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
         * @summary Upload an image to the temporary multimedia.
         * @param {any} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryMultimedia(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TempMultimediaResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).uploadTemporaryMultimedia(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete an item on the UltraCart account. 
         * @summary Delete an item
         * @param {number} merchantItemOid The item oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(merchantItemOid: number, options?: any) {
            return ItemApiFp(configuration).deleteItem(merchantItemOid, options)(fetch, basePath);
        },
        /**
         * Retrieves a single item using the specified item oid. 
         * @summary Retrieve an item
         * @param {number} merchantItemOid The item oid to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).getItem(merchantItemOid, expand, placeholders, options)(fetch, basePath);
        },
        /**
         * Retrieves a single item using the specified item id. 
         * @summary Retrieve an item by item id
         * @param {string} merchantItemId The item id to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByMerchantItemId(merchantItemId: string, expand?: string, placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).getItemByMerchantItemId(merchantItemId, expand, placeholders, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve items
         * @param {number} [parentCategoryId] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
         * @param {string} [parentCategoryPath] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
         * @param {number} [limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch items that have been created/modified since this date/time.
         * @param {string} [sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).getItems(parentCategoryId, parentCategoryPath, limit, offset, since, sort, expand, placeholders, options)(fetch, basePath);
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingTiers(expand?: string, options?: any) {
            return ItemApiFp(configuration).getPricingTiers(expand, options)(fetch, basePath);
        },
        /**
         * Create a new item on the UltraCart account. 
         * @summary Create an item
         * @param {Item} item Item to create
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertItem(item: Item, expand?: string, placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).insertItem(item, expand, placeholders, options)(fetch, basePath);
        },
        /**
         * Update a new item on the UltraCart account. 
         * @summary Update an item
         * @param {Item} item Item to update
         * @param {number} merchantItemOid The item oid to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).updateItem(item, merchantItemOid, expand, placeholders, options)(fetch, basePath);
        },
        /**
         * Update multiple item on the UltraCart account. 
         * @summary Update multiple items
         * @param {ItemsRequest} itemsRequest Items to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItems(itemsRequest: ItemsRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any) {
            return ItemApiFp(configuration).updateItems(itemsRequest, expand, placeholders, async, options)(fetch, basePath);
        },
        /**
         * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
         * @summary Upload an image to the temporary multimedia.
         * @param {any} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryMultimedia(file: any, options?: any) {
            return ItemApiFp(configuration).uploadTemporaryMultimedia(file, options)(fetch, basePath);
        },
    };
};

/**
 * ItemApi - interface
 * @export
 * @interface ItemApi
 */
export interface ItemApiInterface {
    /**
     * Delete an item on the UltraCart account. 
     * @summary Delete an item
     * @param {number} merchantItemOid The item oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    deleteItem(merchantItemOid: number, options?: any): Promise<{}>;

    /**
     * Retrieves a single item using the specified item oid. 
     * @summary Retrieve an item
     * @param {number} merchantItemOid The item oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getItem(merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Retrieves a single item using the specified item id. 
     * @summary Retrieve an item by item id
     * @param {string} merchantItemId The item id to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getItemByMerchantItemId(merchantItemId: string, expand?: string, placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve items
     * @param {number} [parentCategoryId] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
     * @param {string} [parentCategoryPath] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
     * @param {number} [limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch items that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getItems(parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean, options?: any): Promise<ItemsResponse>;

    /**
     * Retrieves the pricing tiers 
     * @summary Retrieve pricing tiers
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getPricingTiers(expand?: string, options?: any): Promise<PricingTiersResponse>;

    /**
     * Create a new item on the UltraCart account. 
     * @summary Create an item
     * @param {Item} item Item to create
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    insertItem(item: Item, expand?: string, placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Update a new item on the UltraCart account. 
     * @summary Update an item
     * @param {Item} item Item to update
     * @param {number} merchantItemOid The item oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    updateItem(item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Update multiple item on the UltraCart account. 
     * @summary Update multiple items
     * @param {ItemsRequest} itemsRequest Items to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    updateItems(itemsRequest: ItemsRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any): Promise<ItemsResponse>;

    /**
     * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
     * @summary Upload an image to the temporary multimedia.
     * @param {any} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    uploadTemporaryMultimedia(file: any, options?: any): Promise<TempMultimediaResponse>;

}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI implements ItemApiInterface {
    /**
     * Delete an item on the UltraCart account. 
     * @summary Delete an item
     * @param {number} merchantItemOid The item oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public deleteItem(merchantItemOid: number, options?: any) {
        return ItemApiFp(this.configuration).deleteItem(merchantItemOid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single item using the specified item oid. 
     * @summary Retrieve an item
     * @param {number} merchantItemOid The item oid to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItem(merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).getItem(merchantItemOid, expand, placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single item using the specified item id. 
     * @summary Retrieve an item by item id
     * @param {string} merchantItemId The item id to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItemByMerchantItemId(merchantItemId: string, expand?: string, placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).getItemByMerchantItemId(merchantItemId, expand, placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve items
     * @param {number} [parentCategoryId] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
     * @param {string} [parentCategoryPath] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
     * @param {number} [limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch items that have been created/modified since this date/time.
     * @param {string} [sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItems(parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).getItems(parentCategoryId, parentCategoryPath, limit, offset, since, sort, expand, placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the pricing tiers 
     * @summary Retrieve pricing tiers
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getPricingTiers(expand?: string, options?: any) {
        return ItemApiFp(this.configuration).getPricingTiers(expand, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new item on the UltraCart account. 
     * @summary Create an item
     * @param {Item} item Item to create
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public insertItem(item: Item, expand?: string, placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).insertItem(item, expand, placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Update a new item on the UltraCart account. 
     * @summary Update an item
     * @param {Item} item Item to update
     * @param {number} merchantItemOid The item oid to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItem(item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).updateItem(item, merchantItemOid, expand, placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Update multiple item on the UltraCart account. 
     * @summary Update multiple items
     * @param {ItemsRequest} itemsRequest Items to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItems(itemsRequest: ItemsRequest, expand?: string, placeholders?: boolean, async?: boolean, options?: any) {
        return ItemApiFp(this.configuration).updateItems(itemsRequest, expand, placeholders, async, options)(this.fetch, this.basePath);
    }

    /**
     * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
     * @summary Upload an image to the temporary multimedia.
     * @param {any} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public uploadTemporaryMultimedia(file: any, options?: any) {
        return ItemApiFp(this.configuration).uploadTemporaryMultimedia(file, options)(this.fetch, this.basePath);
    }

}

/**
 * OauthApi - fetch parameter creator
 * @export
 */
export const OauthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
         * @summary Exchange authorization code for access token.
         * @param {string} clientId The OAuth application client_id.
         * @param {string} grantType Type of grant
         * @param {string} [code] Authorization code received back from the browser redirect
         * @param {string} [redirectUri] The URI that you redirect the browser to to start the authorization process
         * @param {string} [refreshToken] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAccessToken(clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling oauthAccessToken.');
            }
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling oauthAccessToken.');
            }
            const localVarPath = `/oauth/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["ultrabooks_write", "auto_order_write", "coupon_read", "affiliate_read", "coupon_write", "tax_read", "fulfillment_write", "tax_write", "item_read", "fulfillment_read", "webhook_write", "chargeback_write", "user_write", "checkout_write", "storefront_read", "webhook_read", "item_write", "auto_order_read", "customer_read", "user_read", "customer_write", "order_read", "affiliate_write", "storefront_write", "ultrabooks_read", "order_write", "chargeback_read", "checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId as any);
            }

            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType as any);
            }

            if (code !== undefined) {
                localVarFormParams.set('code', code as any);
            }

            if (redirectUri !== undefined) {
                localVarFormParams.set('redirect_uri', redirectUri as any);
            }

            if (refreshToken !== undefined) {
                localVarFormParams.set('refresh_token', refreshToken as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes the OAuth application associated with the specified client_id and token. 
         * @summary Revoke this OAuth application.
         * @param {string} clientId The OAuth application client_id.
         * @param {string} token The OAuth access token that is to be revoked..
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke(clientId: string, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling oauthRevoke.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling oauthRevoke.');
            }
            const localVarPath = `/oauth/revoke`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["ultrabooks_write", "auto_order_write", "coupon_read", "affiliate_read", "coupon_write", "tax_read", "fulfillment_write", "tax_write", "item_read", "fulfillment_read", "webhook_write", "chargeback_write", "user_write", "checkout_write", "storefront_read", "webhook_read", "item_write", "auto_order_read", "customer_read", "user_read", "customer_write", "order_read", "affiliate_write", "storefront_write", "ultrabooks_read", "order_write", "chargeback_read", "checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (clientId !== undefined) {
                localVarFormParams.set('client_id', clientId as any);
            }

            if (token !== undefined) {
                localVarFormParams.set('token', token as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
         * @summary Exchange authorization code for access token.
         * @param {string} clientId The OAuth application client_id.
         * @param {string} grantType Type of grant
         * @param {string} [code] Authorization code received back from the browser redirect
         * @param {string} [redirectUri] The URI that you redirect the browser to to start the authorization process
         * @param {string} [refreshToken] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAccessToken(clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OauthTokenResponse> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauthAccessToken(clientId, grantType, code, redirectUri, refreshToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revokes the OAuth application associated with the specified client_id and token. 
         * @summary Revoke this OAuth application.
         * @param {string} clientId The OAuth application client_id.
         * @param {string} token The OAuth access token that is to be revoked..
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke(clientId: string, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OauthRevokeSuccessResponse> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauthRevoke(clientId, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
         * @summary Exchange authorization code for access token.
         * @param {string} clientId The OAuth application client_id.
         * @param {string} grantType Type of grant
         * @param {string} [code] Authorization code received back from the browser redirect
         * @param {string} [redirectUri] The URI that you redirect the browser to to start the authorization process
         * @param {string} [refreshToken] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAccessToken(clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string, options?: any) {
            return OauthApiFp(configuration).oauthAccessToken(clientId, grantType, code, redirectUri, refreshToken, options)(fetch, basePath);
        },
        /**
         * Revokes the OAuth application associated with the specified client_id and token. 
         * @summary Revoke this OAuth application.
         * @param {string} clientId The OAuth application client_id.
         * @param {string} token The OAuth access token that is to be revoked..
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke(clientId: string, token: string, options?: any) {
            return OauthApiFp(configuration).oauthRevoke(clientId, token, options)(fetch, basePath);
        },
    };
};

/**
 * OauthApi - interface
 * @export
 * @interface OauthApi
 */
export interface OauthApiInterface {
    /**
     * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
     * @summary Exchange authorization code for access token.
     * @param {string} clientId The OAuth application client_id.
     * @param {string} grantType Type of grant
     * @param {string} [code] Authorization code received back from the browser redirect
     * @param {string} [redirectUri] The URI that you redirect the browser to to start the authorization process
     * @param {string} [refreshToken] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApiInterface
     */
    oauthAccessToken(clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string, options?: any): Promise<OauthTokenResponse>;

    /**
     * Revokes the OAuth application associated with the specified client_id and token. 
     * @summary Revoke this OAuth application.
     * @param {string} clientId The OAuth application client_id.
     * @param {string} token The OAuth access token that is to be revoked..
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApiInterface
     */
    oauthRevoke(clientId: string, token: string, options?: any): Promise<OauthRevokeSuccessResponse>;

}

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI implements OauthApiInterface {
    /**
     * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
     * @summary Exchange authorization code for access token.
     * @param {string} clientId The OAuth application client_id.
     * @param {string} grantType Type of grant
     * @param {string} [code] Authorization code received back from the browser redirect
     * @param {string} [redirectUri] The URI that you redirect the browser to to start the authorization process
     * @param {string} [refreshToken] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauthAccessToken(clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string, options?: any) {
        return OauthApiFp(this.configuration).oauthAccessToken(clientId, grantType, code, redirectUri, refreshToken, options)(this.fetch, this.basePath);
    }

    /**
     * Revokes the OAuth application associated with the specified client_id and token. 
     * @summary Revoke this OAuth application.
     * @param {string} clientId The OAuth application client_id.
     * @param {string} token The OAuth access token that is to be revoked..
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauthRevoke(clientId: string, token: string, options?: any) {
        return OauthApiFp(this.configuration).oauthRevoke(clientId, token, options)(this.fetch, this.basePath);
    }

}

/**
 * OrderApi - fetch parameter creator
 * @export
 */
export const OrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order.  Returns true if successful. 
         * @summary Adjusts an order total
         * @param {string} orderId The order id to cancel.
         * @param {string} desiredTotal The desired total with no formatting. example 123.45
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustOrderTotal(orderId: string, desiredTotal: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling adjustOrderTotal.');
            }
            // verify required parameter 'desiredTotal' is not null or undefined
            if (desiredTotal === null || desiredTotal === undefined) {
                throw new RequiredError('desiredTotal','Required parameter desiredTotal was null or undefined when calling adjustOrderTotal.');
            }
            const localVarPath = `/order/orders/{order_id}/adjust_order_total/{desired_total}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"desired_total"}}`, encodeURIComponent(String(desiredTotal)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
         * @summary Cancel an order
         * @param {string} orderId The order id to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling cancelOrder.');
            }
            const localVarPath = `/order/orders/{order_id}/cancel`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an order on the UltraCart account. 
         * @summary Delete an order
         * @param {string} orderId The order id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling deleteOrder.');
            }
            const localVarPath = `/order/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Format the order for display at text or html 
         * @summary Format order
         * @param {string} orderId The order id to format
         * @param {OrderFormat} formatOptions Format options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        format(orderId: string, formatOptions: OrderFormat, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling format.');
            }
            // verify required parameter 'formatOptions' is not null or undefined
            if (formatOptions === null || formatOptions === undefined) {
                throw new RequiredError('formatOptions','Required parameter formatOptions was null or undefined when calling format.');
            }
            const localVarPath = `/order/orders/{order_id}/format`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderFormat" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(formatOptions || {}) : (formatOptions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
         * @summary Generate an order token for a given order id
         * @param {string} orderId The order id to generate a token for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOrderToken(orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling generateOrderToken.');
            }
            const localVarPath = `/order/orders/token/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryConfig(options: any = {}): FetchArgs {
            const localVarPath = `/order/accountsReceivableRetryConfig`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryStats(from?: string, to?: string, options: any = {}): FetchArgs {
            const localVarPath = `/order/accountsReceivableRetryConfig/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single order using the specified order id. 
         * @summary Retrieve an order
         * @param {string} orderId The order id to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrder.');
            }
            const localVarPath = `/order/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single order using the specified order token. 
         * @summary Retrieve an order using a token
         * @param {OrderByTokenQuery} orderByTokenQuery Order by token query
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByToken(orderByTokenQuery: OrderByTokenQuery, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderByTokenQuery' is not null or undefined
            if (orderByTokenQuery === null || orderByTokenQuery === undefined) {
                throw new RequiredError('orderByTokenQuery','Required parameter orderByTokenQuery was null or undefined when calling getOrderByToken.');
            }
            const localVarPath = `/order/orders/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderByTokenQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(orderByTokenQuery || {}) : (orderByTokenQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {string} [orderId] Order Id
         * @param {string} [paymentMethod] Payment Method
         * @param {string} [company] Company
         * @param {string} [firstName] First Name
         * @param {string} [lastName] Last Name
         * @param {string} [city] City
         * @param {string} [stateRegion] State/Region
         * @param {string} [postalCode] Postal Code
         * @param {string} [countryCode] Country Code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [ccEmail] CC Email
         * @param {number} [total] Total
         * @param {string} [screenBrandingThemeCode] Screen Branding Theme Code
         * @param {string} [storefrontHostName] StoreFront Host Name
         * @param {string} [creationDateBegin] Creation Date Begin
         * @param {string} [creationDateEnd] Creation Date End
         * @param {string} [paymentDateBegin] Payment Date Begin
         * @param {string} [paymentDateEnd] Payment Date End
         * @param {string} [shipmentDateBegin] Shipment Date Begin
         * @param {string} [shipmentDateEnd] Shipment Date End
         * @param {string} [rma] RMA
         * @param {string} [purchaseOrderNumber] Purchase Order Number
         * @param {string} [itemId] Item Id
         * @param {string} [currentStage] Current Stage
         * @param {string} [channelPartnerCode] Channel Partner Code
         * @param {string} [channelPartnerOrderId] Channel Partner Order ID
         * @param {number} [customerProfileOid] 
         * @param {string} [refundDateBegin] 
         * @param {string} [refundDateEnd] 
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, customerProfileOid?: number, refundDateBegin?: string, refundDateEnd?: string, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/order/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['order_id'] = orderId;
            }

            if (paymentMethod !== undefined) {
                localVarQueryParameter['payment_method'] = paymentMethod;
            }

            if (company !== undefined) {
                localVarQueryParameter['company'] = company;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (stateRegion !== undefined) {
                localVarQueryParameter['state_region'] = stateRegion;
            }

            if (postalCode !== undefined) {
                localVarQueryParameter['postal_code'] = postalCode;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (ccEmail !== undefined) {
                localVarQueryParameter['cc_email'] = ccEmail;
            }

            if (total !== undefined) {
                localVarQueryParameter['total'] = total;
            }

            if (screenBrandingThemeCode !== undefined) {
                localVarQueryParameter['screen_branding_theme_code'] = screenBrandingThemeCode;
            }

            if (storefrontHostName !== undefined) {
                localVarQueryParameter['storefront_host_name'] = storefrontHostName;
            }

            if (creationDateBegin !== undefined) {
                localVarQueryParameter['creation_date_begin'] = creationDateBegin;
            }

            if (creationDateEnd !== undefined) {
                localVarQueryParameter['creation_date_end'] = creationDateEnd;
            }

            if (paymentDateBegin !== undefined) {
                localVarQueryParameter['payment_date_begin'] = paymentDateBegin;
            }

            if (paymentDateEnd !== undefined) {
                localVarQueryParameter['payment_date_end'] = paymentDateEnd;
            }

            if (shipmentDateBegin !== undefined) {
                localVarQueryParameter['shipment_date_begin'] = shipmentDateBegin;
            }

            if (shipmentDateEnd !== undefined) {
                localVarQueryParameter['shipment_date_end'] = shipmentDateEnd;
            }

            if (rma !== undefined) {
                localVarQueryParameter['rma'] = rma;
            }

            if (purchaseOrderNumber !== undefined) {
                localVarQueryParameter['purchase_order_number'] = purchaseOrderNumber;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['item_id'] = itemId;
            }

            if (currentStage !== undefined) {
                localVarQueryParameter['current_stage'] = currentStage;
            }

            if (channelPartnerCode !== undefined) {
                localVarQueryParameter['channel_partner_code'] = channelPartnerCode;
            }

            if (channelPartnerOrderId !== undefined) {
                localVarQueryParameter['channel_partner_order_id'] = channelPartnerOrderId;
            }

            if (customerProfileOid !== undefined) {
                localVarQueryParameter['customer_profile_oid'] = customerProfileOid;
            }

            if (refundDateBegin !== undefined) {
                localVarQueryParameter['Refund Date Begin'] = refundDateBegin;
            }

            if (refundDateEnd !== undefined) {
                localVarQueryParameter['Refund Date End'] = refundDateEnd;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve order batch
         * @param {OrderQueryBatch} orderBatch Order batch
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBatch(orderBatch: OrderQueryBatch, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderBatch' is not null or undefined
            if (orderBatch === null || orderBatch === undefined) {
                throw new RequiredError('orderBatch','Required parameter orderBatch was null or undefined when calling getOrdersBatch.');
            }
            const localVarPath = `/order/orders/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderQueryBatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(orderBatch || {}) : (orderBatch || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {OrderQuery} orderQuery Order query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByQuery(orderQuery: OrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderQuery' is not null or undefined
            if (orderQuery === null || orderQuery === undefined) {
                throw new RequiredError('orderQuery','Required parameter orderQuery was null or undefined when calling getOrdersByQuery.');
            }
            const localVarPath = `/order/orders/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(orderQuery || {}) : (orderQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
         * @summary Insert an order
         * @param {Order} order Order to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertOrder(order: Order, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling insertOrder.');
            }
            const localVarPath = `/order/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process payment on order 
         * @summary Process payment
         * @param {string} orderId The order id to process payment on
         * @param {OrderProcessPaymentRequest} processPaymentRequest Process payment parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(orderId: string, processPaymentRequest: OrderProcessPaymentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling processPayment.');
            }
            // verify required parameter 'processPaymentRequest' is not null or undefined
            if (processPaymentRequest === null || processPaymentRequest === undefined) {
                throw new RequiredError('processPaymentRequest','Required parameter processPaymentRequest was null or undefined when calling processPayment.');
            }
            const localVarPath = `/order/orders/{order_id}/process_payment`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderProcessPaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(processPaymentRequest || {}) : (processPaymentRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a refund operation on an order and then update the order if successful 
         * @summary Refund an order
         * @param {Order} order Order to refund
         * @param {string} orderId The order id to refund.
         * @param {boolean} [rejectAfterRefund] Reject order after refund
         * @param {boolean} [skipCustomerNotification] Skip customer email notification
         * @param {boolean} [autoOrderCancel] Cancel associated auto orders
         * @param {boolean} [manualRefund] Consider a manual refund done externally
         * @param {boolean} [reverseAffiliateTransactions] Reverse affiliate transactions
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundOrder(order: Order, orderId: string, rejectAfterRefund?: boolean, skipCustomerNotification?: boolean, autoOrderCancel?: boolean, manualRefund?: boolean, reverseAffiliateTransactions?: boolean, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling refundOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling refundOrder.');
            }
            const localVarPath = `/order/orders/{order_id}/refund`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (rejectAfterRefund !== undefined) {
                localVarQueryParameter['reject_after_refund'] = rejectAfterRefund;
            }

            if (skipCustomerNotification !== undefined) {
                localVarQueryParameter['skip_customer_notification'] = skipCustomerNotification;
            }

            if (autoOrderCancel !== undefined) {
                localVarQueryParameter['auto_order_cancel'] = autoOrderCancel;
            }

            if (manualRefund !== undefined) {
                localVarQueryParameter['manual_refund'] = manualRefund;
            }

            if (reverseAffiliateTransactions !== undefined) {
                localVarQueryParameter['reverse_affiliate_transactions'] = reverseAffiliateTransactions;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a replacement order based upon a previous order 
         * @summary Replacement order
         * @param {string} orderId The order id to generate a replacement for.
         * @param {OrderReplacement} replacement Replacement order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacement(orderId: string, replacement: OrderReplacement, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling replacement.');
            }
            // verify required parameter 'replacement' is not null or undefined
            if (replacement === null || replacement === undefined) {
                throw new RequiredError('replacement','Required parameter replacement was null or undefined when calling replacement.');
            }
            const localVarPath = `/order/orders/{order_id}/replacement`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderReplacement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(replacement || {}) : (replacement || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend the receipt for an order on the UltraCart account. 
         * @summary Resend receipt
         * @param {string} orderId The order id to resend the receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReceipt(orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling resendReceipt.');
            }
            const localVarPath = `/order/orders/{order_id}/resend_receipt`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend shipment confirmation for an order on the UltraCart account. 
         * @summary Resend shipment confirmation
         * @param {string} orderId The order id to resend the shipment notification for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendShipmentConfirmation(orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling resendShipmentConfirmation.');
            }
            const localVarPath = `/order/orders/{order_id}/resend_shipment_confirmation`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Update A/R Retry Configuration
         * @param {AccountsReceivableRetryConfig} retryConfig AccountsReceivableRetryConfig object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountsReceivableRetryConfig(retryConfig: AccountsReceivableRetryConfig, options: any = {}): FetchArgs {
            // verify required parameter 'retryConfig' is not null or undefined
            if (retryConfig === null || retryConfig === undefined) {
                throw new RequiredError('retryConfig','Required parameter retryConfig was null or undefined when calling updateAccountsReceivableRetryConfig.');
            }
            const localVarPath = `/order/accountsReceivableRetryConfig`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccountsReceivableRetryConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(retryConfig || {}) : (retryConfig || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
         * @summary Update an order
         * @param {Order} order Order to update
         * @param {string} orderId The order id to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(order: Order, orderId: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling updateOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrder.');
            }
            const localVarPath = `/order/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order.  Returns true if successful. 
         * @summary Adjusts an order total
         * @param {string} orderId The order id to cancel.
         * @param {string} desiredTotal The desired total with no formatting. example 123.45
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustOrderTotal(orderId: string, desiredTotal: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).adjustOrderTotal(orderId, desiredTotal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
         * @summary Cancel an order
         * @param {string} orderId The order id to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).cancelOrder(orderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an order on the UltraCart account. 
         * @summary Delete an order
         * @param {string} orderId The order id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).deleteOrder(orderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Format the order for display at text or html 
         * @summary Format order
         * @param {string} orderId The order id to format
         * @param {OrderFormat} formatOptions Format options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        format(orderId: string, formatOptions: OrderFormat, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderFormatResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).format(orderId, formatOptions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
         * @summary Generate an order token for a given order id
         * @param {string} orderId The order id to generate a token for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOrderToken(orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderTokenResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).generateOrderToken(orderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryConfig(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountsReceivableRetryConfigResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getAccountsReceivableRetryConfig(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryStats(from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountsReceivableRetryStatsResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getAccountsReceivableRetryStats(from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single order using the specified order id. 
         * @summary Retrieve an order
         * @param {string} orderId The order id to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrder(orderId, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single order using the specified order token. 
         * @summary Retrieve an order using a token
         * @param {OrderByTokenQuery} orderByTokenQuery Order by token query
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByToken(orderByTokenQuery: OrderByTokenQuery, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrderByToken(orderByTokenQuery, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {string} [orderId] Order Id
         * @param {string} [paymentMethod] Payment Method
         * @param {string} [company] Company
         * @param {string} [firstName] First Name
         * @param {string} [lastName] Last Name
         * @param {string} [city] City
         * @param {string} [stateRegion] State/Region
         * @param {string} [postalCode] Postal Code
         * @param {string} [countryCode] Country Code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [ccEmail] CC Email
         * @param {number} [total] Total
         * @param {string} [screenBrandingThemeCode] Screen Branding Theme Code
         * @param {string} [storefrontHostName] StoreFront Host Name
         * @param {string} [creationDateBegin] Creation Date Begin
         * @param {string} [creationDateEnd] Creation Date End
         * @param {string} [paymentDateBegin] Payment Date Begin
         * @param {string} [paymentDateEnd] Payment Date End
         * @param {string} [shipmentDateBegin] Shipment Date Begin
         * @param {string} [shipmentDateEnd] Shipment Date End
         * @param {string} [rma] RMA
         * @param {string} [purchaseOrderNumber] Purchase Order Number
         * @param {string} [itemId] Item Id
         * @param {string} [currentStage] Current Stage
         * @param {string} [channelPartnerCode] Channel Partner Code
         * @param {string} [channelPartnerOrderId] Channel Partner Order ID
         * @param {number} [customerProfileOid] 
         * @param {string} [refundDateBegin] 
         * @param {string} [refundDateEnd] 
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, customerProfileOid?: number, refundDateBegin?: string, refundDateEnd?: string, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrders(orderId, paymentMethod, company, firstName, lastName, city, stateRegion, postalCode, countryCode, phone, email, ccEmail, total, screenBrandingThemeCode, storefrontHostName, creationDateBegin, creationDateEnd, paymentDateBegin, paymentDateEnd, shipmentDateBegin, shipmentDateEnd, rma, purchaseOrderNumber, itemId, currentStage, channelPartnerCode, channelPartnerOrderId, customerProfileOid, refundDateBegin, refundDateEnd, limit, offset, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve order batch
         * @param {OrderQueryBatch} orderBatch Order batch
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBatch(orderBatch: OrderQueryBatch, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrdersBatch(orderBatch, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {OrderQuery} orderQuery Order query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByQuery(orderQuery: OrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrdersByQuery(orderQuery, limit, offset, sort, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
         * @summary Insert an order
         * @param {Order} order Order to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertOrder(order: Order, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).insertOrder(order, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Process payment on order 
         * @summary Process payment
         * @param {string} orderId The order id to process payment on
         * @param {OrderProcessPaymentRequest} processPaymentRequest Process payment parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(orderId: string, processPaymentRequest: OrderProcessPaymentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProcessPaymentResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).processPayment(orderId, processPaymentRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a refund operation on an order and then update the order if successful 
         * @summary Refund an order
         * @param {Order} order Order to refund
         * @param {string} orderId The order id to refund.
         * @param {boolean} [rejectAfterRefund] Reject order after refund
         * @param {boolean} [skipCustomerNotification] Skip customer email notification
         * @param {boolean} [autoOrderCancel] Cancel associated auto orders
         * @param {boolean} [manualRefund] Consider a manual refund done externally
         * @param {boolean} [reverseAffiliateTransactions] Reverse affiliate transactions
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundOrder(order: Order, orderId: string, rejectAfterRefund?: boolean, skipCustomerNotification?: boolean, autoOrderCancel?: boolean, manualRefund?: boolean, reverseAffiliateTransactions?: boolean, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).refundOrder(order, orderId, rejectAfterRefund, skipCustomerNotification, autoOrderCancel, manualRefund, reverseAffiliateTransactions, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a replacement order based upon a previous order 
         * @summary Replacement order
         * @param {string} orderId The order id to generate a replacement for.
         * @param {OrderReplacement} replacement Replacement order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacement(orderId: string, replacement: OrderReplacement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderReplacementResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).replacement(orderId, replacement, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resend the receipt for an order on the UltraCart account. 
         * @summary Resend receipt
         * @param {string} orderId The order id to resend the receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReceipt(orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).resendReceipt(orderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resend shipment confirmation for an order on the UltraCart account. 
         * @summary Resend shipment confirmation
         * @param {string} orderId The order id to resend the shipment notification for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendShipmentConfirmation(orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).resendShipmentConfirmation(orderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Update A/R Retry Configuration
         * @param {AccountsReceivableRetryConfig} retryConfig AccountsReceivableRetryConfig object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountsReceivableRetryConfig(retryConfig: AccountsReceivableRetryConfig, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).updateAccountsReceivableRetryConfig(retryConfig, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
         * @summary Update an order
         * @param {Order} order Order to update
         * @param {string} orderId The order id to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(order: Order, orderId: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).updateOrder(order, orderId, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order.  Returns true if successful. 
         * @summary Adjusts an order total
         * @param {string} orderId The order id to cancel.
         * @param {string} desiredTotal The desired total with no formatting. example 123.45
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustOrderTotal(orderId: string, desiredTotal: string, options?: any) {
            return OrderApiFp(configuration).adjustOrderTotal(orderId, desiredTotal, options)(fetch, basePath);
        },
        /**
         * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
         * @summary Cancel an order
         * @param {string} orderId The order id to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any) {
            return OrderApiFp(configuration).cancelOrder(orderId, options)(fetch, basePath);
        },
        /**
         * Delete an order on the UltraCart account. 
         * @summary Delete an order
         * @param {string} orderId The order id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: string, options?: any) {
            return OrderApiFp(configuration).deleteOrder(orderId, options)(fetch, basePath);
        },
        /**
         * Format the order for display at text or html 
         * @summary Format order
         * @param {string} orderId The order id to format
         * @param {OrderFormat} formatOptions Format options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        format(orderId: string, formatOptions: OrderFormat, options?: any) {
            return OrderApiFp(configuration).format(orderId, formatOptions, options)(fetch, basePath);
        },
        /**
         * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
         * @summary Generate an order token for a given order id
         * @param {string} orderId The order id to generate a token for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOrderToken(orderId: string, options?: any) {
            return OrderApiFp(configuration).generateOrderToken(orderId, options)(fetch, basePath);
        },
        /**
         * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryConfig(options?: any) {
            return OrderApiFp(configuration).getAccountsReceivableRetryConfig(options)(fetch, basePath);
        },
        /**
         * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryStats(from?: string, to?: string, options?: any) {
            return OrderApiFp(configuration).getAccountsReceivableRetryStats(from, to, options)(fetch, basePath);
        },
        /**
         * Retrieves a single order using the specified order id. 
         * @summary Retrieve an order
         * @param {string} orderId The order id to retrieve.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrder(orderId, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single order using the specified order token. 
         * @summary Retrieve an order using a token
         * @param {OrderByTokenQuery} orderByTokenQuery Order by token query
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByToken(orderByTokenQuery: OrderByTokenQuery, expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrderByToken(orderByTokenQuery, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {string} [orderId] Order Id
         * @param {string} [paymentMethod] Payment Method
         * @param {string} [company] Company
         * @param {string} [firstName] First Name
         * @param {string} [lastName] Last Name
         * @param {string} [city] City
         * @param {string} [stateRegion] State/Region
         * @param {string} [postalCode] Postal Code
         * @param {string} [countryCode] Country Code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [ccEmail] CC Email
         * @param {number} [total] Total
         * @param {string} [screenBrandingThemeCode] Screen Branding Theme Code
         * @param {string} [storefrontHostName] StoreFront Host Name
         * @param {string} [creationDateBegin] Creation Date Begin
         * @param {string} [creationDateEnd] Creation Date End
         * @param {string} [paymentDateBegin] Payment Date Begin
         * @param {string} [paymentDateEnd] Payment Date End
         * @param {string} [shipmentDateBegin] Shipment Date Begin
         * @param {string} [shipmentDateEnd] Shipment Date End
         * @param {string} [rma] RMA
         * @param {string} [purchaseOrderNumber] Purchase Order Number
         * @param {string} [itemId] Item Id
         * @param {string} [currentStage] Current Stage
         * @param {string} [channelPartnerCode] Channel Partner Code
         * @param {string} [channelPartnerOrderId] Channel Partner Order ID
         * @param {number} [customerProfileOid] 
         * @param {string} [refundDateBegin] 
         * @param {string} [refundDateEnd] 
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, customerProfileOid?: number, refundDateBegin?: string, refundDateEnd?: string, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrders(orderId, paymentMethod, company, firstName, lastName, city, stateRegion, postalCode, countryCode, phone, email, ccEmail, total, screenBrandingThemeCode, storefrontHostName, creationDateBegin, creationDateEnd, paymentDateBegin, paymentDateEnd, shipmentDateBegin, shipmentDateEnd, rma, purchaseOrderNumber, itemId, currentStage, channelPartnerCode, channelPartnerOrderId, customerProfileOid, refundDateBegin, refundDateEnd, limit, offset, sort, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve order batch
         * @param {OrderQueryBatch} orderBatch Order batch
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBatch(orderBatch: OrderQueryBatch, expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrdersBatch(orderBatch, expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {OrderQuery} orderQuery Order query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByQuery(orderQuery: OrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrdersByQuery(orderQuery, limit, offset, sort, expand, options)(fetch, basePath);
        },
        /**
         * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
         * @summary Insert an order
         * @param {Order} order Order to insert
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertOrder(order: Order, expand?: string, options?: any) {
            return OrderApiFp(configuration).insertOrder(order, expand, options)(fetch, basePath);
        },
        /**
         * Process payment on order 
         * @summary Process payment
         * @param {string} orderId The order id to process payment on
         * @param {OrderProcessPaymentRequest} processPaymentRequest Process payment parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(orderId: string, processPaymentRequest: OrderProcessPaymentRequest, options?: any) {
            return OrderApiFp(configuration).processPayment(orderId, processPaymentRequest, options)(fetch, basePath);
        },
        /**
         * Perform a refund operation on an order and then update the order if successful 
         * @summary Refund an order
         * @param {Order} order Order to refund
         * @param {string} orderId The order id to refund.
         * @param {boolean} [rejectAfterRefund] Reject order after refund
         * @param {boolean} [skipCustomerNotification] Skip customer email notification
         * @param {boolean} [autoOrderCancel] Cancel associated auto orders
         * @param {boolean} [manualRefund] Consider a manual refund done externally
         * @param {boolean} [reverseAffiliateTransactions] Reverse affiliate transactions
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundOrder(order: Order, orderId: string, rejectAfterRefund?: boolean, skipCustomerNotification?: boolean, autoOrderCancel?: boolean, manualRefund?: boolean, reverseAffiliateTransactions?: boolean, expand?: string, options?: any) {
            return OrderApiFp(configuration).refundOrder(order, orderId, rejectAfterRefund, skipCustomerNotification, autoOrderCancel, manualRefund, reverseAffiliateTransactions, expand, options)(fetch, basePath);
        },
        /**
         * Create a replacement order based upon a previous order 
         * @summary Replacement order
         * @param {string} orderId The order id to generate a replacement for.
         * @param {OrderReplacement} replacement Replacement order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacement(orderId: string, replacement: OrderReplacement, options?: any) {
            return OrderApiFp(configuration).replacement(orderId, replacement, options)(fetch, basePath);
        },
        /**
         * Resend the receipt for an order on the UltraCart account. 
         * @summary Resend receipt
         * @param {string} orderId The order id to resend the receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReceipt(orderId: string, options?: any) {
            return OrderApiFp(configuration).resendReceipt(orderId, options)(fetch, basePath);
        },
        /**
         * Resend shipment confirmation for an order on the UltraCart account. 
         * @summary Resend shipment confirmation
         * @param {string} orderId The order id to resend the shipment notification for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendShipmentConfirmation(orderId: string, options?: any) {
            return OrderApiFp(configuration).resendShipmentConfirmation(orderId, options)(fetch, basePath);
        },
        /**
         * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Update A/R Retry Configuration
         * @param {AccountsReceivableRetryConfig} retryConfig AccountsReceivableRetryConfig object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountsReceivableRetryConfig(retryConfig: AccountsReceivableRetryConfig, options?: any) {
            return OrderApiFp(configuration).updateAccountsReceivableRetryConfig(retryConfig, options)(fetch, basePath);
        },
        /**
         * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
         * @summary Update an order
         * @param {Order} order Order to update
         * @param {string} orderId The order id to update.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(order: Order, orderId: string, expand?: string, options?: any) {
            return OrderApiFp(configuration).updateOrder(order, orderId, expand, options)(fetch, basePath);
        },
    };
};

/**
 * OrderApi - interface
 * @export
 * @interface OrderApi
 */
export interface OrderApiInterface {
    /**
     * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order.  Returns true if successful. 
     * @summary Adjusts an order total
     * @param {string} orderId The order id to cancel.
     * @param {string} desiredTotal The desired total with no formatting. example 123.45
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    adjustOrderTotal(orderId: string, desiredTotal: string, options?: any): Promise<BaseResponse>;

    /**
     * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
     * @summary Cancel an order
     * @param {string} orderId The order id to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    cancelOrder(orderId: string, options?: any): Promise<BaseResponse>;

    /**
     * Delete an order on the UltraCart account. 
     * @summary Delete an order
     * @param {string} orderId The order id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    deleteOrder(orderId: string, options?: any): Promise<{}>;

    /**
     * Format the order for display at text or html 
     * @summary Format order
     * @param {string} orderId The order id to format
     * @param {OrderFormat} formatOptions Format options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    format(orderId: string, formatOptions: OrderFormat, options?: any): Promise<OrderFormatResponse>;

    /**
     * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
     * @summary Generate an order token for a given order id
     * @param {string} orderId The order id to generate a token for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    generateOrderToken(orderId: string, options?: any): Promise<OrderTokenResponse>;

    /**
     * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getAccountsReceivableRetryConfig(options?: any): Promise<AccountsReceivableRetryConfigResponse>;

    /**
     * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Statistics
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getAccountsReceivableRetryStats(from?: string, to?: string, options?: any): Promise<AccountsReceivableRetryStatsResponse>;

    /**
     * Retrieves a single order using the specified order id. 
     * @summary Retrieve an order
     * @param {string} orderId The order id to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrder(orderId: string, expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Retrieves a single order using the specified order token. 
     * @summary Retrieve an order using a token
     * @param {OrderByTokenQuery} orderByTokenQuery Order by token query
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrderByToken(orderByTokenQuery: OrderByTokenQuery, expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param {string} [orderId] Order Id
     * @param {string} [paymentMethod] Payment Method
     * @param {string} [company] Company
     * @param {string} [firstName] First Name
     * @param {string} [lastName] Last Name
     * @param {string} [city] City
     * @param {string} [stateRegion] State/Region
     * @param {string} [postalCode] Postal Code
     * @param {string} [countryCode] Country Code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [ccEmail] CC Email
     * @param {number} [total] Total
     * @param {string} [screenBrandingThemeCode] Screen Branding Theme Code
     * @param {string} [storefrontHostName] StoreFront Host Name
     * @param {string} [creationDateBegin] Creation Date Begin
     * @param {string} [creationDateEnd] Creation Date End
     * @param {string} [paymentDateBegin] Payment Date Begin
     * @param {string} [paymentDateEnd] Payment Date End
     * @param {string} [shipmentDateBegin] Shipment Date Begin
     * @param {string} [shipmentDateEnd] Shipment Date End
     * @param {string} [rma] RMA
     * @param {string} [purchaseOrderNumber] Purchase Order Number
     * @param {string} [itemId] Item Id
     * @param {string} [currentStage] Current Stage
     * @param {string} [channelPartnerCode] Channel Partner Code
     * @param {string} [channelPartnerOrderId] Channel Partner Order ID
     * @param {number} [customerProfileOid] 
     * @param {string} [refundDateBegin] 
     * @param {string} [refundDateEnd] 
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrders(orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, customerProfileOid?: number, refundDateBegin?: string, refundDateEnd?: string, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve order batch
     * @param {OrderQueryBatch} orderBatch Order batch
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrdersBatch(orderBatch: OrderQueryBatch, expand?: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param {OrderQuery} orderQuery Order query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrdersByQuery(orderQuery: OrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any): Promise<OrdersResponse>;

    /**
     * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
     * @summary Insert an order
     * @param {Order} order Order to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    insertOrder(order: Order, expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Process payment on order 
     * @summary Process payment
     * @param {string} orderId The order id to process payment on
     * @param {OrderProcessPaymentRequest} processPaymentRequest Process payment parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    processPayment(orderId: string, processPaymentRequest: OrderProcessPaymentRequest, options?: any): Promise<OrderProcessPaymentResponse>;

    /**
     * Perform a refund operation on an order and then update the order if successful 
     * @summary Refund an order
     * @param {Order} order Order to refund
     * @param {string} orderId The order id to refund.
     * @param {boolean} [rejectAfterRefund] Reject order after refund
     * @param {boolean} [skipCustomerNotification] Skip customer email notification
     * @param {boolean} [autoOrderCancel] Cancel associated auto orders
     * @param {boolean} [manualRefund] Consider a manual refund done externally
     * @param {boolean} [reverseAffiliateTransactions] Reverse affiliate transactions
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    refundOrder(order: Order, orderId: string, rejectAfterRefund?: boolean, skipCustomerNotification?: boolean, autoOrderCancel?: boolean, manualRefund?: boolean, reverseAffiliateTransactions?: boolean, expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Create a replacement order based upon a previous order 
     * @summary Replacement order
     * @param {string} orderId The order id to generate a replacement for.
     * @param {OrderReplacement} replacement Replacement order details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    replacement(orderId: string, replacement: OrderReplacement, options?: any): Promise<OrderReplacementResponse>;

    /**
     * Resend the receipt for an order on the UltraCart account. 
     * @summary Resend receipt
     * @param {string} orderId The order id to resend the receipt for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    resendReceipt(orderId: string, options?: any): Promise<BaseResponse>;

    /**
     * Resend shipment confirmation for an order on the UltraCart account. 
     * @summary Resend shipment confirmation
     * @param {string} orderId The order id to resend the shipment notification for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    resendShipmentConfirmation(orderId: string, options?: any): Promise<BaseResponse>;

    /**
     * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Update A/R Retry Configuration
     * @param {AccountsReceivableRetryConfig} retryConfig AccountsReceivableRetryConfig object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    updateAccountsReceivableRetryConfig(retryConfig: AccountsReceivableRetryConfig, options?: any): Promise<BaseResponse>;

    /**
     * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
     * @summary Update an order
     * @param {Order} order Order to update
     * @param {string} orderId The order id to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    updateOrder(order: Order, orderId: string, expand?: string, options?: any): Promise<OrderResponse>;

}

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI implements OrderApiInterface {
    /**
     * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order.  Returns true if successful. 
     * @summary Adjusts an order total
     * @param {string} orderId The order id to cancel.
     * @param {string} desiredTotal The desired total with no formatting. example 123.45
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public adjustOrderTotal(orderId: string, desiredTotal: string, options?: any) {
        return OrderApiFp(this.configuration).adjustOrderTotal(orderId, desiredTotal, options)(this.fetch, this.basePath);
    }

    /**
     * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
     * @summary Cancel an order
     * @param {string} orderId The order id to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).cancelOrder(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an order on the UltraCart account. 
     * @summary Delete an order
     * @param {string} orderId The order id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public deleteOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).deleteOrder(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * Format the order for display at text or html 
     * @summary Format order
     * @param {string} orderId The order id to format
     * @param {OrderFormat} formatOptions Format options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public format(orderId: string, formatOptions: OrderFormat, options?: any) {
        return OrderApiFp(this.configuration).format(orderId, formatOptions, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
     * @summary Generate an order token for a given order id
     * @param {string} orderId The order id to generate a token for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public generateOrderToken(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).generateOrderToken(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getAccountsReceivableRetryConfig(options?: any) {
        return OrderApiFp(this.configuration).getAccountsReceivableRetryConfig(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Statistics
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getAccountsReceivableRetryStats(from?: string, to?: string, options?: any) {
        return OrderApiFp(this.configuration).getAccountsReceivableRetryStats(from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single order using the specified order id. 
     * @summary Retrieve an order
     * @param {string} orderId The order id to retrieve.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrder(orderId: string, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrder(orderId, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single order using the specified order token. 
     * @summary Retrieve an order using a token
     * @param {OrderByTokenQuery} orderByTokenQuery Order by token query
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderByToken(orderByTokenQuery: OrderByTokenQuery, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderByToken(orderByTokenQuery, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param {string} [orderId] Order Id
     * @param {string} [paymentMethod] Payment Method
     * @param {string} [company] Company
     * @param {string} [firstName] First Name
     * @param {string} [lastName] Last Name
     * @param {string} [city] City
     * @param {string} [stateRegion] State/Region
     * @param {string} [postalCode] Postal Code
     * @param {string} [countryCode] Country Code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [ccEmail] CC Email
     * @param {number} [total] Total
     * @param {string} [screenBrandingThemeCode] Screen Branding Theme Code
     * @param {string} [storefrontHostName] StoreFront Host Name
     * @param {string} [creationDateBegin] Creation Date Begin
     * @param {string} [creationDateEnd] Creation Date End
     * @param {string} [paymentDateBegin] Payment Date Begin
     * @param {string} [paymentDateEnd] Payment Date End
     * @param {string} [shipmentDateBegin] Shipment Date Begin
     * @param {string} [shipmentDateEnd] Shipment Date End
     * @param {string} [rma] RMA
     * @param {string} [purchaseOrderNumber] Purchase Order Number
     * @param {string} [itemId] Item Id
     * @param {string} [currentStage] Current Stage
     * @param {string} [channelPartnerCode] Channel Partner Code
     * @param {string} [channelPartnerOrderId] Channel Partner Order ID
     * @param {number} [customerProfileOid] 
     * @param {string} [refundDateBegin] 
     * @param {string} [refundDateEnd] 
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrders(orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, customerProfileOid?: number, refundDateBegin?: string, refundDateEnd?: string, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrders(orderId, paymentMethod, company, firstName, lastName, city, stateRegion, postalCode, countryCode, phone, email, ccEmail, total, screenBrandingThemeCode, storefrontHostName, creationDateBegin, creationDateEnd, paymentDateBegin, paymentDateEnd, shipmentDateBegin, shipmentDateEnd, rma, purchaseOrderNumber, itemId, currentStage, channelPartnerCode, channelPartnerOrderId, customerProfileOid, refundDateBegin, refundDateEnd, limit, offset, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve order batch
     * @param {OrderQueryBatch} orderBatch Order batch
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrdersBatch(orderBatch: OrderQueryBatch, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrdersBatch(orderBatch, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param {OrderQuery} orderQuery Order query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrdersByQuery(orderQuery: OrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrdersByQuery(orderQuery, limit, offset, sort, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
     * @summary Insert an order
     * @param {Order} order Order to insert
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public insertOrder(order: Order, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).insertOrder(order, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Process payment on order 
     * @summary Process payment
     * @param {string} orderId The order id to process payment on
     * @param {OrderProcessPaymentRequest} processPaymentRequest Process payment parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public processPayment(orderId: string, processPaymentRequest: OrderProcessPaymentRequest, options?: any) {
        return OrderApiFp(this.configuration).processPayment(orderId, processPaymentRequest, options)(this.fetch, this.basePath);
    }

    /**
     * Perform a refund operation on an order and then update the order if successful 
     * @summary Refund an order
     * @param {Order} order Order to refund
     * @param {string} orderId The order id to refund.
     * @param {boolean} [rejectAfterRefund] Reject order after refund
     * @param {boolean} [skipCustomerNotification] Skip customer email notification
     * @param {boolean} [autoOrderCancel] Cancel associated auto orders
     * @param {boolean} [manualRefund] Consider a manual refund done externally
     * @param {boolean} [reverseAffiliateTransactions] Reverse affiliate transactions
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public refundOrder(order: Order, orderId: string, rejectAfterRefund?: boolean, skipCustomerNotification?: boolean, autoOrderCancel?: boolean, manualRefund?: boolean, reverseAffiliateTransactions?: boolean, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).refundOrder(order, orderId, rejectAfterRefund, skipCustomerNotification, autoOrderCancel, manualRefund, reverseAffiliateTransactions, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Create a replacement order based upon a previous order 
     * @summary Replacement order
     * @param {string} orderId The order id to generate a replacement for.
     * @param {OrderReplacement} replacement Replacement order details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public replacement(orderId: string, replacement: OrderReplacement, options?: any) {
        return OrderApiFp(this.configuration).replacement(orderId, replacement, options)(this.fetch, this.basePath);
    }

    /**
     * Resend the receipt for an order on the UltraCart account. 
     * @summary Resend receipt
     * @param {string} orderId The order id to resend the receipt for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public resendReceipt(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).resendReceipt(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * Resend shipment confirmation for an order on the UltraCart account. 
     * @summary Resend shipment confirmation
     * @param {string} orderId The order id to resend the shipment notification for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public resendShipmentConfirmation(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).resendShipmentConfirmation(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Update A/R Retry Configuration
     * @param {AccountsReceivableRetryConfig} retryConfig AccountsReceivableRetryConfig object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateAccountsReceivableRetryConfig(retryConfig: AccountsReceivableRetryConfig, options?: any) {
        return OrderApiFp(this.configuration).updateAccountsReceivableRetryConfig(retryConfig, options)(this.fetch, this.basePath);
    }

    /**
     * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
     * @summary Update an order
     * @param {Order} order Order to update
     * @param {string} orderId The order id to update.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateOrder(order: Order, orderId: string, expand?: string, options?: any) {
        return OrderApiFp(this.configuration).updateOrder(order, orderId, expand, options)(this.fetch, this.basePath);
    }

}

/**
 * StorefrontApi - fetch parameter creator
 * @export
 */
export const StorefrontApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add to library
         * @param {AddLibraryItemRequest} addLibraryRequest New library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToLibrary(addLibraryRequest: AddLibraryItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'addLibraryRequest' is not null or undefined
            if (addLibraryRequest === null || addLibraryRequest === undefined) {
                throw new RequiredError('addLibraryRequest','Required parameter addLibraryRequest was null or undefined when calling addToLibrary.');
            }
            const localVarPath = `/storefront/code_library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddLibraryItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(addLibraryRequest || {}) : (addLibraryRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply library item to storefront.
         * @param {ApplyLibraryItemRequest} applyLibraryRequest New library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToStoreFront(applyLibraryRequest: ApplyLibraryItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applyLibraryRequest' is not null or undefined
            if (applyLibraryRequest === null || applyLibraryRequest === undefined) {
                throw new RequiredError('applyLibraryRequest','Required parameter applyLibraryRequest was null or undefined when calling applyToStoreFront.');
            }
            const localVarPath = `/storefront/code_library/apply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApplyLibraryItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(applyLibraryRequest || {}) : (applyLibraryRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailList(storefrontOid: number, emailListUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling archiveEmailList.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling archiveEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/archive`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailSegment(storefrontOid: number, emailSegmentUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling archiveEmailSegment.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling archiveEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/archive`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Back populate email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {EmailFlowBackPopulateRequest} backPopulateRequest The request to back populate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backPopulateEmailFlow(storefrontOid: number, emailFlowUuid: string, backPopulateRequest: EmailFlowBackPopulateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling backPopulateEmailFlow.');
            }
            // verify required parameter 'emailFlowUuid' is not null or undefined
            if (emailFlowUuid === null || emailFlowUuid === undefined) {
                throw new RequiredError('emailFlowUuid','Required parameter emailFlowUuid was null or undefined when calling backPopulateEmailFlow.');
            }
            // verify required parameter 'backPopulateRequest' is not null or undefined
            if (backPopulateRequest === null || backPopulateRequest === undefined) {
                throw new RequiredError('backPopulateRequest','Required parameter backPopulateRequest was null or undefined when calling backPopulateEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/backfill`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(emailFlowUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlowBackPopulateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(backPopulateRequest || {}) : (backPopulateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check download of email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} emailSegmentRebuildUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegmentRebuildUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling checkDownloadEmailSegment.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling checkDownloadEmailSegment.');
            }
            // verify required parameter 'emailSegmentRebuildUuid' is not null or undefined
            if (emailSegmentRebuildUuid === null || emailSegmentRebuildUuid === undefined) {
                throw new RequiredError('emailSegmentRebuildUuid','Required parameter emailSegmentRebuildUuid was null or undefined when calling checkDownloadEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/downloadPrepare/{email_segment_rebuild_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)))
                .replace(`{${"email_segment_rebuild_uuid"}}`, encodeURIComponent(String(emailSegmentRebuildUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clone email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {number} [targetStorefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailCampaign(storefrontOid: number, emailCampaignUuid: string, targetStorefrontOid?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling cloneEmailCampaign.');
            }
            // verify required parameter 'emailCampaignUuid' is not null or undefined
            if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
                throw new RequiredError('emailCampaignUuid','Required parameter emailCampaignUuid was null or undefined when calling cloneEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/clone`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(emailCampaignUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (targetStorefrontOid !== undefined) {
                localVarQueryParameter['target_storefront_oid'] = targetStorefrontOid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clone email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {number} [targetStorefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailFlow(storefrontOid: number, emailFlowUuid: string, targetStorefrontOid?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling cloneEmailFlow.');
            }
            // verify required parameter 'emailFlowUuid' is not null or undefined
            if (emailFlowUuid === null || emailFlowUuid === undefined) {
                throw new RequiredError('emailFlowUuid','Required parameter emailFlowUuid was null or undefined when calling cloneEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/clone`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(emailFlowUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (targetStorefrontOid !== undefined) {
                localVarQueryParameter['target_storefront_oid'] = targetStorefrontOid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSendingDomain(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling createEmailSendingDomain.');
            }
            const localVarPath = `/storefront/email/sending_domains/{domain}/create`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete communication sequence stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCommseqStat(storefrontOid: number, commseqUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling deleteEmailCommseqStat.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling deleteEmailCommseqStat.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stat`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailEmail(storefrontOid: number, commseqEmailUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling deleteEmailEmail.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling deleteEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email list customer
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListCustomer(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling deleteEmailListCustomer.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling deleteEmailListCustomer.');
            }
            // verify required parameter 'emailCustomerUuid' is not null or undefined
            if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
                throw new RequiredError('emailCustomerUuid','Required parameter emailCustomerUuid was null or undefined when calling deleteEmailListCustomer.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(emailCustomerUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling deleteEmailPostcard.');
            }
            // verify required parameter 'commseqPostcardUuid' is not null or undefined
            if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
                throw new RequiredError('commseqPostcardUuid','Required parameter commseqPostcardUuid was null or undefined when calling deleteEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseqPostcardUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSendingDomain(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling deleteEmailSendingDomain.');
            }
            const localVarPath = `/storefront/email/sending_domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete experiment
         * @param {number} storefrontOid 
         * @param {number} storefrontExperimentOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(storefrontOid: number, storefrontExperimentOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling deleteExperiment.');
            }
            // verify required parameter 'storefrontExperimentOid' is not null or undefined
            if (storefrontExperimentOid === null || storefrontExperimentOid === undefined) {
                throw new RequiredError('storefrontExperimentOid','Required parameter storefrontExperimentOid was null or undefined when calling deleteExperiment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"storefront_experiment_oid"}}`, encodeURIComponent(String(storefrontExperimentOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete library item
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItem(libraryItemOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'libraryItemOid' is not null or undefined
            if (libraryItemOid === null || libraryItemOid === undefined) {
                throw new RequiredError('libraryItemOid','Required parameter libraryItemOid was null or undefined when calling deleteLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(libraryItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Duplicate library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateLibraryItem(libraryItemOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'libraryItemOid' is not null or undefined
            if (libraryItemOid === null || libraryItemOid === undefined) {
                throw new RequiredError('libraryItemOid','Required parameter libraryItemOid was null or undefined when calling duplicateLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/duplicate`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(libraryItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtain lat/long for an address
         * @param {number} storefrontOid 
         * @param {GeocodeRequest} geocodeRequest geocode request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeAddress(storefrontOid: number, geocodeRequest: GeocodeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling geocodeAddress.');
            }
            // verify required parameter 'geocodeRequest' is not null or undefined
            if (geocodeRequest === null || geocodeRequest === undefined) {
                throw new RequiredError('geocodeRequest','Required parameter geocodeRequest was null or undefined when calling geocodeAddress.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/geocode`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GeocodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(geocodeRequest || {}) : (geocodeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of all the countries 
         * @summary Get countries
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getCountries.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/countries`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a temporary authentication token for the editor 
         * @summary Gets editor token
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorToken(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEditorToken.');
            }
            const localVarPath = `/storefront/{storefront_oid}/editor_token`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication base templates
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailBaseTemplates(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailBaseTemplates.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/baseTemplates`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCampaign.');
            }
            // verify required parameter 'emailCampaignUuid' is not null or undefined
            if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
                throw new RequiredError('emailCampaignUuid','Required parameter emailCampaignUuid was null or undefined when calling getEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(emailCampaignUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign screenshots
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignScreenshots(storefrontOid: number, emailCampaignUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCampaignScreenshots.');
            }
            // verify required parameter 'emailCampaignUuid' is not null or undefined
            if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
                throw new RequiredError('emailCampaignUuid','Required parameter emailCampaignUuid was null or undefined when calling getEmailCampaignScreenshots.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/screenshots`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(emailCampaignUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaigns
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaigns(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCampaigns.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaigns with stats
         * @param {number} storefrontOid 
         * @param {string} statDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignsWithStats(storefrontOid: number, statDays: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCampaignsWithStats.');
            }
            // verify required parameter 'statDays' is not null or undefined
            if (statDays === null || statDays === undefined) {
                throw new RequiredError('statDays','Required parameter statDays was null or undefined when calling getEmailCampaignsWithStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaignsWithStats/{stat_days}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"stat_days"}}`, encodeURIComponent(String(statDays)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email commseq
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseq(storefrontOid: number, commseqUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCommseq.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailCommseq.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence emails stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStatSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqEmailStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatSummaryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCommseqEmailStats.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailCommseqEmailStats.');
            }
            // verify required parameter 'statsRequest' is not null or undefined
            if (statsRequest === null || statsRequest === undefined) {
                throw new RequiredError('statsRequest','Required parameter statsRequest was null or undefined when calling getEmailCommseqEmailStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/emailStats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStatSummaryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(statsRequest || {}) : (statsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence postcard stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqPostcardStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatPostcardSummaryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCommseqPostcardStats.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailCommseqPostcardStats.');
            }
            // verify required parameter 'statsRequest' is not null or undefined
            if (statsRequest === null || statsRequest === undefined) {
                throw new RequiredError('statsRequest','Required parameter statsRequest was null or undefined when calling getEmailCommseqPostcardStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/postcardStats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStatPostcardSummaryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(statsRequest || {}) : (statsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get communication sequence stats overall
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStatOverall(storefrontOid: number, commseqUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCommseqStatOverall.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailCommseqStatOverall.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stat`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence step stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStepStatRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStepStatRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCommseqStepStats.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailCommseqStepStats.');
            }
            // verify required parameter 'statsRequest' is not null or undefined
            if (statsRequest === null || statsRequest === undefined) {
                throw new RequiredError('statsRequest','Required parameter statsRequest was null or undefined when calling getEmailCommseqStepStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stepStats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStepStatRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(statsRequest || {}) : (statsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence customers waiting at each requested step
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, waitingRequest: EmailStepWaitingRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCommseqStepWaiting.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailCommseqStepWaiting.');
            }
            // verify required parameter 'waitingRequest' is not null or undefined
            if (waitingRequest === null || waitingRequest === undefined) {
                throw new RequiredError('waitingRequest','Required parameter waitingRequest was null or undefined when calling getEmailCommseqStepWaiting.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/waiting`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStepWaitingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(waitingRequest || {}) : (waitingRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email commseqs
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqs(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCommseqs.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get customers editor URL
         * @param {number} storefrontOid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomerEditorUrl(storefrontOid: number, emailCustomerUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCustomerEditorUrl.');
            }
            // verify required parameter 'emailCustomerUuid' is not null or undefined
            if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
                throw new RequiredError('emailCustomerUuid','Required parameter emailCustomerUuid was null or undefined when calling getEmailCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/customers/{email_customer_uuid}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(emailCustomerUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email customers
         * @param {number} storefrontOid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [searchEmailPrefix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomers(storefrontOid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/customers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (searchEmailPrefix !== undefined) {
                localVarQueryParameter['searchEmailPrefix'] = searchEmailPrefix;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email dashboard activity
         * @param {number} storefrontOid 
         * @param {number} [lastRecords] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardActivity(storefrontOid: number, lastRecords?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailDashboardActivity.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/dashboard_activity`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (lastRecords !== undefined) {
                localVarQueryParameter['last_records'] = lastRecords;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard stats
         * @param {number} storefrontOid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardStats(storefrontOid: number, days?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailDashboardStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/dashboard_stats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmail(storefrontOid: number, commseqEmailUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailEmail.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling getEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email email clicks
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {string} commseqEmailUuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailClicks(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailEmailClicks.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailEmailClicks.');
            }
            // verify required parameter 'commseqStepUuid' is not null or undefined
            if (commseqStepUuid === null || commseqStepUuid === undefined) {
                throw new RequiredError('commseqStepUuid','Required parameter commseqStepUuid was null or undefined when calling getEmailEmailClicks.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling getEmailEmailClicks.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/steps/{commseq_step_uuid}/emails/{commseq_email_uuid}/clicks`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)))
                .replace(`{${"commseq_step_uuid"}}`, encodeURIComponent(String(commseqStepUuid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email order customer editor url
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailCustomerEditorUrl(storefrontOid: number, commseqEmailUuid: string, orderId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailEmailCustomerEditorUrl.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling getEmailEmailCustomerEditorUrl.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getEmailEmailCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/orders/{order_id}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)))
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email email orders
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {string} commseqEmailUuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailOrders(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailEmailOrders.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling getEmailEmailOrders.');
            }
            // verify required parameter 'commseqStepUuid' is not null or undefined
            if (commseqStepUuid === null || commseqStepUuid === undefined) {
                throw new RequiredError('commseqStepUuid','Required parameter commseqStepUuid was null or undefined when calling getEmailEmailOrders.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling getEmailEmailOrders.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/steps/{commseq_step_uuid}/emails/{commseq_email_uuid}/orders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)))
                .replace(`{${"commseq_step_uuid"}}`, encodeURIComponent(String(commseqStepUuid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email emails
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmails(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailEmails.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email emails multiple
         * @param {number} storefrontOid 
         * @param {EmailCommseqEmailsRequest} emailCommseqEmailsRequest Request of email uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailsMultiple(storefrontOid: number, emailCommseqEmailsRequest: EmailCommseqEmailsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailEmailsMultiple.');
            }
            // verify required parameter 'emailCommseqEmailsRequest' is not null or undefined
            if (emailCommseqEmailsRequest === null || emailCommseqEmailsRequest === undefined) {
                throw new RequiredError('emailCommseqEmailsRequest','Required parameter emailCommseqEmailsRequest was null or undefined when calling getEmailEmailsMultiple.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/multiple`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmailsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqEmailsRequest || {}) : (emailCommseqEmailsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlow(storefrontOid: number, emailFlowUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailFlow.');
            }
            // verify required parameter 'emailFlowUuid' is not null or undefined
            if (emailFlowUuid === null || emailFlowUuid === undefined) {
                throw new RequiredError('emailFlowUuid','Required parameter emailFlowUuid was null or undefined when calling getEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(emailFlowUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flow screenshots
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowScreenshots(storefrontOid: number, emailFlowUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailFlowScreenshots.');
            }
            // verify required parameter 'emailFlowUuid' is not null or undefined
            if (emailFlowUuid === null || emailFlowUuid === undefined) {
                throw new RequiredError('emailFlowUuid','Required parameter emailFlowUuid was null or undefined when calling getEmailFlowScreenshots.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/screenshots`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(emailFlowUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flows
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlows(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailFlows.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email globalsettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailGlobalSettings(options: any = {}): FetchArgs {
            const localVarPath = `/storefront/email/global_settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailList(storefrontOid: number, emailListUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailList.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling getEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email list customer editor url
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomerEditorUrl(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailListCustomerEditorUrl.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling getEmailListCustomerEditorUrl.');
            }
            // verify required parameter 'emailCustomerUuid' is not null or undefined
            if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
                throw new RequiredError('emailCustomerUuid','Required parameter emailCustomerUuid was null or undefined when calling getEmailListCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(emailCustomerUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email list customers
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomers(storefrontOid: number, emailListUuid: string, pageNumber?: number, pageSize?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailListCustomers.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling getEmailListCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email lists
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailLists.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email performance
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPerformance(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailPerformance.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/performance`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email plan
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPlan(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailPlan.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/plan`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailPostcard.');
            }
            // verify required parameter 'commseqPostcardUuid' is not null or undefined
            if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
                throw new RequiredError('commseqPostcardUuid','Required parameter commseqPostcardUuid was null or undefined when calling getEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseqPostcardUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email postcards
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcards(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailPostcards.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email postcards multiple
         * @param {number} storefrontOid 
         * @param {EmailCommseqPostcardsRequest} emailCommseqPostcardsRequest Request of postcard uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcardsMultiple(storefrontOid: number, emailCommseqPostcardsRequest: EmailCommseqPostcardsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailPostcardsMultiple.');
            }
            // verify required parameter 'emailCommseqPostcardsRequest' is not null or undefined
            if (emailCommseqPostcardsRequest === null || emailCommseqPostcardsRequest === undefined) {
                throw new RequiredError('emailCommseqPostcardsRequest','Required parameter emailCommseqPostcardsRequest was null or undefined when calling getEmailPostcardsMultiple.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/multiple`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcardsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqPostcardsRequest || {}) : (emailCommseqPostcardsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegment(storefrontOid: number, emailSegmentUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailSegment.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling getEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segment customers editor URL
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomerEditorUrl(storefrontOid: number, emailSegmentUuid: string, emailCustomerUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
            }
            // verify required parameter 'emailCustomerUuid' is not null or undefined
            if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
                throw new RequiredError('emailCustomerUuid','Required parameter emailCustomerUuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers/{email_customer_uuid}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(emailCustomerUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segment customers
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, pageNumber?: number, pageSize?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailSegmentCustomers.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling getEmailSegmentCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segments
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegments(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailSegments.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email sending domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomain(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling getEmailSendingDomain.');
            }
            const localVarPath = `/storefront/email/sending_domain/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email sending domain status
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomainStatus(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling getEmailSendingDomainStatus.');
            }
            const localVarPath = `/storefront/email/sending_domains/{domain}/status`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email sending domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomains(options: any = {}): FetchArgs {
            const localVarPath = `/storefront/email/sending_domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email settings
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSettings(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailSettings.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/settings`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email template
         * @param {number} storefrontOid 
         * @param {number} emailTemplateOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate(storefrontOid: number, emailTemplateOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailTemplate.');
            }
            // verify required parameter 'emailTemplateOid' is not null or undefined
            if (emailTemplateOid === null || emailTemplateOid === undefined) {
                throw new RequiredError('emailTemplateOid','Required parameter emailTemplateOid was null or undefined when calling getEmailTemplate.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/templates/{email_template_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_template_oid"}}`, encodeURIComponent(String(emailTemplateOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email templates
         * @param {number} storefrontOid 
         * @param {string} [triggerType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplates(storefrontOid: number, triggerType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailTemplates.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/templates`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (triggerType !== undefined) {
                localVarQueryParameter['trigger_type'] = triggerType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of third party email providers
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailThirdPartyProviders(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getEmailThirdPartyProviders.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/third_party_providers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiments
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getExperiments.');
            }
            const localVarPath = `/storefront/{storefront_oid}/experiments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of property names for a given property type 
         * @summary Get histogram property names
         * @param {number} storefrontOid 
         * @param {string} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyNames(storefrontOid: number, propertyType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getHistogramPropertyNames.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/histogram/property_names`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (propertyType !== undefined) {
                localVarQueryParameter['property_type'] = propertyType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of property values for a given property name and type 
         * @summary Get histogram property values
         * @param {number} storefrontOid 
         * @param {string} [propertyName] 
         * @param {string} [propertyType] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyValues(storefrontOid: number, propertyName?: string, propertyType?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getHistogramPropertyValues.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/histogram/property_values`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (propertyName !== undefined) {
                localVarQueryParameter['property_name'] = propertyName;
            }

            if (propertyType !== undefined) {
                localVarQueryParameter['property_type'] = propertyType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get library values used to populate drop down boxes for filtering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryFilterValues(options: any = {}): FetchArgs {
            const localVarPath = `/storefront/code_library/filter_values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItem(libraryItemOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'libraryItemOid' is not null or undefined
            if (libraryItemOid === null || libraryItemOid === undefined) {
                throw new RequiredError('libraryItemOid','Required parameter libraryItemOid was null or undefined when calling getLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(libraryItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get thumbnail parameters
         * @param {ThumbnailParametersRequest} thumbnailParameters Thumbnail Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailParameters(thumbnailParameters: ThumbnailParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'thumbnailParameters' is not null or undefined
            if (thumbnailParameters === null || thumbnailParameters === undefined) {
                throw new RequiredError('thumbnailParameters','Required parameter thumbnailParameters was null or undefined when calling getThumbnailParameters.');
            }
            const localVarPath = `/storefront/thumbnailParameters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ThumbnailParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(thumbnailParameters || {}) : (thumbnailParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a transactional email 
         * @summary Gets a transaction email object
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmail(storefrontOid: number, emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getTransactionEmail.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling getTransactionEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list/{email_id}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of all transactional emails and return back just their names 
         * @summary Gets a list of transaction email names
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailList(storefrontOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getTransactionEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactional email screenshots
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailScreenshots(storefrontOid: number, emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling getTransactionEmailScreenshots.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling getTransactionEmailScreenshots.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list/{email_id}/screenshots`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Globally unsubscribe a customer
         * @param {number} storefrontOid 
         * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnsubscribe(storefrontOid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling globalUnsubscribe.');
            }
            // verify required parameter 'unsubscribe' is not null or undefined
            if (unsubscribe === null || unsubscribe === undefined) {
                throw new RequiredError('unsubscribe','Required parameter unsubscribe was null or undefined when calling globalUnsubscribe.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/globalUnsubscribe`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailGlobalUnsubscribeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(unsubscribe || {}) : (unsubscribe || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a third party provider list
         * @param {number} storefrontOid 
         * @param {EmailThirdPartyListImportRequest} importRequest lists to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmailThirdPartyProviderList(storefrontOid: number, importRequest: EmailThirdPartyListImportRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling importEmailThirdPartyProviderList.');
            }
            // verify required parameter 'importRequest' is not null or undefined
            if (importRequest === null || importRequest === undefined) {
                throw new RequiredError('importRequest','Required parameter importRequest was null or undefined when calling importEmailThirdPartyProviderList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/third_party_providers/import`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailThirdPartyListImportRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(importRequest || {}) : (importRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email campaign
         * @param {number} storefrontOid 
         * @param {EmailCampaign} emailCampaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaign(storefrontOid: number, emailCampaign: EmailCampaign, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling insertEmailCampaign.');
            }
            // verify required parameter 'emailCampaign' is not null or undefined
            if (emailCampaign === null || emailCampaign === undefined) {
                throw new RequiredError('emailCampaign','Required parameter emailCampaign was null or undefined when calling insertEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCampaign" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCampaign || {}) : (emailCampaign || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email commseq
         * @param {number} storefrontOid 
         * @param {EmailCommseq} emailCommseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCommseq(storefrontOid: number, emailCommseq: EmailCommseq, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling insertEmailCommseq.');
            }
            // verify required parameter 'emailCommseq' is not null or undefined
            if (emailCommseq === null || emailCommseq === undefined) {
                throw new RequiredError('emailCommseq','Required parameter emailCommseq was null or undefined when calling insertEmailCommseq.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseq || {}) : (emailCommseq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email email
         * @param {number} storefrontOid 
         * @param {EmailCommseqEmail} emailCommseqEmail Email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailEmail(storefrontOid: number, emailCommseqEmail: EmailCommseqEmail, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling insertEmailEmail.');
            }
            // verify required parameter 'emailCommseqEmail' is not null or undefined
            if (emailCommseqEmail === null || emailCommseqEmail === undefined) {
                throw new RequiredError('emailCommseqEmail','Required parameter emailCommseqEmail was null or undefined when calling insertEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqEmail || {}) : (emailCommseqEmail || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email flow
         * @param {number} storefrontOid 
         * @param {EmailFlow} emailFlow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlow(storefrontOid: number, emailFlow: EmailFlow, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling insertEmailFlow.');
            }
            // verify required parameter 'emailFlow' is not null or undefined
            if (emailFlow === null || emailFlow === undefined) {
                throw new RequiredError('emailFlow','Required parameter emailFlow was null or undefined when calling insertEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlow" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailFlow || {}) : (emailFlow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email list
         * @param {number} storefrontOid 
         * @param {EmailList} emailList Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailList(storefrontOid: number, emailList: EmailList, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling insertEmailList.');
            }
            // verify required parameter 'emailList' is not null or undefined
            if (emailList === null || emailList === undefined) {
                throw new RequiredError('emailList','Required parameter emailList was null or undefined when calling insertEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailList" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailList || {}) : (emailList || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email postcard
         * @param {number} storefrontOid 
         * @param {EmailCommseqPostcard} emailCommseqPostcard Email postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailPostcard(storefrontOid: number, emailCommseqPostcard: EmailCommseqPostcard, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling insertEmailPostcard.');
            }
            // verify required parameter 'emailCommseqPostcard' is not null or undefined
            if (emailCommseqPostcard === null || emailCommseqPostcard === undefined) {
                throw new RequiredError('emailCommseqPostcard','Required parameter emailCommseqPostcard was null or undefined when calling insertEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqPostcard || {}) : (emailCommseqPostcard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email segment
         * @param {number} storefrontOid 
         * @param {EmailSegment} emailSegment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailSegment(storefrontOid: number, emailSegment: EmailSegment, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling insertEmailSegment.');
            }
            // verify required parameter 'emailSegment' is not null or undefined
            if (emailSegment === null || emailSegment === undefined) {
                throw new RequiredError('emailSegment','Required parameter emailSegment was null or undefined when calling insertEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailSegment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailSegment || {}) : (emailSegment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare download of email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling prepareDownloadEmailSegment.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling prepareDownloadEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/downloadPrepare`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishLibraryItem(libraryItemOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'libraryItemOid' is not null or undefined
            if (libraryItemOid === null || libraryItemOid === undefined) {
                throw new RequiredError('libraryItemOid','Required parameter libraryItemOid was null or undefined when calling publishLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/publish`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(libraryItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase public library item, which creates a copy of the item in your personal code library
         * @param {number} libraryItemOid 
         * @param {number} [storefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLibraryItem(libraryItemOid: number, storefrontOid?: number, options: any = {}): FetchArgs {
            // verify required parameter 'libraryItemOid' is not null or undefined
            if (libraryItemOid === null || libraryItemOid === undefined) {
                throw new RequiredError('libraryItemOid','Required parameter libraryItemOid was null or undefined when calling purchaseLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/purchase`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(libraryItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (storefrontOid !== undefined) {
                localVarQueryParameter['storefront_oid'] = storefrontOid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Release email communication sequence customers waiting at the specified step
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling releaseEmailCommseqStepWaiting.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling releaseEmailCommseqStepWaiting.');
            }
            // verify required parameter 'commseqStepUuid' is not null or undefined
            if (commseqStepUuid === null || commseqStepUuid === undefined) {
                throw new RequiredError('commseqStepUuid','Required parameter commseqStepUuid was null or undefined when calling releaseEmailCommseqStepWaiting.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/waiting/{commseq_step_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)))
                .replace(`{${"commseq_step_uuid"}}`, encodeURIComponent(String(commseqStepUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a review of an email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailReviewRequest Email commseq email review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        review(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailReviewRequest: EmailCommseqEmailSendTestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling review.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling review.');
            }
            // verify required parameter 'emailCommseqEmailReviewRequest' is not null or undefined
            if (emailCommseqEmailReviewRequest === null || emailCommseqEmailReviewRequest === undefined) {
                throw new RequiredError('emailCommseqEmailReviewRequest','Required parameter emailCommseqEmailReviewRequest was null or undefined when calling review.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/review`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmailSendTestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqEmailReviewRequest || {}) : (emailCommseqEmailReviewRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Searches for all matching values
         * @param {string} [category] 
         * @param {string} [matches] 
         * @param {string} [storefrontOid] 
         * @param {number} [maxHits] 
         * @param {string} [subcategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(category?: string, matches?: string, storefrontOid?: string, maxHits?: number, subcategory?: string, options: any = {}): FetchArgs {
            const localVarPath = `/storefront/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (matches !== undefined) {
                localVarQueryParameter['matches'] = matches;
            }

            if (storefrontOid !== undefined) {
                localVarQueryParameter['storefront_oid'] = storefrontOid;
            }

            if (maxHits !== undefined) {
                localVarQueryParameter['max_hits'] = maxHits;
            }

            if (subcategory !== undefined) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Searches for all matching values (using POST)
         * @param {LookupRequest} lookupRequest LookupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(lookupRequest: LookupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'lookupRequest' is not null or undefined
            if (lookupRequest === null || lookupRequest === undefined) {
                throw new RequiredError('lookupRequest','Required parameter lookupRequest was null or undefined when calling search2.');
            }
            const localVarPath = `/storefront/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(lookupRequest || {}) : (lookupRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search email list customers
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailListCustomers(storefrontOid: number, emailListUuid: string, startsWith?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling searchEmailListCustomers.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling searchEmailListCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/search`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (startsWith !== undefined) {
                localVarQueryParameter['startsWith'] = startsWith;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search email segment customers
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, startsWith?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling searchEmailSegmentCustomers.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling searchEmailSegmentCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/search`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (startsWith !== undefined) {
                localVarQueryParameter['startsWith'] = startsWith;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLibraryItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemQuery' is not null or undefined
            if (itemQuery === null || itemQuery === undefined) {
                throw new RequiredError('itemQuery','Required parameter itemQuery was null or undefined when calling searchLibraryItems.');
            }
            const localVarPath = `/storefront/code_library/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemQuery || {}) : (itemQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPublishedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemQuery' is not null or undefined
            if (itemQuery === null || itemQuery === undefined) {
                throw new RequiredError('itemQuery','Required parameter itemQuery was null or undefined when calling searchPublishedItems.');
            }
            const localVarPath = `/storefront/code_library/search_published`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemQuery || {}) : (itemQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items needing review or rejected
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReviewItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemQuery' is not null or undefined
            if (itemQuery === null || itemQuery === undefined) {
                throw new RequiredError('itemQuery','Required parameter itemQuery was null or undefined when calling searchReviewItems.');
            }
            const localVarPath = `/storefront/code_library/search_review`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemQuery || {}) : (itemQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSharedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemQuery' is not null or undefined
            if (itemQuery === null || itemQuery === undefined) {
                throw new RequiredError('itemQuery','Required parameter itemQuery was null or undefined when calling searchSharedItems.');
            }
            const localVarPath = `/storefront/code_library/search_shared`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemQuery || {}) : (itemQuery || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send email test
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailTestRequest Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailTest(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailTestRequest: EmailCommseqEmailSendTestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling sendEmailTest.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling sendEmailTest.');
            }
            // verify required parameter 'emailCommseqEmailTestRequest' is not null or undefined
            if (emailCommseqEmailTestRequest === null || emailCommseqEmailTestRequest === undefined) {
                throw new RequiredError('emailCommseqEmailTestRequest','Required parameter emailCommseqEmailTestRequest was null or undefined when calling sendEmailTest.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/test`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmailSendTestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqEmailTestRequest || {}) : (emailCommseqEmailTestRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send postcard test
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {EmailCommseqPostcardSendTestRequest} emailCommseqPostcardTestRequest Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPostcardTest(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcardTestRequest: EmailCommseqPostcardSendTestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling sendPostcardTest.');
            }
            // verify required parameter 'commseqPostcardUuid' is not null or undefined
            if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
                throw new RequiredError('commseqPostcardUuid','Required parameter commseqPostcardUuid was null or undefined when calling sendPostcardTest.');
            }
            // verify required parameter 'emailCommseqPostcardTestRequest' is not null or undefined
            if (emailCommseqPostcardTestRequest === null || emailCommseqPostcardTestRequest === undefined) {
                throw new RequiredError('emailCommseqPostcardTestRequest','Required parameter emailCommseqPostcardTestRequest was null or undefined when calling sendPostcardTest.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}/test`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseqPostcardUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcardSendTestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqPostcardTestRequest || {}) : (emailCommseqPostcardTestRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling startEmailCampaign.');
            }
            // verify required parameter 'emailCampaignUuid' is not null or undefined
            if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
                throw new RequiredError('emailCampaignUuid','Required parameter emailCampaignUuid was null or undefined when calling startEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/start`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(emailCampaignUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe customers to email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {Array<EmailCustomer>} customers Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEmailList(storefrontOid: number, emailListUuid: string, customers: Array<EmailCustomer>, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling subscribeToEmailList.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling subscribeToEmailList.');
            }
            // verify required parameter 'customers' is not null or undefined
            if (customers === null || customers === undefined) {
                throw new RequiredError('customers','Required parameter customers was null or undefined when calling subscribeToEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/subscribe`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;EmailCustomer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customers || {}) : (customers || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {EmailCampaign} emailCampaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaign(storefrontOid: number, emailCampaignUuid: string, emailCampaign: EmailCampaign, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailCampaign.');
            }
            // verify required parameter 'emailCampaignUuid' is not null or undefined
            if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
                throw new RequiredError('emailCampaignUuid','Required parameter emailCampaignUuid was null or undefined when calling updateEmailCampaign.');
            }
            // verify required parameter 'emailCampaign' is not null or undefined
            if (emailCampaign === null || emailCampaign === undefined) {
                throw new RequiredError('emailCampaign','Required parameter emailCampaign was null or undefined when calling updateEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(emailCampaignUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCampaign" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCampaign || {}) : (emailCampaign || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email commseq
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailCommseq} emailCommseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCommseq(storefrontOid: number, commseqUuid: string, emailCommseq: EmailCommseq, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailCommseq.');
            }
            // verify required parameter 'commseqUuid' is not null or undefined
            if (commseqUuid === null || commseqUuid === undefined) {
                throw new RequiredError('commseqUuid','Required parameter commseqUuid was null or undefined when calling updateEmailCommseq.');
            }
            // verify required parameter 'emailCommseq' is not null or undefined
            if (emailCommseq === null || emailCommseq === undefined) {
                throw new RequiredError('emailCommseq','Required parameter emailCommseq was null or undefined when calling updateEmailCommseq.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseqUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseq || {}) : (emailCommseq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email customer
         * @param {number} storefrontOid 
         * @param {string} emailCustomerUuid 
         * @param {EmailCustomer} emailCustomer Email customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCustomer(storefrontOid: number, emailCustomerUuid: string, emailCustomer: EmailCustomer, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailCustomer.');
            }
            // verify required parameter 'emailCustomerUuid' is not null or undefined
            if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
                throw new RequiredError('emailCustomerUuid','Required parameter emailCustomerUuid was null or undefined when calling updateEmailCustomer.');
            }
            // verify required parameter 'emailCustomer' is not null or undefined
            if (emailCustomer === null || emailCustomer === undefined) {
                throw new RequiredError('emailCustomer','Required parameter emailCustomer was null or undefined when calling updateEmailCustomer.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/customers/{email_customer_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(emailCustomerUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCustomer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCustomer || {}) : (emailCustomer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmail} emailCommseqEmail Email commseq email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailEmail(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmail: EmailCommseqEmail, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailEmail.');
            }
            // verify required parameter 'commseqEmailUuid' is not null or undefined
            if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
                throw new RequiredError('commseqEmailUuid','Required parameter commseqEmailUuid was null or undefined when calling updateEmailEmail.');
            }
            // verify required parameter 'emailCommseqEmail' is not null or undefined
            if (emailCommseqEmail === null || emailCommseqEmail === undefined) {
                throw new RequiredError('emailCommseqEmail','Required parameter emailCommseqEmail was null or undefined when calling updateEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseqEmailUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqEmail || {}) : (emailCommseqEmail || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {EmailFlow} emailFlow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlow(storefrontOid: number, emailFlowUuid: string, emailFlow: EmailFlow, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailFlow.');
            }
            // verify required parameter 'emailFlowUuid' is not null or undefined
            if (emailFlowUuid === null || emailFlowUuid === undefined) {
                throw new RequiredError('emailFlowUuid','Required parameter emailFlowUuid was null or undefined when calling updateEmailFlow.');
            }
            // verify required parameter 'emailFlow' is not null or undefined
            if (emailFlow === null || emailFlow === undefined) {
                throw new RequiredError('emailFlow','Required parameter emailFlow was null or undefined when calling updateEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(emailFlowUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlow" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailFlow || {}) : (emailFlow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email global settings
         * @param {EmailGlobalSettings} globalSettings global settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailGlobalSettings(globalSettings: EmailGlobalSettings, options: any = {}): FetchArgs {
            // verify required parameter 'globalSettings' is not null or undefined
            if (globalSettings === null || globalSettings === undefined) {
                throw new RequiredError('globalSettings','Required parameter globalSettings was null or undefined when calling updateEmailGlobalSettings.');
            }
            const localVarPath = `/storefront/email/global_settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailGlobalSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(globalSettings || {}) : (globalSettings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {EmailList} emailList Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailList(storefrontOid: number, emailListUuid: string, emailList: EmailList, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailList.');
            }
            // verify required parameter 'emailListUuid' is not null or undefined
            if (emailListUuid === null || emailListUuid === undefined) {
                throw new RequiredError('emailListUuid','Required parameter emailListUuid was null or undefined when calling updateEmailList.');
            }
            // verify required parameter 'emailList' is not null or undefined
            if (emailList === null || emailList === undefined) {
                throw new RequiredError('emailList','Required parameter emailList was null or undefined when calling updateEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(emailListUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailList" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailList || {}) : (emailList || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email plan
         * @param {number} storefrontOid 
         * @param {EmailPlan} settings plan request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPlan(storefrontOid: number, settings: EmailPlan, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailPlan.');
            }
            // verify required parameter 'settings' is not null or undefined
            if (settings === null || settings === undefined) {
                throw new RequiredError('settings','Required parameter settings was null or undefined when calling updateEmailPlan.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/plan`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailPlan" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(settings || {}) : (settings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {EmailCommseqPostcard} emailCommseqPostcard Email commseq postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcard: EmailCommseqPostcard, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailPostcard.');
            }
            // verify required parameter 'commseqPostcardUuid' is not null or undefined
            if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
                throw new RequiredError('commseqPostcardUuid','Required parameter commseqPostcardUuid was null or undefined when calling updateEmailPostcard.');
            }
            // verify required parameter 'emailCommseqPostcard' is not null or undefined
            if (emailCommseqPostcard === null || emailCommseqPostcard === undefined) {
                throw new RequiredError('emailCommseqPostcard','Required parameter emailCommseqPostcard was null or undefined when calling updateEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseqPostcardUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailCommseqPostcard || {}) : (emailCommseqPostcard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {EmailSegment} emailSegment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegment: EmailSegment, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailSegment.');
            }
            // verify required parameter 'emailSegmentUuid' is not null or undefined
            if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
                throw new RequiredError('emailSegmentUuid','Required parameter emailSegmentUuid was null or undefined when calling updateEmailSegment.');
            }
            // verify required parameter 'emailSegment' is not null or undefined
            if (emailSegment === null || emailSegment === undefined) {
                throw new RequiredError('emailSegment','Required parameter emailSegment was null or undefined when calling updateEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(emailSegmentUuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailSegment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(emailSegment || {}) : (emailSegment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email settings
         * @param {number} storefrontOid 
         * @param {EmailSettings} settings settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSettings(storefrontOid: number, settings: EmailSettings, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateEmailSettings.');
            }
            // verify required parameter 'settings' is not null or undefined
            if (settings === null || settings === undefined) {
                throw new RequiredError('settings','Required parameter settings was null or undefined when calling updateEmailSettings.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/settings`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(settings || {}) : (settings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update experiment
         * @param {number} storefrontOid 
         * @param {number} storefrontExperimentOid 
         * @param {Experiment} experiment Experiment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment(storefrontOid: number, storefrontExperimentOid: number, experiment: Experiment, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateExperiment.');
            }
            // verify required parameter 'storefrontExperimentOid' is not null or undefined
            if (storefrontExperimentOid === null || storefrontExperimentOid === undefined) {
                throw new RequiredError('storefrontExperimentOid','Required parameter storefrontExperimentOid was null or undefined when calling updateExperiment.');
            }
            // verify required parameter 'experiment' is not null or undefined
            if (experiment === null || experiment === undefined) {
                throw new RequiredError('experiment','Required parameter experiment was null or undefined when calling updateExperiment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"storefront_experiment_oid"}}`, encodeURIComponent(String(storefrontExperimentOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Experiment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(experiment || {}) : (experiment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update library item. Note that only certain fields may be updated via this method.
         * @param {number} libraryItemOid 
         * @param {LibraryItem} libraryItem Library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryItem(libraryItemOid: number, libraryItem: LibraryItem, options: any = {}): FetchArgs {
            // verify required parameter 'libraryItemOid' is not null or undefined
            if (libraryItemOid === null || libraryItemOid === undefined) {
                throw new RequiredError('libraryItemOid','Required parameter libraryItemOid was null or undefined when calling updateLibraryItem.');
            }
            // verify required parameter 'libraryItem' is not null or undefined
            if (libraryItem === null || libraryItem === undefined) {
                throw new RequiredError('libraryItem','Required parameter libraryItem was null or undefined when calling updateLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(libraryItemOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(libraryItem || {}) : (libraryItem || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a transactional email 
         * @summary Updates a transaction email object
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {TransactionEmail} transactionEmail TransactionEmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionEmail(storefrontOid: number, emailId: string, transactionEmail: TransactionEmail, options: any = {}): FetchArgs {
            // verify required parameter 'storefrontOid' is not null or undefined
            if (storefrontOid === null || storefrontOid === undefined) {
                throw new RequiredError('storefrontOid','Required parameter storefrontOid was null or undefined when calling updateTransactionEmail.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId','Required parameter emailId was null or undefined when calling updateTransactionEmail.');
            }
            // verify required parameter 'transactionEmail' is not null or undefined
            if (transactionEmail === null || transactionEmail === undefined) {
                throw new RequiredError('transactionEmail','Required parameter transactionEmail was null or undefined when calling updateTransactionEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list/{email_id}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefrontOid)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(transactionEmail || {}) : (transactionEmail || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorefrontApi - functional programming interface
 * @export
 */
export const StorefrontApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add to library
         * @param {AddLibraryItemRequest} addLibraryRequest New library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToLibrary(addLibraryRequest: AddLibraryItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).addToLibrary(addLibraryRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Apply library item to storefront.
         * @param {ApplyLibraryItemRequest} applyLibraryRequest New library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToStoreFront(applyLibraryRequest: ApplyLibraryItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplyLibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).applyToStoreFront(applyLibraryRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailList(storefrontOid: number, emailListUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListArchiveResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).archiveEmailList(storefrontOid, emailListUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentArchiveResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).archiveEmailSegment(storefrontOid, emailSegmentUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Back populate email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {EmailFlowBackPopulateRequest} backPopulateRequest The request to back populate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backPopulateEmailFlow(storefrontOid: number, emailFlowUuid: string, backPopulateRequest: EmailFlowBackPopulateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowBackPopulateResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).backPopulateEmailFlow(storefrontOid, emailFlowUuid, backPopulateRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check download of email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} emailSegmentRebuildUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegmentRebuildUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentDownloadPrepareResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).checkDownloadEmailSegment(storefrontOid, emailSegmentUuid, emailSegmentRebuildUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clone email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {number} [targetStorefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailCampaign(storefrontOid: number, emailCampaignUuid: string, targetStorefrontOid?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).cloneEmailCampaign(storefrontOid, emailCampaignUuid, targetStorefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clone email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {number} [targetStorefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailFlow(storefrontOid: number, emailFlowUuid: string, targetStorefrontOid?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).cloneEmailFlow(storefrontOid, emailFlowUuid, targetStorefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSendingDomain(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).createEmailSendingDomain(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete communication sequence stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCommseqStat(storefrontOid: number, commseqUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailCommseqStat(storefrontOid, commseqUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailEmail(storefrontOid, commseqEmailUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email list customer
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListCustomer(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailListCustomer(storefrontOid, emailListUuid, emailCustomerUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailPostcard(storefrontOid, commseqPostcardUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary delete email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSendingDomain(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailSendingDomain(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete experiment
         * @param {number} storefrontOid 
         * @param {number} storefrontExperimentOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(storefrontOid: number, storefrontExperimentOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteExperiment(storefrontOid, storefrontExperimentOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete library item
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItem(libraryItemOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteLibraryItem(libraryItemOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Duplicate library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateLibraryItem(libraryItemOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).duplicateLibraryItem(libraryItemOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Obtain lat/long for an address
         * @param {number} storefrontOid 
         * @param {GeocodeRequest} geocodeRequest geocode request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeAddress(storefrontOid: number, geocodeRequest: GeocodeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GeocodeResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).geocodeAddress(storefrontOid, geocodeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of all the countries 
         * @summary Get countries
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountriesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getCountries(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a temporary authentication token for the editor 
         * @summary Gets editor token
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorToken(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailEditorTokenResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEditorToken(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication base templates
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailBaseTemplates(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailBaseTemplateListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailBaseTemplates(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaign(storefrontOid, emailCampaignUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign screenshots
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignScreenshots(storefrontOid: number, emailCampaignUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenshotsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaignScreenshots(storefrontOid, emailCampaignUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaigns
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaigns(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaigns(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaigns with stats
         * @param {number} storefrontOid 
         * @param {string} statDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignsWithStats(storefrontOid: number, statDays: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaignsWithStats(storefrontOid, statDays, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email commseq
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseq(storefrontOid: number, commseqUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseq(storefrontOid, commseqUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence emails stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStatSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqEmailStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatSummaryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStatSummaryResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqEmailStats(storefrontOid, commseqUuid, statsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence postcard stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqPostcardStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStatPostcardSummaryResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqPostcardStats(storefrontOid, commseqUuid, statsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get communication sequence stats overall
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStatOverall(storefrontOid: number, commseqUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqStatResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqStatOverall(storefrontOid, commseqUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence step stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStepStatRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStepStatRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStepStatResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqStepStats(storefrontOid, commseqUuid, statsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence customers waiting at each requested step
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, waitingRequest: EmailStepWaitingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStepWaitingResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqStepWaiting(storefrontOid, commseqUuid, waitingRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email commseqs
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqs(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqs(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get customers editor URL
         * @param {number} storefrontOid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomerEditorUrl(storefrontOid: number, emailCustomerUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCustomerEditorUrl(storefrontOid, emailCustomerUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email customers
         * @param {number} storefrontOid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [searchEmailPrefix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomers(storefrontOid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCustomers(storefrontOid, pageNumber, pageSize, searchEmailPrefix, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email dashboard activity
         * @param {number} storefrontOid 
         * @param {number} [lastRecords] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardActivity(storefrontOid: number, lastRecords?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailDashboardActivityResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailDashboardActivity(storefrontOid, lastRecords, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get dashboard stats
         * @param {number} storefrontOid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardStats(storefrontOid: number, days?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailDashboardStatsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailDashboardStats(storefrontOid, days, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmail(storefrontOid, commseqEmailUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email email clicks
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {string} commseqEmailUuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailClicks(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailClicksResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailClicks(storefrontOid, commseqUuid, commseqStepUuid, commseqEmailUuid, days, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email order customer editor url
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailCustomerEditorUrl(storefrontOid: number, commseqEmailUuid: string, orderId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailCustomerEditorUrl(storefrontOid, commseqEmailUuid, orderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email email orders
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {string} commseqEmailUuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailOrders(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailOrdersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailOrders(storefrontOid, commseqUuid, commseqStepUuid, commseqEmailUuid, days, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email emails
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmails(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmails(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email emails multiple
         * @param {number} storefrontOid 
         * @param {EmailCommseqEmailsRequest} emailCommseqEmailsRequest Request of email uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailsMultiple(storefrontOid: number, emailCommseqEmailsRequest: EmailCommseqEmailsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailsMultiple(storefrontOid, emailCommseqEmailsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlow(storefrontOid: number, emailFlowUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlow(storefrontOid, emailFlowUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flow screenshots
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowScreenshots(storefrontOid: number, emailFlowUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenshotsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlowScreenshots(storefrontOid, emailFlowUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flows
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlows(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlows(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email globalsettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailGlobalSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailGlobalSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailGlobalSettings(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailList(storefrontOid: number, emailListUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailList(storefrontOid, emailListUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email list customer editor url
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomerEditorUrl(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailListCustomerEditorUrl(storefrontOid, emailListUuid, emailCustomerUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email list customers
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomers(storefrontOid: number, emailListUuid: string, pageNumber?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailListCustomers(storefrontOid, emailListUuid, pageNumber, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email lists
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailLists(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email performance
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPerformance(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPerformanceResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPerformance(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email plan
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPlan(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPlanResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPlan(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPostcard(storefrontOid, commseqPostcardUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email postcards
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcards(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPostcards(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email postcards multiple
         * @param {number} storefrontOid 
         * @param {EmailCommseqPostcardsRequest} emailCommseqPostcardsRequest Request of postcard uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcardsMultiple(storefrontOid: number, emailCommseqPostcardsRequest: EmailCommseqPostcardsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPostcardsMultiple(storefrontOid, emailCommseqPostcardsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegment(storefrontOid, emailSegmentUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segment customers editor URL
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomerEditorUrl(storefrontOid: number, emailSegmentUuid: string, emailCustomerUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegmentCustomerEditorUrl(storefrontOid, emailSegmentUuid, emailCustomerUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segment customers
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, pageNumber?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegmentCustomers(storefrontOid, emailSegmentUuid, pageNumber, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segments
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegments(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegments(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email sending domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomain(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSendingDomain(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email sending domain status
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomainStatus(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSendingDomainStatus(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email sending domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomains(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSendingDomains(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email settings
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSettings(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSettings(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email template
         * @param {number} storefrontOid 
         * @param {number} emailTemplateOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate(storefrontOid: number, emailTemplateOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailTemplate> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailTemplate(storefrontOid, emailTemplateOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email templates
         * @param {number} storefrontOid 
         * @param {string} [triggerType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplates(storefrontOid: number, triggerType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailTemplatesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailTemplates(storefrontOid, triggerType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of third party email providers
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailThirdPartyProviders(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailThirdPartyProvidersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailThirdPartyProviders(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiments
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExperimentsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getExperiments(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of property names for a given property type 
         * @summary Get histogram property names
         * @param {number} storefrontOid 
         * @param {string} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyNames(storefrontOid: number, propertyType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailHistogramPropertyNamesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getHistogramPropertyNames(storefrontOid, propertyType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of property values for a given property name and type 
         * @summary Get histogram property values
         * @param {number} storefrontOid 
         * @param {string} [propertyName] 
         * @param {string} [propertyType] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyValues(storefrontOid: number, propertyName?: string, propertyType?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailHistogramPropertyValuesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getHistogramPropertyValues(storefrontOid, propertyName, propertyType, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get library values used to populate drop down boxes for filtering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryFilterValues(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryFilterValuesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getLibraryFilterValues(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItem(libraryItemOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getLibraryItem(libraryItemOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get thumbnail parameters
         * @param {ThumbnailParametersRequest} thumbnailParameters Thumbnail Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailParameters(thumbnailParameters: ThumbnailParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ThumbnailParametersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getThumbnailParameters(thumbnailParameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a transactional email 
         * @summary Gets a transaction email object
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmail(storefrontOid: number, emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTransactionEmail(storefrontOid, emailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of all transactional emails and return back just their names 
         * @summary Gets a list of transaction email names
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailList(storefrontOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionEmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTransactionEmailList(storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get transactional email screenshots
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailScreenshots(storefrontOid: number, emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenshotsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTransactionEmailScreenshots(storefrontOid, emailId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Globally unsubscribe a customer
         * @param {number} storefrontOid 
         * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnsubscribe(storefrontOid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailGlobalUnsubscribeResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).globalUnsubscribe(storefrontOid, unsubscribe, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Import a third party provider list
         * @param {number} storefrontOid 
         * @param {EmailThirdPartyListImportRequest} importRequest lists to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmailThirdPartyProviderList(storefrontOid: number, importRequest: EmailThirdPartyListImportRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).importEmailThirdPartyProviderList(storefrontOid, importRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email campaign
         * @param {number} storefrontOid 
         * @param {EmailCampaign} emailCampaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaign(storefrontOid: number, emailCampaign: EmailCampaign, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailCampaign(storefrontOid, emailCampaign, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email commseq
         * @param {number} storefrontOid 
         * @param {EmailCommseq} emailCommseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCommseq(storefrontOid: number, emailCommseq: EmailCommseq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailCommseq(storefrontOid, emailCommseq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email email
         * @param {number} storefrontOid 
         * @param {EmailCommseqEmail} emailCommseqEmail Email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailEmail(storefrontOid: number, emailCommseqEmail: EmailCommseqEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailEmail(storefrontOid, emailCommseqEmail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email flow
         * @param {number} storefrontOid 
         * @param {EmailFlow} emailFlow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlow(storefrontOid: number, emailFlow: EmailFlow, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailFlow(storefrontOid, emailFlow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email list
         * @param {number} storefrontOid 
         * @param {EmailList} emailList Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailList(storefrontOid: number, emailList: EmailList, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailList(storefrontOid, emailList, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email postcard
         * @param {number} storefrontOid 
         * @param {EmailCommseqPostcard} emailCommseqPostcard Email postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailPostcard(storefrontOid: number, emailCommseqPostcard: EmailCommseqPostcard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailPostcard(storefrontOid, emailCommseqPostcard, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email segment
         * @param {number} storefrontOid 
         * @param {EmailSegment} emailSegment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailSegment(storefrontOid: number, emailSegment: EmailSegment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailSegment(storefrontOid, emailSegment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Prepare download of email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentDownloadPrepareResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).prepareDownloadEmailSegment(storefrontOid, emailSegmentUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Publish library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishLibraryItem(libraryItemOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).publishLibraryItem(libraryItemOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Purchase public library item, which creates a copy of the item in your personal code library
         * @param {number} libraryItemOid 
         * @param {number} [storefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLibraryItem(libraryItemOid: number, storefrontOid?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).purchaseLibraryItem(libraryItemOid, storefrontOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Release email communication sequence customers waiting at the specified step
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).releaseEmailCommseqStepWaiting(storefrontOid, commseqUuid, commseqStepUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Request a review of an email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailReviewRequest Email commseq email review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        review(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailReviewRequest: EmailCommseqEmailSendTestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailSendTestResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).review(storefrontOid, commseqEmailUuid, emailCommseqEmailReviewRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Searches for all matching values
         * @param {string} [category] 
         * @param {string} [matches] 
         * @param {string} [storefrontOid] 
         * @param {number} [maxHits] 
         * @param {string} [subcategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(category?: string, matches?: string, storefrontOid?: string, maxHits?: number, subcategory?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LookupResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).search(category, matches, storefrontOid, maxHits, subcategory, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Searches for all matching values (using POST)
         * @param {LookupRequest} lookupRequest LookupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(lookupRequest: LookupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LookupResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).search2(lookupRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search email list customers
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailListCustomers(storefrontOid: number, emailListUuid: string, startsWith?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchEmailListCustomers(storefrontOid, emailListUuid, startsWith, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search email segment customers
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, startsWith?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchEmailSegmentCustomers(storefrontOid, emailSegmentUuid, startsWith, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLibraryItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchLibraryItems(itemQuery, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPublishedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchPublishedItems(itemQuery, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items needing review or rejected
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReviewItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchReviewItems(itemQuery, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSharedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchSharedItems(itemQuery, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send email test
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailTestRequest Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailTest(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailTestRequest: EmailCommseqEmailSendTestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailSendTestResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).sendEmailTest(storefrontOid, commseqEmailUuid, emailCommseqEmailTestRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send postcard test
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {EmailCommseqPostcardSendTestRequest} emailCommseqPostcardTestRequest Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPostcardTest(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcardTestRequest: EmailCommseqPostcardSendTestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardSendTestResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).sendPostcardTest(storefrontOid, commseqPostcardUuid, emailCommseqPostcardTestRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).startEmailCampaign(storefrontOid, emailCampaignUuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Subscribe customers to email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {Array<EmailCustomer>} customers Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEmailList(storefrontOid: number, emailListUuid: string, customers: Array<EmailCustomer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListSubscribeResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).subscribeToEmailList(storefrontOid, emailListUuid, customers, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {EmailCampaign} emailCampaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaign(storefrontOid: number, emailCampaignUuid: string, emailCampaign: EmailCampaign, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailCampaign(storefrontOid, emailCampaignUuid, emailCampaign, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email commseq
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailCommseq} emailCommseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCommseq(storefrontOid: number, commseqUuid: string, emailCommseq: EmailCommseq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailCommseq(storefrontOid, commseqUuid, emailCommseq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email customer
         * @param {number} storefrontOid 
         * @param {string} emailCustomerUuid 
         * @param {EmailCustomer} emailCustomer Email customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCustomer(storefrontOid: number, emailCustomerUuid: string, emailCustomer: EmailCustomer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailCustomer(storefrontOid, emailCustomerUuid, emailCustomer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmail} emailCommseqEmail Email commseq email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailEmail(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmail: EmailCommseqEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailEmail(storefrontOid, commseqEmailUuid, emailCommseqEmail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {EmailFlow} emailFlow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlow(storefrontOid: number, emailFlowUuid: string, emailFlow: EmailFlow, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailFlow(storefrontOid, emailFlowUuid, emailFlow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email global settings
         * @param {EmailGlobalSettings} globalSettings global settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailGlobalSettings(globalSettings: EmailGlobalSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailGlobalSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailGlobalSettings(globalSettings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {EmailList} emailList Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailList(storefrontOid: number, emailListUuid: string, emailList: EmailList, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailList(storefrontOid, emailListUuid, emailList, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email plan
         * @param {number} storefrontOid 
         * @param {EmailPlan} settings plan request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPlan(storefrontOid: number, settings: EmailPlan, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPlanResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailPlan(storefrontOid, settings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {EmailCommseqPostcard} emailCommseqPostcard Email commseq postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcard: EmailCommseqPostcard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailPostcard(storefrontOid, commseqPostcardUuid, emailCommseqPostcard, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {EmailSegment} emailSegment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegment: EmailSegment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailSegment(storefrontOid, emailSegmentUuid, emailSegment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email settings
         * @param {number} storefrontOid 
         * @param {EmailSettings} settings settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSettings(storefrontOid: number, settings: EmailSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailSettings(storefrontOid, settings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update experiment
         * @param {number} storefrontOid 
         * @param {number} storefrontExperimentOid 
         * @param {Experiment} experiment Experiment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment(storefrontOid: number, storefrontExperimentOid: number, experiment: Experiment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExperimentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateExperiment(storefrontOid, storefrontExperimentOid, experiment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update library item. Note that only certain fields may be updated via this method.
         * @param {number} libraryItemOid 
         * @param {LibraryItem} libraryItem Library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryItem(libraryItemOid: number, libraryItem: LibraryItem, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateLibraryItem(libraryItemOid, libraryItem, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a transactional email 
         * @summary Updates a transaction email object
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {TransactionEmail} transactionEmail TransactionEmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionEmail(storefrontOid: number, emailId: string, transactionEmail: TransactionEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateTransactionEmail(storefrontOid, emailId, transactionEmail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StorefrontApi - factory interface
 * @export
 */
export const StorefrontApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add to library
         * @param {AddLibraryItemRequest} addLibraryRequest New library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToLibrary(addLibraryRequest: AddLibraryItemRequest, options?: any) {
            return StorefrontApiFp(configuration).addToLibrary(addLibraryRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Apply library item to storefront.
         * @param {ApplyLibraryItemRequest} applyLibraryRequest New library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToStoreFront(applyLibraryRequest: ApplyLibraryItemRequest, options?: any) {
            return StorefrontApiFp(configuration).applyToStoreFront(applyLibraryRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailList(storefrontOid: number, emailListUuid: string, options?: any) {
            return StorefrontApiFp(configuration).archiveEmailList(storefrontOid, emailListUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any) {
            return StorefrontApiFp(configuration).archiveEmailSegment(storefrontOid, emailSegmentUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Back populate email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {EmailFlowBackPopulateRequest} backPopulateRequest The request to back populate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backPopulateEmailFlow(storefrontOid: number, emailFlowUuid: string, backPopulateRequest: EmailFlowBackPopulateRequest, options?: any) {
            return StorefrontApiFp(configuration).backPopulateEmailFlow(storefrontOid, emailFlowUuid, backPopulateRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check download of email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} emailSegmentRebuildUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegmentRebuildUuid: string, options?: any) {
            return StorefrontApiFp(configuration).checkDownloadEmailSegment(storefrontOid, emailSegmentUuid, emailSegmentRebuildUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clone email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {number} [targetStorefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailCampaign(storefrontOid: number, emailCampaignUuid: string, targetStorefrontOid?: number, options?: any) {
            return StorefrontApiFp(configuration).cloneEmailCampaign(storefrontOid, emailCampaignUuid, targetStorefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clone email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {number} [targetStorefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailFlow(storefrontOid: number, emailFlowUuid: string, targetStorefrontOid?: number, options?: any) {
            return StorefrontApiFp(configuration).cloneEmailFlow(storefrontOid, emailFlowUuid, targetStorefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSendingDomain(domain: string, options?: any) {
            return StorefrontApiFp(configuration).createEmailSendingDomain(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete communication sequence stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCommseqStat(storefrontOid: number, commseqUuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailCommseqStat(storefrontOid, commseqUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailEmail(storefrontOid, commseqEmailUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email list customer
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListCustomer(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailListCustomer(storefrontOid, emailListUuid, emailCustomerUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailPostcard(storefrontOid, commseqPostcardUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary delete email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSendingDomain(domain: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailSendingDomain(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete experiment
         * @param {number} storefrontOid 
         * @param {number} storefrontExperimentOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(storefrontOid: number, storefrontExperimentOid: number, options?: any) {
            return StorefrontApiFp(configuration).deleteExperiment(storefrontOid, storefrontExperimentOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete library item
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItem(libraryItemOid: number, options?: any) {
            return StorefrontApiFp(configuration).deleteLibraryItem(libraryItemOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Duplicate library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateLibraryItem(libraryItemOid: number, options?: any) {
            return StorefrontApiFp(configuration).duplicateLibraryItem(libraryItemOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Obtain lat/long for an address
         * @param {number} storefrontOid 
         * @param {GeocodeRequest} geocodeRequest geocode request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeAddress(storefrontOid: number, geocodeRequest: GeocodeRequest, options?: any) {
            return StorefrontApiFp(configuration).geocodeAddress(storefrontOid, geocodeRequest, options)(fetch, basePath);
        },
        /**
         * Obtain a list of all the countries 
         * @summary Get countries
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getCountries(storefrontOid, options)(fetch, basePath);
        },
        /**
         * Fetches a temporary authentication token for the editor 
         * @summary Gets editor token
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorToken(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEditorToken(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication base templates
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailBaseTemplates(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailBaseTemplates(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaign(storefrontOid, emailCampaignUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign screenshots
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignScreenshots(storefrontOid: number, emailCampaignUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaignScreenshots(storefrontOid, emailCampaignUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaigns
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaigns(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaigns(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaigns with stats
         * @param {number} storefrontOid 
         * @param {string} statDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignsWithStats(storefrontOid: number, statDays: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaignsWithStats(storefrontOid, statDays, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email commseq
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseq(storefrontOid: number, commseqUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseq(storefrontOid, commseqUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence emails stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStatSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqEmailStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatSummaryRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqEmailStats(storefrontOid, commseqUuid, statsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence postcard stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqPostcardStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqPostcardStats(storefrontOid, commseqUuid, statsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get communication sequence stats overall
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStatOverall(storefrontOid: number, commseqUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqStatOverall(storefrontOid, commseqUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence step stats
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStepStatRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStepStatRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqStepStats(storefrontOid, commseqUuid, statsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence customers waiting at each requested step
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, waitingRequest: EmailStepWaitingRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqStepWaiting(storefrontOid, commseqUuid, waitingRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email commseqs
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqs(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqs(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get customers editor URL
         * @param {number} storefrontOid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomerEditorUrl(storefrontOid: number, emailCustomerUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCustomerEditorUrl(storefrontOid, emailCustomerUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email customers
         * @param {number} storefrontOid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [searchEmailPrefix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomers(storefrontOid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCustomers(storefrontOid, pageNumber, pageSize, searchEmailPrefix, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email dashboard activity
         * @param {number} storefrontOid 
         * @param {number} [lastRecords] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardActivity(storefrontOid: number, lastRecords?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailDashboardActivity(storefrontOid, lastRecords, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get dashboard stats
         * @param {number} storefrontOid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardStats(storefrontOid: number, days?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailDashboardStats(storefrontOid, days, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmail(storefrontOid, commseqEmailUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email email clicks
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {string} commseqEmailUuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailClicks(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailClicks(storefrontOid, commseqUuid, commseqStepUuid, commseqEmailUuid, days, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email order customer editor url
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailCustomerEditorUrl(storefrontOid: number, commseqEmailUuid: string, orderId: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailCustomerEditorUrl(storefrontOid, commseqEmailUuid, orderId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email email orders
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {string} commseqEmailUuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailOrders(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailOrders(storefrontOid, commseqUuid, commseqStepUuid, commseqEmailUuid, days, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email emails
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmails(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmails(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email emails multiple
         * @param {number} storefrontOid 
         * @param {EmailCommseqEmailsRequest} emailCommseqEmailsRequest Request of email uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailsMultiple(storefrontOid: number, emailCommseqEmailsRequest: EmailCommseqEmailsRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailsMultiple(storefrontOid, emailCommseqEmailsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlow(storefrontOid: number, emailFlowUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlow(storefrontOid, emailFlowUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flow screenshots
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowScreenshots(storefrontOid: number, emailFlowUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlowScreenshots(storefrontOid, emailFlowUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flows
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlows(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlows(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email globalsettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailGlobalSettings(options?: any) {
            return StorefrontApiFp(configuration).getEmailGlobalSettings(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailList(storefrontOid: number, emailListUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailList(storefrontOid, emailListUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email list customer editor url
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomerEditorUrl(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailListCustomerEditorUrl(storefrontOid, emailListUuid, emailCustomerUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email list customers
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomers(storefrontOid: number, emailListUuid: string, pageNumber?: number, pageSize?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailListCustomers(storefrontOid, emailListUuid, pageNumber, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email lists
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailLists(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email performance
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPerformance(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailPerformance(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email plan
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPlan(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailPlan(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailPostcard(storefrontOid, commseqPostcardUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email postcards
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcards(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailPostcards(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email postcards multiple
         * @param {number} storefrontOid 
         * @param {EmailCommseqPostcardsRequest} emailCommseqPostcardsRequest Request of postcard uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcardsMultiple(storefrontOid: number, emailCommseqPostcardsRequest: EmailCommseqPostcardsRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailPostcardsMultiple(storefrontOid, emailCommseqPostcardsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegment(storefrontOid, emailSegmentUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segment customers editor URL
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} emailCustomerUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomerEditorUrl(storefrontOid: number, emailSegmentUuid: string, emailCustomerUuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegmentCustomerEditorUrl(storefrontOid, emailSegmentUuid, emailCustomerUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segment customers
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, pageNumber?: number, pageSize?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegmentCustomers(storefrontOid, emailSegmentUuid, pageNumber, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segments
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegments(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegments(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email sending domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomain(domain: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSendingDomain(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email sending domain status
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomainStatus(domain: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSendingDomainStatus(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email sending domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomains(options?: any) {
            return StorefrontApiFp(configuration).getEmailSendingDomains(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email settings
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSettings(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailSettings(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email template
         * @param {number} storefrontOid 
         * @param {number} emailTemplateOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate(storefrontOid: number, emailTemplateOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailTemplate(storefrontOid, emailTemplateOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email templates
         * @param {number} storefrontOid 
         * @param {string} [triggerType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplates(storefrontOid: number, triggerType?: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailTemplates(storefrontOid, triggerType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of third party email providers
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailThirdPartyProviders(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailThirdPartyProviders(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiments
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getExperiments(storefrontOid, options)(fetch, basePath);
        },
        /**
         * Obtain a list of property names for a given property type 
         * @summary Get histogram property names
         * @param {number} storefrontOid 
         * @param {string} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyNames(storefrontOid: number, propertyType?: string, options?: any) {
            return StorefrontApiFp(configuration).getHistogramPropertyNames(storefrontOid, propertyType, options)(fetch, basePath);
        },
        /**
         * Obtain a list of property values for a given property name and type 
         * @summary Get histogram property values
         * @param {number} storefrontOid 
         * @param {string} [propertyName] 
         * @param {string} [propertyType] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyValues(storefrontOid: number, propertyName?: string, propertyType?: string, limit?: number, options?: any) {
            return StorefrontApiFp(configuration).getHistogramPropertyValues(storefrontOid, propertyName, propertyType, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get library values used to populate drop down boxes for filtering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryFilterValues(options?: any) {
            return StorefrontApiFp(configuration).getLibraryFilterValues(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItem(libraryItemOid: number, options?: any) {
            return StorefrontApiFp(configuration).getLibraryItem(libraryItemOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get thumbnail parameters
         * @param {ThumbnailParametersRequest} thumbnailParameters Thumbnail Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailParameters(thumbnailParameters: ThumbnailParametersRequest, options?: any) {
            return StorefrontApiFp(configuration).getThumbnailParameters(thumbnailParameters, options)(fetch, basePath);
        },
        /**
         * Fetch a transactional email 
         * @summary Gets a transaction email object
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmail(storefrontOid: number, emailId: string, options?: any) {
            return StorefrontApiFp(configuration).getTransactionEmail(storefrontOid, emailId, options)(fetch, basePath);
        },
        /**
         * Obtain a list of all transactional emails and return back just their names 
         * @summary Gets a list of transaction email names
         * @param {number} storefrontOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailList(storefrontOid: number, options?: any) {
            return StorefrontApiFp(configuration).getTransactionEmailList(storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get transactional email screenshots
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailScreenshots(storefrontOid: number, emailId: string, options?: any) {
            return StorefrontApiFp(configuration).getTransactionEmailScreenshots(storefrontOid, emailId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Globally unsubscribe a customer
         * @param {number} storefrontOid 
         * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnsubscribe(storefrontOid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any) {
            return StorefrontApiFp(configuration).globalUnsubscribe(storefrontOid, unsubscribe, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Import a third party provider list
         * @param {number} storefrontOid 
         * @param {EmailThirdPartyListImportRequest} importRequest lists to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmailThirdPartyProviderList(storefrontOid: number, importRequest: EmailThirdPartyListImportRequest, options?: any) {
            return StorefrontApiFp(configuration).importEmailThirdPartyProviderList(storefrontOid, importRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email campaign
         * @param {number} storefrontOid 
         * @param {EmailCampaign} emailCampaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaign(storefrontOid: number, emailCampaign: EmailCampaign, options?: any) {
            return StorefrontApiFp(configuration).insertEmailCampaign(storefrontOid, emailCampaign, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email commseq
         * @param {number} storefrontOid 
         * @param {EmailCommseq} emailCommseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCommseq(storefrontOid: number, emailCommseq: EmailCommseq, options?: any) {
            return StorefrontApiFp(configuration).insertEmailCommseq(storefrontOid, emailCommseq, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email email
         * @param {number} storefrontOid 
         * @param {EmailCommseqEmail} emailCommseqEmail Email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailEmail(storefrontOid: number, emailCommseqEmail: EmailCommseqEmail, options?: any) {
            return StorefrontApiFp(configuration).insertEmailEmail(storefrontOid, emailCommseqEmail, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email flow
         * @param {number} storefrontOid 
         * @param {EmailFlow} emailFlow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlow(storefrontOid: number, emailFlow: EmailFlow, options?: any) {
            return StorefrontApiFp(configuration).insertEmailFlow(storefrontOid, emailFlow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email list
         * @param {number} storefrontOid 
         * @param {EmailList} emailList Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailList(storefrontOid: number, emailList: EmailList, options?: any) {
            return StorefrontApiFp(configuration).insertEmailList(storefrontOid, emailList, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email postcard
         * @param {number} storefrontOid 
         * @param {EmailCommseqPostcard} emailCommseqPostcard Email postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailPostcard(storefrontOid: number, emailCommseqPostcard: EmailCommseqPostcard, options?: any) {
            return StorefrontApiFp(configuration).insertEmailPostcard(storefrontOid, emailCommseqPostcard, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email segment
         * @param {number} storefrontOid 
         * @param {EmailSegment} emailSegment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailSegment(storefrontOid: number, emailSegment: EmailSegment, options?: any) {
            return StorefrontApiFp(configuration).insertEmailSegment(storefrontOid, emailSegment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Prepare download of email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any) {
            return StorefrontApiFp(configuration).prepareDownloadEmailSegment(storefrontOid, emailSegmentUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Publish library item.
         * @param {number} libraryItemOid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishLibraryItem(libraryItemOid: number, options?: any) {
            return StorefrontApiFp(configuration).publishLibraryItem(libraryItemOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Purchase public library item, which creates a copy of the item in your personal code library
         * @param {number} libraryItemOid 
         * @param {number} [storefrontOid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLibraryItem(libraryItemOid: number, storefrontOid?: number, options?: any) {
            return StorefrontApiFp(configuration).purchaseLibraryItem(libraryItemOid, storefrontOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Release email communication sequence customers waiting at the specified step
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {string} commseqStepUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, options?: any) {
            return StorefrontApiFp(configuration).releaseEmailCommseqStepWaiting(storefrontOid, commseqUuid, commseqStepUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Request a review of an email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailReviewRequest Email commseq email review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        review(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailReviewRequest: EmailCommseqEmailSendTestRequest, options?: any) {
            return StorefrontApiFp(configuration).review(storefrontOid, commseqEmailUuid, emailCommseqEmailReviewRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Searches for all matching values
         * @param {string} [category] 
         * @param {string} [matches] 
         * @param {string} [storefrontOid] 
         * @param {number} [maxHits] 
         * @param {string} [subcategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(category?: string, matches?: string, storefrontOid?: string, maxHits?: number, subcategory?: string, options?: any) {
            return StorefrontApiFp(configuration).search(category, matches, storefrontOid, maxHits, subcategory, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Searches for all matching values (using POST)
         * @param {LookupRequest} lookupRequest LookupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(lookupRequest: LookupRequest, options?: any) {
            return StorefrontApiFp(configuration).search2(lookupRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search email list customers
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailListCustomers(storefrontOid: number, emailListUuid: string, startsWith?: string, options?: any) {
            return StorefrontApiFp(configuration).searchEmailListCustomers(storefrontOid, emailListUuid, startsWith, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search email segment customers
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, startsWith?: string, options?: any) {
            return StorefrontApiFp(configuration).searchEmailSegmentCustomers(storefrontOid, emailSegmentUuid, startsWith, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLibraryItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchLibraryItems(itemQuery, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPublishedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchPublishedItems(itemQuery, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items needing review or rejected
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReviewItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchReviewItems(itemQuery, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} itemQuery Item query
         * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSharedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchSharedItems(itemQuery, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send email test
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailTestRequest Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailTest(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailTestRequest: EmailCommseqEmailSendTestRequest, options?: any) {
            return StorefrontApiFp(configuration).sendEmailTest(storefrontOid, commseqEmailUuid, emailCommseqEmailTestRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send postcard test
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {EmailCommseqPostcardSendTestRequest} emailCommseqPostcardTestRequest Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPostcardTest(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcardTestRequest: EmailCommseqPostcardSendTestRequest, options?: any) {
            return StorefrontApiFp(configuration).sendPostcardTest(storefrontOid, commseqPostcardUuid, emailCommseqPostcardTestRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any) {
            return StorefrontApiFp(configuration).startEmailCampaign(storefrontOid, emailCampaignUuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Subscribe customers to email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {Array<EmailCustomer>} customers Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEmailList(storefrontOid: number, emailListUuid: string, customers: Array<EmailCustomer>, options?: any) {
            return StorefrontApiFp(configuration).subscribeToEmailList(storefrontOid, emailListUuid, customers, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email campaign
         * @param {number} storefrontOid 
         * @param {string} emailCampaignUuid 
         * @param {EmailCampaign} emailCampaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaign(storefrontOid: number, emailCampaignUuid: string, emailCampaign: EmailCampaign, options?: any) {
            return StorefrontApiFp(configuration).updateEmailCampaign(storefrontOid, emailCampaignUuid, emailCampaign, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email commseq
         * @param {number} storefrontOid 
         * @param {string} commseqUuid 
         * @param {EmailCommseq} emailCommseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCommseq(storefrontOid: number, commseqUuid: string, emailCommseq: EmailCommseq, options?: any) {
            return StorefrontApiFp(configuration).updateEmailCommseq(storefrontOid, commseqUuid, emailCommseq, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email customer
         * @param {number} storefrontOid 
         * @param {string} emailCustomerUuid 
         * @param {EmailCustomer} emailCustomer Email customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCustomer(storefrontOid: number, emailCustomerUuid: string, emailCustomer: EmailCustomer, options?: any) {
            return StorefrontApiFp(configuration).updateEmailCustomer(storefrontOid, emailCustomerUuid, emailCustomer, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email email
         * @param {number} storefrontOid 
         * @param {string} commseqEmailUuid 
         * @param {EmailCommseqEmail} emailCommseqEmail Email commseq email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailEmail(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmail: EmailCommseqEmail, options?: any) {
            return StorefrontApiFp(configuration).updateEmailEmail(storefrontOid, commseqEmailUuid, emailCommseqEmail, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email flow
         * @param {number} storefrontOid 
         * @param {string} emailFlowUuid 
         * @param {EmailFlow} emailFlow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlow(storefrontOid: number, emailFlowUuid: string, emailFlow: EmailFlow, options?: any) {
            return StorefrontApiFp(configuration).updateEmailFlow(storefrontOid, emailFlowUuid, emailFlow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email global settings
         * @param {EmailGlobalSettings} globalSettings global settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailGlobalSettings(globalSettings: EmailGlobalSettings, options?: any) {
            return StorefrontApiFp(configuration).updateEmailGlobalSettings(globalSettings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email list
         * @param {number} storefrontOid 
         * @param {string} emailListUuid 
         * @param {EmailList} emailList Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailList(storefrontOid: number, emailListUuid: string, emailList: EmailList, options?: any) {
            return StorefrontApiFp(configuration).updateEmailList(storefrontOid, emailListUuid, emailList, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email plan
         * @param {number} storefrontOid 
         * @param {EmailPlan} settings plan request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPlan(storefrontOid: number, settings: EmailPlan, options?: any) {
            return StorefrontApiFp(configuration).updateEmailPlan(storefrontOid, settings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email postcard
         * @param {number} storefrontOid 
         * @param {string} commseqPostcardUuid 
         * @param {EmailCommseqPostcard} emailCommseqPostcard Email commseq postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcard: EmailCommseqPostcard, options?: any) {
            return StorefrontApiFp(configuration).updateEmailPostcard(storefrontOid, commseqPostcardUuid, emailCommseqPostcard, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email segment
         * @param {number} storefrontOid 
         * @param {string} emailSegmentUuid 
         * @param {EmailSegment} emailSegment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegment: EmailSegment, options?: any) {
            return StorefrontApiFp(configuration).updateEmailSegment(storefrontOid, emailSegmentUuid, emailSegment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email settings
         * @param {number} storefrontOid 
         * @param {EmailSettings} settings settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSettings(storefrontOid: number, settings: EmailSettings, options?: any) {
            return StorefrontApiFp(configuration).updateEmailSettings(storefrontOid, settings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update experiment
         * @param {number} storefrontOid 
         * @param {number} storefrontExperimentOid 
         * @param {Experiment} experiment Experiment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment(storefrontOid: number, storefrontExperimentOid: number, experiment: Experiment, options?: any) {
            return StorefrontApiFp(configuration).updateExperiment(storefrontOid, storefrontExperimentOid, experiment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update library item. Note that only certain fields may be updated via this method.
         * @param {number} libraryItemOid 
         * @param {LibraryItem} libraryItem Library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryItem(libraryItemOid: number, libraryItem: LibraryItem, options?: any) {
            return StorefrontApiFp(configuration).updateLibraryItem(libraryItemOid, libraryItem, options)(fetch, basePath);
        },
        /**
         * Updates a transactional email 
         * @summary Updates a transaction email object
         * @param {number} storefrontOid 
         * @param {string} emailId 
         * @param {TransactionEmail} transactionEmail TransactionEmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionEmail(storefrontOid: number, emailId: string, transactionEmail: TransactionEmail, options?: any) {
            return StorefrontApiFp(configuration).updateTransactionEmail(storefrontOid, emailId, transactionEmail, options)(fetch, basePath);
        },
    };
};

/**
 * StorefrontApi - interface
 * @export
 * @interface StorefrontApi
 */
export interface StorefrontApiInterface {
    /**
     * 
     * @summary Add to library
     * @param {AddLibraryItemRequest} addLibraryRequest New library item request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    addToLibrary(addLibraryRequest: AddLibraryItemRequest, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Apply library item to storefront.
     * @param {ApplyLibraryItemRequest} applyLibraryRequest New library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    applyToStoreFront(applyLibraryRequest: ApplyLibraryItemRequest, options?: any): Promise<ApplyLibraryItemResponse>;

    /**
     * 
     * @summary Archive email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    archiveEmailList(storefrontOid: number, emailListUuid: string, options?: any): Promise<EmailListArchiveResponse>;

    /**
     * 
     * @summary Archive email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    archiveEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any): Promise<EmailSegmentArchiveResponse>;

    /**
     * 
     * @summary Back populate email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {EmailFlowBackPopulateRequest} backPopulateRequest The request to back populate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    backPopulateEmailFlow(storefrontOid: number, emailFlowUuid: string, backPopulateRequest: EmailFlowBackPopulateRequest, options?: any): Promise<EmailFlowBackPopulateResponse>;

    /**
     * 
     * @summary Check download of email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {string} emailSegmentRebuildUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    checkDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegmentRebuildUuid: string, options?: any): Promise<EmailSegmentDownloadPrepareResponse>;

    /**
     * 
     * @summary Clone email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {number} [targetStorefrontOid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    cloneEmailCampaign(storefrontOid: number, emailCampaignUuid: string, targetStorefrontOid?: number, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Clone email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {number} [targetStorefrontOid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    cloneEmailFlow(storefrontOid: number, emailFlowUuid: string, targetStorefrontOid?: number, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Create email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    createEmailSendingDomain(domain: string, options?: any): Promise<EmailSendingDomainResponse>;

    /**
     * 
     * @summary Delete communication sequence stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailCommseqStat(storefrontOid: number, commseqUuid: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Delete email email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete email list customer
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailListCustomer(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete email postcard
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary delete email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailSendingDomain(domain: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete experiment
     * @param {number} storefrontOid 
     * @param {number} storefrontExperimentOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteExperiment(storefrontOid: number, storefrontExperimentOid: number, options?: any): Promise<{}>;

    /**
     * 
     * @summary Delete library item
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteLibraryItem(libraryItemOid: number, options?: any): Promise<{}>;

    /**
     * 
     * @summary Duplicate library item.
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    duplicateLibraryItem(libraryItemOid: number, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Obtain lat/long for an address
     * @param {number} storefrontOid 
     * @param {GeocodeRequest} geocodeRequest geocode request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    geocodeAddress(storefrontOid: number, geocodeRequest: GeocodeRequest, options?: any): Promise<GeocodeResponse>;

    /**
     * Obtain a list of all the countries 
     * @summary Get countries
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getCountries(storefrontOid: number, options?: any): Promise<CountriesResponse>;

    /**
     * Fetches a temporary authentication token for the editor 
     * @summary Gets editor token
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEditorToken(storefrontOid: number, options?: any): Promise<EmailEditorTokenResponse>;

    /**
     * 
     * @summary Get email communication base templates
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailBaseTemplates(storefrontOid: number, options?: any): Promise<EmailBaseTemplateListResponse>;

    /**
     * 
     * @summary Get email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Get email campaign screenshots
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaignScreenshots(storefrontOid: number, emailCampaignUuid: string, options?: any): Promise<ScreenshotsResponse>;

    /**
     * 
     * @summary Get email campaigns
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaigns(storefrontOid: number, options?: any): Promise<EmailCampaignsResponse>;

    /**
     * 
     * @summary Get email campaigns with stats
     * @param {number} storefrontOid 
     * @param {string} statDays 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaignsWithStats(storefrontOid: number, statDays: string, options?: any): Promise<EmailCampaignsResponse>;

    /**
     * 
     * @summary Get email commseq
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseq(storefrontOid: number, commseqUuid: string, options?: any): Promise<EmailCommseqResponse>;

    /**
     * 
     * @summary Get email communication sequence emails stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStatSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqEmailStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatSummaryRequest, options?: any): Promise<EmailStatSummaryResponse>;

    /**
     * 
     * @summary Get email communication sequence postcard stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqPostcardStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any): Promise<EmailStatPostcardSummaryResponse>;

    /**
     * 
     * @summary Get communication sequence stats overall
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqStatOverall(storefrontOid: number, commseqUuid: string, options?: any): Promise<EmailCommseqStatResponse>;

    /**
     * 
     * @summary Get email communication sequence step stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStepStatRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqStepStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStepStatRequest, options?: any): Promise<EmailStepStatResponse>;

    /**
     * 
     * @summary Get email communication sequence customers waiting at each requested step
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, waitingRequest: EmailStepWaitingRequest, options?: any): Promise<EmailStepWaitingResponse>;

    /**
     * 
     * @summary Get email commseqs
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqs(storefrontOid: number, options?: any): Promise<EmailCommseqsResponse>;

    /**
     * 
     * @summary Get customers editor URL
     * @param {number} storefrontOid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCustomerEditorUrl(storefrontOid: number, emailCustomerUuid: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email customers
     * @param {number} storefrontOid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {string} [searchEmailPrefix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCustomers(storefrontOid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any): Promise<EmailCustomersResponse>;

    /**
     * 
     * @summary Get email dashboard activity
     * @param {number} storefrontOid 
     * @param {number} [lastRecords] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailDashboardActivity(storefrontOid: number, lastRecords?: number, options?: any): Promise<EmailDashboardActivityResponse>;

    /**
     * 
     * @summary Get dashboard stats
     * @param {number} storefrontOid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailDashboardStats(storefrontOid: number, days?: number, options?: any): Promise<EmailDashboardStatsResponse>;

    /**
     * 
     * @summary Get email email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any): Promise<EmailCommseqEmailResponse>;

    /**
     * 
     * @summary Get email email clicks
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {string} commseqStepUuid 
     * @param {string} commseqEmailUuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailClicks(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any): Promise<EmailClicksResponse>;

    /**
     * 
     * @summary Get email order customer editor url
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailCustomerEditorUrl(storefrontOid: number, commseqEmailUuid: string, orderId: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email email orders
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {string} commseqStepUuid 
     * @param {string} commseqEmailUuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailOrders(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any): Promise<EmailOrdersResponse>;

    /**
     * 
     * @summary Get email emails
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmails(storefrontOid: number, options?: any): Promise<EmailCommseqEmailsResponse>;

    /**
     * 
     * @summary Get email emails multiple
     * @param {number} storefrontOid 
     * @param {EmailCommseqEmailsRequest} emailCommseqEmailsRequest Request of email uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailsMultiple(storefrontOid: number, emailCommseqEmailsRequest: EmailCommseqEmailsRequest, options?: any): Promise<EmailCommseqEmailsResponse>;

    /**
     * 
     * @summary Get email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlow(storefrontOid: number, emailFlowUuid: string, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Get email flow screenshots
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlowScreenshots(storefrontOid: number, emailFlowUuid: string, options?: any): Promise<ScreenshotsResponse>;

    /**
     * 
     * @summary Get email flows
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlows(storefrontOid: number, options?: any): Promise<EmailFlowsResponse>;

    /**
     * 
     * @summary Get email globalsettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailGlobalSettings(options?: any): Promise<EmailGlobalSettingsResponse>;

    /**
     * 
     * @summary Get email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailList(storefrontOid: number, emailListUuid: string, options?: any): Promise<EmailListResponse>;

    /**
     * 
     * @summary Get email list customer editor url
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailListCustomerEditorUrl(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email list customers
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailListCustomers(storefrontOid: number, emailListUuid: string, pageNumber?: number, pageSize?: number, options?: any): Promise<EmailListCustomersResponse>;

    /**
     * 
     * @summary Get email lists
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailLists(storefrontOid: number, options?: any): Promise<EmailListsResponse>;

    /**
     * 
     * @summary Get email performance
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPerformance(storefrontOid: number, options?: any): Promise<EmailPerformanceResponse>;

    /**
     * 
     * @summary Get email plan
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPlan(storefrontOid: number, options?: any): Promise<EmailPlanResponse>;

    /**
     * 
     * @summary Get email postcard
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any): Promise<EmailCommseqPostcardResponse>;

    /**
     * 
     * @summary Get email postcards
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPostcards(storefrontOid: number, options?: any): Promise<EmailCommseqPostcardsResponse>;

    /**
     * 
     * @summary Get email postcards multiple
     * @param {number} storefrontOid 
     * @param {EmailCommseqPostcardsRequest} emailCommseqPostcardsRequest Request of postcard uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPostcardsMultiple(storefrontOid: number, emailCommseqPostcardsRequest: EmailCommseqPostcardsRequest, options?: any): Promise<EmailCommseqPostcardsResponse>;

    /**
     * 
     * @summary Get email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any): Promise<EmailSegmentResponse>;

    /**
     * 
     * @summary Get email segment customers editor URL
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegmentCustomerEditorUrl(storefrontOid: number, emailSegmentUuid: string, emailCustomerUuid: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email segment customers
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, pageNumber?: number, pageSize?: number, options?: any): Promise<EmailSegmentCustomersResponse>;

    /**
     * 
     * @summary Get email segments
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegments(storefrontOid: number, options?: any): Promise<EmailSegmentsResponse>;

    /**
     * 
     * @summary Get email sending domain
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSendingDomain(domain: string, options?: any): Promise<EmailSendingDomainResponse>;

    /**
     * 
     * @summary Get email sending domain status
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSendingDomainStatus(domain: string, options?: any): Promise<EmailSendingDomainResponse>;

    /**
     * 
     * @summary Get email sending domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSendingDomains(options?: any): Promise<EmailSendingDomainsResponse>;

    /**
     * 
     * @summary Get email settings
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSettings(storefrontOid: number, options?: any): Promise<EmailSettingsResponse>;

    /**
     * 
     * @summary Get email template
     * @param {number} storefrontOid 
     * @param {number} emailTemplateOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailTemplate(storefrontOid: number, emailTemplateOid: number, options?: any): Promise<EmailTemplate>;

    /**
     * 
     * @summary Get email templates
     * @param {number} storefrontOid 
     * @param {string} [triggerType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailTemplates(storefrontOid: number, triggerType?: string, options?: any): Promise<EmailTemplatesResponse>;

    /**
     * 
     * @summary Get a list of third party email providers
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailThirdPartyProviders(storefrontOid: number, options?: any): Promise<EmailThirdPartyProvidersResponse>;

    /**
     * 
     * @summary Get experiments
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getExperiments(storefrontOid: number, options?: any): Promise<ExperimentsResponse>;

    /**
     * Obtain a list of property names for a given property type 
     * @summary Get histogram property names
     * @param {number} storefrontOid 
     * @param {string} [propertyType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getHistogramPropertyNames(storefrontOid: number, propertyType?: string, options?: any): Promise<EmailHistogramPropertyNamesResponse>;

    /**
     * Obtain a list of property values for a given property name and type 
     * @summary Get histogram property values
     * @param {number} storefrontOid 
     * @param {string} [propertyName] 
     * @param {string} [propertyType] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getHistogramPropertyValues(storefrontOid: number, propertyName?: string, propertyType?: string, limit?: number, options?: any): Promise<EmailHistogramPropertyValuesResponse>;

    /**
     * 
     * @summary Get library values used to populate drop down boxes for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getLibraryFilterValues(options?: any): Promise<LibraryFilterValuesResponse>;

    /**
     * 
     * @summary Get library item.
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getLibraryItem(libraryItemOid: number, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Get thumbnail parameters
     * @param {ThumbnailParametersRequest} thumbnailParameters Thumbnail Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getThumbnailParameters(thumbnailParameters: ThumbnailParametersRequest, options?: any): Promise<ThumbnailParametersResponse>;

    /**
     * Fetch a transactional email 
     * @summary Gets a transaction email object
     * @param {number} storefrontOid 
     * @param {string} emailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTransactionEmail(storefrontOid: number, emailId: string, options?: any): Promise<TransactionEmailResponse>;

    /**
     * Obtain a list of all transactional emails and return back just their names 
     * @summary Gets a list of transaction email names
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTransactionEmailList(storefrontOid: number, options?: any): Promise<TransactionEmailListResponse>;

    /**
     * 
     * @summary Get transactional email screenshots
     * @param {number} storefrontOid 
     * @param {string} emailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTransactionEmailScreenshots(storefrontOid: number, emailId: string, options?: any): Promise<ScreenshotsResponse>;

    /**
     * 
     * @summary Globally unsubscribe a customer
     * @param {number} storefrontOid 
     * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    globalUnsubscribe(storefrontOid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any): Promise<EmailGlobalUnsubscribeResponse>;

    /**
     * 
     * @summary Import a third party provider list
     * @param {number} storefrontOid 
     * @param {EmailThirdPartyListImportRequest} importRequest lists to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    importEmailThirdPartyProviderList(storefrontOid: number, importRequest: EmailThirdPartyListImportRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary Insert email campaign
     * @param {number} storefrontOid 
     * @param {EmailCampaign} emailCampaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailCampaign(storefrontOid: number, emailCampaign: EmailCampaign, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Insert email commseq
     * @param {number} storefrontOid 
     * @param {EmailCommseq} emailCommseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailCommseq(storefrontOid: number, emailCommseq: EmailCommseq, options?: any): Promise<EmailCommseqResponse>;

    /**
     * 
     * @summary Insert email email
     * @param {number} storefrontOid 
     * @param {EmailCommseqEmail} emailCommseqEmail Email email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailEmail(storefrontOid: number, emailCommseqEmail: EmailCommseqEmail, options?: any): Promise<EmailCommseqEmailResponse>;

    /**
     * 
     * @summary Insert email flow
     * @param {number} storefrontOid 
     * @param {EmailFlow} emailFlow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailFlow(storefrontOid: number, emailFlow: EmailFlow, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Insert email list
     * @param {number} storefrontOid 
     * @param {EmailList} emailList Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailList(storefrontOid: number, emailList: EmailList, options?: any): Promise<EmailListResponse>;

    /**
     * 
     * @summary Insert email postcard
     * @param {number} storefrontOid 
     * @param {EmailCommseqPostcard} emailCommseqPostcard Email postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailPostcard(storefrontOid: number, emailCommseqPostcard: EmailCommseqPostcard, options?: any): Promise<EmailCommseqPostcardResponse>;

    /**
     * 
     * @summary Insert email segment
     * @param {number} storefrontOid 
     * @param {EmailSegment} emailSegment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailSegment(storefrontOid: number, emailSegment: EmailSegment, options?: any): Promise<EmailSegmentResponse>;

    /**
     * 
     * @summary Prepare download of email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    prepareDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any): Promise<EmailSegmentDownloadPrepareResponse>;

    /**
     * 
     * @summary Publish library item.
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    publishLibraryItem(libraryItemOid: number, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Purchase public library item, which creates a copy of the item in your personal code library
     * @param {number} libraryItemOid 
     * @param {number} [storefrontOid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    purchaseLibraryItem(libraryItemOid: number, storefrontOid?: number, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Release email communication sequence customers waiting at the specified step
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {string} commseqStepUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    releaseEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Request a review of an email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailReviewRequest Email commseq email review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    review(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailReviewRequest: EmailCommseqEmailSendTestRequest, options?: any): Promise<EmailCommseqEmailSendTestResponse>;

    /**
     * 
     * @summary Searches for all matching values
     * @param {string} [category] 
     * @param {string} [matches] 
     * @param {string} [storefrontOid] 
     * @param {number} [maxHits] 
     * @param {string} [subcategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    search(category?: string, matches?: string, storefrontOid?: string, maxHits?: number, subcategory?: string, options?: any): Promise<LookupResponse>;

    /**
     * 
     * @summary Searches for all matching values (using POST)
     * @param {LookupRequest} lookupRequest LookupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    search2(lookupRequest: LookupRequest, options?: any): Promise<LookupResponse>;

    /**
     * 
     * @summary Search email list customers
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchEmailListCustomers(storefrontOid: number, emailListUuid: string, startsWith?: string, options?: any): Promise<EmailListCustomersResponse>;

    /**
     * 
     * @summary Search email segment customers
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, startsWith?: string, options?: any): Promise<EmailSegmentCustomersResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchLibraryItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchPublishedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items needing review or rejected
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchReviewItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchSharedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * 
     * @summary Send email test
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailTestRequest Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    sendEmailTest(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailTestRequest: EmailCommseqEmailSendTestRequest, options?: any): Promise<EmailCommseqEmailSendTestResponse>;

    /**
     * 
     * @summary Send postcard test
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {EmailCommseqPostcardSendTestRequest} emailCommseqPostcardTestRequest Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    sendPostcardTest(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcardTestRequest: EmailCommseqPostcardSendTestRequest, options?: any): Promise<EmailCommseqPostcardSendTestResponse>;

    /**
     * 
     * @summary Start email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    startEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Subscribe customers to email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {Array<EmailCustomer>} customers Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    subscribeToEmailList(storefrontOid: number, emailListUuid: string, customers: Array<EmailCustomer>, options?: any): Promise<EmailListSubscribeResponse>;

    /**
     * 
     * @summary Update email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {EmailCampaign} emailCampaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailCampaign(storefrontOid: number, emailCampaignUuid: string, emailCampaign: EmailCampaign, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Update email commseq
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailCommseq} emailCommseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailCommseq(storefrontOid: number, commseqUuid: string, emailCommseq: EmailCommseq, options?: any): Promise<EmailCommseqResponse>;

    /**
     * 
     * @summary Update email customer
     * @param {number} storefrontOid 
     * @param {string} emailCustomerUuid 
     * @param {EmailCustomer} emailCustomer Email customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailCustomer(storefrontOid: number, emailCustomerUuid: string, emailCustomer: EmailCustomer, options?: any): Promise<{}>;

    /**
     * 
     * @summary Update email email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {EmailCommseqEmail} emailCommseqEmail Email commseq email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailEmail(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmail: EmailCommseqEmail, options?: any): Promise<EmailCommseqEmailResponse>;

    /**
     * 
     * @summary Update email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {EmailFlow} emailFlow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailFlow(storefrontOid: number, emailFlowUuid: string, emailFlow: EmailFlow, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Update email global settings
     * @param {EmailGlobalSettings} globalSettings global settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailGlobalSettings(globalSettings: EmailGlobalSettings, options?: any): Promise<EmailGlobalSettingsResponse>;

    /**
     * 
     * @summary Update email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {EmailList} emailList Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailList(storefrontOid: number, emailListUuid: string, emailList: EmailList, options?: any): Promise<EmailListResponse>;

    /**
     * 
     * @summary Update email plan
     * @param {number} storefrontOid 
     * @param {EmailPlan} settings plan request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailPlan(storefrontOid: number, settings: EmailPlan, options?: any): Promise<EmailPlanResponse>;

    /**
     * 
     * @summary Update email postcard
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {EmailCommseqPostcard} emailCommseqPostcard Email commseq postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcard: EmailCommseqPostcard, options?: any): Promise<EmailCommseqPostcardResponse>;

    /**
     * 
     * @summary Update email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {EmailSegment} emailSegment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegment: EmailSegment, options?: any): Promise<EmailSegmentResponse>;

    /**
     * 
     * @summary Update email settings
     * @param {number} storefrontOid 
     * @param {EmailSettings} settings settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailSettings(storefrontOid: number, settings: EmailSettings, options?: any): Promise<EmailSettingsResponse>;

    /**
     * 
     * @summary Update experiment
     * @param {number} storefrontOid 
     * @param {number} storefrontExperimentOid 
     * @param {Experiment} experiment Experiment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateExperiment(storefrontOid: number, storefrontExperimentOid: number, experiment: Experiment, options?: any): Promise<ExperimentResponse>;

    /**
     * 
     * @summary Update library item. Note that only certain fields may be updated via this method.
     * @param {number} libraryItemOid 
     * @param {LibraryItem} libraryItem Library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateLibraryItem(libraryItemOid: number, libraryItem: LibraryItem, options?: any): Promise<LibraryItemResponse>;

    /**
     * Updates a transactional email 
     * @summary Updates a transaction email object
     * @param {number} storefrontOid 
     * @param {string} emailId 
     * @param {TransactionEmail} transactionEmail TransactionEmail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateTransactionEmail(storefrontOid: number, emailId: string, transactionEmail: TransactionEmail, options?: any): Promise<TransactionEmailResponse>;

}

/**
 * StorefrontApi - object-oriented interface
 * @export
 * @class StorefrontApi
 * @extends {BaseAPI}
 */
export class StorefrontApi extends BaseAPI implements StorefrontApiInterface {
    /**
     * 
     * @summary Add to library
     * @param {AddLibraryItemRequest} addLibraryRequest New library item request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public addToLibrary(addLibraryRequest: AddLibraryItemRequest, options?: any) {
        return StorefrontApiFp(this.configuration).addToLibrary(addLibraryRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Apply library item to storefront.
     * @param {ApplyLibraryItemRequest} applyLibraryRequest New library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public applyToStoreFront(applyLibraryRequest: ApplyLibraryItemRequest, options?: any) {
        return StorefrontApiFp(this.configuration).applyToStoreFront(applyLibraryRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public archiveEmailList(storefrontOid: number, emailListUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).archiveEmailList(storefrontOid, emailListUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public archiveEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).archiveEmailSegment(storefrontOid, emailSegmentUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Back populate email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {EmailFlowBackPopulateRequest} backPopulateRequest The request to back populate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public backPopulateEmailFlow(storefrontOid: number, emailFlowUuid: string, backPopulateRequest: EmailFlowBackPopulateRequest, options?: any) {
        return StorefrontApiFp(this.configuration).backPopulateEmailFlow(storefrontOid, emailFlowUuid, backPopulateRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check download of email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {string} emailSegmentRebuildUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public checkDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegmentRebuildUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).checkDownloadEmailSegment(storefrontOid, emailSegmentUuid, emailSegmentRebuildUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clone email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {number} [targetStorefrontOid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public cloneEmailCampaign(storefrontOid: number, emailCampaignUuid: string, targetStorefrontOid?: number, options?: any) {
        return StorefrontApiFp(this.configuration).cloneEmailCampaign(storefrontOid, emailCampaignUuid, targetStorefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clone email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {number} [targetStorefrontOid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public cloneEmailFlow(storefrontOid: number, emailFlowUuid: string, targetStorefrontOid?: number, options?: any) {
        return StorefrontApiFp(this.configuration).cloneEmailFlow(storefrontOid, emailFlowUuid, targetStorefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public createEmailSendingDomain(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).createEmailSendingDomain(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete communication sequence stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailCommseqStat(storefrontOid: number, commseqUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailCommseqStat(storefrontOid, commseqUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailEmail(storefrontOid, commseqEmailUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email list customer
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailListCustomer(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailListCustomer(storefrontOid, emailListUuid, emailCustomerUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email postcard
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailPostcard(storefrontOid, commseqPostcardUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary delete email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailSendingDomain(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailSendingDomain(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete experiment
     * @param {number} storefrontOid 
     * @param {number} storefrontExperimentOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteExperiment(storefrontOid: number, storefrontExperimentOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).deleteExperiment(storefrontOid, storefrontExperimentOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete library item
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteLibraryItem(libraryItemOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).deleteLibraryItem(libraryItemOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Duplicate library item.
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public duplicateLibraryItem(libraryItemOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).duplicateLibraryItem(libraryItemOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Obtain lat/long for an address
     * @param {number} storefrontOid 
     * @param {GeocodeRequest} geocodeRequest geocode request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public geocodeAddress(storefrontOid: number, geocodeRequest: GeocodeRequest, options?: any) {
        return StorefrontApiFp(this.configuration).geocodeAddress(storefrontOid, geocodeRequest, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of all the countries 
     * @summary Get countries
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getCountries(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getCountries(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a temporary authentication token for the editor 
     * @summary Gets editor token
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEditorToken(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEditorToken(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication base templates
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailBaseTemplates(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailBaseTemplates(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaign(storefrontOid, emailCampaignUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign screenshots
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaignScreenshots(storefrontOid: number, emailCampaignUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaignScreenshots(storefrontOid, emailCampaignUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaigns
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaigns(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaigns(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaigns with stats
     * @param {number} storefrontOid 
     * @param {string} statDays 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaignsWithStats(storefrontOid: number, statDays: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaignsWithStats(storefrontOid, statDays, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email commseq
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseq(storefrontOid: number, commseqUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseq(storefrontOid, commseqUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence emails stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStatSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqEmailStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatSummaryRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqEmailStats(storefrontOid, commseqUuid, statsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence postcard stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqPostcardStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqPostcardStats(storefrontOid, commseqUuid, statsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get communication sequence stats overall
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqStatOverall(storefrontOid: number, commseqUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqStatOverall(storefrontOid, commseqUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence step stats
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStepStatRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqStepStats(storefrontOid: number, commseqUuid: string, statsRequest: EmailStepStatRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqStepStats(storefrontOid, commseqUuid, statsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence customers waiting at each requested step
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, waitingRequest: EmailStepWaitingRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqStepWaiting(storefrontOid, commseqUuid, waitingRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email commseqs
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqs(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqs(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get customers editor URL
     * @param {number} storefrontOid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCustomerEditorUrl(storefrontOid: number, emailCustomerUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCustomerEditorUrl(storefrontOid, emailCustomerUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email customers
     * @param {number} storefrontOid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {string} [searchEmailPrefix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCustomers(storefrontOid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCustomers(storefrontOid, pageNumber, pageSize, searchEmailPrefix, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email dashboard activity
     * @param {number} storefrontOid 
     * @param {number} [lastRecords] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailDashboardActivity(storefrontOid: number, lastRecords?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailDashboardActivity(storefrontOid, lastRecords, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get dashboard stats
     * @param {number} storefrontOid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailDashboardStats(storefrontOid: number, days?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailDashboardStats(storefrontOid, days, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmail(storefrontOid: number, commseqEmailUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmail(storefrontOid, commseqEmailUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email email clicks
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {string} commseqStepUuid 
     * @param {string} commseqEmailUuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailClicks(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailClicks(storefrontOid, commseqUuid, commseqStepUuid, commseqEmailUuid, days, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email order customer editor url
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailCustomerEditorUrl(storefrontOid: number, commseqEmailUuid: string, orderId: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailCustomerEditorUrl(storefrontOid, commseqEmailUuid, orderId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email email orders
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {string} commseqStepUuid 
     * @param {string} commseqEmailUuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailOrders(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailOrders(storefrontOid, commseqUuid, commseqStepUuid, commseqEmailUuid, days, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email emails
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmails(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmails(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email emails multiple
     * @param {number} storefrontOid 
     * @param {EmailCommseqEmailsRequest} emailCommseqEmailsRequest Request of email uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailsMultiple(storefrontOid: number, emailCommseqEmailsRequest: EmailCommseqEmailsRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailsMultiple(storefrontOid, emailCommseqEmailsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlow(storefrontOid: number, emailFlowUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlow(storefrontOid, emailFlowUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flow screenshots
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlowScreenshots(storefrontOid: number, emailFlowUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlowScreenshots(storefrontOid, emailFlowUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flows
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlows(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlows(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email globalsettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailGlobalSettings(options?: any) {
        return StorefrontApiFp(this.configuration).getEmailGlobalSettings(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailList(storefrontOid: number, emailListUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailList(storefrontOid, emailListUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email list customer editor url
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailListCustomerEditorUrl(storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailListCustomerEditorUrl(storefrontOid, emailListUuid, emailCustomerUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email list customers
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailListCustomers(storefrontOid: number, emailListUuid: string, pageNumber?: number, pageSize?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailListCustomers(storefrontOid, emailListUuid, pageNumber, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email lists
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailLists(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailLists(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email performance
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPerformance(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPerformance(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email plan
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPlan(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPlan(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email postcard
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPostcard(storefrontOid, commseqPostcardUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email postcards
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPostcards(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPostcards(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email postcards multiple
     * @param {number} storefrontOid 
     * @param {EmailCommseqPostcardsRequest} emailCommseqPostcardsRequest Request of postcard uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPostcardsMultiple(storefrontOid: number, emailCommseqPostcardsRequest: EmailCommseqPostcardsRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPostcardsMultiple(storefrontOid, emailCommseqPostcardsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegment(storefrontOid, emailSegmentUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segment customers editor URL
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {string} emailCustomerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegmentCustomerEditorUrl(storefrontOid: number, emailSegmentUuid: string, emailCustomerUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegmentCustomerEditorUrl(storefrontOid, emailSegmentUuid, emailCustomerUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segment customers
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, pageNumber?: number, pageSize?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegmentCustomers(storefrontOid, emailSegmentUuid, pageNumber, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segments
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegments(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegments(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email sending domain
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSendingDomain(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSendingDomain(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email sending domain status
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSendingDomainStatus(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSendingDomainStatus(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email sending domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSendingDomains(options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSendingDomains(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email settings
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSettings(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSettings(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email template
     * @param {number} storefrontOid 
     * @param {number} emailTemplateOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailTemplate(storefrontOid: number, emailTemplateOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailTemplate(storefrontOid, emailTemplateOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email templates
     * @param {number} storefrontOid 
     * @param {string} [triggerType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailTemplates(storefrontOid: number, triggerType?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailTemplates(storefrontOid, triggerType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of third party email providers
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailThirdPartyProviders(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailThirdPartyProviders(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get experiments
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getExperiments(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getExperiments(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of property names for a given property type 
     * @summary Get histogram property names
     * @param {number} storefrontOid 
     * @param {string} [propertyType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getHistogramPropertyNames(storefrontOid: number, propertyType?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getHistogramPropertyNames(storefrontOid, propertyType, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of property values for a given property name and type 
     * @summary Get histogram property values
     * @param {number} storefrontOid 
     * @param {string} [propertyName] 
     * @param {string} [propertyType] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getHistogramPropertyValues(storefrontOid: number, propertyName?: string, propertyType?: string, limit?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getHistogramPropertyValues(storefrontOid, propertyName, propertyType, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get library values used to populate drop down boxes for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getLibraryFilterValues(options?: any) {
        return StorefrontApiFp(this.configuration).getLibraryFilterValues(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get library item.
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getLibraryItem(libraryItemOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getLibraryItem(libraryItemOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get thumbnail parameters
     * @param {ThumbnailParametersRequest} thumbnailParameters Thumbnail Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getThumbnailParameters(thumbnailParameters: ThumbnailParametersRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getThumbnailParameters(thumbnailParameters, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a transactional email 
     * @summary Gets a transaction email object
     * @param {number} storefrontOid 
     * @param {string} emailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTransactionEmail(storefrontOid: number, emailId: string, options?: any) {
        return StorefrontApiFp(this.configuration).getTransactionEmail(storefrontOid, emailId, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of all transactional emails and return back just their names 
     * @summary Gets a list of transaction email names
     * @param {number} storefrontOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTransactionEmailList(storefrontOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getTransactionEmailList(storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get transactional email screenshots
     * @param {number} storefrontOid 
     * @param {string} emailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTransactionEmailScreenshots(storefrontOid: number, emailId: string, options?: any) {
        return StorefrontApiFp(this.configuration).getTransactionEmailScreenshots(storefrontOid, emailId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Globally unsubscribe a customer
     * @param {number} storefrontOid 
     * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public globalUnsubscribe(storefrontOid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any) {
        return StorefrontApiFp(this.configuration).globalUnsubscribe(storefrontOid, unsubscribe, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Import a third party provider list
     * @param {number} storefrontOid 
     * @param {EmailThirdPartyListImportRequest} importRequest lists to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public importEmailThirdPartyProviderList(storefrontOid: number, importRequest: EmailThirdPartyListImportRequest, options?: any) {
        return StorefrontApiFp(this.configuration).importEmailThirdPartyProviderList(storefrontOid, importRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email campaign
     * @param {number} storefrontOid 
     * @param {EmailCampaign} emailCampaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailCampaign(storefrontOid: number, emailCampaign: EmailCampaign, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailCampaign(storefrontOid, emailCampaign, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email commseq
     * @param {number} storefrontOid 
     * @param {EmailCommseq} emailCommseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailCommseq(storefrontOid: number, emailCommseq: EmailCommseq, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailCommseq(storefrontOid, emailCommseq, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email email
     * @param {number} storefrontOid 
     * @param {EmailCommseqEmail} emailCommseqEmail Email email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailEmail(storefrontOid: number, emailCommseqEmail: EmailCommseqEmail, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailEmail(storefrontOid, emailCommseqEmail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email flow
     * @param {number} storefrontOid 
     * @param {EmailFlow} emailFlow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailFlow(storefrontOid: number, emailFlow: EmailFlow, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailFlow(storefrontOid, emailFlow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email list
     * @param {number} storefrontOid 
     * @param {EmailList} emailList Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailList(storefrontOid: number, emailList: EmailList, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailList(storefrontOid, emailList, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email postcard
     * @param {number} storefrontOid 
     * @param {EmailCommseqPostcard} emailCommseqPostcard Email postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailPostcard(storefrontOid: number, emailCommseqPostcard: EmailCommseqPostcard, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailPostcard(storefrontOid, emailCommseqPostcard, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email segment
     * @param {number} storefrontOid 
     * @param {EmailSegment} emailSegment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailSegment(storefrontOid: number, emailSegment: EmailSegment, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailSegment(storefrontOid, emailSegment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Prepare download of email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public prepareDownloadEmailSegment(storefrontOid: number, emailSegmentUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).prepareDownloadEmailSegment(storefrontOid, emailSegmentUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Publish library item.
     * @param {number} libraryItemOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public publishLibraryItem(libraryItemOid: number, options?: any) {
        return StorefrontApiFp(this.configuration).publishLibraryItem(libraryItemOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Purchase public library item, which creates a copy of the item in your personal code library
     * @param {number} libraryItemOid 
     * @param {number} [storefrontOid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public purchaseLibraryItem(libraryItemOid: number, storefrontOid?: number, options?: any) {
        return StorefrontApiFp(this.configuration).purchaseLibraryItem(libraryItemOid, storefrontOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Release email communication sequence customers waiting at the specified step
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {string} commseqStepUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public releaseEmailCommseqStepWaiting(storefrontOid: number, commseqUuid: string, commseqStepUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).releaseEmailCommseqStepWaiting(storefrontOid, commseqUuid, commseqStepUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Request a review of an email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailReviewRequest Email commseq email review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public review(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailReviewRequest: EmailCommseqEmailSendTestRequest, options?: any) {
        return StorefrontApiFp(this.configuration).review(storefrontOid, commseqEmailUuid, emailCommseqEmailReviewRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Searches for all matching values
     * @param {string} [category] 
     * @param {string} [matches] 
     * @param {string} [storefrontOid] 
     * @param {number} [maxHits] 
     * @param {string} [subcategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public search(category?: string, matches?: string, storefrontOid?: string, maxHits?: number, subcategory?: string, options?: any) {
        return StorefrontApiFp(this.configuration).search(category, matches, storefrontOid, maxHits, subcategory, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Searches for all matching values (using POST)
     * @param {LookupRequest} lookupRequest LookupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public search2(lookupRequest: LookupRequest, options?: any) {
        return StorefrontApiFp(this.configuration).search2(lookupRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search email list customers
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchEmailListCustomers(storefrontOid: number, emailListUuid: string, startsWith?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchEmailListCustomers(storefrontOid, emailListUuid, startsWith, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search email segment customers
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchEmailSegmentCustomers(storefrontOid: number, emailSegmentUuid: string, startsWith?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchEmailSegmentCustomers(storefrontOid, emailSegmentUuid, startsWith, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchLibraryItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchLibraryItems(itemQuery, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchPublishedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchPublishedItems(itemQuery, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items needing review or rejected
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchReviewItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchReviewItems(itemQuery, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} itemQuery Item query
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchSharedItems(itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchSharedItems(itemQuery, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send email test
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {EmailCommseqEmailSendTestRequest} emailCommseqEmailTestRequest Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public sendEmailTest(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailTestRequest: EmailCommseqEmailSendTestRequest, options?: any) {
        return StorefrontApiFp(this.configuration).sendEmailTest(storefrontOid, commseqEmailUuid, emailCommseqEmailTestRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send postcard test
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {EmailCommseqPostcardSendTestRequest} emailCommseqPostcardTestRequest Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public sendPostcardTest(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcardTestRequest: EmailCommseqPostcardSendTestRequest, options?: any) {
        return StorefrontApiFp(this.configuration).sendPostcardTest(storefrontOid, commseqPostcardUuid, emailCommseqPostcardTestRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public startEmailCampaign(storefrontOid: number, emailCampaignUuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).startEmailCampaign(storefrontOid, emailCampaignUuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Subscribe customers to email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {Array<EmailCustomer>} customers Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public subscribeToEmailList(storefrontOid: number, emailListUuid: string, customers: Array<EmailCustomer>, options?: any) {
        return StorefrontApiFp(this.configuration).subscribeToEmailList(storefrontOid, emailListUuid, customers, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email campaign
     * @param {number} storefrontOid 
     * @param {string} emailCampaignUuid 
     * @param {EmailCampaign} emailCampaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailCampaign(storefrontOid: number, emailCampaignUuid: string, emailCampaign: EmailCampaign, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailCampaign(storefrontOid, emailCampaignUuid, emailCampaign, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email commseq
     * @param {number} storefrontOid 
     * @param {string} commseqUuid 
     * @param {EmailCommseq} emailCommseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailCommseq(storefrontOid: number, commseqUuid: string, emailCommseq: EmailCommseq, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailCommseq(storefrontOid, commseqUuid, emailCommseq, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email customer
     * @param {number} storefrontOid 
     * @param {string} emailCustomerUuid 
     * @param {EmailCustomer} emailCustomer Email customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailCustomer(storefrontOid: number, emailCustomerUuid: string, emailCustomer: EmailCustomer, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailCustomer(storefrontOid, emailCustomerUuid, emailCustomer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email email
     * @param {number} storefrontOid 
     * @param {string} commseqEmailUuid 
     * @param {EmailCommseqEmail} emailCommseqEmail Email commseq email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailEmail(storefrontOid: number, commseqEmailUuid: string, emailCommseqEmail: EmailCommseqEmail, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailEmail(storefrontOid, commseqEmailUuid, emailCommseqEmail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email flow
     * @param {number} storefrontOid 
     * @param {string} emailFlowUuid 
     * @param {EmailFlow} emailFlow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailFlow(storefrontOid: number, emailFlowUuid: string, emailFlow: EmailFlow, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailFlow(storefrontOid, emailFlowUuid, emailFlow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email global settings
     * @param {EmailGlobalSettings} globalSettings global settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailGlobalSettings(globalSettings: EmailGlobalSettings, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailGlobalSettings(globalSettings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email list
     * @param {number} storefrontOid 
     * @param {string} emailListUuid 
     * @param {EmailList} emailList Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailList(storefrontOid: number, emailListUuid: string, emailList: EmailList, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailList(storefrontOid, emailListUuid, emailList, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email plan
     * @param {number} storefrontOid 
     * @param {EmailPlan} settings plan request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailPlan(storefrontOid: number, settings: EmailPlan, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailPlan(storefrontOid, settings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email postcard
     * @param {number} storefrontOid 
     * @param {string} commseqPostcardUuid 
     * @param {EmailCommseqPostcard} emailCommseqPostcard Email commseq postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailPostcard(storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcard: EmailCommseqPostcard, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailPostcard(storefrontOid, commseqPostcardUuid, emailCommseqPostcard, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email segment
     * @param {number} storefrontOid 
     * @param {string} emailSegmentUuid 
     * @param {EmailSegment} emailSegment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailSegment(storefrontOid: number, emailSegmentUuid: string, emailSegment: EmailSegment, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailSegment(storefrontOid, emailSegmentUuid, emailSegment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email settings
     * @param {number} storefrontOid 
     * @param {EmailSettings} settings settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailSettings(storefrontOid: number, settings: EmailSettings, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailSettings(storefrontOid, settings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update experiment
     * @param {number} storefrontOid 
     * @param {number} storefrontExperimentOid 
     * @param {Experiment} experiment Experiment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateExperiment(storefrontOid: number, storefrontExperimentOid: number, experiment: Experiment, options?: any) {
        return StorefrontApiFp(this.configuration).updateExperiment(storefrontOid, storefrontExperimentOid, experiment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update library item. Note that only certain fields may be updated via this method.
     * @param {number} libraryItemOid 
     * @param {LibraryItem} libraryItem Library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateLibraryItem(libraryItemOid: number, libraryItem: LibraryItem, options?: any) {
        return StorefrontApiFp(this.configuration).updateLibraryItem(libraryItemOid, libraryItem, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a transactional email 
     * @summary Updates a transaction email object
     * @param {number} storefrontOid 
     * @param {string} emailId 
     * @param {TransactionEmail} transactionEmail TransactionEmail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateTransactionEmail(storefrontOid: number, emailId: string, transactionEmail: TransactionEmail, options?: any) {
        return StorefrontApiFp(this.configuration).updateTransactionEmail(storefrontOid, emailId, transactionEmail, options)(this.fetch, this.basePath);
    }

}

/**
 * TaxApi - fetch parameter creator
 * @export
 */
export const TaxApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Self tax provider city. 
         * @summary Deletes a Self tax provider city
         * @param {string} city The city being deleted.
         * @param {TaxCity} taxCity tax city to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCity(city: string, taxCity: TaxCity, options: any = {}): FetchArgs {
            // verify required parameter 'city' is not null or undefined
            if (city === null || city === undefined) {
                throw new RequiredError('city','Required parameter city was null or undefined when calling deleteTaxProviderSelfCity.');
            }
            // verify required parameter 'taxCity' is not null or undefined
            if (taxCity === null || taxCity === undefined) {
                throw new RequiredError('taxCity','Required parameter taxCity was null or undefined when calling deleteTaxProviderSelfCity.');
            }
            const localVarPath = `/tax/providers/self/city/{city}`
                .replace(`{${"city"}}`, encodeURIComponent(String(city)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCity" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxCity || {}) : (taxCity || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider country. 
         * @summary Deletes a Self tax provider country
         * @param {string} countryCode The country code being deleted.
         * @param {TaxCountry} taxCountry tax country to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options: any = {}): FetchArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling deleteTaxProviderSelfCountry.');
            }
            // verify required parameter 'taxCountry' is not null or undefined
            if (taxCountry === null || taxCountry === undefined) {
                throw new RequiredError('taxCountry','Required parameter taxCountry was null or undefined when calling deleteTaxProviderSelfCountry.');
            }
            const localVarPath = `/tax/providers/self/country/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCountry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxCountry || {}) : (taxCountry || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider county. 
         * @summary Deletes a Self tax provider county
         * @param {string} county The county being deleted.
         * @param {TaxCounty} taxCounty tax county to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options: any = {}): FetchArgs {
            // verify required parameter 'county' is not null or undefined
            if (county === null || county === undefined) {
                throw new RequiredError('county','Required parameter county was null or undefined when calling deleteTaxProviderSelfCounty.');
            }
            // verify required parameter 'taxCounty' is not null or undefined
            if (taxCounty === null || taxCounty === undefined) {
                throw new RequiredError('taxCounty','Required parameter taxCounty was null or undefined when calling deleteTaxProviderSelfCounty.');
            }
            const localVarPath = `/tax/providers/self/county/{county}`
                .replace(`{${"county"}}`, encodeURIComponent(String(county)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCounty" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxCounty || {}) : (taxCounty || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider postalCode. 
         * @summary Deletes a Self tax provider postalCode
         * @param {string} postalCode The postal code being deleted.
         * @param {TaxPostalCode} taxPostalCode tax postal code to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options: any = {}): FetchArgs {
            // verify required parameter 'postalCode' is not null or undefined
            if (postalCode === null || postalCode === undefined) {
                throw new RequiredError('postalCode','Required parameter postalCode was null or undefined when calling deleteTaxProviderSelfPostalCode.');
            }
            // verify required parameter 'taxPostalCode' is not null or undefined
            if (taxPostalCode === null || taxPostalCode === undefined) {
                throw new RequiredError('taxPostalCode','Required parameter taxPostalCode was null or undefined when calling deleteTaxProviderSelfPostalCode.');
            }
            const localVarPath = `/tax/providers/self/postalCode/{postal_code}`
                .replace(`{${"postal_code"}}`, encodeURIComponent(String(postalCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxPostalCode" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxPostalCode || {}) : (taxPostalCode || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider state. 
         * @summary Deletes a Self tax provider state
         * @param {string} stateCode The state code being deleted.
         * @param {TaxState} taxState tax state to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfState(stateCode: string, taxState: TaxState, options: any = {}): FetchArgs {
            // verify required parameter 'stateCode' is not null or undefined
            if (stateCode === null || stateCode === undefined) {
                throw new RequiredError('stateCode','Required parameter stateCode was null or undefined when calling deleteTaxProviderSelfState.');
            }
            // verify required parameter 'taxState' is not null or undefined
            if (taxState === null || taxState === undefined) {
                throw new RequiredError('taxState','Required parameter taxState was null or undefined when calling deleteTaxProviderSelfState.');
            }
            const localVarPath = `/tax/providers/self/state/{stateCode}`
                .replace(`{${"stateCode"}}`, encodeURIComponent(String(stateCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxState || {}) : (taxState || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Avalara tax provider. 
         * @summary Retrieve the Avalara tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalara(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/avalara`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Avalara Tax companies configured by the merchant 
         * @summary Returns Avalara Tax companies configured by the merchant
         * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraCompanies(taxProviderAvalara: TaxProviderAvalara, options: any = {}): FetchArgs {
            // verify required parameter 'taxProviderAvalara' is not null or undefined
            if (taxProviderAvalara === null || taxProviderAvalara === undefined) {
                throw new RequiredError('taxProviderAvalara','Required parameter taxProviderAvalara was null or undefined when calling getTaxProviderAvalaraCompanies.');
            }
            const localVarPath = `/tax/providers/avalara/companies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderAvalara" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxProviderAvalara || {}) : (taxProviderAvalara || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to connect to Avalara and returns back the response. 
         * @summary Attempts to connect to Avalara and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraTest(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/avalara/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Self tax provider. 
         * @summary Retrieve the Self tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelf(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Self tax provider countries. 
         * @summary Retrieve the Self tax provider countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfCountries(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/self/countries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Self tax provider regions for a given country code. 
         * @summary Retrieve the Self tax provider regions for a given country code
         * @param {string} countryCode The country code regions desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfRegionsByCountryCode(countryCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling getTaxProviderSelfRegionsByCountryCode.');
            }
            const localVarPath = `/tax/providers/self/regions/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Sovos tax provider. 
         * @summary Retrieve the Sovos tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovos(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/sovos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to connect to Sovos and returns back the response. 
         * @summary Attempts to connect to Sovos and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovosTest(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/sovos/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the TaxJar tax provider. 
         * @summary Retrieve the TaxJar tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJar(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/taxjar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to connect to TaxJar and returns back the response. 
         * @summary Attempts to connect to TaxJar and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJarTest(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/taxjar/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the UltraCart tax provider. 
         * @summary Retrieve the UltraCart tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderUltraCart(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/ultracart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves tax methods for this account. 
         * @summary Retrieve tax methods
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviders(limit?: number, offset?: number, expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (expand !== undefined) {
                localVarQueryParameter['_expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle a tax provider to active. 
         * @summary Toggle a tax provider to active
         * @param {string} providerName The tax provider to set active.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveTaxProvider(providerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'providerName' is not null or undefined
            if (providerName === null || providerName === undefined) {
                throw new RequiredError('providerName','Required parameter providerName was null or undefined when calling setActiveTaxProvider.');
            }
            const localVarPath = `/tax/providers/setActive/{providerName}`
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Avalara tax provider. 
         * @summary Update the Avalara tax provider
         * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderAvalara(taxProviderAvalara: TaxProviderAvalara, options: any = {}): FetchArgs {
            // verify required parameter 'taxProviderAvalara' is not null or undefined
            if (taxProviderAvalara === null || taxProviderAvalara === undefined) {
                throw new RequiredError('taxProviderAvalara','Required parameter taxProviderAvalara was null or undefined when calling updateTaxProviderAvalara.');
            }
            const localVarPath = `/tax/providers/avalara`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderAvalara" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxProviderAvalara || {}) : (taxProviderAvalara || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Self tax provider. 
         * @summary Update the Self tax provider
         * @param {TaxProviderSelf} taxProviderSelf TaxProviderSelf object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelf(taxProviderSelf: TaxProviderSelf, options: any = {}): FetchArgs {
            // verify required parameter 'taxProviderSelf' is not null or undefined
            if (taxProviderSelf === null || taxProviderSelf === undefined) {
                throw new RequiredError('taxProviderSelf','Required parameter taxProviderSelf was null or undefined when calling updateTaxProviderSelf.');
            }
            const localVarPath = `/tax/providers/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderSelf" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxProviderSelf || {}) : (taxProviderSelf || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider city. 
         * @summary Updates a Self tax provider city
         * @param {string} city The city being updated.
         * @param {TaxCity} taxCity tax city to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCity(city: string, taxCity: TaxCity, options: any = {}): FetchArgs {
            // verify required parameter 'city' is not null or undefined
            if (city === null || city === undefined) {
                throw new RequiredError('city','Required parameter city was null or undefined when calling updateTaxProviderSelfCity.');
            }
            // verify required parameter 'taxCity' is not null or undefined
            if (taxCity === null || taxCity === undefined) {
                throw new RequiredError('taxCity','Required parameter taxCity was null or undefined when calling updateTaxProviderSelfCity.');
            }
            const localVarPath = `/tax/providers/self/city/{city}`
                .replace(`{${"city"}}`, encodeURIComponent(String(city)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCity" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxCity || {}) : (taxCity || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider country. 
         * @summary Updates a Self tax provider country
         * @param {string} countryCode The country code being updated.
         * @param {TaxCountry} taxCountry tax country to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options: any = {}): FetchArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling updateTaxProviderSelfCountry.');
            }
            // verify required parameter 'taxCountry' is not null or undefined
            if (taxCountry === null || taxCountry === undefined) {
                throw new RequiredError('taxCountry','Required parameter taxCountry was null or undefined when calling updateTaxProviderSelfCountry.');
            }
            const localVarPath = `/tax/providers/self/country/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCountry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxCountry || {}) : (taxCountry || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider county. 
         * @summary Updates a Self tax provider county
         * @param {string} county The county being updated.
         * @param {TaxCounty} taxCounty tax county to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options: any = {}): FetchArgs {
            // verify required parameter 'county' is not null or undefined
            if (county === null || county === undefined) {
                throw new RequiredError('county','Required parameter county was null or undefined when calling updateTaxProviderSelfCounty.');
            }
            // verify required parameter 'taxCounty' is not null or undefined
            if (taxCounty === null || taxCounty === undefined) {
                throw new RequiredError('taxCounty','Required parameter taxCounty was null or undefined when calling updateTaxProviderSelfCounty.');
            }
            const localVarPath = `/tax/providers/self/county/{county}`
                .replace(`{${"county"}}`, encodeURIComponent(String(county)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCounty" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxCounty || {}) : (taxCounty || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider postalCode. 
         * @summary Updates a Self tax provider postalCode
         * @param {string} postalCode The postal code being updated.
         * @param {TaxPostalCode} taxPostalCode tax postal code to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options: any = {}): FetchArgs {
            // verify required parameter 'postalCode' is not null or undefined
            if (postalCode === null || postalCode === undefined) {
                throw new RequiredError('postalCode','Required parameter postalCode was null or undefined when calling updateTaxProviderSelfPostalCode.');
            }
            // verify required parameter 'taxPostalCode' is not null or undefined
            if (taxPostalCode === null || taxPostalCode === undefined) {
                throw new RequiredError('taxPostalCode','Required parameter taxPostalCode was null or undefined when calling updateTaxProviderSelfPostalCode.');
            }
            const localVarPath = `/tax/providers/self/postalCode/{postal_code}`
                .replace(`{${"postal_code"}}`, encodeURIComponent(String(postalCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxPostalCode" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxPostalCode || {}) : (taxPostalCode || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider state. 
         * @summary Updates a Self tax provider state
         * @param {string} stateCode The state code being updated.
         * @param {TaxState} taxState tax state to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfState(stateCode: string, taxState: TaxState, options: any = {}): FetchArgs {
            // verify required parameter 'stateCode' is not null or undefined
            if (stateCode === null || stateCode === undefined) {
                throw new RequiredError('stateCode','Required parameter stateCode was null or undefined when calling updateTaxProviderSelfState.');
            }
            // verify required parameter 'taxState' is not null or undefined
            if (taxState === null || taxState === undefined) {
                throw new RequiredError('taxState','Required parameter taxState was null or undefined when calling updateTaxProviderSelfState.');
            }
            const localVarPath = `/tax/providers/self/state/{stateCode}`
                .replace(`{${"stateCode"}}`, encodeURIComponent(String(stateCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxState || {}) : (taxState || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Sovos tax provider. 
         * @summary Update the Sovos tax provider
         * @param {TaxProviderSovos} taxProviderSovos TaxProviderSovos object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSovos(taxProviderSovos: TaxProviderSovos, options: any = {}): FetchArgs {
            // verify required parameter 'taxProviderSovos' is not null or undefined
            if (taxProviderSovos === null || taxProviderSovos === undefined) {
                throw new RequiredError('taxProviderSovos','Required parameter taxProviderSovos was null or undefined when calling updateTaxProviderSovos.');
            }
            const localVarPath = `/tax/providers/sovos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderSovos" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxProviderSovos || {}) : (taxProviderSovos || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the TaxJar tax provider. 
         * @summary Update the TaxJar tax provider
         * @param {TaxProviderTaxJar} taxProviderTaxJar TaxProviderTaxJar object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderTaxJar(taxProviderTaxJar: TaxProviderTaxJar, options: any = {}): FetchArgs {
            // verify required parameter 'taxProviderTaxJar' is not null or undefined
            if (taxProviderTaxJar === null || taxProviderTaxJar === undefined) {
                throw new RequiredError('taxProviderTaxJar','Required parameter taxProviderTaxJar was null or undefined when calling updateTaxProviderTaxJar.');
            }
            const localVarPath = `/tax/providers/taxjar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderTaxJar" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxProviderTaxJar || {}) : (taxProviderTaxJar || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the UltraCart tax provider. 
         * @summary Update the UltraCart tax provider
         * @param {TaxProviderUltraCart} taxProviderUltracart TaxProviderUltraCart object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderUltraCart(taxProviderUltracart: TaxProviderUltraCart, options: any = {}): FetchArgs {
            // verify required parameter 'taxProviderUltracart' is not null or undefined
            if (taxProviderUltracart === null || taxProviderUltracart === undefined) {
                throw new RequiredError('taxProviderUltracart','Required parameter taxProviderUltracart was null or undefined when calling updateTaxProviderUltraCart.');
            }
            const localVarPath = `/tax/providers/ultracart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderUltraCart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(taxProviderUltracart || {}) : (taxProviderUltracart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxApi - functional programming interface
 * @export
 */
export const TaxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a Self tax provider city. 
         * @summary Deletes a Self tax provider city
         * @param {string} city The city being deleted.
         * @param {TaxCity} taxCity tax city to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfCity(city, taxCity, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider country. 
         * @summary Deletes a Self tax provider country
         * @param {string} countryCode The country code being deleted.
         * @param {TaxCountry} taxCountry tax country to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfCountry(countryCode, taxCountry, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider county. 
         * @summary Deletes a Self tax provider county
         * @param {string} county The county being deleted.
         * @param {TaxCounty} taxCounty tax county to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfCounty(county, taxCounty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider postalCode. 
         * @summary Deletes a Self tax provider postalCode
         * @param {string} postalCode The postal code being deleted.
         * @param {TaxPostalCode} taxPostalCode tax postal code to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfPostalCode(postalCode, taxPostalCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider state. 
         * @summary Deletes a Self tax provider state
         * @param {string} stateCode The state code being deleted.
         * @param {TaxState} taxState tax state to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfState(stateCode, taxState, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Avalara tax provider. 
         * @summary Retrieve the Avalara tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalara(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderAvalara> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderAvalara(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns Avalara Tax companies configured by the merchant 
         * @summary Returns Avalara Tax companies configured by the merchant
         * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraCompanies(taxProviderAvalara: TaxProviderAvalara, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderAvalaraCompaniesResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderAvalaraCompanies(taxProviderAvalara, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Attempts to connect to Avalara and returns back the response. 
         * @summary Attempts to connect to Avalara and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraTest(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTestResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderAvalaraTest(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Self tax provider. 
         * @summary Retrieve the Self tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelf(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelf> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSelf(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Self tax provider countries. 
         * @summary Retrieve the Self tax provider countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfCountries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelfCountriesResponse> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSelfCountries(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Self tax provider regions for a given country code. 
         * @summary Retrieve the Self tax provider regions for a given country code
         * @param {string} countryCode The country code regions desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelfRegionsResponse> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSelfRegionsByCountryCode(countryCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Sovos tax provider. 
         * @summary Retrieve the Sovos tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSovos> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSovos(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Attempts to connect to Sovos and returns back the response. 
         * @summary Attempts to connect to Sovos and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovosTest(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTestResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSovosTest(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the TaxJar tax provider. 
         * @summary Retrieve the TaxJar tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJar(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTaxJar> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderTaxJar(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Attempts to connect to TaxJar and returns back the response. 
         * @summary Attempts to connect to TaxJar and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJarTest(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTestResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderTaxJarTest(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the UltraCart tax provider. 
         * @summary Retrieve the UltraCart tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderUltraCart(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderUltraCart> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderUltraCart(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves tax methods for this account. 
         * @summary Retrieve tax methods
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviders(limit?: number, offset?: number, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProvidersResponse> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviders(limit, offset, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Toggle a tax provider to active. 
         * @summary Toggle a tax provider to active
         * @param {string} providerName The tax provider to set active.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveTaxProvider(providerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderActivateResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).setActiveTaxProvider(providerName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Avalara tax provider. 
         * @summary Update the Avalara tax provider
         * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderAvalara(taxProviderAvalara: TaxProviderAvalara, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderAvalara> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderAvalara(taxProviderAvalara, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Self tax provider. 
         * @summary Update the Self tax provider
         * @param {TaxProviderSelf} taxProviderSelf TaxProviderSelf object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelf(taxProviderSelf: TaxProviderSelf, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelf> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelf(taxProviderSelf, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider city. 
         * @summary Updates a Self tax provider city
         * @param {string} city The city being updated.
         * @param {TaxCity} taxCity tax city to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxCity> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfCity(city, taxCity, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider country. 
         * @summary Updates a Self tax provider country
         * @param {string} countryCode The country code being updated.
         * @param {TaxCountry} taxCountry tax country to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxCountry> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfCountry(countryCode, taxCountry, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider county. 
         * @summary Updates a Self tax provider county
         * @param {string} county The county being updated.
         * @param {TaxCounty} taxCounty tax county to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxCounty> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfCounty(county, taxCounty, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider postalCode. 
         * @summary Updates a Self tax provider postalCode
         * @param {string} postalCode The postal code being updated.
         * @param {TaxPostalCode} taxPostalCode tax postal code to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxPostalCode> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfPostalCode(postalCode, taxPostalCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider state. 
         * @summary Updates a Self tax provider state
         * @param {string} stateCode The state code being updated.
         * @param {TaxState} taxState tax state to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxState> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfState(stateCode, taxState, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Sovos tax provider. 
         * @summary Update the Sovos tax provider
         * @param {TaxProviderSovos} taxProviderSovos TaxProviderSovos object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSovos(taxProviderSovos: TaxProviderSovos, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSovos> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSovos(taxProviderSovos, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the TaxJar tax provider. 
         * @summary Update the TaxJar tax provider
         * @param {TaxProviderTaxJar} taxProviderTaxJar TaxProviderTaxJar object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderTaxJar(taxProviderTaxJar: TaxProviderTaxJar, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTaxJar> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderTaxJar(taxProviderTaxJar, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the UltraCart tax provider. 
         * @summary Update the UltraCart tax provider
         * @param {TaxProviderUltraCart} taxProviderUltracart TaxProviderUltraCart object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderUltraCart(taxProviderUltracart: TaxProviderUltraCart, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderUltraCart> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderUltraCart(taxProviderUltracart, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaxApi - factory interface
 * @export
 */
export const TaxApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a Self tax provider city. 
         * @summary Deletes a Self tax provider city
         * @param {string} city The city being deleted.
         * @param {TaxCity} taxCity tax city to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfCity(city, taxCity, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider country. 
         * @summary Deletes a Self tax provider country
         * @param {string} countryCode The country code being deleted.
         * @param {TaxCountry} taxCountry tax country to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfCountry(countryCode, taxCountry, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider county. 
         * @summary Deletes a Self tax provider county
         * @param {string} county The county being deleted.
         * @param {TaxCounty} taxCounty tax county to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfCounty(county, taxCounty, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider postalCode. 
         * @summary Deletes a Self tax provider postalCode
         * @param {string} postalCode The postal code being deleted.
         * @param {TaxPostalCode} taxPostalCode tax postal code to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfPostalCode(postalCode, taxPostalCode, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider state. 
         * @summary Deletes a Self tax provider state
         * @param {string} stateCode The state code being deleted.
         * @param {TaxState} taxState tax state to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfState(stateCode, taxState, options)(fetch, basePath);
        },
        /**
         * Retrieves the Avalara tax provider. 
         * @summary Retrieve the Avalara tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalara(options?: any) {
            return TaxApiFp(configuration).getTaxProviderAvalara(options)(fetch, basePath);
        },
        /**
         * Returns Avalara Tax companies configured by the merchant 
         * @summary Returns Avalara Tax companies configured by the merchant
         * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraCompanies(taxProviderAvalara: TaxProviderAvalara, options?: any) {
            return TaxApiFp(configuration).getTaxProviderAvalaraCompanies(taxProviderAvalara, options)(fetch, basePath);
        },
        /**
         * Attempts to connect to Avalara and returns back the response. 
         * @summary Attempts to connect to Avalara and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraTest(options?: any) {
            return TaxApiFp(configuration).getTaxProviderAvalaraTest(options)(fetch, basePath);
        },
        /**
         * Retrieves the Self tax provider. 
         * @summary Retrieve the Self tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelf(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSelf(options)(fetch, basePath);
        },
        /**
         * Retrieves the Self tax provider countries. 
         * @summary Retrieve the Self tax provider countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfCountries(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSelfCountries(options)(fetch, basePath);
        },
        /**
         * Retrieves the Self tax provider regions for a given country code. 
         * @summary Retrieve the Self tax provider regions for a given country code
         * @param {string} countryCode The country code regions desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any) {
            return TaxApiFp(configuration).getTaxProviderSelfRegionsByCountryCode(countryCode, options)(fetch, basePath);
        },
        /**
         * Retrieves the Sovos tax provider. 
         * @summary Retrieve the Sovos tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovos(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSovos(options)(fetch, basePath);
        },
        /**
         * Attempts to connect to Sovos and returns back the response. 
         * @summary Attempts to connect to Sovos and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovosTest(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSovosTest(options)(fetch, basePath);
        },
        /**
         * Retrieves the TaxJar tax provider. 
         * @summary Retrieve the TaxJar tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJar(options?: any) {
            return TaxApiFp(configuration).getTaxProviderTaxJar(options)(fetch, basePath);
        },
        /**
         * Attempts to connect to TaxJar and returns back the response. 
         * @summary Attempts to connect to TaxJar and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJarTest(options?: any) {
            return TaxApiFp(configuration).getTaxProviderTaxJarTest(options)(fetch, basePath);
        },
        /**
         * Retrieves the UltraCart tax provider. 
         * @summary Retrieve the UltraCart tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderUltraCart(options?: any) {
            return TaxApiFp(configuration).getTaxProviderUltraCart(options)(fetch, basePath);
        },
        /**
         * Retrieves tax methods for this account. 
         * @summary Retrieve tax methods
         * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviders(limit?: number, offset?: number, expand?: string, options?: any) {
            return TaxApiFp(configuration).getTaxProviders(limit, offset, expand, options)(fetch, basePath);
        },
        /**
         * Toggle a tax provider to active. 
         * @summary Toggle a tax provider to active
         * @param {string} providerName The tax provider to set active.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveTaxProvider(providerName: string, options?: any) {
            return TaxApiFp(configuration).setActiveTaxProvider(providerName, options)(fetch, basePath);
        },
        /**
         * Update the Avalara tax provider. 
         * @summary Update the Avalara tax provider
         * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderAvalara(taxProviderAvalara: TaxProviderAvalara, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderAvalara(taxProviderAvalara, options)(fetch, basePath);
        },
        /**
         * Update the Self tax provider. 
         * @summary Update the Self tax provider
         * @param {TaxProviderSelf} taxProviderSelf TaxProviderSelf object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelf(taxProviderSelf: TaxProviderSelf, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelf(taxProviderSelf, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider city. 
         * @summary Updates a Self tax provider city
         * @param {string} city The city being updated.
         * @param {TaxCity} taxCity tax city to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfCity(city, taxCity, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider country. 
         * @summary Updates a Self tax provider country
         * @param {string} countryCode The country code being updated.
         * @param {TaxCountry} taxCountry tax country to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfCountry(countryCode, taxCountry, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider county. 
         * @summary Updates a Self tax provider county
         * @param {string} county The county being updated.
         * @param {TaxCounty} taxCounty tax county to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfCounty(county, taxCounty, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider postalCode. 
         * @summary Updates a Self tax provider postalCode
         * @param {string} postalCode The postal code being updated.
         * @param {TaxPostalCode} taxPostalCode tax postal code to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfPostalCode(postalCode, taxPostalCode, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider state. 
         * @summary Updates a Self tax provider state
         * @param {string} stateCode The state code being updated.
         * @param {TaxState} taxState tax state to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfState(stateCode, taxState, options)(fetch, basePath);
        },
        /**
         * Update the Sovos tax provider. 
         * @summary Update the Sovos tax provider
         * @param {TaxProviderSovos} taxProviderSovos TaxProviderSovos object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSovos(taxProviderSovos: TaxProviderSovos, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSovos(taxProviderSovos, options)(fetch, basePath);
        },
        /**
         * Update the TaxJar tax provider. 
         * @summary Update the TaxJar tax provider
         * @param {TaxProviderTaxJar} taxProviderTaxJar TaxProviderTaxJar object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderTaxJar(taxProviderTaxJar: TaxProviderTaxJar, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderTaxJar(taxProviderTaxJar, options)(fetch, basePath);
        },
        /**
         * Update the UltraCart tax provider. 
         * @summary Update the UltraCart tax provider
         * @param {TaxProviderUltraCart} taxProviderUltracart TaxProviderUltraCart object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderUltraCart(taxProviderUltracart: TaxProviderUltraCart, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderUltraCart(taxProviderUltracart, options)(fetch, basePath);
        },
    };
};

/**
 * TaxApi - interface
 * @export
 * @interface TaxApi
 */
export interface TaxApiInterface {
    /**
     * Deletes a Self tax provider city. 
     * @summary Deletes a Self tax provider city
     * @param {string} city The city being deleted.
     * @param {TaxCity} taxCity tax city to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider country. 
     * @summary Deletes a Self tax provider country
     * @param {string} countryCode The country code being deleted.
     * @param {TaxCountry} taxCountry tax country to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider county. 
     * @summary Deletes a Self tax provider county
     * @param {string} county The county being deleted.
     * @param {TaxCounty} taxCounty tax county to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider postalCode. 
     * @summary Deletes a Self tax provider postalCode
     * @param {string} postalCode The postal code being deleted.
     * @param {TaxPostalCode} taxPostalCode tax postal code to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider state. 
     * @summary Deletes a Self tax provider state
     * @param {string} stateCode The state code being deleted.
     * @param {TaxState} taxState tax state to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any): Promise<{}>;

    /**
     * Retrieves the Avalara tax provider. 
     * @summary Retrieve the Avalara tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderAvalara(options?: any): Promise<TaxProviderAvalara>;

    /**
     * Returns Avalara Tax companies configured by the merchant 
     * @summary Returns Avalara Tax companies configured by the merchant
     * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderAvalaraCompanies(taxProviderAvalara: TaxProviderAvalara, options?: any): Promise<TaxProviderAvalaraCompaniesResult>;

    /**
     * Attempts to connect to Avalara and returns back the response. 
     * @summary Attempts to connect to Avalara and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderAvalaraTest(options?: any): Promise<TaxProviderTestResult>;

    /**
     * Retrieves the Self tax provider. 
     * @summary Retrieve the Self tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSelf(options?: any): Promise<TaxProviderSelf>;

    /**
     * Retrieves the Self tax provider countries. 
     * @summary Retrieve the Self tax provider countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSelfCountries(options?: any): Promise<TaxProviderSelfCountriesResponse>;

    /**
     * Retrieves the Self tax provider regions for a given country code. 
     * @summary Retrieve the Self tax provider regions for a given country code
     * @param {string} countryCode The country code regions desired.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any): Promise<TaxProviderSelfRegionsResponse>;

    /**
     * Retrieves the Sovos tax provider. 
     * @summary Retrieve the Sovos tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSovos(options?: any): Promise<TaxProviderSovos>;

    /**
     * Attempts to connect to Sovos and returns back the response. 
     * @summary Attempts to connect to Sovos and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSovosTest(options?: any): Promise<TaxProviderTestResult>;

    /**
     * Retrieves the TaxJar tax provider. 
     * @summary Retrieve the TaxJar tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderTaxJar(options?: any): Promise<TaxProviderTaxJar>;

    /**
     * Attempts to connect to TaxJar and returns back the response. 
     * @summary Attempts to connect to TaxJar and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderTaxJarTest(options?: any): Promise<TaxProviderTestResult>;

    /**
     * Retrieves the UltraCart tax provider. 
     * @summary Retrieve the UltraCart tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderUltraCart(options?: any): Promise<TaxProviderUltraCart>;

    /**
     * Retrieves tax methods for this account. 
     * @summary Retrieve tax methods
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviders(limit?: number, offset?: number, expand?: string, options?: any): Promise<TaxProvidersResponse>;

    /**
     * Toggle a tax provider to active. 
     * @summary Toggle a tax provider to active
     * @param {string} providerName The tax provider to set active.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    setActiveTaxProvider(providerName: string, options?: any): Promise<TaxProviderActivateResult>;

    /**
     * Update the Avalara tax provider. 
     * @summary Update the Avalara tax provider
     * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderAvalara(taxProviderAvalara: TaxProviderAvalara, options?: any): Promise<TaxProviderAvalara>;

    /**
     * Update the Self tax provider. 
     * @summary Update the Self tax provider
     * @param {TaxProviderSelf} taxProviderSelf TaxProviderSelf object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelf(taxProviderSelf: TaxProviderSelf, options?: any): Promise<TaxProviderSelf>;

    /**
     * Updates a Self tax provider city. 
     * @summary Updates a Self tax provider city
     * @param {string} city The city being updated.
     * @param {TaxCity} taxCity tax city to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any): Promise<TaxCity>;

    /**
     * Updates a Self tax provider country. 
     * @summary Updates a Self tax provider country
     * @param {string} countryCode The country code being updated.
     * @param {TaxCountry} taxCountry tax country to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any): Promise<TaxCountry>;

    /**
     * Updates a Self tax provider county. 
     * @summary Updates a Self tax provider county
     * @param {string} county The county being updated.
     * @param {TaxCounty} taxCounty tax county to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any): Promise<TaxCounty>;

    /**
     * Updates a Self tax provider postalCode. 
     * @summary Updates a Self tax provider postalCode
     * @param {string} postalCode The postal code being updated.
     * @param {TaxPostalCode} taxPostalCode tax postal code to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any): Promise<TaxPostalCode>;

    /**
     * Updates a Self tax provider state. 
     * @summary Updates a Self tax provider state
     * @param {string} stateCode The state code being updated.
     * @param {TaxState} taxState tax state to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any): Promise<TaxState>;

    /**
     * Update the Sovos tax provider. 
     * @summary Update the Sovos tax provider
     * @param {TaxProviderSovos} taxProviderSovos TaxProviderSovos object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSovos(taxProviderSovos: TaxProviderSovos, options?: any): Promise<TaxProviderSovos>;

    /**
     * Update the TaxJar tax provider. 
     * @summary Update the TaxJar tax provider
     * @param {TaxProviderTaxJar} taxProviderTaxJar TaxProviderTaxJar object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderTaxJar(taxProviderTaxJar: TaxProviderTaxJar, options?: any): Promise<TaxProviderTaxJar>;

    /**
     * Update the UltraCart tax provider. 
     * @summary Update the UltraCart tax provider
     * @param {TaxProviderUltraCart} taxProviderUltracart TaxProviderUltraCart object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderUltraCart(taxProviderUltracart: TaxProviderUltraCart, options?: any): Promise<TaxProviderUltraCart>;

}

/**
 * TaxApi - object-oriented interface
 * @export
 * @class TaxApi
 * @extends {BaseAPI}
 */
export class TaxApi extends BaseAPI implements TaxApiInterface {
    /**
     * Deletes a Self tax provider city. 
     * @summary Deletes a Self tax provider city
     * @param {string} city The city being deleted.
     * @param {TaxCity} taxCity tax city to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfCity(city, taxCity, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider country. 
     * @summary Deletes a Self tax provider country
     * @param {string} countryCode The country code being deleted.
     * @param {TaxCountry} taxCountry tax country to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfCountry(countryCode, taxCountry, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider county. 
     * @summary Deletes a Self tax provider county
     * @param {string} county The county being deleted.
     * @param {TaxCounty} taxCounty tax county to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfCounty(county, taxCounty, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider postalCode. 
     * @summary Deletes a Self tax provider postalCode
     * @param {string} postalCode The postal code being deleted.
     * @param {TaxPostalCode} taxPostalCode tax postal code to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfPostalCode(postalCode, taxPostalCode, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider state. 
     * @summary Deletes a Self tax provider state
     * @param {string} stateCode The state code being deleted.
     * @param {TaxState} taxState tax state to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfState(stateCode, taxState, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Avalara tax provider. 
     * @summary Retrieve the Avalara tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderAvalara(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderAvalara(options)(this.fetch, this.basePath);
    }

    /**
     * Returns Avalara Tax companies configured by the merchant 
     * @summary Returns Avalara Tax companies configured by the merchant
     * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderAvalaraCompanies(taxProviderAvalara: TaxProviderAvalara, options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderAvalaraCompanies(taxProviderAvalara, options)(this.fetch, this.basePath);
    }

    /**
     * Attempts to connect to Avalara and returns back the response. 
     * @summary Attempts to connect to Avalara and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderAvalaraTest(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderAvalaraTest(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Self tax provider. 
     * @summary Retrieve the Self tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSelf(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSelf(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Self tax provider countries. 
     * @summary Retrieve the Self tax provider countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSelfCountries(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSelfCountries(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Self tax provider regions for a given country code. 
     * @summary Retrieve the Self tax provider regions for a given country code
     * @param {string} countryCode The country code regions desired.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSelfRegionsByCountryCode(countryCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Sovos tax provider. 
     * @summary Retrieve the Sovos tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSovos(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSovos(options)(this.fetch, this.basePath);
    }

    /**
     * Attempts to connect to Sovos and returns back the response. 
     * @summary Attempts to connect to Sovos and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSovosTest(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSovosTest(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the TaxJar tax provider. 
     * @summary Retrieve the TaxJar tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderTaxJar(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderTaxJar(options)(this.fetch, this.basePath);
    }

    /**
     * Attempts to connect to TaxJar and returns back the response. 
     * @summary Attempts to connect to TaxJar and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderTaxJarTest(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderTaxJarTest(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the UltraCart tax provider. 
     * @summary Retrieve the UltraCart tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderUltraCart(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderUltraCart(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves tax methods for this account. 
     * @summary Retrieve tax methods
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviders(limit?: number, offset?: number, expand?: string, options?: any) {
        return TaxApiFp(this.configuration).getTaxProviders(limit, offset, expand, options)(this.fetch, this.basePath);
    }

    /**
     * Toggle a tax provider to active. 
     * @summary Toggle a tax provider to active
     * @param {string} providerName The tax provider to set active.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public setActiveTaxProvider(providerName: string, options?: any) {
        return TaxApiFp(this.configuration).setActiveTaxProvider(providerName, options)(this.fetch, this.basePath);
    }

    /**
     * Update the Avalara tax provider. 
     * @summary Update the Avalara tax provider
     * @param {TaxProviderAvalara} taxProviderAvalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderAvalara(taxProviderAvalara: TaxProviderAvalara, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderAvalara(taxProviderAvalara, options)(this.fetch, this.basePath);
    }

    /**
     * Update the Self tax provider. 
     * @summary Update the Self tax provider
     * @param {TaxProviderSelf} taxProviderSelf TaxProviderSelf object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelf(taxProviderSelf: TaxProviderSelf, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelf(taxProviderSelf, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider city. 
     * @summary Updates a Self tax provider city
     * @param {string} city The city being updated.
     * @param {TaxCity} taxCity tax city to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfCity(city: string, taxCity: TaxCity, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfCity(city, taxCity, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider country. 
     * @summary Updates a Self tax provider country
     * @param {string} countryCode The country code being updated.
     * @param {TaxCountry} taxCountry tax country to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfCountry(countryCode: string, taxCountry: TaxCountry, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfCountry(countryCode, taxCountry, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider county. 
     * @summary Updates a Self tax provider county
     * @param {string} county The county being updated.
     * @param {TaxCounty} taxCounty tax county to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfCounty(county: string, taxCounty: TaxCounty, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfCounty(county, taxCounty, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider postalCode. 
     * @summary Updates a Self tax provider postalCode
     * @param {string} postalCode The postal code being updated.
     * @param {TaxPostalCode} taxPostalCode tax postal code to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfPostalCode(postalCode: string, taxPostalCode: TaxPostalCode, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfPostalCode(postalCode, taxPostalCode, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider state. 
     * @summary Updates a Self tax provider state
     * @param {string} stateCode The state code being updated.
     * @param {TaxState} taxState tax state to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfState(stateCode: string, taxState: TaxState, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfState(stateCode, taxState, options)(this.fetch, this.basePath);
    }

    /**
     * Update the Sovos tax provider. 
     * @summary Update the Sovos tax provider
     * @param {TaxProviderSovos} taxProviderSovos TaxProviderSovos object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSovos(taxProviderSovos: TaxProviderSovos, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSovos(taxProviderSovos, options)(this.fetch, this.basePath);
    }

    /**
     * Update the TaxJar tax provider. 
     * @summary Update the TaxJar tax provider
     * @param {TaxProviderTaxJar} taxProviderTaxJar TaxProviderTaxJar object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderTaxJar(taxProviderTaxJar: TaxProviderTaxJar, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderTaxJar(taxProviderTaxJar, options)(this.fetch, this.basePath);
    }

    /**
     * Update the UltraCart tax provider. 
     * @summary Update the UltraCart tax provider
     * @param {TaxProviderUltraCart} taxProviderUltracart TaxProviderUltraCart object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderUltraCart(taxProviderUltracart: TaxProviderUltraCart, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderUltraCart(taxProviderUltracart, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a group on the UltraCart account. 
         * @summary Delete a group
         * @param {number} groupOid The group_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'groupOid' is not null or undefined
            if (groupOid === null || groupOid === undefined) {
                throw new RequiredError('groupOid','Required parameter groupOid was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/user/groups/{group_oid}`
                .replace(`{${"group_oid"}}`, encodeURIComponent(String(groupOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user on the UltraCart account. 
         * @summary Delete a user
         * @param {number} userId The user_id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/user/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single group using the specified group id. 
         * @summary Retrieve a group
         * @param {number} groupOid The group id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'groupOid' is not null or undefined
            if (groupOid === null || groupOid === undefined) {
                throw new RequiredError('groupOid','Required parameter groupOid was null or undefined when calling getGroup.');
            }
            const localVarPath = `/user/groups/{group_oid}`
                .replace(`{${"group_oid"}}`, encodeURIComponent(String(groupOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options: any = {}): FetchArgs {
            const localVarPath = `/user/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single user using the specified user id. 
         * @summary Retrieve a user
         * @param {number} userId The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/user/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves logins for a single user using the specified user id. 
         * @summary Retrieve a user's login history
         * @param {number} userId The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLogins(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserLogins.');
            }
            const localVarPath = `/user/users/{user_id}/logins`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options: any = {}): FetchArgs {
            const localVarPath = `/user/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a group on the UltraCart account. 
         * @summary Insert a group
         * @param {Group} group Group to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertGroup(group: Group, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling insertGroup.');
            }
            const localVarPath = `/user/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(group || {}) : (group || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a user on the UltraCart account. 
         * @summary Insert a user
         * @param {User} user User to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUser(user: User, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling insertUser.');
            }
            const localVarPath = `/user/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a group on the UltraCart account. 
         * @summary Update a group
         * @param {Group} group Group to update
         * @param {number} groupOid The group_oid to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(group: Group, groupOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'groupOid' is not null or undefined
            if (groupOid === null || groupOid === undefined) {
                throw new RequiredError('groupOid','Required parameter groupOid was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/user/groups/{group_oid}`
                .replace(`{${"group_oid"}}`, encodeURIComponent(String(groupOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(group || {}) : (group || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user on the UltraCart account. 
         * @summary Update a user
         * @param {User} user User to update
         * @param {number} userId The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/user/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a group on the UltraCart account. 
         * @summary Delete a group
         * @param {number} groupOid The group_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteGroup(groupOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user on the UltraCart account. 
         * @summary Delete a user
         * @param {number} userId The user_id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single group using the specified group id. 
         * @summary Retrieve a group
         * @param {number} groupOid The group id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getGroup(groupOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupsResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getGroups(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single user using the specified user id. 
         * @summary Retrieve a user
         * @param {number} userId The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves logins for a single user using the specified user id. 
         * @summary Retrieve a user's login history
         * @param {number} userId The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLogins(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserLoginsResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserLogins(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsersResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a group on the UltraCart account. 
         * @summary Insert a group
         * @param {Group} group Group to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertGroup(group: Group, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).insertGroup(group, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a user on the UltraCart account. 
         * @summary Insert a user
         * @param {User} user User to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUser(user: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).insertUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a group on the UltraCart account. 
         * @summary Update a group
         * @param {Group} group Group to update
         * @param {number} groupOid The group_oid to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(group: Group, groupOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateGroup(group, groupOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user on the UltraCart account. 
         * @summary Update a user
         * @param {User} user User to update
         * @param {number} userId The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(user, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a group on the UltraCart account. 
         * @summary Delete a group
         * @param {number} groupOid The group_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupOid: number, options?: any) {
            return UserApiFp(configuration).deleteGroup(groupOid, options)(fetch, basePath);
        },
        /**
         * Delete a user on the UltraCart account. 
         * @summary Delete a user
         * @param {number} userId The user_id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: any) {
            return UserApiFp(configuration).deleteUser(userId, options)(fetch, basePath);
        },
        /**
         * Retrieves a single group using the specified group id. 
         * @summary Retrieve a group
         * @param {number} groupOid The group id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupOid: number, options?: any) {
            return UserApiFp(configuration).getGroup(groupOid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any) {
            return UserApiFp(configuration).getGroups(options)(fetch, basePath);
        },
        /**
         * Retrieves a single user using the specified user id. 
         * @summary Retrieve a user
         * @param {number} userId The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options?: any) {
            return UserApiFp(configuration).getUser(userId, options)(fetch, basePath);
        },
        /**
         * Retrieves logins for a single user using the specified user id. 
         * @summary Retrieve a user's login history
         * @param {number} userId The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLogins(userId: number, options?: any) {
            return UserApiFp(configuration).getUserLogins(userId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any) {
            return UserApiFp(configuration).getUsers(options)(fetch, basePath);
        },
        /**
         * Insert a group on the UltraCart account. 
         * @summary Insert a group
         * @param {Group} group Group to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertGroup(group: Group, options?: any) {
            return UserApiFp(configuration).insertGroup(group, options)(fetch, basePath);
        },
        /**
         * Insert a user on the UltraCart account. 
         * @summary Insert a user
         * @param {User} user User to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUser(user: User, options?: any) {
            return UserApiFp(configuration).insertUser(user, options)(fetch, basePath);
        },
        /**
         * Update a group on the UltraCart account. 
         * @summary Update a group
         * @param {Group} group Group to update
         * @param {number} groupOid The group_oid to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(group: Group, groupOid: number, options?: any) {
            return UserApiFp(configuration).updateGroup(group, groupOid, options)(fetch, basePath);
        },
        /**
         * Update a user on the UltraCart account. 
         * @summary Update a user
         * @param {User} user User to update
         * @param {number} userId The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, userId: number, options?: any) {
            return UserApiFp(configuration).updateUser(user, userId, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Delete a group on the UltraCart account. 
     * @summary Delete a group
     * @param {number} groupOid The group_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteGroup(groupOid: number, options?: any): Promise<{}>;

    /**
     * Delete a user on the UltraCart account. 
     * @summary Delete a user
     * @param {number} userId The user_id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUser(userId: number, options?: any): Promise<{}>;

    /**
     * Retrieves a single group using the specified group id. 
     * @summary Retrieve a group
     * @param {number} groupOid The group id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getGroup(groupOid: number, options?: any): Promise<{}>;

    /**
     * 
     * @summary Get groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getGroups(options?: any): Promise<GroupsResponse>;

    /**
     * Retrieves a single user using the specified user id. 
     * @summary Retrieve a user
     * @param {number} userId The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUser(userId: number, options?: any): Promise<UserResponse>;

    /**
     * Retrieves logins for a single user using the specified user id. 
     * @summary Retrieve a user's login history
     * @param {number} userId The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserLogins(userId: number, options?: any): Promise<UserLoginsResponse>;

    /**
     * 
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsers(options?: any): Promise<UsersResponse>;

    /**
     * Insert a group on the UltraCart account. 
     * @summary Insert a group
     * @param {Group} group Group to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    insertGroup(group: Group, options?: any): Promise<GroupResponse>;

    /**
     * Insert a user on the UltraCart account. 
     * @summary Insert a user
     * @param {User} user User to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    insertUser(user: User, options?: any): Promise<UserResponse>;

    /**
     * Update a group on the UltraCart account. 
     * @summary Update a group
     * @param {Group} group Group to update
     * @param {number} groupOid The group_oid to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateGroup(group: Group, groupOid: number, options?: any): Promise<GroupResponse>;

    /**
     * Update a user on the UltraCart account. 
     * @summary Update a user
     * @param {User} user User to update
     * @param {number} userId The user_id to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUser(user: User, userId: number, options?: any): Promise<UserResponse>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Delete a group on the UltraCart account. 
     * @summary Delete a group
     * @param {number} groupOid The group_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteGroup(groupOid: number, options?: any) {
        return UserApiFp(this.configuration).deleteGroup(groupOid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user on the UltraCart account. 
     * @summary Delete a user
     * @param {number} userId The user_id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userId: number, options?: any) {
        return UserApiFp(this.configuration).deleteUser(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single group using the specified group id. 
     * @summary Retrieve a group
     * @param {number} groupOid The group id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getGroup(groupOid: number, options?: any) {
        return UserApiFp(this.configuration).getGroup(groupOid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getGroups(options?: any) {
        return UserApiFp(this.configuration).getGroups(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single user using the specified user id. 
     * @summary Retrieve a user
     * @param {number} userId The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: number, options?: any) {
        return UserApiFp(this.configuration).getUser(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves logins for a single user using the specified user id. 
     * @summary Retrieve a user's login history
     * @param {number} userId The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserLogins(userId: number, options?: any) {
        return UserApiFp(this.configuration).getUserLogins(userId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(options?: any) {
        return UserApiFp(this.configuration).getUsers(options)(this.fetch, this.basePath);
    }

    /**
     * Insert a group on the UltraCart account. 
     * @summary Insert a group
     * @param {Group} group Group to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public insertGroup(group: Group, options?: any) {
        return UserApiFp(this.configuration).insertGroup(group, options)(this.fetch, this.basePath);
    }

    /**
     * Insert a user on the UltraCart account. 
     * @summary Insert a user
     * @param {User} user User to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public insertUser(user: User, options?: any) {
        return UserApiFp(this.configuration).insertUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * Update a group on the UltraCart account. 
     * @summary Update a group
     * @param {Group} group Group to update
     * @param {number} groupOid The group_oid to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateGroup(group: Group, groupOid: number, options?: any) {
        return UserApiFp(this.configuration).updateGroup(group, groupOid, options)(this.fetch, this.basePath);
    }

    /**
     * Update a user on the UltraCart account. 
     * @summary Update a user
     * @param {User} user User to update
     * @param {number} userId The user_id to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(user: User, userId: number, options?: any) {
        return UserApiFp(this.configuration).updateUser(user, userId, options)(this.fetch, this.basePath);
    }

}

/**
 * WebhookApi - fetch parameter creator
 * @export
 */
export const WebhookApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a webhook on the UltraCart account. 
         * @summary Delete a webhook
         * @param {number} webhookOid The webhook oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
         * @summary Delete a webhook by URL
         * @param {Webhook} webhook Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByUrl(webhook: Webhook, options: any = {}): FetchArgs {
            // verify required parameter 'webhook' is not null or undefined
            if (webhook === null || webhook === undefined) {
                throw new RequiredError('webhook','Required parameter webhook was null or undefined when calling deleteWebhookByUrl.');
            }
            const localVarPath = `/webhook/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Webhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhook || {}) : (webhook || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an individual log for a webhook given the webhook oid the request id. 
         * @summary Retrieve an individual log
         * @param {number} webhookOid The webhook oid that owns the log.
         * @param {string} requestId The request id associated with the log to view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLog(webhookOid: number, requestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling getWebhookLog.');
            }
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling getWebhookLog.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}/logs/{requestId}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
         * @summary Retrieve the log summaries
         * @param {number} webhookOid The webhook oid to retrieve log summaries for.
         * @param {number} [limit] The maximum number of records to return on this one API call.
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch log summaries that have been delivered since this date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLogSummaries(webhookOid: number, limit?: number, offset?: number, since?: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling getWebhookLogSummaries.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}/logs`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (since !== undefined) {
                localVarQueryParameter['_since'] = since;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the webhooks associated with this application. 
         * @summary Retrieve webhooks
         * @param {number} [limit] The maximum number of records to return on this one API call.
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the webhooks.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(limit?: number, offset?: number, sort?: string, placeholders?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/webhook/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['_limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['_offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['_sort'] = sort;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
         * @summary Add a webhook
         * @param {Webhook} webhook Webhook to create
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertWebhook(webhook: Webhook, placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'webhook' is not null or undefined
            if (webhook === null || webhook === undefined) {
                throw new RequiredError('webhook','Required parameter webhook was null or undefined when calling insertWebhook.');
            }
            const localVarPath = `/webhook/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Webhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhook || {}) : (webhook || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
         * @summary Resend events to the webhook endpoint.
         * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
         * @param {string} eventName The event to reflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEvent(webhookOid: number, eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling resendEvent.');
            }
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling resendEvent.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}/reflow/{eventName}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)))
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook on the account 
         * @summary Update a webhook
         * @param {Webhook} webhook Webhook to update
         * @param {number} webhookOid The webhook oid to update.
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhook: Webhook, webhookOid: number, placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'webhook' is not null or undefined
            if (webhook === null || webhook === undefined) {
                throw new RequiredError('webhook','Required parameter webhook was null or undefined when calling updateWebhook.');
            }
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling updateWebhook.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Webhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhook || {}) : (webhook || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a webhook on the UltraCart account. 
         * @summary Delete a webhook
         * @param {number} webhookOid The webhook oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).deleteWebhook(webhookOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
         * @summary Delete a webhook by URL
         * @param {Webhook} webhook Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByUrl(webhook: Webhook, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).deleteWebhookByUrl(webhook, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves an individual log for a webhook given the webhook oid the request id. 
         * @summary Retrieve an individual log
         * @param {number} webhookOid The webhook oid that owns the log.
         * @param {string} requestId The request id associated with the log to view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLog(webhookOid: number, requestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookLogResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhookLog(webhookOid, requestId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
         * @summary Retrieve the log summaries
         * @param {number} webhookOid The webhook oid to retrieve log summaries for.
         * @param {number} [limit] The maximum number of records to return on this one API call.
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch log summaries that have been delivered since this date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLogSummaries(webhookOid: number, limit?: number, offset?: number, since?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookLogSummariesResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhookLogSummaries(webhookOid, limit, offset, since, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the webhooks associated with this application. 
         * @summary Retrieve webhooks
         * @param {number} [limit] The maximum number of records to return on this one API call.
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the webhooks.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(limit?: number, offset?: number, sort?: string, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhooksResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhooks(limit, offset, sort, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
         * @summary Add a webhook
         * @param {Webhook} webhook Webhook to create
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertWebhook(webhook: Webhook, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).insertWebhook(webhook, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
         * @summary Resend events to the webhook endpoint.
         * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
         * @param {string} eventName The event to reflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEvent(webhookOid: number, eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookSampleRequestResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).resendEvent(webhookOid, eventName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a webhook on the account 
         * @summary Update a webhook
         * @param {Webhook} webhook Webhook to update
         * @param {number} webhookOid The webhook oid to update.
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhook: Webhook, webhookOid: number, placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).updateWebhook(webhook, webhookOid, placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a webhook on the UltraCart account. 
         * @summary Delete a webhook
         * @param {number} webhookOid The webhook oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookOid: number, options?: any) {
            return WebhookApiFp(configuration).deleteWebhook(webhookOid, options)(fetch, basePath);
        },
        /**
         * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
         * @summary Delete a webhook by URL
         * @param {Webhook} webhook Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByUrl(webhook: Webhook, options?: any) {
            return WebhookApiFp(configuration).deleteWebhookByUrl(webhook, options)(fetch, basePath);
        },
        /**
         * Retrieves an individual log for a webhook given the webhook oid the request id. 
         * @summary Retrieve an individual log
         * @param {number} webhookOid The webhook oid that owns the log.
         * @param {string} requestId The request id associated with the log to view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLog(webhookOid: number, requestId: string, options?: any) {
            return WebhookApiFp(configuration).getWebhookLog(webhookOid, requestId, options)(fetch, basePath);
        },
        /**
         * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
         * @summary Retrieve the log summaries
         * @param {number} webhookOid The webhook oid to retrieve log summaries for.
         * @param {number} [limit] The maximum number of records to return on this one API call.
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [since] Fetch log summaries that have been delivered since this date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLogSummaries(webhookOid: number, limit?: number, offset?: number, since?: string, options?: any) {
            return WebhookApiFp(configuration).getWebhookLogSummaries(webhookOid, limit, offset, since, options)(fetch, basePath);
        },
        /**
         * Retrieves the webhooks associated with this application. 
         * @summary Retrieve webhooks
         * @param {number} [limit] The maximum number of records to return on this one API call.
         * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [sort] The sort order of the webhooks.  See documentation for examples
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(limit?: number, offset?: number, sort?: string, placeholders?: boolean, options?: any) {
            return WebhookApiFp(configuration).getWebhooks(limit, offset, sort, placeholders, options)(fetch, basePath);
        },
        /**
         * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
         * @summary Add a webhook
         * @param {Webhook} webhook Webhook to create
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertWebhook(webhook: Webhook, placeholders?: boolean, options?: any) {
            return WebhookApiFp(configuration).insertWebhook(webhook, placeholders, options)(fetch, basePath);
        },
        /**
         * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
         * @summary Resend events to the webhook endpoint.
         * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
         * @param {string} eventName The event to reflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEvent(webhookOid: number, eventName: string, options?: any) {
            return WebhookApiFp(configuration).resendEvent(webhookOid, eventName, options)(fetch, basePath);
        },
        /**
         * Update a webhook on the account 
         * @summary Update a webhook
         * @param {Webhook} webhook Webhook to update
         * @param {number} webhookOid The webhook oid to update.
         * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhook: Webhook, webhookOid: number, placeholders?: boolean, options?: any) {
            return WebhookApiFp(configuration).updateWebhook(webhook, webhookOid, placeholders, options)(fetch, basePath);
        },
    };
};

/**
 * WebhookApi - interface
 * @export
 * @interface WebhookApi
 */
export interface WebhookApiInterface {
    /**
     * Delete a webhook on the UltraCart account. 
     * @summary Delete a webhook
     * @param {number} webhookOid The webhook oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    deleteWebhook(webhookOid: number, options?: any): Promise<{}>;

    /**
     * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
     * @summary Delete a webhook by URL
     * @param {Webhook} webhook Webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    deleteWebhookByUrl(webhook: Webhook, options?: any): Promise<WebhookResponse>;

    /**
     * Retrieves an individual log for a webhook given the webhook oid the request id. 
     * @summary Retrieve an individual log
     * @param {number} webhookOid The webhook oid that owns the log.
     * @param {string} requestId The request id associated with the log to view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getWebhookLog(webhookOid: number, requestId: string, options?: any): Promise<WebhookLogResponse>;

    /**
     * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
     * @summary Retrieve the log summaries
     * @param {number} webhookOid The webhook oid to retrieve log summaries for.
     * @param {number} [limit] The maximum number of records to return on this one API call.
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch log summaries that have been delivered since this date/time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getWebhookLogSummaries(webhookOid: number, limit?: number, offset?: number, since?: string, options?: any): Promise<WebhookLogSummariesResponse>;

    /**
     * Retrieves the webhooks associated with this application. 
     * @summary Retrieve webhooks
     * @param {number} [limit] The maximum number of records to return on this one API call.
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the webhooks.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getWebhooks(limit?: number, offset?: number, sort?: string, placeholders?: boolean, options?: any): Promise<WebhooksResponse>;

    /**
     * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
     * @summary Add a webhook
     * @param {Webhook} webhook Webhook to create
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    insertWebhook(webhook: Webhook, placeholders?: boolean, options?: any): Promise<WebhookResponse>;

    /**
     * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
     * @summary Resend events to the webhook endpoint.
     * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
     * @param {string} eventName The event to reflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    resendEvent(webhookOid: number, eventName: string, options?: any): Promise<WebhookSampleRequestResponse>;

    /**
     * Update a webhook on the account 
     * @summary Update a webhook
     * @param {Webhook} webhook Webhook to update
     * @param {number} webhookOid The webhook oid to update.
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    updateWebhook(webhook: Webhook, webhookOid: number, placeholders?: boolean, options?: any): Promise<WebhookResponse>;

}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI implements WebhookApiInterface {
    /**
     * Delete a webhook on the UltraCart account. 
     * @summary Delete a webhook
     * @param {number} webhookOid The webhook oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public deleteWebhook(webhookOid: number, options?: any) {
        return WebhookApiFp(this.configuration).deleteWebhook(webhookOid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
     * @summary Delete a webhook by URL
     * @param {Webhook} webhook Webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public deleteWebhookByUrl(webhook: Webhook, options?: any) {
        return WebhookApiFp(this.configuration).deleteWebhookByUrl(webhook, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves an individual log for a webhook given the webhook oid the request id. 
     * @summary Retrieve an individual log
     * @param {number} webhookOid The webhook oid that owns the log.
     * @param {string} requestId The request id associated with the log to view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhookLog(webhookOid: number, requestId: string, options?: any) {
        return WebhookApiFp(this.configuration).getWebhookLog(webhookOid, requestId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
     * @summary Retrieve the log summaries
     * @param {number} webhookOid The webhook oid to retrieve log summaries for.
     * @param {number} [limit] The maximum number of records to return on this one API call.
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [since] Fetch log summaries that have been delivered since this date/time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhookLogSummaries(webhookOid: number, limit?: number, offset?: number, since?: string, options?: any) {
        return WebhookApiFp(this.configuration).getWebhookLogSummaries(webhookOid, limit, offset, since, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the webhooks associated with this application. 
     * @summary Retrieve webhooks
     * @param {number} [limit] The maximum number of records to return on this one API call.
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the webhooks.  See documentation for examples
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhooks(limit?: number, offset?: number, sort?: string, placeholders?: boolean, options?: any) {
        return WebhookApiFp(this.configuration).getWebhooks(limit, offset, sort, placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
     * @summary Add a webhook
     * @param {Webhook} webhook Webhook to create
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public insertWebhook(webhook: Webhook, placeholders?: boolean, options?: any) {
        return WebhookApiFp(this.configuration).insertWebhook(webhook, placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
     * @summary Resend events to the webhook endpoint.
     * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
     * @param {string} eventName The event to reflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public resendEvent(webhookOid: number, eventName: string, options?: any) {
        return WebhookApiFp(this.configuration).resendEvent(webhookOid, eventName, options)(this.fetch, this.basePath);
    }

    /**
     * Update a webhook on the account 
     * @summary Update a webhook
     * @param {Webhook} webhook Webhook to update
     * @param {number} webhookOid The webhook oid to update.
     * @param {boolean} [placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public updateWebhook(webhook: Webhook, webhookOid: number, placeholders?: boolean, options?: any) {
        return WebhookApiFp(this.configuration).updateWebhook(webhook, webhookOid, placeholders, options)(this.fetch, this.basePath);
    }

}

