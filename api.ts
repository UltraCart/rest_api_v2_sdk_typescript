/**
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://secure.ultracart.com/rest/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AccountsReceivableRetryConfig {
    /**
    * True if the retry should run daily.  False puts the retry service into an inactive state for this merchant.
    */
    'active'?: boolean;
    /**
    * True if this account has linked accounts that it can process.
    */
    'allowProcessLinkedAccounts'?: boolean;
    /**
    * The current service plan that the account is on.
    */
    'currentServicePlan'?: string;
    /**
    * A list of days and what actions should take place on those days after an order reaches accounts receivable
    */
    'dailyActivityList'?: Array<AccountsReceivableRetryDayActivity>;
    /**
    * If not null, this account is managed by the specified parent merchant id.
    */
    'managedByLinkedAccountMerchantId'?: boolean;
    /**
    * UltraCart merchant ID
    */
    'merchantId'?: string;
    /**
    * A list of email addresses to receive summary notifications from the retry service.
    */
    'notifyEmails'?: Array<string>;
    /**
    * If true, email addresses are notified of rejections.
    */
    'notifyRejections'?: boolean;
    /**
    * If true, email addresses are notified of successful charges.
    */
    'notifySuccesses'?: boolean;
    /**
    * If true, all linked accounts are also processed using the same rules.
    */
    'processLinkedAccounts'?: boolean;
    /**
    * The percentage rate charged for the service.
    */
    'processingPercentage'?: string;
    /**
    * If true, the order is rejected the day after the last configured activity day
    */
    'rejectAtEnd'?: boolean;
    /**
    * True if the account is currently in trial mode.  Set to false to exit trial mode.
    */
    'trialMode'?: boolean;
    /**
    * The date when trial mode expires.  If this date is reached without exiting trial mode, the service will de-activate.
    */
    'trialModeExpirationDts'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "allowProcessLinkedAccounts",
            "baseName": "allow_process_linked_accounts",
            "type": "boolean"
        },
        {
            "name": "currentServicePlan",
            "baseName": "current_service_plan",
            "type": "string"
        },
        {
            "name": "dailyActivityList",
            "baseName": "daily_activity_list",
            "type": "Array<AccountsReceivableRetryDayActivity>"
        },
        {
            "name": "managedByLinkedAccountMerchantId",
            "baseName": "managed_by_linked_account_merchant_id",
            "type": "boolean"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "notifyEmails",
            "baseName": "notify_emails",
            "type": "Array<string>"
        },
        {
            "name": "notifyRejections",
            "baseName": "notify_rejections",
            "type": "boolean"
        },
        {
            "name": "notifySuccesses",
            "baseName": "notify_successes",
            "type": "boolean"
        },
        {
            "name": "processLinkedAccounts",
            "baseName": "process_linked_accounts",
            "type": "boolean"
        },
        {
            "name": "processingPercentage",
            "baseName": "processing_percentage",
            "type": "string"
        },
        {
            "name": "rejectAtEnd",
            "baseName": "reject_at_end",
            "type": "boolean"
        },
        {
            "name": "trialMode",
            "baseName": "trial_mode",
            "type": "boolean"
        },
        {
            "name": "trialModeExpirationDts",
            "baseName": "trial_mode_expiration_dts",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountsReceivableRetryConfig.attributeTypeMap;
    }
}

export class AccountsReceivableRetryConfigResponse {
    'config'?: AccountsReceivableRetryConfig;
    'couponCodes'?: Array<string>;
    'emails'?: Array<string>;
    'error'?: Error;
    'hasLinkedAccounts'?: boolean;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "config",
            "baseName": "config",
            "type": "AccountsReceivableRetryConfig"
        },
        {
            "name": "couponCodes",
            "baseName": "coupon_codes",
            "type": "Array<string>"
        },
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<string>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "hasLinkedAccounts",
            "baseName": "has_linked_accounts",
            "type": "boolean"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return AccountsReceivableRetryConfigResponse.attributeTypeMap;
    }
}

export class AccountsReceivableRetryDayActivity {
    /**
    * True if a charge attempt should be made on this day.  False means the order should be rejected on this day.
    */
    'charge'?: boolean;
    /**
    * The coupon code that should be applied to this order.
    */
    'couponCode'?: string;
    /**
    * The number of days since the order placed in Accounts Receivable
    */
    'day'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "charge",
            "baseName": "charge",
            "type": "boolean"
        },
        {
            "name": "couponCode",
            "baseName": "coupon_code",
            "type": "string"
        },
        {
            "name": "day",
            "baseName": "day",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AccountsReceivableRetryDayActivity.attributeTypeMap;
    }
}

export class AccountsReceivableRetryStatAccount {
    'days'?: Array<AccountsReceivableRetryStatMetrics>;
    'merchantId'?: string;
    'overall'?: AccountsReceivableRetryStatMetrics;
    'revenueForPeriod'?: Array<AccountsReceivableRetryStatRevenue>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "days",
            "baseName": "days",
            "type": "Array<AccountsReceivableRetryStatMetrics>"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "overall",
            "baseName": "overall",
            "type": "AccountsReceivableRetryStatMetrics"
        },
        {
            "name": "revenueForPeriod",
            "baseName": "revenue_for_period",
            "type": "Array<AccountsReceivableRetryStatRevenue>"
        }    ];

    static getAttributeTypeMap() {
        return AccountsReceivableRetryStatAccount.attributeTypeMap;
    }
}

export class AccountsReceivableRetryStatMetrics {
    'attempts'?: number;
    'attemptsFormatted'?: string;
    'conversionRate'?: number;
    'conversionRateFormatted'?: string;
    'day'?: number;
    'discounts'?: number;
    'discountsFormatted'?: string;
    'revenue'?: number;
    'revenueFormatted'?: string;
    'successes'?: number;
    'successesFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "attempts",
            "baseName": "attempts",
            "type": "number"
        },
        {
            "name": "attemptsFormatted",
            "baseName": "attempts_formatted",
            "type": "string"
        },
        {
            "name": "conversionRate",
            "baseName": "conversion_rate",
            "type": "number"
        },
        {
            "name": "conversionRateFormatted",
            "baseName": "conversion_rate_formatted",
            "type": "string"
        },
        {
            "name": "day",
            "baseName": "day",
            "type": "number"
        },
        {
            "name": "discounts",
            "baseName": "discounts",
            "type": "number"
        },
        {
            "name": "discountsFormatted",
            "baseName": "discounts_formatted",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "revenueFormatted",
            "baseName": "revenue_formatted",
            "type": "string"
        },
        {
            "name": "successes",
            "baseName": "successes",
            "type": "number"
        },
        {
            "name": "successesFormatted",
            "baseName": "successes_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountsReceivableRetryStatMetrics.attributeTypeMap;
    }
}

export class AccountsReceivableRetryStatRevenue {
    'label'?: string;
    'revenue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AccountsReceivableRetryStatRevenue.attributeTypeMap;
    }
}

export class AccountsReceivableRetryStatsResponse {
    'error'?: Error;
    'linkedAccounts'?: Array<AccountsReceivableRetryStatAccount>;
    'metadata'?: ResponseMetadata;
    'overall'?: AccountsReceivableRetryStatAccount;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "linkedAccounts",
            "baseName": "linked_accounts",
            "type": "Array<AccountsReceivableRetryStatAccount>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "overall",
            "baseName": "overall",
            "type": "AccountsReceivableRetryStatAccount"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return AccountsReceivableRetryStatsResponse.attributeTypeMap;
    }
}

export class Activity {
    'action'?: string;
    'metric'?: string;
    'subject'?: string;
    'ts'?: number;
    'type'?: string;
    'uuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "metric",
            "baseName": "metric",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "ts",
            "baseName": "ts",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Activity.attributeTypeMap;
    }
}

export class AddLibraryItemRequest {
    /**
    * Cjson to be added to library
    */
    'cjson'?: string;
    /**
    * flow, campaign, cjson, email, transactional_email or upsell
    */
    'contentType'?: string;
    /**
    * description of library item
    */
    'description'?: string;
    /**
    * Required if content_type is transactional_email. This is the name of the email template (html, not text).  This name should have a .vm file extension.  An example is auto_order_cancel_html.vm
    */
    'emailName'?: string;
    /**
    * Required if content_type is transactional_email. This is the full path to the email template stored in the file system.  This defines which StoreFront contains the desired email template.  An example is /themes/Elements/core/emails/auto_order_cancel_html.vm
    */
    'emailPath'?: string;
    /**
    * Screenshot urls for display
    */
    'screenshots'?: Array<LibraryItemScreenshot>;
    /**
    * StoreFront oid where content originates necessary for tracking down relative assets
    */
    'storefrontOid'?: number;
    /**
    * title of library item, usually the name of the flow or campaign, or description of cjson
    */
    'title'?: string;
    /**
    * Required if content_type is upsell. This is object identifier of a StoreFront Upsell Offer.
    */
    'upsellOfferOid'?: number;
    /**
    * UUID of communication flow, campaign, email, or null if this item is something else. transactional_email do not have a uuid because they are singleton objects within a storefront and easily identifiable by name
    */
    'uuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cjson",
            "baseName": "cjson",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "emailName",
            "baseName": "email_name",
            "type": "string"
        },
        {
            "name": "emailPath",
            "baseName": "email_path",
            "type": "string"
        },
        {
            "name": "screenshots",
            "baseName": "screenshots",
            "type": "Array<LibraryItemScreenshot>"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "upsellOfferOid",
            "baseName": "upsell_offer_oid",
            "type": "number"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddLibraryItemRequest.attributeTypeMap;
    }
}

export class AffiliateClick {
    /**
    * Unique object identifier for this click
    */
    'affiliateClickOid'?: number;
    /**
    * Unique object identifier for for the link that this click is associated with
    */
    'affiliateLinkOid'?: number;
    /**
    * Affiliate object ID associated with this click
    */
    'affiliateOid'?: number;
    /**
    * Date/time that the click was made
    */
    'clickDts'?: string;
    /**
    * IP address that generated the click
    */
    'ipAddress'?: string;
    /**
    * URL of the landing page the customer was sent to.
    */
    'landingPage'?: string;
    /**
    * Query string on the landing page URL the customer was sent to.
    */
    'landingPageQueryString'?: string;
    'link'?: AffiliateLink;
    /**
    * URL that referred the click (Browser Header Referer)
    */
    'referrer'?: string;
    /**
    * Query string that was on the referrer URL.
    */
    'referrerQueryString'?: string;
    /**
    * Sub ID value passed on the click
    */
    'subId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateClickOid",
            "baseName": "affiliate_click_oid",
            "type": "number"
        },
        {
            "name": "affiliateLinkOid",
            "baseName": "affiliate_link_oid",
            "type": "number"
        },
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "clickDts",
            "baseName": "click_dts",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ip_address",
            "type": "string"
        },
        {
            "name": "landingPage",
            "baseName": "landing_page",
            "type": "string"
        },
        {
            "name": "landingPageQueryString",
            "baseName": "landing_page_query_string",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "AffiliateLink"
        },
        {
            "name": "referrer",
            "baseName": "referrer",
            "type": "string"
        },
        {
            "name": "referrerQueryString",
            "baseName": "referrer_query_string",
            "type": "string"
        },
        {
            "name": "subId",
            "baseName": "sub_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AffiliateClick.attributeTypeMap;
    }
}

export class AffiliateClickQuery {
    /**
    * Unique object identifier for for the link that this click is associated with
    */
    'affiliateLinkOid'?: number;
    /**
    * Affiliate ID associated with the click
    */
    'affiliateOid'?: number;
    /**
    * Minimum click date/time to return
    */
    'clickDtsBegin'?: string;
    /**
    * Maximum click date/time to return
    */
    'clickDtsEnd'?: string;
    /**
    * IP address that generated the click
    */
    'ipAddress'?: string;
    /**
    * Sub ID value passed on the click
    */
    'subId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateLinkOid",
            "baseName": "affiliate_link_oid",
            "type": "number"
        },
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "clickDtsBegin",
            "baseName": "click_dts_begin",
            "type": "string"
        },
        {
            "name": "clickDtsEnd",
            "baseName": "click_dts_end",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ip_address",
            "type": "string"
        },
        {
            "name": "subId",
            "baseName": "sub_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AffiliateClickQuery.attributeTypeMap;
    }
}

export class AffiliateClicksResponse {
    /**
    * clicks
    */
    'clicks'?: Array<AffiliateClick>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "Array<AffiliateClick>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return AffiliateClicksResponse.attributeTypeMap;
    }
}

export class AffiliateLedger {
    /**
    * Unique object identifier for the click associated with this ledger entry
    */
    'affiliateClickOid'?: number;
    /**
    * Unique object identifier for the link that this click is associated with
    */
    'affiliateLinkOid'?: number;
    /**
    * Affiliate object ID associated with this transaction
    */
    'affiliateOid'?: number;
    /**
    * User that assigned the transaction if it was done manually
    */
    'assignedByUser'?: string;
    'click'?: AffiliateClick;
    /**
    * Item ID associated with this transaction
    */
    'itemId'?: string;
    'link'?: AffiliateLink;
    'order'?: Order;
    /**
    * Order ID associated with this transaction
    */
    'orderId'?: string;
    /**
    * Date/time of the original transaction for reversals
    */
    'originalTransactionDts'?: string;
    /**
    * Sub ID associated with transaction (from the click)
    */
    'subId'?: string;
    /**
    * Tier number that this transaction earned
    */
    'tierNumber'?: string;
    /**
    * Transaction amount
    */
    'transactionAmount'?: number;
    /**
    * Amount of the transaction that has been paid out.
    */
    'transactionAmountPaid'?: number;
    /**
    * Date/time that the transaction was made
    */
    'transactionDts'?: string;
    /**
    * Memo explaining the transaction
    */
    'transactionMemo'?: string;
    /**
    * Percentage associated with this transaction
    */
    'transactionPercentage'?: string;
    /**
    * Transaction state
    */
    'transactionState'?: AffiliateLedger.TransactionStateEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateClickOid",
            "baseName": "affiliate_click_oid",
            "type": "number"
        },
        {
            "name": "affiliateLinkOid",
            "baseName": "affiliate_link_oid",
            "type": "number"
        },
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "assignedByUser",
            "baseName": "assigned_by_user",
            "type": "string"
        },
        {
            "name": "click",
            "baseName": "click",
            "type": "AffiliateClick"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "AffiliateLink"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "originalTransactionDts",
            "baseName": "original_transaction_dts",
            "type": "string"
        },
        {
            "name": "subId",
            "baseName": "sub_id",
            "type": "string"
        },
        {
            "name": "tierNumber",
            "baseName": "tier_number",
            "type": "string"
        },
        {
            "name": "transactionAmount",
            "baseName": "transaction_amount",
            "type": "number"
        },
        {
            "name": "transactionAmountPaid",
            "baseName": "transaction_amount_paid",
            "type": "number"
        },
        {
            "name": "transactionDts",
            "baseName": "transaction_dts",
            "type": "string"
        },
        {
            "name": "transactionMemo",
            "baseName": "transaction_memo",
            "type": "string"
        },
        {
            "name": "transactionPercentage",
            "baseName": "transaction_percentage",
            "type": "string"
        },
        {
            "name": "transactionState",
            "baseName": "transaction_state",
            "type": "AffiliateLedger.TransactionStateEnum"
        }    ];

    static getAttributeTypeMap() {
        return AffiliateLedger.attributeTypeMap;
    }
}

export namespace AffiliateLedger {
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}
export class AffiliateLedgerQuery {
    /**
    * Affiliate ID associated with the ledger
    */
    'affiliateOid'?: number;
    /**
    * Item id associated with the ledger entry
    */
    'itemId'?: string;
    /**
    * Order ID associated with the ledger entries
    */
    'orderId'?: string;
    /**
    * Sub ID value passed on the click that generated the ledger
    */
    'subId'?: string;
    /**
    * Minimum transaction date/time to return
    */
    'transactionDtsBegin'?: string;
    /**
    * Maximum transaction date/time to return
    */
    'transactionDtsEnd'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "subId",
            "baseName": "sub_id",
            "type": "string"
        },
        {
            "name": "transactionDtsBegin",
            "baseName": "transaction_dts_begin",
            "type": "string"
        },
        {
            "name": "transactionDtsEnd",
            "baseName": "transaction_dts_end",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AffiliateLedgerQuery.attributeTypeMap;
    }
}

export class AffiliateLedgersResponse {
    'error'?: Error;
    /**
    * ledgers
    */
    'ledgers'?: Array<AffiliateLedger>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "ledgers",
            "baseName": "ledgers",
            "type": "Array<AffiliateLedger>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return AffiliateLedgersResponse.attributeTypeMap;
    }
}

export class AffiliateLink {
    /**
    * Unique object identifier associated with this link
    */
    'affiliateLinkOid'?: number;
    /**
    * Managed link OID that this link object was generated from
    */
    'affiliateManagedLinkOid'?: number;
    /**
    * Affiliate object ID associated with this link
    */
    'affiliateOid'?: number;
    /**
    * The affiliate program item this managed link is associated with
    */
    'affiliateProgramItemOid'?: number;
    /**
    * Code associated with the link
    */
    'code'?: string;
    /**
    * Creative (image or text) associated with this link
    */
    'creativeOid'?: number;
    /**
    * Custom HTML associated with this link
    */
    'customHtml'?: string;
    /**
    * Approved status of the custom html
    */
    'customHtmlApprovalStatus'?: AffiliateLink.CustomHtmlApprovalStatusEnum;
    /**
    * Custom landing page URL if configured
    */
    'customLandingUrl'?: string;
    /**
    * True if the link has been deleted
    */
    'deleted'?: boolean;
    /**
    * Invisible link approval status
    */
    'invisibleLinkApprovalStatus'?: AffiliateLink.InvisibleLinkApprovalStatusEnum;
    /**
    * Invisible link URL prefix
    */
    'invisibleLinkUrlPrefix'?: string;
    /**
    * Name of the link
    */
    'name'?: string;
    /**
    * Type of link
    */
    'type'?: AffiliateLink.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateLinkOid",
            "baseName": "affiliate_link_oid",
            "type": "number"
        },
        {
            "name": "affiliateManagedLinkOid",
            "baseName": "affiliate_managed_link_oid",
            "type": "number"
        },
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "affiliateProgramItemOid",
            "baseName": "affiliate_program_item_oid",
            "type": "number"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "creativeOid",
            "baseName": "creative_oid",
            "type": "number"
        },
        {
            "name": "customHtml",
            "baseName": "custom_html",
            "type": "string"
        },
        {
            "name": "customHtmlApprovalStatus",
            "baseName": "custom_html_approval_status",
            "type": "AffiliateLink.CustomHtmlApprovalStatusEnum"
        },
        {
            "name": "customLandingUrl",
            "baseName": "custom_landing_url",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "invisibleLinkApprovalStatus",
            "baseName": "invisible_link_approval_status",
            "type": "AffiliateLink.InvisibleLinkApprovalStatusEnum"
        },
        {
            "name": "invisibleLinkUrlPrefix",
            "baseName": "invisible_link_url_prefix",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "AffiliateLink.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return AffiliateLink.attributeTypeMap;
    }
}

export namespace AffiliateLink {
    export enum CustomHtmlApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    export enum InvisibleLinkApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    export enum TypeEnum {
        Image = <any> 'image',
        Text = <any> 'text',
        Invisible = <any> 'invisible',
        Direct = <any> 'direct'
    }
}
export class ApiUserApplicationProfile {
    /**
    * Application logo URL
    */
    'apiApplicationLogoUrl'?: string;
    /**
    * Application description
    */
    'applicationDescription'?: string;
    /**
    * Application name
    */
    'applicationName'?: string;
    /**
    * Developer name
    */
    'developerName'?: string;
    /**
    * Developer website
    */
    'developerWebsite'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiApplicationLogoUrl",
            "baseName": "api_application_logo_url",
            "type": "string"
        },
        {
            "name": "applicationDescription",
            "baseName": "application_description",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "application_name",
            "type": "string"
        },
        {
            "name": "developerName",
            "baseName": "developer_name",
            "type": "string"
        },
        {
            "name": "developerWebsite",
            "baseName": "developer_website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiUserApplicationProfile.attributeTypeMap;
    }
}

export class ApplyLibraryItemRequest {
    /**
    * Normal emails are applied to an existing email object, so when requesting a library item to be applied to an email, supply the email uuid.  This is only for normal emails.  Transactional emails do not have a uuid.
    */
    'emailUuid'?: string;
    /**
    * Library item oid that you wish to apply to the given StoreFront
    */
    'libraryItemOid'?: number;
    /**
    * StoreFront oid where content originates necessary for tracking down relative assets
    */
    'storefrontOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailUuid",
            "baseName": "email_uuid",
            "type": "string"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApplyLibraryItemRequest.attributeTypeMap;
    }
}

export class ApplyLibraryItemResponse {
    /**
    * Cjson from library item, only populated if this library item was a cjson snippet or marketing email (not transactional)
    */
    'cjson'?: string;
    /**
    * flow, campaign, cjson, upsell, transactional_email or email
    */
    'contentType'?: string;
    /**
    * If a marketing email was applied, this is the path to the template encapsulating the cjson.  This is needed for the UltraCart UI.
    */
    'emailTemplateVmPath'?: string;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * StoreFront oid where content originates necessary for tracking down relative assets
    */
    'storefrontOid'?: number;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    /**
    * title of library item, usually the name of the flow or campaign, or description of cjson
    */
    'title'?: string;
    /**
    * UUID of marketing email or communication flow/campaign if this library item was an email, campaign or flow
    */
    'uuid'?: string;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cjson",
            "baseName": "cjson",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "emailTemplateVmPath",
            "baseName": "email_template_vm_path",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ApplyLibraryItemResponse.attributeTypeMap;
    }
}

export class AutoOrder {
    /**
    * Unique code assigned to this auto order
    */
    'autoOrderCode'?: string;
    /**
    * Auto order object identifier
    */
    'autoOrderOid'?: number;
    /**
    * Cancel this auto order after X additional rebills
    */
    'cancelAfterNextXOrders'?: number;
    /**
    * True if the auto order was canceled because the customer purchased a downgrade item
    */
    'cancelDowngrade'?: boolean;
    /**
    * True if the auto order was canceled because the customer purchased an upgrade item
    */
    'cancelUpgrade'?: boolean;
    /**
    * The user that canceled the auto order
    */
    'canceledByUser'?: string;
    /**
    * The date/time that the auto order was canceled
    */
    'canceledDts'?: string;
    /**
    * True if the auto order ran successfully to completion
    */
    'completed'?: boolean;
    /**
    * The number of credit card attempts that have taken place
    */
    'creditCardAttempt'?: number;
    /**
    * The date/time the auto order was disabled due to failed rebills
    */
    'disabledDts'?: string;
    /**
    * True if this auto order is enabled
    */
    'enabled'?: boolean;
    /**
    * The reason this auto order failed during the last rebill attempt
    */
    'failureReason'?: string;
    /**
    * The items that are setup to rebill
    */
    'items'?: Array<AutoOrderItem>;
    /**
    * The next time that the auto order will be attempted for processing
    */
    'nextAttempt'?: string;
    'originalOrder'?: Order;
    /**
    * The original order id that this auto order is associated with.
    */
    'originalOrderId'?: string;
    /**
    * Override the affiliate id given credit for rebills of this auto order
    */
    'overrideAffiliateId'?: number;
    /**
    * Rebill orders that have taken place on this auto order
    */
    'rebillOrders'?: Array<Order>;
    /**
    * The RTG code associated with this order for future rebills
    */
    'rotatingTransactionGatewayCode'?: string;
    /**
    * The status of the auto order
    */
    'status'?: AutoOrder.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoOrderCode",
            "baseName": "auto_order_code",
            "type": "string"
        },
        {
            "name": "autoOrderOid",
            "baseName": "auto_order_oid",
            "type": "number"
        },
        {
            "name": "cancelAfterNextXOrders",
            "baseName": "cancel_after_next_x_orders",
            "type": "number"
        },
        {
            "name": "cancelDowngrade",
            "baseName": "cancel_downgrade",
            "type": "boolean"
        },
        {
            "name": "cancelUpgrade",
            "baseName": "cancel_upgrade",
            "type": "boolean"
        },
        {
            "name": "canceledByUser",
            "baseName": "canceled_by_user",
            "type": "string"
        },
        {
            "name": "canceledDts",
            "baseName": "canceled_dts",
            "type": "string"
        },
        {
            "name": "completed",
            "baseName": "completed",
            "type": "boolean"
        },
        {
            "name": "creditCardAttempt",
            "baseName": "credit_card_attempt",
            "type": "number"
        },
        {
            "name": "disabledDts",
            "baseName": "disabled_dts",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "failureReason",
            "baseName": "failure_reason",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<AutoOrderItem>"
        },
        {
            "name": "nextAttempt",
            "baseName": "next_attempt",
            "type": "string"
        },
        {
            "name": "originalOrder",
            "baseName": "original_order",
            "type": "Order"
        },
        {
            "name": "originalOrderId",
            "baseName": "original_order_id",
            "type": "string"
        },
        {
            "name": "overrideAffiliateId",
            "baseName": "override_affiliate_id",
            "type": "number"
        },
        {
            "name": "rebillOrders",
            "baseName": "rebill_orders",
            "type": "Array<Order>"
        },
        {
            "name": "rotatingTransactionGatewayCode",
            "baseName": "rotating_transaction_gateway_code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "AutoOrder.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrder.attributeTypeMap;
    }
}

export namespace AutoOrder {
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}
export class AutoOrderItem {
    /**
    * Arbitrary item id that should be rebilled instead of the normal schedule
    */
    'arbitraryItemId'?: string;
    /**
    * An arbitrary percentage discount to provide on future rebills
    */
    'arbitraryPercentageDiscount'?: number;
    /**
    * Arbitrary quantity to rebill
    */
    'arbitraryQuantity'?: number;
    /**
    * The number of days to rebill if the frequency is set to an arbitrary number of days
    */
    'arbitraryScheduleDays'?: number;
    /**
    * Arbitrary unit cost that rebills of this item should occur at
    */
    'arbitraryUnitCost'?: number;
    /**
    * The number of rebills to give the arbitrary unit cost on before reverting to normal pricing.
    */
    'arbitraryUnitCostRemainingOrders'?: number;
    /**
    * Primary key of AutoOrderItem
    */
    'autoOrderItemOid'?: number;
    /**
    * Frequency of the rebill if not a fixed schedule
    */
    'frequency'?: AutoOrderItem.FrequencyEnum;
    /**
    * The future rebill schedule for this item up to the next ten rebills
    */
    'futureSchedules'?: Array<AutoOrderItemFutureSchedule>;
    /**
    * Date/time of the last order of this item
    */
    'lastOrderDts'?: string;
    /**
    * The life time value of this item including the original purchase
    */
    'lifeTimeValue'?: number;
    /**
    * The date/time of when the next pre-shipment notice should be sent
    */
    'nextPreshipmentNoticeDts'?: string;
    /**
    * Date/time that this item is scheduled to rebill
    */
    'nextShipmentDts'?: string;
    /**
    * Date/time after which no additional rebills of this item should occur
    */
    'noOrderAfterDts'?: string;
    /**
    * The number of times this item has rebilled
    */
    'numberOfRebills'?: number;
    /**
    * Options associated with this item
    */
    'options'?: Array<AutoOrderItemOption>;
    /**
    * The original item id purchased.  This item controls scheduling.  If you wish to modify a schedule, for example, from monthly to yearly, change this item from your monthly item to your yearly item, and then change the next_shipment_dts to your desired date.
    */
    'originalItemId'?: string;
    /**
    * The original quantity purchased
    */
    'originalQuantity'?: number;
    /**
    * The PayPal Payer ID tied to this item
    */
    'paypalPayerId'?: string;
    /**
    * The PayPal Profile ID tied to this item
    */
    'paypalRecurringPaymentProfileId'?: string;
    /**
    * True if the preshipment notice associated with the next rebill has been sent
    */
    'preshipmentNoticeSent'?: boolean;
    /**
    * The value of the rebills of this item
    */
    'rebillValue'?: number;
    /**
    * The number of rebills remaining before this item is complete
    */
    'remainingRepeatCount'?: number;
    'simpleSchedule'?: AutoOrderItemSimpleSchedule;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "arbitraryItemId",
            "baseName": "arbitrary_item_id",
            "type": "string"
        },
        {
            "name": "arbitraryPercentageDiscount",
            "baseName": "arbitrary_percentage_discount",
            "type": "number"
        },
        {
            "name": "arbitraryQuantity",
            "baseName": "arbitrary_quantity",
            "type": "number"
        },
        {
            "name": "arbitraryScheduleDays",
            "baseName": "arbitrary_schedule_days",
            "type": "number"
        },
        {
            "name": "arbitraryUnitCost",
            "baseName": "arbitrary_unit_cost",
            "type": "number"
        },
        {
            "name": "arbitraryUnitCostRemainingOrders",
            "baseName": "arbitrary_unit_cost_remaining_orders",
            "type": "number"
        },
        {
            "name": "autoOrderItemOid",
            "baseName": "auto_order_item_oid",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "AutoOrderItem.FrequencyEnum"
        },
        {
            "name": "futureSchedules",
            "baseName": "future_schedules",
            "type": "Array<AutoOrderItemFutureSchedule>"
        },
        {
            "name": "lastOrderDts",
            "baseName": "last_order_dts",
            "type": "string"
        },
        {
            "name": "lifeTimeValue",
            "baseName": "life_time_value",
            "type": "number"
        },
        {
            "name": "nextPreshipmentNoticeDts",
            "baseName": "next_preshipment_notice_dts",
            "type": "string"
        },
        {
            "name": "nextShipmentDts",
            "baseName": "next_shipment_dts",
            "type": "string"
        },
        {
            "name": "noOrderAfterDts",
            "baseName": "no_order_after_dts",
            "type": "string"
        },
        {
            "name": "numberOfRebills",
            "baseName": "number_of_rebills",
            "type": "number"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<AutoOrderItemOption>"
        },
        {
            "name": "originalItemId",
            "baseName": "original_item_id",
            "type": "string"
        },
        {
            "name": "originalQuantity",
            "baseName": "original_quantity",
            "type": "number"
        },
        {
            "name": "paypalPayerId",
            "baseName": "paypal_payer_id",
            "type": "string"
        },
        {
            "name": "paypalRecurringPaymentProfileId",
            "baseName": "paypal_recurring_payment_profile_id",
            "type": "string"
        },
        {
            "name": "preshipmentNoticeSent",
            "baseName": "preshipment_notice_sent",
            "type": "boolean"
        },
        {
            "name": "rebillValue",
            "baseName": "rebill_value",
            "type": "number"
        },
        {
            "name": "remainingRepeatCount",
            "baseName": "remaining_repeat_count",
            "type": "number"
        },
        {
            "name": "simpleSchedule",
            "baseName": "simple_schedule",
            "type": "AutoOrderItemSimpleSchedule"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrderItem.attributeTypeMap;
    }
}

export namespace AutoOrderItem {
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}
export class AutoOrderItemFutureSchedule {
    /**
    * Item ID that should rebill
    */
    'itemId'?: string;
    /**
    * The number of times this rebill represents
    */
    'rebillCount'?: number;
    /**
    * Date/time that this item is scheduled to rebill
    */
    'shipmentDts'?: string;
    /**
    * The unit cost of the item rebilling
    */
    'unitCost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "rebillCount",
            "baseName": "rebill_count",
            "type": "number"
        },
        {
            "name": "shipmentDts",
            "baseName": "shipment_dts",
            "type": "string"
        },
        {
            "name": "unitCost",
            "baseName": "unit_cost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrderItemFutureSchedule.attributeTypeMap;
    }
}

export class AutoOrderItemOption {
    /**
    * Label
    */
    'label'?: string;
    /**
    * Value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrderItemOption.attributeTypeMap;
    }
}

export class AutoOrderItemSimpleSchedule {
    /**
    * Frequency of the rebill if not a fixed schedule
    */
    'frequency'?: AutoOrderItemSimpleSchedule.FrequencyEnum;
    /**
    * Item ID that should rebill
    */
    'itemId'?: string;
    /**
    * The number of times this simple schedule is configured for
    */
    'repeatCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "AutoOrderItemSimpleSchedule.FrequencyEnum"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "repeatCount",
            "baseName": "repeat_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrderItemSimpleSchedule.attributeTypeMap;
    }
}

export namespace AutoOrderItemSimpleSchedule {
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}
export class AutoOrderQuery {
    /**
    * Auto order code
    */
    'autoOrderCode'?: string;
    /**
    * Card type
    */
    'cardType'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid'?: number;
    /**
    * Email
    */
    'email'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Item ID
    */
    'itemId'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Next shipment date begin
    */
    'nextShipmentDateBegin'?: string;
    /**
    * Next shipment date end
    */
    'nextShipmentDateEnd'?: string;
    /**
    * Original order date begin
    */
    'originalOrderDateBegin'?: string;
    /**
    * Original order date end
    */
    'originalOrderDateEnd'?: string;
    /**
    * Original order ID
    */
    'originalOrderId'?: string;
    /**
    * Phone
    */
    'phone'?: string;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * State
    */
    'state'?: string;
    /**
    * Status
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoOrderCode",
            "baseName": "auto_order_code",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "card_type",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "nextShipmentDateBegin",
            "baseName": "next_shipment_date_begin",
            "type": "string"
        },
        {
            "name": "nextShipmentDateEnd",
            "baseName": "next_shipment_date_end",
            "type": "string"
        },
        {
            "name": "originalOrderDateBegin",
            "baseName": "original_order_date_begin",
            "type": "string"
        },
        {
            "name": "originalOrderDateEnd",
            "baseName": "original_order_date_end",
            "type": "string"
        },
        {
            "name": "originalOrderId",
            "baseName": "original_order_id",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrderQuery.attributeTypeMap;
    }
}

export class AutoOrderQueryBatch {
    /**
    * Auto order oids
    */
    'autoOrderOids'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoOrderOids",
            "baseName": "auto_order_oids",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrderQueryBatch.attributeTypeMap;
    }
}

export class AutoOrderResponse {
    'autoOrder'?: AutoOrder;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoOrder",
            "baseName": "auto_order",
            "type": "AutoOrder"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrderResponse.attributeTypeMap;
    }
}

export class AutoOrdersRequest {
    /**
    * auto_orders
    */
    'autoOrders'?: Array<AutoOrder>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoOrders",
            "baseName": "autoOrders",
            "type": "Array<AutoOrder>"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrdersRequest.attributeTypeMap;
    }
}

export class AutoOrdersResponse {
    'autoOrders'?: Array<AutoOrder>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoOrders",
            "baseName": "auto_orders",
            "type": "Array<AutoOrder>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return AutoOrdersResponse.attributeTypeMap;
    }
}

export class AvalaraConfig {
    /**
    * Avalara account ID
    */
    'accountId'?: string;
    /**
    * True if Avalara is active for this merchant
    */
    'active'?: boolean;
    /**
    * Unique identifier for this avalara config object
    */
    'avalaraOid'?: number;
    /**
    * Avalara company ID
    */
    'companyId'?: string;
    /**
    * True if this Avalara configuration is set to enable tax valuation by UPC
    */
    'enableUpc'?: boolean;
    /**
    * True if this Avalara configuration is to estimate taxes only and not report placed orders to Avalara
    */
    'estimateOnly'?: boolean;
    /**
    * Optional customer code for customers without profiles, defaults to GuestCustomer
    */
    'guestCustomerCode'?: string;
    /**
    * Date/time of the connection test to Avalara
    */
    'lastTestDts'?: string;
    /**
    * Avalara license key
    */
    'licenseKey'?: string;
    /**
    * True if this Avalara instance is pointed at the Avalara Sandbox
    */
    'sandbox'?: boolean;
    /**
    * Send test orders through to Avalara.  The default is to not transmit test orders to Avalara.
    */
    'sendTestOrders'?: boolean;
    /**
    * Avalara service URL
    */
    'serviceUrl'?: string;
    /**
    * Test results of the last connection test to Avalara
    */
    'testResults'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "account_id",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "avalaraOid",
            "baseName": "avalara_oid",
            "type": "number"
        },
        {
            "name": "companyId",
            "baseName": "company_id",
            "type": "string"
        },
        {
            "name": "enableUpc",
            "baseName": "enable_upc",
            "type": "boolean"
        },
        {
            "name": "estimateOnly",
            "baseName": "estimate_only",
            "type": "boolean"
        },
        {
            "name": "guestCustomerCode",
            "baseName": "guest_customer_code",
            "type": "string"
        },
        {
            "name": "lastTestDts",
            "baseName": "last_test_dts",
            "type": "string"
        },
        {
            "name": "licenseKey",
            "baseName": "license_key",
            "type": "string"
        },
        {
            "name": "sandbox",
            "baseName": "sandbox",
            "type": "boolean"
        },
        {
            "name": "sendTestOrders",
            "baseName": "send_test_orders",
            "type": "boolean"
        },
        {
            "name": "serviceUrl",
            "baseName": "service_url",
            "type": "string"
        },
        {
            "name": "testResults",
            "baseName": "test_results",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AvalaraConfig.attributeTypeMap;
    }
}

export class BaseResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return BaseResponse.attributeTypeMap;
    }
}

export class Cart {
    'affiliate'?: CartAffiliate;
    /**
    * The ISO-4217 three letter base currency code of the account
    */
    'baseCurrencyCode'?: string;
    'billing'?: CartBilling;
    'buysafe'?: CartBuysafe;
    /**
    * Unique identifier for this cart
    */
    'cartId'?: string;
    'checkout'?: CartCheckout;
    /**
    * Coupons
    */
    'coupons'?: Array<CartCoupon>;
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    'currencyConversion'?: CartCurrencyConversion;
    'customerProfile'?: CartCustomerProfile;
    /**
    * The exchange rate if the customer is viewing a different currency than the base
    */
    'exchangeRate'?: number;
    'gift'?: CartGift;
    'giftCertificate'?: CartGiftCertificate;
    /**
    * Items
    */
    'items'?: Array<CartItem>;
    /**
    * The ISO-631 three letter code the customer would like to checkout with
    */
    'languageIsoCode'?: string;
    /**
    * True if the customer is logged into their profile
    */
    'loggedIn'?: boolean;
    'marketing'?: CartMarketing;
    /**
    * Merchant ID this cart is associated with
    */
    'merchantId'?: string;
    'payment'?: CartPayment;
    /**
    * Properties associated with the cart
    */
    'properties'?: Array<CartProperty>;
    'settings'?: CartSettings;
    'shipping'?: CartShipping;
    'summary'?: CartSummary;
    'taxes'?: CartTaxes;
    'upsellAfter'?: CartUpsellAfter;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliate",
            "baseName": "affiliate",
            "type": "CartAffiliate"
        },
        {
            "name": "baseCurrencyCode",
            "baseName": "base_currency_code",
            "type": "string"
        },
        {
            "name": "billing",
            "baseName": "billing",
            "type": "CartBilling"
        },
        {
            "name": "buysafe",
            "baseName": "buysafe",
            "type": "CartBuysafe"
        },
        {
            "name": "cartId",
            "baseName": "cart_id",
            "type": "string"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "CartCheckout"
        },
        {
            "name": "coupons",
            "baseName": "coupons",
            "type": "Array<CartCoupon>"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currencyConversion",
            "baseName": "currency_conversion",
            "type": "CartCurrencyConversion"
        },
        {
            "name": "customerProfile",
            "baseName": "customer_profile",
            "type": "CartCustomerProfile"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchange_rate",
            "type": "number"
        },
        {
            "name": "gift",
            "baseName": "gift",
            "type": "CartGift"
        },
        {
            "name": "giftCertificate",
            "baseName": "gift_certificate",
            "type": "CartGiftCertificate"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<CartItem>"
        },
        {
            "name": "languageIsoCode",
            "baseName": "language_iso_code",
            "type": "string"
        },
        {
            "name": "loggedIn",
            "baseName": "logged_in",
            "type": "boolean"
        },
        {
            "name": "marketing",
            "baseName": "marketing",
            "type": "CartMarketing"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "CartPayment"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<CartProperty>"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "CartSettings"
        },
        {
            "name": "shipping",
            "baseName": "shipping",
            "type": "CartShipping"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "CartSummary"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "CartTaxes"
        },
        {
            "name": "upsellAfter",
            "baseName": "upsell_after",
            "type": "CartUpsellAfter"
        }    ];

    static getAttributeTypeMap() {
        return Cart.attributeTypeMap;
    }
}

export class CartAffiliate {
    /**
    * Affiliate id associated with the cart
    */
    'affiliateId'?: number;
    /**
    * Affiliate sub id associated with the cart
    */
    'affiliateSubId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateId",
            "baseName": "affiliate_id",
            "type": "number"
        },
        {
            "name": "affiliateSubId",
            "baseName": "affiliate_sub_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartAffiliate.attributeTypeMap;
    }
}

export class CartAffirmCheckoutResponse {
    /**
    * Checkout JSON object
    */
    'checkoutJson'?: string;
    /**
    * Errors that should be displayed to the customer
    */
    'errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "checkoutJson",
            "baseName": "checkout_json",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CartAffirmCheckoutResponse.attributeTypeMap;
    }
}

export class CartBilling {
    /**
    * Address line 1
    */
    'address1'?: string;
    /**
    * Address line 2
    */
    'address2'?: string;
    /**
    * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
    */
    'ccEmails'?: Array<string>;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Day phone
    */
    'dayPhone'?: string;
    /**
    * Email
    */
    'email'?: string;
    /**
    * Email entered for confirmation
    */
    'emailConfirm'?: string;
    /**
    * Evening phone
    */
    'eveningPhone'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion'?: string;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "ccEmails",
            "baseName": "cc_emails",
            "type": "Array<string>"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "dayPhone",
            "baseName": "day_phone",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailConfirm",
            "baseName": "email_confirm",
            "type": "string"
        },
        {
            "name": "eveningPhone",
            "baseName": "evening_phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartBilling.attributeTypeMap;
    }
}

export class CartBuysafe {
    /**
    * True if buySAFE is willing to bond the order
    */
    'bondAvailable'?: boolean;
    'bondCost'?: Currency;
    /**
    * True if the bond is free (merchant paying for it)
    */
    'bondFree'?: boolean;
    /**
    * True if the customer wants the bond
    */
    'bondWanted'?: boolean;
    /**
    * Recommend text to display to the customer
    */
    'cartDisplayText'?: string;
    /**
    * URL associated with the recommended text
    */
    'cartDisplayUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bondAvailable",
            "baseName": "bond_available",
            "type": "boolean"
        },
        {
            "name": "bondCost",
            "baseName": "bond_cost",
            "type": "Currency"
        },
        {
            "name": "bondFree",
            "baseName": "bond_free",
            "type": "boolean"
        },
        {
            "name": "bondWanted",
            "baseName": "bond_wanted",
            "type": "boolean"
        },
        {
            "name": "cartDisplayText",
            "baseName": "cart_display_text",
            "type": "string"
        },
        {
            "name": "cartDisplayUrl",
            "baseName": "cart_display_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartBuysafe.attributeTypeMap;
    }
}

export class CartCheckout {
    /**
    * Comments from the customer.  Rarely used on the single page checkout.
    */
    'comments'?: string;
    /**
    * Custom field 1
    */
    'customField1'?: string;
    /**
    * Custom field 2
    */
    'customField2'?: string;
    /**
    * Custom field 3
    */
    'customField3'?: string;
    /**
    * Custom field 4
    */
    'customField4'?: string;
    /**
    * Custom field 5
    */
    'customField5'?: string;
    /**
    * Custom field 6
    */
    'customField6'?: string;
    /**
    * Custom field 7
    */
    'customField7'?: string;
    /**
    * IP Address (read only unless non-browser key authenticated)
    */
    'ipAddress'?: string;
    /**
    * Return code assigned for send return email operation
    */
    'returnCode'?: string;
    /**
    * Screen branding theme code
    */
    'screenBrandingThemeCode'?: string;
    /**
    * StoreFront Host Name
    */
    'storefrontHostName'?: string;
    /**
    * User agent of the browser
    */
    'userAgent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "customField1",
            "baseName": "custom_field1",
            "type": "string"
        },
        {
            "name": "customField2",
            "baseName": "custom_field2",
            "type": "string"
        },
        {
            "name": "customField3",
            "baseName": "custom_field3",
            "type": "string"
        },
        {
            "name": "customField4",
            "baseName": "custom_field4",
            "type": "string"
        },
        {
            "name": "customField5",
            "baseName": "custom_field5",
            "type": "string"
        },
        {
            "name": "customField6",
            "baseName": "custom_field6",
            "type": "string"
        },
        {
            "name": "customField7",
            "baseName": "custom_field7",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ip_address",
            "type": "string"
        },
        {
            "name": "returnCode",
            "baseName": "return_code",
            "type": "string"
        },
        {
            "name": "screenBrandingThemeCode",
            "baseName": "screen_branding_theme_code",
            "type": "string"
        },
        {
            "name": "storefrontHostName",
            "baseName": "storefront_host_name",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "user_agent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartCheckout.attributeTypeMap;
    }
}

export class CartCoupon {
    /**
    * Coupon code
    */
    'couponCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "couponCode",
            "baseName": "coupon_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartCoupon.attributeTypeMap;
    }
}

export class CartCurrencyConversion {
    /**
    * Base currency code for this merchant
    */
    'baseCurrencyCode'?: string;
    /**
    * Conversion information for 1 unit of base currency to target currencies
    */
    'currencies'?: Array<Currency>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "baseCurrencyCode",
            "baseName": "base_currency_Code",
            "type": "string"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "Array<Currency>"
        }    ];

    static getAttributeTypeMap() {
        return CartCurrencyConversion.attributeTypeMap;
    }
}

export class CartCustomerProfile {
    /**
    * True if profile is allowed to bill to their 3rd party shipping account
    */
    'allow3rdPartyBilling'?: boolean;
    /**
    * True if this profile is allowed to use a COD
    */
    'allowCod'?: boolean;
    /**
    * True if this profile is allowed to use a purchase order
    */
    'allowPurchaseOrder'?: boolean;
    /**
    * Billing addresses on file for this profile
    */
    'billingAddresses'?: Array<CartCustomerProfileAddress>;
    /**
    * Credit cards on file for this profile (masked)
    */
    'creditCards'?: Array<CartCustomerProfileCreditCard>;
    /**
    * Unique identifier
    */
    'customerProfileOid'?: number;
    /**
    * DHL account number on file
    */
    'dhlAccountNumber'?: string;
    /**
    * DHL duty account number on file
    */
    'dhlDutyAccountNumber'?: string;
    /**
    * Email
    */
    'email'?: string;
    /**
    * FedEx account number on file
    */
    'fedexAccountNumber'?: string;
    /**
    * True if this profile always qualifies for free shipping
    */
    'freeShipping'?: boolean;
    /**
    * The minimum aount that this profile has to purchase to qualify for free shipping
    */
    'freeShippingMinimum'?: number;
    /**
    * Maximum item count this profile can purchase
    */
    'maximumItemCount'?: number;
    /**
    * Minimum item count this profile must purchase
    */
    'minimumItemCount'?: number;
    /**
    * Minimum subtotal this profile must purchase
    */
    'minimumSubtotal'?: number;
    /**
    * True if this profile is prevented from using coupons
    */
    'noCoupons'?: boolean;
    /**
    * True if this profile is never given free shipping
    */
    'noFreeShipping'?: boolean;
    /**
    * True if this customers orders are not charged in real-time
    */
    'noRealtimeCharge'?: boolean;
    /**
    * Pricing tier names this profile qualifies for
    */
    'pricingTiers'?: Array<string>;
    /**
    * Shipping addresses on file for this profile
    */
    'shippingAddresses'?: Array<CartCustomerProfileAddress>;
    /**
    * True if this profile is exempt from sales tax
    */
    'taxExempt'?: boolean;
    /**
    * UPS account number on file
    */
    'upsAccountNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allow3rdPartyBilling",
            "baseName": "allow_3rd_party_billing",
            "type": "boolean"
        },
        {
            "name": "allowCod",
            "baseName": "allow_cod",
            "type": "boolean"
        },
        {
            "name": "allowPurchaseOrder",
            "baseName": "allow_purchase_order",
            "type": "boolean"
        },
        {
            "name": "billingAddresses",
            "baseName": "billing_addresses",
            "type": "Array<CartCustomerProfileAddress>"
        },
        {
            "name": "creditCards",
            "baseName": "credit_cards",
            "type": "Array<CartCustomerProfileCreditCard>"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "dhlAccountNumber",
            "baseName": "dhl_account_number",
            "type": "string"
        },
        {
            "name": "dhlDutyAccountNumber",
            "baseName": "dhl_duty_account_number",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fedexAccountNumber",
            "baseName": "fedex_account_number",
            "type": "string"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "boolean"
        },
        {
            "name": "freeShippingMinimum",
            "baseName": "free_shipping_minimum",
            "type": "number"
        },
        {
            "name": "maximumItemCount",
            "baseName": "maximum_item_count",
            "type": "number"
        },
        {
            "name": "minimumItemCount",
            "baseName": "minimum_item_count",
            "type": "number"
        },
        {
            "name": "minimumSubtotal",
            "baseName": "minimum_subtotal",
            "type": "number"
        },
        {
            "name": "noCoupons",
            "baseName": "no_coupons",
            "type": "boolean"
        },
        {
            "name": "noFreeShipping",
            "baseName": "no_free_shipping",
            "type": "boolean"
        },
        {
            "name": "noRealtimeCharge",
            "baseName": "no_realtime_charge",
            "type": "boolean"
        },
        {
            "name": "pricingTiers",
            "baseName": "pricing_tiers",
            "type": "Array<string>"
        },
        {
            "name": "shippingAddresses",
            "baseName": "shipping_addresses",
            "type": "Array<CartCustomerProfileAddress>"
        },
        {
            "name": "taxExempt",
            "baseName": "tax_exempt",
            "type": "boolean"
        },
        {
            "name": "upsAccountNumber",
            "baseName": "ups_account_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartCustomerProfile.attributeTypeMap;
    }
}

export class CartCustomerProfileAddress {
    /**
    * Address 1
    */
    'address1'?: string;
    /**
    * Address 2
    */
    'address2'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 Country code
    */
    'countryCode'?: string;
    /**
    * Day phone
    */
    'dayPhone'?: string;
    /**
    * Evening phone
    */
    'eveningPhone'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Unique identifier for this address
    */
    'oid'?: number;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion'?: string;
    /**
    * Tax county if a billing address
    */
    'taxCounty'?: string;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "dayPhone",
            "baseName": "day_phone",
            "type": "string"
        },
        {
            "name": "eveningPhone",
            "baseName": "evening_phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "oid",
            "baseName": "oid",
            "type": "number"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "taxCounty",
            "baseName": "tax_county",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartCustomerProfileAddress.attributeTypeMap;
    }
}

export class CartCustomerProfileCreditCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth'?: number;
    /**
    * Card expiration year (four digit)
    */
    'cardExpirationYear'?: number;
    /**
    * Card number (masked last 4 digits)
    */
    'cardNumber'?: string;
    /**
    * Card type
    */
    'cardType'?: CartCustomerProfileCreditCard.CardTypeEnum;
    /**
    * Unique identifier for this stored card
    */
    'customerProfileCreditCardId'?: number;
    /**
    * Last used
    */
    'lastUsedDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardExpirationMonth",
            "baseName": "card_expiration_month",
            "type": "number"
        },
        {
            "name": "cardExpirationYear",
            "baseName": "card_expiration_year",
            "type": "number"
        },
        {
            "name": "cardNumber",
            "baseName": "card_number",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "card_type",
            "type": "CartCustomerProfileCreditCard.CardTypeEnum"
        },
        {
            "name": "customerProfileCreditCardId",
            "baseName": "customer_profile_credit_card_id",
            "type": "number"
        },
        {
            "name": "lastUsedDate",
            "baseName": "last_used_date",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartCustomerProfileCreditCard.attributeTypeMap;
    }
}

export namespace CartCustomerProfileCreditCard {
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        MasterCard = <any> 'MasterCard',
        JCB = <any> 'JCB',
        VISA = <any> 'VISA'
    }
}
export class CartFinalizeOrderRequest {
    'cart'?: Cart;
    'options'?: CartFinalizeOrderRequestOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "CartFinalizeOrderRequestOptions"
        }    ];

    static getAttributeTypeMap() {
        return CartFinalizeOrderRequest.attributeTypeMap;
    }
}

export class CartFinalizeOrderRequestOptions {
    /**
    * Automatically approve the purchase order
    */
    'autoApprovePurchaseOrder'?: boolean;
    /**
    * Channel partner code to associate this order with
    */
    'channelPartnerCode'?: string;
    /**
    * Channel partner oid to associate this order with
    */
    'channelPartnerOid'?: number;
    /**
    * Channel partner order id for reference
    */
    'channelPartnerOrderId'?: string;
    /**
    * Consider this order a recurring order for the purposes of payment gateway recurring flag
    */
    'considerRecurring'?: boolean;
    /**
    * If the order was authorized outside of UltraCart, this is the amount of the authorization
    */
    'creditCardAuthorizationAmount'?: number;
    /**
    * If the order was authorized outside of UltraCart, this is the date/time of the authorization
    */
    'creditCardAuthorizationDate'?: string;
    /**
    * If the order was authorized outside of UltraCart, this is the authorization reference number
    */
    'creditCardAuthorizationReferenceNumber'?: string;
    /**
    * Prevents normal real-time processing of the payment and sends the order to Accounts Receivable
    */
    'noRealtimePaymentProcessing'?: boolean;
    /**
    * True if the system should create another cart automatically if the current cart was logged into a profile
    */
    'setupNextCart'?: boolean;
    /**
    * Skip payment processing and move the order on to shipping (or completed if no shipping required)
    */
    'skipPaymentProcessing'?: boolean;
    /**
    * True the order in the completed stage
    */
    'storeCompleted'?: boolean;
    /**
    * Store the order in accounts receivable if the payment declines
    */
    'storeIfPaymentDeclines'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoApprovePurchaseOrder",
            "baseName": "auto_approve_purchase_order",
            "type": "boolean"
        },
        {
            "name": "channelPartnerCode",
            "baseName": "channel_partner_code",
            "type": "string"
        },
        {
            "name": "channelPartnerOid",
            "baseName": "channel_partner_oid",
            "type": "number"
        },
        {
            "name": "channelPartnerOrderId",
            "baseName": "channel_partner_order_id",
            "type": "string"
        },
        {
            "name": "considerRecurring",
            "baseName": "consider_recurring",
            "type": "boolean"
        },
        {
            "name": "creditCardAuthorizationAmount",
            "baseName": "credit_card_authorization_amount",
            "type": "number"
        },
        {
            "name": "creditCardAuthorizationDate",
            "baseName": "credit_card_authorization_date",
            "type": "string"
        },
        {
            "name": "creditCardAuthorizationReferenceNumber",
            "baseName": "credit_card_authorization_reference_number",
            "type": "string"
        },
        {
            "name": "noRealtimePaymentProcessing",
            "baseName": "no_realtime_payment_processing",
            "type": "boolean"
        },
        {
            "name": "setupNextCart",
            "baseName": "setup_next_cart",
            "type": "boolean"
        },
        {
            "name": "skipPaymentProcessing",
            "baseName": "skip_payment_processing",
            "type": "boolean"
        },
        {
            "name": "storeCompleted",
            "baseName": "store_completed",
            "type": "boolean"
        },
        {
            "name": "storeIfPaymentDeclines",
            "baseName": "store_if_payment_declines",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CartFinalizeOrderRequestOptions.attributeTypeMap;
    }
}

export class CartFinalizeOrderResponse {
    /**
    * Error messages if the order could not be completed
    */
    'errors'?: Array<string>;
    'nextCart'?: Cart;
    'order'?: Order;
    /**
    * Order ID assigned to the order
    */
    'orderId'?: string;
    /**
    * True if the cart was converted successfully to an order
    */
    'successful'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        },
        {
            "name": "nextCart",
            "baseName": "next_cart",
            "type": "Cart"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "successful",
            "baseName": "successful",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CartFinalizeOrderResponse.attributeTypeMap;
    }
}

export class CartGift {
    /**
    * True if this order is a gift
    */
    'gift'?: boolean;
    'giftCharge'?: Currency;
    /**
    * Email address of the gift recipient
    */
    'giftEmail'?: string;
    /**
    * Message to the gift recipient
    */
    'giftMessage'?: string;
    'giftWrapCost'?: Currency;
    /**
    * Title of the selected gift wrap
    */
    'giftWrapTitle'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gift",
            "baseName": "gift",
            "type": "boolean"
        },
        {
            "name": "giftCharge",
            "baseName": "gift_charge",
            "type": "Currency"
        },
        {
            "name": "giftEmail",
            "baseName": "gift_email",
            "type": "string"
        },
        {
            "name": "giftMessage",
            "baseName": "gift_message",
            "type": "string"
        },
        {
            "name": "giftWrapCost",
            "baseName": "gift_wrap_cost",
            "type": "Currency"
        },
        {
            "name": "giftWrapTitle",
            "baseName": "gift_wrap_title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartGift.attributeTypeMap;
    }
}

export class CartGiftCertificate {
    'giftCertificateAmount'?: Currency;
    /**
    * Gift certificate code
    */
    'giftCertificateCode'?: string;
    'giftCertificateRemainingBalanceAfterOrder'?: Currency;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "giftCertificateAmount",
            "baseName": "gift_certificate_amount",
            "type": "Currency"
        },
        {
            "name": "giftCertificateCode",
            "baseName": "gift_certificate_code",
            "type": "string"
        },
        {
            "name": "giftCertificateRemainingBalanceAfterOrder",
            "baseName": "gift_certificate_remaining_balance_after_order",
            "type": "Currency"
        }    ];

    static getAttributeTypeMap() {
        return CartGiftCertificate.attributeTypeMap;
    }
}

export class CartItem {
    'arbitraryUnitCost'?: Currency;
    /**
    * Attributes
    */
    'attributes'?: Array<CartItemAttribute>;
    /**
    * Auto order schedule the customer selected
    */
    'autoOrderSchedule'?: string;
    /**
    * URL to the default multimedia image
    */
    'defaultImageUrl'?: string;
    /**
    * URL to the default multimedia thumbnail
    */
    'defaultThumbnailUrl'?: string;
    /**
    * Description of the item
    */
    'description'?: string;
    'discount'?: Currency;
    /**
    * Extended description of the item
    */
    'extendedDescription'?: string;
    /**
    * Item ID
    */
    'itemId'?: string;
    /**
    * Item object identifier
    */
    'itemOid'?: number;
    /**
    * True if this item is a kit
    */
    'kit'?: boolean;
    /**
    * Options associated with the kit components
    */
    'kitComponentOptions'?: Array<CartKitComponentOption>;
    'manufacturerSuggestedRetailPrice'?: Currency;
    /**
    * Maximum quantity the customer can purchase
    */
    'maximumQuantity'?: number;
    /**
    * Minimum quantity the customer can purchase
    */
    'minimumQuantity'?: number;
    /**
    * Multimedia
    */
    'multimedia'?: Array<CartItemMultimedia>;
    /**
    * Options
    */
    'options'?: Array<CartItemOption>;
    'phsyical'?: CartItemPhysical;
    /**
    * Position of the item in the cart
    */
    'position'?: number;
    /**
    * True if this item is on pre-order
    */
    'preorder'?: boolean;
    /**
    * quantity
    */
    'quantity'?: number;
    /**
    * Customer selectable auto order schedules
    */
    'schedules'?: Array<string>;
    'totalCost'?: Currency;
    'totalCostWithDiscount'?: Currency;
    'unitCost'?: Currency;
    'unitCostWithDiscount'?: Currency;
    /**
    * True if this item was added to the cart as part of an upsell
    */
    'upsell'?: boolean;
    /**
    * Variations
    */
    'variations'?: Array<CartItemVariationSelection>;
    /**
    * URL to view the product on the site
    */
    'viewUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "arbitraryUnitCost",
            "baseName": "arbitrary_unit_cost",
            "type": "Currency"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<CartItemAttribute>"
        },
        {
            "name": "autoOrderSchedule",
            "baseName": "auto_order_schedule",
            "type": "string"
        },
        {
            "name": "defaultImageUrl",
            "baseName": "default_image_url",
            "type": "string"
        },
        {
            "name": "defaultThumbnailUrl",
            "baseName": "default_thumbnail_url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discount",
            "baseName": "discount",
            "type": "Currency"
        },
        {
            "name": "extendedDescription",
            "baseName": "extended_description",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "itemOid",
            "baseName": "item_oid",
            "type": "number"
        },
        {
            "name": "kit",
            "baseName": "kit",
            "type": "boolean"
        },
        {
            "name": "kitComponentOptions",
            "baseName": "kit_component_options",
            "type": "Array<CartKitComponentOption>"
        },
        {
            "name": "manufacturerSuggestedRetailPrice",
            "baseName": "manufacturer_suggested_retail_price",
            "type": "Currency"
        },
        {
            "name": "maximumQuantity",
            "baseName": "maximum_quantity",
            "type": "number"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimum_quantity",
            "type": "number"
        },
        {
            "name": "multimedia",
            "baseName": "multimedia",
            "type": "Array<CartItemMultimedia>"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<CartItemOption>"
        },
        {
            "name": "phsyical",
            "baseName": "phsyical",
            "type": "CartItemPhysical"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "preorder",
            "baseName": "preorder",
            "type": "boolean"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "schedules",
            "baseName": "schedules",
            "type": "Array<string>"
        },
        {
            "name": "totalCost",
            "baseName": "total_cost",
            "type": "Currency"
        },
        {
            "name": "totalCostWithDiscount",
            "baseName": "total_cost_with_discount",
            "type": "Currency"
        },
        {
            "name": "unitCost",
            "baseName": "unit_cost",
            "type": "Currency"
        },
        {
            "name": "unitCostWithDiscount",
            "baseName": "unit_cost_with_discount",
            "type": "Currency"
        },
        {
            "name": "upsell",
            "baseName": "upsell",
            "type": "boolean"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<CartItemVariationSelection>"
        },
        {
            "name": "viewUrl",
            "baseName": "view_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartItem.attributeTypeMap;
    }
}

export class CartItemAttribute {
    /**
    * Name of the attribute
    */
    'name'?: string;
    /**
    * Type of attribute
    */
    'type'?: string;
    /**
    * Value of the attribute
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartItemAttribute.attributeTypeMap;
    }
}

export class CartItemMultimedia {
    /**
    * Code assigned to the multimedia
    */
    'code'?: string;
    /**
    * Description
    */
    'description'?: string;
    /**
    * True if the image should be excluded from galleries
    */
    'excludeFromGallery'?: boolean;
    /**
    * Image height
    */
    'imageHeight'?: number;
    /**
    * Image width
    */
    'imageWidth'?: number;
    /**
    * True if the multimedia is the default for this type
    */
    'isDefault'?: boolean;
    /**
    * Thumbnails of the images
    */
    'thumbnails'?: Array<CartItemMultimediaThumbnail>;
    /**
    * Type of multimedia
    */
    'type'?: CartItemMultimedia.TypeEnum;
    /**
    * URL to view multimedia at
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "excludeFromGallery",
            "baseName": "exclude_from_gallery",
            "type": "boolean"
        },
        {
            "name": "imageHeight",
            "baseName": "image_height",
            "type": "number"
        },
        {
            "name": "imageWidth",
            "baseName": "image_width",
            "type": "number"
        },
        {
            "name": "isDefault",
            "baseName": "is_default",
            "type": "boolean"
        },
        {
            "name": "thumbnails",
            "baseName": "thumbnails",
            "type": "Array<CartItemMultimediaThumbnail>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CartItemMultimedia.TypeEnum"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartItemMultimedia.attributeTypeMap;
    }
}

export namespace CartItemMultimedia {
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}
export class CartItemMultimediaThumbnail {
    /**
    * Height in pixels
    */
    'height'?: number;
    /**
    * True if thumbnail is a PNG, otherwise its a JPEG
    */
    'png'?: boolean;
    /**
    * True if the thumbnail is square
    */
    'square'?: boolean;
    /**
    * URL for the thumbnail
    */
    'url'?: string;
    /**
    * Width in pixels
    */
    'width'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "png",
            "baseName": "png",
            "type": "boolean"
        },
        {
            "name": "square",
            "baseName": "square",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CartItemMultimediaThumbnail.attributeTypeMap;
    }
}

export class CartItemOption {
    'costIfSpecified'?: Currency;
    'costPerLetter'?: Currency;
    'costPerLine'?: Currency;
    /**
    * True if the default answer is ignored
    */
    'ignoreIfDefault'?: boolean;
    /**
    * Display label for the option
    */
    'label'?: string;
    /**
    * Name of the option
    */
    'name'?: string;
    /**
    * Charge the fee a single time instead of multiplying by the quantity
    */
    'oneTimeFee'?: boolean;
    /**
    * Unique identifier for the option
    */
    'optionOid'?: number;
    /**
    * True if the customer is required to select a value
    */
    'required'?: boolean;
    /**
    * The value of the option specified by the customer
    */
    'selectedValue'?: string;
    /**
    * Type of option
    */
    'type'?: CartItemOption.TypeEnum;
    /**
    * Values that the customer can select from for radio or select type options
    */
    'values'?: Array<CartItemOptionValue>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "costIfSpecified",
            "baseName": "cost_if_specified",
            "type": "Currency"
        },
        {
            "name": "costPerLetter",
            "baseName": "cost_per_letter",
            "type": "Currency"
        },
        {
            "name": "costPerLine",
            "baseName": "cost_per_line",
            "type": "Currency"
        },
        {
            "name": "ignoreIfDefault",
            "baseName": "ignore_if_default",
            "type": "boolean"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "oneTimeFee",
            "baseName": "one_time_fee",
            "type": "boolean"
        },
        {
            "name": "optionOid",
            "baseName": "option_oid",
            "type": "number"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "selectedValue",
            "baseName": "selected_value",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CartItemOption.TypeEnum"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<CartItemOptionValue>"
        }    ];

    static getAttributeTypeMap() {
        return CartItemOption.attributeTypeMap;
    }
}

export namespace CartItemOption {
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}
export class CartItemOptionValue {
    'additionalCost'?: Currency;
    'additionalWeight'?: Weight;
    /**
    * True if this is the default value
    */
    'defaultValue'?: boolean;
    /**
    * Display order of the option value
    */
    'displayOrder'?: number;
    /**
    * Value of the option the customer can select
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalCost",
            "baseName": "additional_cost",
            "type": "Currency"
        },
        {
            "name": "additionalWeight",
            "baseName": "additional_weight",
            "type": "Weight"
        },
        {
            "name": "defaultValue",
            "baseName": "default_value",
            "type": "boolean"
        },
        {
            "name": "displayOrder",
            "baseName": "display_order",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartItemOptionValue.attributeTypeMap;
    }
}

export class CartItemPhysical {
    'height'?: Distance;
    'length'?: Distance;
    'weight'?: Weight;
    'width'?: Distance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "height",
            "baseName": "height",
            "type": "Distance"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "Distance"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "Weight"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "Distance"
        }    ];

    static getAttributeTypeMap() {
        return CartItemPhysical.attributeTypeMap;
    }
}

export class CartItemVariationSelection {
    /**
    * Variation name
    */
    'variationName'?: string;
    /**
    * Variation value
    */
    'variationValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "variationName",
            "baseName": "variation_name",
            "type": "string"
        },
        {
            "name": "variationValue",
            "baseName": "variation_value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartItemVariationSelection.attributeTypeMap;
    }
}

export class CartKitComponentOption {
    'costIfSpecified'?: Currency;
    'costPerLetter'?: Currency;
    'costPerLine'?: Currency;
    /**
    * True if the default answer is ignored
    */
    'ignoreIfDefault'?: boolean;
    /**
    * Kit component item id
    */
    'itemId'?: string;
    /**
    * Unique identifier for the kit component item
    */
    'itemOid'?: number;
    /**
    * Display label for the option
    */
    'label'?: string;
    /**
    * Name of the option
    */
    'name'?: string;
    /**
    * Charge the fee a single time instead of multiplying by the quantity
    */
    'oneTimeFee'?: boolean;
    /**
    * Unique identifier for the option
    */
    'optionOid'?: number;
    /**
    * True if the customer is required to select a value
    */
    'required'?: boolean;
    /**
    * The value of the option specified by the customer
    */
    'selectedValue'?: string;
    /**
    * Type of option
    */
    'type'?: CartKitComponentOption.TypeEnum;
    /**
    * Values that the customer can select from for radio or select type options
    */
    'values'?: Array<CartItemOptionValue>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "costIfSpecified",
            "baseName": "cost_if_specified",
            "type": "Currency"
        },
        {
            "name": "costPerLetter",
            "baseName": "cost_per_letter",
            "type": "Currency"
        },
        {
            "name": "costPerLine",
            "baseName": "cost_per_line",
            "type": "Currency"
        },
        {
            "name": "ignoreIfDefault",
            "baseName": "ignore_if_default",
            "type": "boolean"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "itemOid",
            "baseName": "item_oid",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "oneTimeFee",
            "baseName": "one_time_fee",
            "type": "boolean"
        },
        {
            "name": "optionOid",
            "baseName": "option_oid",
            "type": "number"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "selectedValue",
            "baseName": "selected_value",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CartKitComponentOption.TypeEnum"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<CartItemOptionValue>"
        }    ];

    static getAttributeTypeMap() {
        return CartKitComponentOption.attributeTypeMap;
    }
}

export namespace CartKitComponentOption {
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}
export class CartMarketing {
    /**
    * The advertising source the customer indicated
    */
    'advertisingSource'?: string;
    /**
    * True if the customer agrees to receiving marketing emails
    */
    'mailingListOptIn'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advertisingSource",
            "baseName": "advertising_source",
            "type": "string"
        },
        {
            "name": "mailingListOptIn",
            "baseName": "mailing_list_opt_in",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CartMarketing.attributeTypeMap;
    }
}

export class CartPayment {
    'affirm'?: CartPaymentAffirm;
    'amazon'?: CartPaymentAmazon;
    'check'?: CartPaymentCheck;
    'creditCard'?: CartPaymentCreditCard;
    /**
    * Payment method
    */
    'paymentMethod'?: string;
    'purchaseOrder'?: CartPaymentPurchaseOrder;
    /**
    * Rotating transaction gateway code
    */
    'rtgCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affirm",
            "baseName": "affirm",
            "type": "CartPaymentAffirm"
        },
        {
            "name": "amazon",
            "baseName": "amazon",
            "type": "CartPaymentAmazon"
        },
        {
            "name": "check",
            "baseName": "check",
            "type": "CartPaymentCheck"
        },
        {
            "name": "creditCard",
            "baseName": "credit_card",
            "type": "CartPaymentCreditCard"
        },
        {
            "name": "paymentMethod",
            "baseName": "payment_method",
            "type": "string"
        },
        {
            "name": "purchaseOrder",
            "baseName": "purchase_order",
            "type": "CartPaymentPurchaseOrder"
        },
        {
            "name": "rtgCode",
            "baseName": "rtg_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartPayment.attributeTypeMap;
    }
}

export class CartPaymentAffirm {
    /**
    * Affirm checkout token
    */
    'affirmCheckoutToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affirmCheckoutToken",
            "baseName": "affirm_checkout_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartPaymentAffirm.attributeTypeMap;
    }
}

export class CartPaymentAmazon {
    /**
    * Amazon order reference id
    */
    'amazonOrderReferenceId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amazonOrderReferenceId",
            "baseName": "amazon_order_reference_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartPaymentAmazon.attributeTypeMap;
    }
}

export class CartPaymentCheck {
    /**
    * Check number they are paying with
    */
    'checkNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "checkNumber",
            "baseName": "check_number",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CartPaymentCheck.attributeTypeMap;
    }
}

export class CartPaymentCreditCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth'?: number;
    /**
    * Card expiration year (four digit year)
    */
    'cardExpirationYear'?: number;
    /**
    * Card number (masked to the last 4)
    */
    'cardNumber'?: string;
    /**
    * Hosted field token for the card number
    */
    'cardNumberToken'?: string;
    /**
    * Card type
    */
    'cardType'?: string;
    /**
    * Card verification number (masked)
    */
    'cardVerificationNumber'?: string;
    /**
    * Hosted field token for the card verification number
    */
    'cardVerificationNumberToken'?: string;
    /**
    * ID of the stored credit card to use
    */
    'customerProfileCreditCardId'?: number;
    /**
    * True if the customer wants to store the card on their profile for future re-use
    */
    'storeCreditCard'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardExpirationMonth",
            "baseName": "card_expiration_month",
            "type": "number"
        },
        {
            "name": "cardExpirationYear",
            "baseName": "card_expiration_year",
            "type": "number"
        },
        {
            "name": "cardNumber",
            "baseName": "card_number",
            "type": "string"
        },
        {
            "name": "cardNumberToken",
            "baseName": "card_number_token",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "card_type",
            "type": "string"
        },
        {
            "name": "cardVerificationNumber",
            "baseName": "card_verification_number",
            "type": "string"
        },
        {
            "name": "cardVerificationNumberToken",
            "baseName": "card_verification_number_token",
            "type": "string"
        },
        {
            "name": "customerProfileCreditCardId",
            "baseName": "customer_profile_credit_card_id",
            "type": "number"
        },
        {
            "name": "storeCreditCard",
            "baseName": "store_credit_card",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CartPaymentCreditCard.attributeTypeMap;
    }
}

export class CartPaymentPurchaseOrder {
    /**
    * Purchase order number
    */
    'purchaseOrderNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseOrderNumber",
            "baseName": "purchase_order_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartPaymentPurchaseOrder.attributeTypeMap;
    }
}

export class CartProfileLoginRequest {
    'cart'?: Cart;
    /**
    * Unique identifier for customer profile.  Can not be used with browser key authentication type.
    */
    'customerProfileOid'?: number;
    /**
    * Password for the profile
    */
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartProfileLoginRequest.attributeTypeMap;
    }
}

export class CartProfileLoginResponse {
    'cart'?: Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CartProfileLoginResponse.attributeTypeMap;
    }
}

export class CartProfileRegisterRequest {
    'cart'?: Cart;
    /**
    * Password for the profile
    */
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartProfileRegisterRequest.attributeTypeMap;
    }
}

export class CartProfileRegisterResponse {
    'cart'?: Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CartProfileRegisterResponse.attributeTypeMap;
    }
}

export class CartProperty {
    /**
    * True if this property is displayed to the customer
    */
    'display'?: boolean;
    /**
    * The date/time that the property expires and is deleted
    */
    'expirationDts'?: string;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "display",
            "baseName": "display",
            "type": "boolean"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartProperty.attributeTypeMap;
    }
}

export class CartResponse {
    'cart'?: Cart;
    /**
    * Errors that should be displayed to the customer
    */
    'errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CartResponse.attributeTypeMap;
    }
}

export class CartSettings {
    'billing'?: CartSettingsBilling;
    'gift'?: CartSettingsGift;
    'payment'?: CartSettingsPayment;
    'shipping'?: CartSettingsShipping;
    'taxes'?: CartSettingsTaxes;
    'terms'?: CartSettingsTerms;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billing",
            "baseName": "billing",
            "type": "CartSettingsBilling"
        },
        {
            "name": "gift",
            "baseName": "gift",
            "type": "CartSettingsGift"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "CartSettingsPayment"
        },
        {
            "name": "shipping",
            "baseName": "shipping",
            "type": "CartSettingsShipping"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "CartSettingsTaxes"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "CartSettingsTerms"
        }    ];

    static getAttributeTypeMap() {
        return CartSettings.attributeTypeMap;
    }
}

export class CartSettingsBilling {
    /**
    * Provinces
    */
    'provinces'?: Array<CartSettingsProvince>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "provinces",
            "baseName": "provinces",
            "type": "Array<CartSettingsProvince>"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsBilling.attributeTypeMap;
    }
}

export class CartSettingsGift {
    /**
    * True if this checkout supports gift giving
    */
    'allowGifts'?: boolean;
    'giftCharge'?: Currency;
    /**
    * The gift wraps available for the customer to select from
    */
    'giftWraps'?: Array<CartSettingsGiftWrap>;
    /**
    * The maximum length of the gift message the giver can enter
    */
    'maxMessageLength'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowGifts",
            "baseName": "allow_gifts",
            "type": "boolean"
        },
        {
            "name": "giftCharge",
            "baseName": "gift_charge",
            "type": "Currency"
        },
        {
            "name": "giftWraps",
            "baseName": "gift_wraps",
            "type": "Array<CartSettingsGiftWrap>"
        },
        {
            "name": "maxMessageLength",
            "baseName": "max_message_length",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsGift.attributeTypeMap;
    }
}

export class CartSettingsGiftWrap {
    'cost'?: Currency;
    /**
    * Title of the gift wrap
    */
    'title'?: string;
    /**
    * URL for the sample of the gift wrap
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cost",
            "baseName": "cost",
            "type": "Currency"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsGiftWrap.attributeTypeMap;
    }
}

export class CartSettingsPayment {
    'amazon'?: CartSettingsPaymentAmazon;
    'creditCard'?: CartSettingsPaymentCreditCard;
    /**
    * True if this card requires a payment from the customer
    */
    'needPayment'?: boolean;
    'paypal'?: CartSettingsPaymentPayPal;
    /**
    * True if Amazon payments are available on this order
    */
    'supportsAmazon'?: boolean;
    /**
    * True if check payments are available on this order
    */
    'supportsCheck'?: boolean;
    /**
    * True if COD payments are available on this order
    */
    'supportsCod'?: boolean;
    /**
    * True if credit card payments are available on this order
    */
    'supportsCreditCard'?: boolean;
    /**
    * True if money order payments are available on this order
    */
    'supportsMoneyOrder'?: boolean;
    /**
    * True if PayPal payments are available on this order
    */
    'supportsPaypal'?: boolean;
    /**
    * True if purchase order payments are available on this order
    */
    'supportsPurchaseOrder'?: boolean;
    /**
    * True if quote requests payments are available on this order
    */
    'supportsQuoteRequest'?: boolean;
    /**
    * True if wire transfer payments are available on this order
    */
    'supportsWireTransfer'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amazon",
            "baseName": "amazon",
            "type": "CartSettingsPaymentAmazon"
        },
        {
            "name": "creditCard",
            "baseName": "credit_card",
            "type": "CartSettingsPaymentCreditCard"
        },
        {
            "name": "needPayment",
            "baseName": "need_payment",
            "type": "boolean"
        },
        {
            "name": "paypal",
            "baseName": "paypal",
            "type": "CartSettingsPaymentPayPal"
        },
        {
            "name": "supportsAmazon",
            "baseName": "supports_amazon",
            "type": "boolean"
        },
        {
            "name": "supportsCheck",
            "baseName": "supports_check",
            "type": "boolean"
        },
        {
            "name": "supportsCod",
            "baseName": "supports_cod",
            "type": "boolean"
        },
        {
            "name": "supportsCreditCard",
            "baseName": "supports_credit_card",
            "type": "boolean"
        },
        {
            "name": "supportsMoneyOrder",
            "baseName": "supports_money_order",
            "type": "boolean"
        },
        {
            "name": "supportsPaypal",
            "baseName": "supports_paypal",
            "type": "boolean"
        },
        {
            "name": "supportsPurchaseOrder",
            "baseName": "supports_purchase_order",
            "type": "boolean"
        },
        {
            "name": "supportsQuoteRequest",
            "baseName": "supports_quote_request",
            "type": "boolean"
        },
        {
            "name": "supportsWireTransfer",
            "baseName": "supports_wire_transfer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsPayment.attributeTypeMap;
    }
}

export class CartSettingsPaymentAmazon {
    /**
    * Amazon button URL
    */
    'amazonButtonUrl'?: string;
    /**
    * Amazon merchant ID
    */
    'amazonMerchantId'?: string;
    /**
    * Amazon widget URL
    */
    'amazonWidgetUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amazonButtonUrl",
            "baseName": "amazon_button_url",
            "type": "string"
        },
        {
            "name": "amazonMerchantId",
            "baseName": "amazon_merchant_id",
            "type": "string"
        },
        {
            "name": "amazonWidgetUrl",
            "baseName": "amazon_widget_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsPaymentAmazon.attributeTypeMap;
    }
}

export class CartSettingsPaymentCreditCard {
    /**
    * True if the credit card verification number should be collected
    */
    'collectCreditCardVerificationNumber'?: boolean;
    /**
    * Available credit card types
    */
    'creditCardTypes'?: Array<string>;
    /**
    * The shoppingCartToken needed for proper initialization of hosted fields collection
    */
    'hostedFieldsShoppingCartToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "collectCreditCardVerificationNumber",
            "baseName": "collect_credit_card_verification_number",
            "type": "boolean"
        },
        {
            "name": "creditCardTypes",
            "baseName": "credit_card_types",
            "type": "Array<string>"
        },
        {
            "name": "hostedFieldsShoppingCartToken",
            "baseName": "hosted_fields_shopping_cart_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsPaymentCreditCard.attributeTypeMap;
    }
}

export class CartSettingsPaymentPayPal {
    /**
    * PayPal button alt text
    */
    'paypalButtonAltText'?: string;
    /**
    * PayPal button URL
    */
    'paypalButtonUrl'?: string;
    /**
    * PayPal Credit button URL
    */
    'paypalCreditButtonUrl'?: string;
    /**
    * PayPal Credit legal image URL
    */
    'paypalCreditLegalImageUrl'?: string;
    /**
    * PayPal Credit legal URL
    */
    'paypalCreditLegalUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paypalButtonAltText",
            "baseName": "paypal_button_alt_text",
            "type": "string"
        },
        {
            "name": "paypalButtonUrl",
            "baseName": "paypal_button_url",
            "type": "string"
        },
        {
            "name": "paypalCreditButtonUrl",
            "baseName": "paypal_credit_button_url",
            "type": "string"
        },
        {
            "name": "paypalCreditLegalImageUrl",
            "baseName": "paypal_credit_legal_image_url",
            "type": "string"
        },
        {
            "name": "paypalCreditLegalUrl",
            "baseName": "paypal_credit_legal_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsPaymentPayPal.attributeTypeMap;
    }
}

export class CartSettingsProvince {
    'code'?: string;
    'province'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "province",
            "baseName": "province",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsProvince.attributeTypeMap;
    }
}

export class CartSettingsShipping {
    'deliverOnDate'?: CartSettingsShippingCalendar;
    /**
    * Estimates for this cart
    */
    'estimates'?: Array<CartSettingsShippingEstimate>;
    /**
    * True if this order needs shipping
    */
    'needShipping'?: boolean;
    /**
    * Provinces
    */
    'provinces'?: Array<CartSettingsProvince>;
    'shipOnDate'?: CartSettingsShippingCalendar;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deliverOnDate",
            "baseName": "deliver_on_date",
            "type": "CartSettingsShippingCalendar"
        },
        {
            "name": "estimates",
            "baseName": "estimates",
            "type": "Array<CartSettingsShippingEstimate>"
        },
        {
            "name": "needShipping",
            "baseName": "need_shipping",
            "type": "boolean"
        },
        {
            "name": "provinces",
            "baseName": "provinces",
            "type": "Array<CartSettingsProvince>"
        },
        {
            "name": "shipOnDate",
            "baseName": "ship_on_date",
            "type": "CartSettingsShippingCalendar"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsShipping.attributeTypeMap;
    }
}

export class CartSettingsShippingCalendar {
    /**
    * Specified dates that are blacked out on the calendar in ISO8601 format
    */
    'blackouts'?: Array<string>;
    /**
    * Days of week that should be enabled on the calendar (0 - Sunday through 6 - Saturday)
    */
    'daysOfWeek'?: Array<boolean>;
    /**
    * The earliest date that can be selected on the calendar
    */
    'earliest'?: string;
    /**
    * True if the customer is required to select a date
    */
    'require'?: boolean;
    /**
    * True if this calendar should be shown to the customer
    */
    'show'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "blackouts",
            "baseName": "blackouts",
            "type": "Array<string>"
        },
        {
            "name": "daysOfWeek",
            "baseName": "days_of_week",
            "type": "Array<boolean>"
        },
        {
            "name": "earliest",
            "baseName": "earliest",
            "type": "string"
        },
        {
            "name": "require",
            "baseName": "require",
            "type": "boolean"
        },
        {
            "name": "show",
            "baseName": "show",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsShippingCalendar.attributeTypeMap;
    }
}

export class CartSettingsShippingEstimate {
    /**
    * True if this method allows the customer to use their own shipper account number
    */
    'allow3rdPartyBilling'?: boolean;
    /**
    * Comment to display to the customer about this method
    */
    'comment'?: string;
    'cost'?: Currency;
    'costBeforeDiscount'?: Currency;
    /**
    * True if this is the default method
    */
    'defaultMethod'?: boolean;
    'discount'?: Currency;
    /**
    * True if this method is discounted because of a coupon
    */
    'discounted'?: boolean;
    /**
    * The name to display to the customer
    */
    'displayName'?: string;
    /**
    * Date of the estimated delivery (or range)
    */
    'estimatedDelivery'?: string;
    /**
    * True if a lift gate option for this method should be offered to the customer
    */
    'liftGateOption'?: boolean;
    /**
    * Shipping method name
    */
    'name'?: string;
    'tax'?: Currency;
    'totalTax'?: Currency;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allow3rdPartyBilling",
            "baseName": "allow_3rd_party_billing",
            "type": "boolean"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "cost",
            "baseName": "cost",
            "type": "Currency"
        },
        {
            "name": "costBeforeDiscount",
            "baseName": "cost_before_discount",
            "type": "Currency"
        },
        {
            "name": "defaultMethod",
            "baseName": "default_method",
            "type": "boolean"
        },
        {
            "name": "discount",
            "baseName": "discount",
            "type": "Currency"
        },
        {
            "name": "discounted",
            "baseName": "discounted",
            "type": "boolean"
        },
        {
            "name": "displayName",
            "baseName": "display_name",
            "type": "string"
        },
        {
            "name": "estimatedDelivery",
            "baseName": "estimated_delivery",
            "type": "string"
        },
        {
            "name": "liftGateOption",
            "baseName": "lift_gate_option",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "Currency"
        },
        {
            "name": "totalTax",
            "baseName": "total_tax",
            "type": "Currency"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsShippingEstimate.attributeTypeMap;
    }
}

export class CartSettingsTaxes {
    'counties'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "counties",
            "baseName": "counties",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsTaxes.attributeTypeMap;
    }
}

export class CartSettingsTerms {
    /**
    * HTML version of the terms
    */
    'html'?: string;
    /**
    * Text version of the terms.
    */
    'text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartSettingsTerms.attributeTypeMap;
    }
}

export class CartShipping {
    /**
    * Address line 1
    */
    'address1'?: string;
    /**
    * Address line 2
    */
    'address2'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Day time phone
    */
    'dayPhone'?: string;
    /**
    * Date the customer is requesting delivery on. Typically used for perishable product delivery.
    */
    'deliveryDate'?: string;
    /**
    * Evening phone
    */
    'eveningPhone'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Lift gate requested (LTL shipping methods only)
    */
    'liftGate'?: boolean;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
    */
    'shipOnDate'?: string;
    /**
    * True if the shipping adress is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
    */
    'shipToResidential'?: boolean;
    /**
    * 3rd party account number to ship against for UPS or FedEx
    */
    'shipping3rdPartyAccountNumber'?: string;
    /**
    * Shipping method
    */
    'shippingMethod'?: string;
    /**
    * Special instructions from the customer regarding shipping
    */
    'specialInstructions'?: string;
    /**
    * State/Region
    */
    'stateRegion'?: string;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "dayPhone",
            "baseName": "day_phone",
            "type": "string"
        },
        {
            "name": "deliveryDate",
            "baseName": "delivery_date",
            "type": "string"
        },
        {
            "name": "eveningPhone",
            "baseName": "evening_phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "liftGate",
            "baseName": "lift_gate",
            "type": "boolean"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "shipOnDate",
            "baseName": "ship_on_date",
            "type": "string"
        },
        {
            "name": "shipToResidential",
            "baseName": "ship_to_residential",
            "type": "boolean"
        },
        {
            "name": "shipping3rdPartyAccountNumber",
            "baseName": "shipping_3rd_party_account_number",
            "type": "string"
        },
        {
            "name": "shippingMethod",
            "baseName": "shipping_method",
            "type": "string"
        },
        {
            "name": "specialInstructions",
            "baseName": "special_instructions",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartShipping.attributeTypeMap;
    }
}

export class CartSummary {
    'arbitraryShippingHandlingTotal'?: Currency;
    'arbitraryTax'?: Currency;
    'arbitraryTaxRate'?: Currency;
    'arbitraryTaxableSubtotal'?: Currency;
    'shippingHandling'?: Currency;
    'shippingHandlingDiscount'?: Currency;
    'shippingHandlingWithDiscount'?: Currency;
    'subtotal'?: Currency;
    'subtotalDiscount'?: Currency;
    'subtotalWithDiscount'?: Currency;
    'surcharge'?: Currency;
    'tax'?: Currency;
    'taxableSubtotal'?: Currency;
    'taxableSubtotalDiscount'?: Currency;
    'taxableSubtotalWithDiscount'?: Currency;
    'total'?: Currency;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "arbitraryShippingHandlingTotal",
            "baseName": "arbitrary_shipping_handling_total",
            "type": "Currency"
        },
        {
            "name": "arbitraryTax",
            "baseName": "arbitrary_tax",
            "type": "Currency"
        },
        {
            "name": "arbitraryTaxRate",
            "baseName": "arbitrary_tax_rate",
            "type": "Currency"
        },
        {
            "name": "arbitraryTaxableSubtotal",
            "baseName": "arbitrary_taxable_subtotal",
            "type": "Currency"
        },
        {
            "name": "shippingHandling",
            "baseName": "shipping_handling",
            "type": "Currency"
        },
        {
            "name": "shippingHandlingDiscount",
            "baseName": "shipping_handling_discount",
            "type": "Currency"
        },
        {
            "name": "shippingHandlingWithDiscount",
            "baseName": "shipping_handling_with_discount",
            "type": "Currency"
        },
        {
            "name": "subtotal",
            "baseName": "subtotal",
            "type": "Currency"
        },
        {
            "name": "subtotalDiscount",
            "baseName": "subtotal_discount",
            "type": "Currency"
        },
        {
            "name": "subtotalWithDiscount",
            "baseName": "subtotal_with_discount",
            "type": "Currency"
        },
        {
            "name": "surcharge",
            "baseName": "surcharge",
            "type": "Currency"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "Currency"
        },
        {
            "name": "taxableSubtotal",
            "baseName": "taxable_subtotal",
            "type": "Currency"
        },
        {
            "name": "taxableSubtotalDiscount",
            "baseName": "taxable_subtotal_discount",
            "type": "Currency"
        },
        {
            "name": "taxableSubtotalWithDiscount",
            "baseName": "taxable_subtotal_with_discount",
            "type": "Currency"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Currency"
        }    ];

    static getAttributeTypeMap() {
        return CartSummary.attributeTypeMap;
    }
}

export class CartTaxes {
    /**
    * Tax county if the state requires it.
    */
    'county'?: string;
    /**
    * True if tax exempt
    */
    'exempt'?: boolean;
    /**
    * Tax rate
    */
    'rate'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "exempt",
            "baseName": "exempt",
            "type": "boolean"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CartTaxes.attributeTypeMap;
    }
}

export class CartUpsellAfter {
    /**
    * The date/time after which the cart will finalize into an order.
    */
    'finalizeAfterDts'?: string;
    /**
    * The amount of inactivity in minutes after which the cart should be finalized into an order.  This will calculate the finalize_after_dts field.
    */
    'finalizeAfterMinutes'?: number;
    /**
    * Upsell path code
    */
    'upsellPathCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "finalizeAfterDts",
            "baseName": "finalize_after_dts",
            "type": "string"
        },
        {
            "name": "finalizeAfterMinutes",
            "baseName": "finalize_after_minutes",
            "type": "number"
        },
        {
            "name": "upsellPathCode",
            "baseName": "upsell_path_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CartUpsellAfter.attributeTypeMap;
    }
}

export class CartValidationRequest {
    'cart'?: Cart;
    /**
    * Checks to perform
    */
    'checks'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "checks",
            "baseName": "checks",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CartValidationRequest.attributeTypeMap;
    }
}

export class CartValidationResponse {
    'cart'?: Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CartValidationResponse.attributeTypeMap;
    }
}

export class ChargebackDispute {
    /**
    * Account number
    */
    'accountNumber'?: string;
    /**
    * Adjustment request text
    */
    'adjustmentRequestText'?: string;
    /**
    * Amount
    */
    'amount'?: number;
    /**
    * Auth code
    */
    'authCode'?: string;
    /**
    * Case number
    */
    'caseNumber'?: string;
    /**
    * Chargeback Dispute Oid
    */
    'chargebackDisputeOid'?: number;
    /**
    * Chargeback dts
    */
    'chargebackDts'?: string;
    /**
    * Currency
    */
    'currency'?: string;
    /**
    * Customer care notes
    */
    'customerCareNotes'?: string;
    /**
    * Encryption key
    */
    'encryptionKey'?: string;
    /**
    * Expiration Dts
    */
    'expirationDts'?: string;
    /**
    * Fax failure reason
    */
    'faxFailureReason'?: string;
    /**
    * Fax number
    */
    'faxNumber'?: string;
    /**
    * Fax transaction id
    */
    'faxTransactionId'?: number;
    /**
    * icsid
    */
    'icsid'?: string;
    /**
    * Merchant account profile oid
    */
    'merchantAccountProfileOid'?: number;
    'order'?: Order;
    /**
    * Order Id
    */
    'orderId'?: string;
    /**
    * Partial card number
    */
    'partialCardNumber'?: string;
    /**
    * PDF file oid
    */
    'pdfFileOid'?: string;
    /**
    * Reason code
    */
    'reasonCode'?: string;
    /**
    * Status
    */
    'status'?: string;
    /**
    * Website URL
    */
    'websiteUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountNumber",
            "baseName": "account_number",
            "type": "string"
        },
        {
            "name": "adjustmentRequestText",
            "baseName": "adjustment_request_text",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "authCode",
            "baseName": "auth_code",
            "type": "string"
        },
        {
            "name": "caseNumber",
            "baseName": "case_number",
            "type": "string"
        },
        {
            "name": "chargebackDisputeOid",
            "baseName": "chargeback_dispute_oid",
            "type": "number"
        },
        {
            "name": "chargebackDts",
            "baseName": "chargeback_dts",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "customerCareNotes",
            "baseName": "customer_care_notes",
            "type": "string"
        },
        {
            "name": "encryptionKey",
            "baseName": "encryption_key",
            "type": "string"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "faxFailureReason",
            "baseName": "fax_failure_reason",
            "type": "string"
        },
        {
            "name": "faxNumber",
            "baseName": "fax_number",
            "type": "string"
        },
        {
            "name": "faxTransactionId",
            "baseName": "fax_transaction_id",
            "type": "number"
        },
        {
            "name": "icsid",
            "baseName": "icsid",
            "type": "string"
        },
        {
            "name": "merchantAccountProfileOid",
            "baseName": "merchant_account_profile_oid",
            "type": "number"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "partialCardNumber",
            "baseName": "partial_card_number",
            "type": "string"
        },
        {
            "name": "pdfFileOid",
            "baseName": "pdf_file_oid",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reason_code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "websiteUrl",
            "baseName": "website_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChargebackDispute.attributeTypeMap;
    }
}

export class ChargebackDisputeResponse {
    'chargeback'?: ChargebackDispute;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "chargeback",
            "baseName": "chargeback",
            "type": "ChargebackDispute"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ChargebackDisputeResponse.attributeTypeMap;
    }
}

export class ChargebackDisputesResponse {
    'chargebacks'?: Array<ChargebackDispute>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "chargebacks",
            "baseName": "chargebacks",
            "type": "Array<ChargebackDispute>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ChargebackDisputesResponse.attributeTypeMap;
    }
}

export class CheckoutAllowedCountriesResponse {
    'countries'?: Array<Country>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countries",
            "baseName": "countries",
            "type": "Array<Country>"
        }    ];

    static getAttributeTypeMap() {
        return CheckoutAllowedCountriesResponse.attributeTypeMap;
    }
}

export class CheckoutHandoffRequest {
    'cart'?: Cart;
    /**
    * If any error happen during the processing on the UltraCart side, the browser will be redirected to your error_return_url with the error passed in this parameter name.
    */
    'errorParameterName'?: string;
    /**
    * The URL to return the browser to if there are processing errors on the UltraCart side.
    */
    'errorReturnUrl'?: string;
    /**
    * The type of handoff operation to perform
    */
    'operation'?: CheckoutHandoffRequest.OperationEnum;
    /**
    * The maximum amount of revenue that you think the customer could add during a custom upsell after sequence on your checkout.
    */
    'paypalMaximumUpsellRevenue'?: number;
    /**
    * The URl to return the customers browser to after they have completed the PayPal process.
    */
    'paypalReturnUrl'?: string;
    /**
    * The desired secure host name to perform the handoff on.  This should match the desired StoreFront.
    */
    'secureHostName'?: string;
    /**
    * The UltraCart Analytics cookie value.  Populate this if you're handing off from a different domain than the checkout.
    */
    'ucacid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "errorParameterName",
            "baseName": "error_parameter_name",
            "type": "string"
        },
        {
            "name": "errorReturnUrl",
            "baseName": "error_return_url",
            "type": "string"
        },
        {
            "name": "operation",
            "baseName": "operation",
            "type": "CheckoutHandoffRequest.OperationEnum"
        },
        {
            "name": "paypalMaximumUpsellRevenue",
            "baseName": "paypal_maximum_upsell_revenue",
            "type": "number"
        },
        {
            "name": "paypalReturnUrl",
            "baseName": "paypal_return_url",
            "type": "string"
        },
        {
            "name": "secureHostName",
            "baseName": "secure_host_name",
            "type": "string"
        },
        {
            "name": "ucacid",
            "baseName": "ucacid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CheckoutHandoffRequest.attributeTypeMap;
    }
}

export namespace CheckoutHandoffRequest {
    export enum OperationEnum {
        Checkout = <any> 'checkout',
        PayPal = <any> 'payPal',
        PayPalCredit = <any> 'payPalCredit',
        View = <any> 'view',
        Affirm = <any> 'affirm'
    }
}
export class CheckoutHandoffResponse {
    'cart'?: Cart;
    /**
    * Errors that occurred which are preventing the handoff operation.  Display these to the customer.
    */
    'errors'?: Array<string>;
    /**
    * The URL that you should redirect the customers browser to
    */
    'redirectToUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cart",
            "baseName": "cart",
            "type": "Cart"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<string>"
        },
        {
            "name": "redirectToUrl",
            "baseName": "redirect_to_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CheckoutHandoffResponse.attributeTypeMap;
    }
}

export class CheckoutSetupBrowserKeyRequest {
    /**
    * Allowed referrers.  If URLs are specified, automatic translation will convert them to proper allowed referrer maskes.
    */
    'allowedReferrers'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowedReferrers",
            "baseName": "allowed_referrers",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CheckoutSetupBrowserKeyRequest.attributeTypeMap;
    }
}

export class CheckoutSetupBrowserKeyResponse {
    /**
    * Browser key that is used to authenticate against the new linked application.
    */
    'browserKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "browserKey",
            "baseName": "browser_key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CheckoutSetupBrowserKeyResponse.attributeTypeMap;
    }
}

export class CheckoutStateProvinceResponse {
    'stateProvinces'?: Array<StateProvince>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stateProvinces",
            "baseName": "stateProvinces",
            "type": "Array<StateProvince>"
        }    ];

    static getAttributeTypeMap() {
        return CheckoutStateProvinceResponse.attributeTypeMap;
    }
}

export class CityStateZip {
    'city'?: string;
    'error'?: string;
    'state'?: string;
    'validZip'?: boolean;
    'zip'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "validZip",
            "baseName": "validZip",
            "type": "boolean"
        },
        {
            "name": "zip",
            "baseName": "zip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CityStateZip.attributeTypeMap;
    }
}

export class CountriesResponse {
    'countries'?: Array<Country>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countries",
            "baseName": "countries",
            "type": "Array<Country>"
        }    ];

    static getAttributeTypeMap() {
        return CountriesResponse.attributeTypeMap;
    }
}

export class Country {
    /**
    * iso_2_code
    */
    'iso2Code'?: string;
    /**
    * name
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "iso2Code",
            "baseName": "iso_2_code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Country.attributeTypeMap;
    }
}

export class Coupon {
    /**
    * Associates an order with an affiliate when this value is set.
    */
    'affiliateOid'?: number;
    /**
    * True if multiple one time codes for this coupon can be used on a cart at the same time.
    */
    'allowMultipleOneTimeCodes'?: boolean;
    'amountOffItems'?: CouponAmountOffItems;
    'amountOffShipping'?: CouponAmountOffShipping;
    'amountOffShippingWithItemsPurchase'?: CouponAmountOffShippingWithItemsPurchase;
    'amountOffSubtotal'?: CouponAmountOffSubtotal;
    'amountOffSubtotalAndFreeShipping'?: CouponAmountOffSubtotalFreeShippingWithPurchase;
    'amountOffSubtotalAndShipping'?: CouponAmountOffSubtotalAndShipping;
    'amountOffSubtotalWithBlockPurchase'?: CouponAmountOffSubtotalWithBlockPurchase;
    'amountOffSubtotalWithItemsPurchase'?: CouponAmountOffSubtotalWithItemsPurchase;
    'automaticallyApplyCouponCodes'?: CouponAutomaticallyApplyCouponCodes;
    /**
    * Calculated description displayed to the customer if no description is specified.
    */
    'calculatedDescription'?: string;
    /**
    * True if this coupon can be used with other coupons in a single order.
    */
    'canBeUsedWithOtherCoupons'?: boolean;
    /**
    * Coupon oid.
    */
    'couponOid'?: number;
    /**
    * Coupon type.
    */
    'couponType'?: string;
    /**
    * Description of the coupon up to 50 characters.
    */
    'description'?: string;
    'discountItemWithItemPurchase'?: CouponDiscountItemWithItemPurchase;
    'discountItems'?: CouponDiscountItems;
    /**
    * Date/time when coupon expires
    */
    'expirationDts'?: string;
    'freeItemAndShippingWithSubtotal'?: CouponFreeItemAndShippingWithSubtotal;
    'freeItemWithItemPurchase'?: CouponFreeItemWithItemPurchase;
    'freeItemWithSubtotal'?: CouponFreeItemWithSubtotal;
    'freeItemsWithItemPurchase'?: CouponFreeItemsWithItemPurchase;
    'freeItemsWithMixmatchPurchase'?: CouponFreeItemsWithMixMatchPurchase;
    'freeShipping'?: CouponFreeShipping;
    'freeShippingSpecificItems'?: CouponFreeShippingSpecificItems;
    'freeShippingWithItemsPurchase'?: CouponFreeShippingWithItemsPurchase;
    'freeShippingWithSubtotal'?: CouponFreeShippingWithSubtotal;
    /**
    * Merchant code of coupon up to 20 characters.
    */
    'merchantCode'?: string;
    /**
    * Internal notes about this coupon.  These are not visible to customer.
    */
    'merchantNotes'?: string;
    'multipleAmountsOffItems'?: CouponMultipleAmountsOffItems;
    'noDiscount'?: CouponNoDiscount;
    'percentOffItemWithItemsQuantityPurchase'?: CouponPercentOffItemWithItemsQuantityPurchase;
    'percentOffItems'?: CouponPercentOffItems;
    'percentOffItemsAndFreeShipping'?: CouponPercentOffItemsAndFreeShipping;
    'percentOffItemsWithItemsPurchase'?: CouponPercentOffItemsWithItemsPurchase;
    'percentOffRetailPriceItems'?: CouponPercentOffRetailPriceItems;
    'percentOffShipping'?: CouponPercentOffShipping;
    'percentOffSubtotal'?: CouponPercentOffSubtotal;
    'percentOffSubtotalAndFreeShipping'?: CouponPercentOffSubtotalAndFreeShipping;
    'percentOffSubtotalLimit'?: CouponPercentOffSubtotalLimit;
    'percentOffSubtotalWithItemsPurchase'?: CouponPercentOffSubtotalWithItemsPurchase;
    'percentOffSubtotalWithSubtotal'?: CouponPercentOffSubtotalWithSubtotal;
    /**
    * Quickbooks accounting code.
    */
    'quickbooksCode'?: string;
    /**
    * Optional list of postal codes which restrict a coupon to within these postal codes.
    */
    'restrictByPostalCodes'?: Array<string>;
    /**
    * Optional list of legacy screen branding theme codes to limit coupon use to only those themes.
    */
    'restrictByScreenBrandingThemeCodes'?: Array<CouponRestriction>;
    /**
    * Optional list of storefronts to limit coupon use to only those storefronts.
    */
    'restrictByStorefronts'?: Array<CouponRestriction>;
    /**
    * Date/time when coupon is valid
    */
    'startDts'?: string;
    'tieredAmountOffItem'?: CouponTieredAmountOffItem;
    'tieredAmountOffSubtotal'?: CouponTieredAmountOffSubtotal;
    'tieredPercentOffItems'?: CouponTieredPercentOffItems;
    'tieredPercentOffShipping'?: CouponTieredPercentOffShipping;
    'tieredPercentOffSubtotal'?: CouponTieredPercentOffSubtotal;
    /**
    * Who may use this coupon.
    */
    'usableBy'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "allowMultipleOneTimeCodes",
            "baseName": "allow_multiple_one_time_codes",
            "type": "boolean"
        },
        {
            "name": "amountOffItems",
            "baseName": "amount_off_items",
            "type": "CouponAmountOffItems"
        },
        {
            "name": "amountOffShipping",
            "baseName": "amount_off_shipping",
            "type": "CouponAmountOffShipping"
        },
        {
            "name": "amountOffShippingWithItemsPurchase",
            "baseName": "amount_off_shipping_with_items_purchase",
            "type": "CouponAmountOffShippingWithItemsPurchase"
        },
        {
            "name": "amountOffSubtotal",
            "baseName": "amount_off_subtotal",
            "type": "CouponAmountOffSubtotal"
        },
        {
            "name": "amountOffSubtotalAndFreeShipping",
            "baseName": "amount_off_subtotal_and_free_shipping",
            "type": "CouponAmountOffSubtotalFreeShippingWithPurchase"
        },
        {
            "name": "amountOffSubtotalAndShipping",
            "baseName": "amount_off_subtotal_and_shipping",
            "type": "CouponAmountOffSubtotalAndShipping"
        },
        {
            "name": "amountOffSubtotalWithBlockPurchase",
            "baseName": "amount_off_subtotal_with_block_purchase",
            "type": "CouponAmountOffSubtotalWithBlockPurchase"
        },
        {
            "name": "amountOffSubtotalWithItemsPurchase",
            "baseName": "amount_off_subtotal_with_items_purchase",
            "type": "CouponAmountOffSubtotalWithItemsPurchase"
        },
        {
            "name": "automaticallyApplyCouponCodes",
            "baseName": "automatically_apply_coupon_codes",
            "type": "CouponAutomaticallyApplyCouponCodes"
        },
        {
            "name": "calculatedDescription",
            "baseName": "calculated_description",
            "type": "string"
        },
        {
            "name": "canBeUsedWithOtherCoupons",
            "baseName": "can_be_used_with_other_coupons",
            "type": "boolean"
        },
        {
            "name": "couponOid",
            "baseName": "coupon_oid",
            "type": "number"
        },
        {
            "name": "couponType",
            "baseName": "coupon_type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discountItemWithItemPurchase",
            "baseName": "discount_item_with_item_purchase",
            "type": "CouponDiscountItemWithItemPurchase"
        },
        {
            "name": "discountItems",
            "baseName": "discount_items",
            "type": "CouponDiscountItems"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "freeItemAndShippingWithSubtotal",
            "baseName": "free_item_and_shipping_with_subtotal",
            "type": "CouponFreeItemAndShippingWithSubtotal"
        },
        {
            "name": "freeItemWithItemPurchase",
            "baseName": "free_item_with_item_purchase",
            "type": "CouponFreeItemWithItemPurchase"
        },
        {
            "name": "freeItemWithSubtotal",
            "baseName": "free_item_with_subtotal",
            "type": "CouponFreeItemWithSubtotal"
        },
        {
            "name": "freeItemsWithItemPurchase",
            "baseName": "free_items_with_item_purchase",
            "type": "CouponFreeItemsWithItemPurchase"
        },
        {
            "name": "freeItemsWithMixmatchPurchase",
            "baseName": "free_items_with_mixmatch_purchase",
            "type": "CouponFreeItemsWithMixMatchPurchase"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "CouponFreeShipping"
        },
        {
            "name": "freeShippingSpecificItems",
            "baseName": "free_shipping_specific_items",
            "type": "CouponFreeShippingSpecificItems"
        },
        {
            "name": "freeShippingWithItemsPurchase",
            "baseName": "free_shipping_with_items_purchase",
            "type": "CouponFreeShippingWithItemsPurchase"
        },
        {
            "name": "freeShippingWithSubtotal",
            "baseName": "free_shipping_with_subtotal",
            "type": "CouponFreeShippingWithSubtotal"
        },
        {
            "name": "merchantCode",
            "baseName": "merchant_code",
            "type": "string"
        },
        {
            "name": "merchantNotes",
            "baseName": "merchant_notes",
            "type": "string"
        },
        {
            "name": "multipleAmountsOffItems",
            "baseName": "multiple_amounts_off_items",
            "type": "CouponMultipleAmountsOffItems"
        },
        {
            "name": "noDiscount",
            "baseName": "no_discount",
            "type": "CouponNoDiscount"
        },
        {
            "name": "percentOffItemWithItemsQuantityPurchase",
            "baseName": "percent_off_item_with_items_quantity_purchase",
            "type": "CouponPercentOffItemWithItemsQuantityPurchase"
        },
        {
            "name": "percentOffItems",
            "baseName": "percent_off_items",
            "type": "CouponPercentOffItems"
        },
        {
            "name": "percentOffItemsAndFreeShipping",
            "baseName": "percent_off_items_and_free_shipping",
            "type": "CouponPercentOffItemsAndFreeShipping"
        },
        {
            "name": "percentOffItemsWithItemsPurchase",
            "baseName": "percent_off_items_with_items_purchase",
            "type": "CouponPercentOffItemsWithItemsPurchase"
        },
        {
            "name": "percentOffRetailPriceItems",
            "baseName": "percent_off_retail_price_items",
            "type": "CouponPercentOffRetailPriceItems"
        },
        {
            "name": "percentOffShipping",
            "baseName": "percent_off_shipping",
            "type": "CouponPercentOffShipping"
        },
        {
            "name": "percentOffSubtotal",
            "baseName": "percent_off_subtotal",
            "type": "CouponPercentOffSubtotal"
        },
        {
            "name": "percentOffSubtotalAndFreeShipping",
            "baseName": "percent_off_subtotal_and_free_shipping",
            "type": "CouponPercentOffSubtotalAndFreeShipping"
        },
        {
            "name": "percentOffSubtotalLimit",
            "baseName": "percent_off_subtotal_limit",
            "type": "CouponPercentOffSubtotalLimit"
        },
        {
            "name": "percentOffSubtotalWithItemsPurchase",
            "baseName": "percent_off_subtotal_with_items_purchase",
            "type": "CouponPercentOffSubtotalWithItemsPurchase"
        },
        {
            "name": "percentOffSubtotalWithSubtotal",
            "baseName": "percent_off_subtotal_with_subtotal",
            "type": "CouponPercentOffSubtotalWithSubtotal"
        },
        {
            "name": "quickbooksCode",
            "baseName": "quickbooks_code",
            "type": "string"
        },
        {
            "name": "restrictByPostalCodes",
            "baseName": "restrict_by_postal_codes",
            "type": "Array<string>"
        },
        {
            "name": "restrictByScreenBrandingThemeCodes",
            "baseName": "restrict_by_screen_branding_theme_codes",
            "type": "Array<CouponRestriction>"
        },
        {
            "name": "restrictByStorefronts",
            "baseName": "restrict_by_storefronts",
            "type": "Array<CouponRestriction>"
        },
        {
            "name": "startDts",
            "baseName": "start_dts",
            "type": "string"
        },
        {
            "name": "tieredAmountOffItem",
            "baseName": "tiered_amount_off_item",
            "type": "CouponTieredAmountOffItem"
        },
        {
            "name": "tieredAmountOffSubtotal",
            "baseName": "tiered_amount_off_subtotal",
            "type": "CouponTieredAmountOffSubtotal"
        },
        {
            "name": "tieredPercentOffItems",
            "baseName": "tiered_percent_off_items",
            "type": "CouponTieredPercentOffItems"
        },
        {
            "name": "tieredPercentOffShipping",
            "baseName": "tiered_percent_off_shipping",
            "type": "CouponTieredPercentOffShipping"
        },
        {
            "name": "tieredPercentOffSubtotal",
            "baseName": "tiered_percent_off_subtotal",
            "type": "CouponTieredPercentOffSubtotal"
        },
        {
            "name": "usableBy",
            "baseName": "usable_by",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Coupon.attributeTypeMap;
    }
}

export class CouponAmountOffItems {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of shipping discount
    */
    'discountAmount'?: number;
    /**
    * A list of items which are eligible for the discount amount.
    */
    'items'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffItems.attributeTypeMap;
    }
}

export class CouponAmountOffShipping {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount'?: number;
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffShipping.attributeTypeMap;
    }
}

export class CouponAmountOffShippingWithItemsPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of shipping discount
    */
    'discountAmount'?: number;
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items'?: Array<string>;
    /**
    * One or more shipping methods that may receive this discount
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffShippingWithItemsPurchase.attributeTypeMap;
    }
}

export class CouponAmountOffSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffSubtotal.attributeTypeMap;
    }
}

export class CouponAmountOffSubtotalAndShipping {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffSubtotalAndShipping.attributeTypeMap;
    }
}

export class CouponAmountOffSubtotalFreeShippingWithPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount'?: number;
    /**
    * The purchase amount to qualify for subtotal discount and free shipping
    */
    'purchaseAmount'?: number;
    /**
    * One or more shipping methods that may be free
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "purchaseAmount",
            "baseName": "purchase_amount",
            "type": "number"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffSubtotalFreeShippingWithPurchase.attributeTypeMap;
    }
}

export class CouponAmountOffSubtotalWithBlockPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount'?: number;
    /**
    * Required item that must be purchased for coupon to be valid
    */
    'requiredPurchaseItem'?: string;
    /**
    * Discount amount is multiplied by the number of blocks.  A block is this many quantity of the required item.
    */
    'requiredPurchaseQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "requiredPurchaseItem",
            "baseName": "required_purchase_item",
            "type": "string"
        },
        {
            "name": "requiredPurchaseQuantity",
            "baseName": "required_purchase_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffSubtotalWithBlockPurchase.attributeTypeMap;
    }
}

export class CouponAmountOffSubtotalWithItemsPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The amount of shipping discount
    */
    'discountAmount'?: number;
    /**
    * A list of items of which a quantity of one or many must be purchased for coupon to be valid.
    */
    'items'?: Array<string>;
    /**
    * The quantity of items that must be purchased for the discount to be applied.
    */
    'requiredPurchaseQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "requiredPurchaseQuantity",
            "baseName": "required_purchase_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponAmountOffSubtotalWithItemsPurchase.attributeTypeMap;
    }
}

export class CouponAutomaticallyApplyCouponCodes {
    /**
    * The coupon codes to automatically apply if this coupon is applied
    */
    'couponCodes'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "couponCodes",
            "baseName": "coupon_codes",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponAutomaticallyApplyCouponCodes.attributeTypeMap;
    }
}

export class CouponCodesRequest {
    'error'?: Error;
    /**
    * Expiration Date
    */
    'expirationDts'?: string;
    /**
    * Expiration seconds
    */
    'expirationSeconds'?: number;
    'metadata'?: ResponseMetadata;
    /**
    * Quantity
    */
    'quantity'?: number;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "expirationSeconds",
            "baseName": "expiration_seconds",
            "type": "number"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return CouponCodesRequest.attributeTypeMap;
    }
}

export class CouponCodesResponse {
    /**
    * Coupon codes
    */
    'couponCodes'?: Array<string>;
    'error'?: Error;
    /**
    * Expiration date
    */
    'expirationDts'?: string;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "couponCodes",
            "baseName": "coupon_codes",
            "type": "Array<string>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return CouponCodesResponse.attributeTypeMap;
    }
}

export class CouponDiscountItemWithItemPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The item that will be sold at the discount_price when required_purchase_item is purchased.
    */
    'discountItem'?: string;
    /**
    * The price (unit cost) of the discounted item
    */
    'discountPrice'?: number;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit'?: number;
    /**
    * The item that must be purchased for the discount to be applied to the discount item.
    */
    'requiredPurchaseItem'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountItem",
            "baseName": "discount_item",
            "type": "string"
        },
        {
            "name": "discountPrice",
            "baseName": "discount_price",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "requiredPurchaseItem",
            "baseName": "required_purchase_item",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CouponDiscountItemWithItemPurchase.attributeTypeMap;
    }
}

export class CouponDiscountItems {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The price (unit cost) of the discounted item
    */
    'discountPrice'?: number;
    /**
    * A list of items that are eligible for this discount_price.
    */
    'items'?: Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountPrice",
            "baseName": "discount_price",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponDiscountItems.attributeTypeMap;
    }
}

export class CouponEditorValues {
    /**
    * coupon_types
    */
    'couponTypes'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "couponTypes",
            "baseName": "coupon_types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponEditorValues.attributeTypeMap;
    }
}

export class CouponFreeItemAndShippingWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * A list of items that are eligible for this discount_price.
    */
    'items'?: Array<string>;
    /**
    * The limit of free items that may be received when purchasing multiple items
    */
    'limit'?: number;
    /**
    * One or more shipping methods that may be free
    */
    'shippingMethods'?: Array<string>;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        },
        {
            "name": "subtotalAmount",
            "baseName": "subtotal_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeItemAndShippingWithSubtotal.attributeTypeMap;
    }
}

export class CouponFreeItemWithItemPurchase {
    /**
    * A list of free items which will receive a discount if one of the required purchase items is purchased.
    */
    'items'?: Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit'?: number;
    /**
    * If true then the free item is matched 1:1 with the free item in the list.
    */
    'matchRequiredPurchaseItemToFreeItem'?: boolean;
    /**
    * Required items (at least one from the list) that must be purchased for coupon to be valid
    */
    'requiredPurchaseItems'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "matchRequiredPurchaseItemToFreeItem",
            "baseName": "match_required_purchase_item_to_free_item",
            "type": "boolean"
        },
        {
            "name": "requiredPurchaseItems",
            "baseName": "required_purchase_items",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeItemWithItemPurchase.attributeTypeMap;
    }
}

export class CouponFreeItemWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * A list of items that are eligible for this discount_price.
    */
    'items'?: Array<string>;
    /**
    * The limit of free items that may be received when purchasing multiple items
    */
    'limit'?: number;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "subtotalAmount",
            "baseName": "subtotal_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeItemWithSubtotal.attributeTypeMap;
    }
}

export class CouponFreeItemsWithItemPurchase {
    /**
    * The item id of the free item that will be received when the required mix and match group quantity is purchased.
    */
    'freeItem'?: string;
    /**
    * The quantity of free item that will be received.
    */
    'freeQuantity'?: number;
    /**
    * The limit of free items that may be received when purchasing multiple items
    */
    'limit'?: number;
    /**
    * Required item that must be purchased for coupon to be valid
    */
    'requiredPurchaseItem'?: string;
    /**
    * Required quantity of mix and match group items that must be purchased for coupon to be valid
    */
    'requiredPurchaseQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "freeItem",
            "baseName": "free_item",
            "type": "string"
        },
        {
            "name": "freeQuantity",
            "baseName": "free_quantity",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "requiredPurchaseItem",
            "baseName": "required_purchase_item",
            "type": "string"
        },
        {
            "name": "requiredPurchaseQuantity",
            "baseName": "required_purchase_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeItemsWithItemPurchase.attributeTypeMap;
    }
}

export class CouponFreeItemsWithMixMatchPurchase {
    /**
    * The item id of the free item that will be received when the required mix and match group quantity is purchased.
    */
    'freeItem'?: string;
    /**
    * The quantity of free item that will be received.
    */
    'freeQuantity'?: number;
    /**
    * The limit of free items that may be received when purchasing multiple mix and match group items
    */
    'limit'?: number;
    /**
    * Required mix and match group that must be purchased for coupon to be valid
    */
    'requiredPurchaseMixAndMatchGroup'?: string;
    /**
    * Required quantity of mix and match group items that must be purchased for coupon to be valid
    */
    'requiredPurchaseQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "freeItem",
            "baseName": "free_item",
            "type": "string"
        },
        {
            "name": "freeQuantity",
            "baseName": "free_quantity",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "requiredPurchaseMixAndMatchGroup",
            "baseName": "required_purchase_mix_and_match_group",
            "type": "string"
        },
        {
            "name": "requiredPurchaseQuantity",
            "baseName": "required_purchase_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeItemsWithMixMatchPurchase.attributeTypeMap;
    }
}

export class CouponFreeShipping {
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeShipping.attributeTypeMap;
    }
}

export class CouponFreeShippingSpecificItems {
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeShippingSpecificItems.attributeTypeMap;
    }
}

export class CouponFreeShippingWithItemsPurchase {
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items'?: Array<string>;
    /**
    * One or more shipping methods that may receive this discount
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeShippingWithItemsPurchase.attributeTypeMap;
    }
}

export class CouponFreeShippingWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The purchase amount to qualify for subtotal discount and free shipping
    */
    'purchaseAmount'?: number;
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "purchaseAmount",
            "baseName": "purchase_amount",
            "type": "number"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponFreeShippingWithSubtotal.attributeTypeMap;
    }
}

export class CouponMultipleAmountsOffItems {
    /**
    * A list of item discounts.
    */
    'discounts'?: Array<CouponTierItemDiscount>;
    /**
    * The (optional) maximum quantity of items that may receive a discount.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discounts",
            "baseName": "discounts",
            "type": "Array<CouponTierItemDiscount>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponMultipleAmountsOffItems.attributeTypeMap;
    }
}

export class CouponNoDiscount {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CouponNoDiscount.attributeTypeMap;
    }
}

export class CouponPercentOffItemWithItemsQuantityPurchase {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * A list of items which will receive a discount if one of the required purchase items is purchased.
    */
    'items'?: Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit'?: number;
    /**
    * Required items (at least one from the list) that must be purchased for coupon to be valid
    */
    'requiredPurchaseItems'?: Array<string>;
    /**
    * The quantity of items that must be purchased for the discount to be applied.
    */
    'requiredPurchaseQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "requiredPurchaseItems",
            "baseName": "required_purchase_items",
            "type": "Array<string>"
        },
        {
            "name": "requiredPurchaseQuantity",
            "baseName": "required_purchase_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffItemWithItemsQuantityPurchase.attributeTypeMap;
    }
}

export class CouponPercentOffItems {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * A list of items which cannot be discounted.
    */
    'excludedItems'?: Array<string>;
    /**
    * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
    */
    'items'?: Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "excludedItems",
            "baseName": "excluded_items",
            "type": "Array<string>"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffItems.attributeTypeMap;
    }
}

export class CouponPercentOffItemsAndFreeShipping {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * A list of items which cannot be discounted.
    */
    'excludedItems'?: Array<string>;
    /**
    * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
    */
    'items'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "excludedItems",
            "baseName": "excluded_items",
            "type": "Array<string>"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffItemsAndFreeShipping.attributeTypeMap;
    }
}

export class CouponPercentOffItemsWithItemsPurchase {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * A list of items which will receive a discount if one of the required purchase items is purchased.
    */
    'items'?: Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit'?: number;
    /**
    * Required items (at least one from the list) that must be purchased for coupon to be valid
    */
    'requiredPurchaseItems'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "requiredPurchaseItems",
            "baseName": "required_purchase_items",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffItemsWithItemsPurchase.attributeTypeMap;
    }
}

export class CouponPercentOffRetailPriceItems {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * A list of items which cannot be discounted.
    */
    'excludedItems'?: Array<string>;
    /**
    * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
    */
    'items'?: Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "excludedItems",
            "baseName": "excluded_items",
            "type": "Array<string>"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffRetailPriceItems.attributeTypeMap;
    }
}

export class CouponPercentOffShipping {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffShipping.attributeTypeMap;
    }
}

export class CouponPercentOffSubtotal {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffSubtotal.attributeTypeMap;
    }
}

export class CouponPercentOffSubtotalAndFreeShipping {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * One or more shipping methods that may be free
    */
    'shippingMethods'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffSubtotalAndFreeShipping.attributeTypeMap;
    }
}

export class CouponPercentOffSubtotalLimit {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * The maximum amount of subtotal used to determine discount.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffSubtotalLimit.attributeTypeMap;
    }
}

export class CouponPercentOffSubtotalWithItemsPurchase {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffSubtotalWithItemsPurchase.attributeTypeMap;
    }
}

export class CouponPercentOffSubtotalWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode'?: string;
    /**
    * The percentage of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "subtotalAmount",
            "baseName": "subtotal_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponPercentOffSubtotalWithSubtotal.attributeTypeMap;
    }
}

export class CouponQuery {
    /**
    * Affiliate oid
    */
    'affiliateOid'?: number;
    /**
    * The type of coupon.
    */
    'couponType'?: string;
    /**
    * Description of this coupon
    */
    'description'?: string;
    /**
    * Exclude expired coupons if true
    */
    'excludeExpired'?: boolean;
    /**
    * Expiration date begin
    */
    'expirationDtsBegin'?: string;
    /**
    * Expiration date begin
    */
    'expirationDtsEnd'?: string;
    /**
    * Merchant code is a unique character string for this coupon.
    */
    'merchantCode'?: string;
    /**
    * Start date begin
    */
    'startDtsBegin'?: string;
    /**
    * Start date end
    */
    'startDtsEnd'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "couponType",
            "baseName": "coupon_type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "excludeExpired",
            "baseName": "exclude_expired",
            "type": "boolean"
        },
        {
            "name": "expirationDtsBegin",
            "baseName": "expiration_dts_begin",
            "type": "string"
        },
        {
            "name": "expirationDtsEnd",
            "baseName": "expiration_dts_end",
            "type": "string"
        },
        {
            "name": "merchantCode",
            "baseName": "merchant_code",
            "type": "string"
        },
        {
            "name": "startDtsBegin",
            "baseName": "start_dts_begin",
            "type": "string"
        },
        {
            "name": "startDtsEnd",
            "baseName": "start_dts_end",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CouponQuery.attributeTypeMap;
    }
}

export class CouponResponse {
    'coupon'?: Coupon;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "coupon",
            "baseName": "coupon",
            "type": "Coupon"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return CouponResponse.attributeTypeMap;
    }
}

export class CouponRestriction {
    'invalidForThis'?: boolean;
    'name'?: string;
    'validForThis'?: boolean;
    'validOnlyForThis'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invalidForThis",
            "baseName": "invalidForThis",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "validForThis",
            "baseName": "validForThis",
            "type": "boolean"
        },
        {
            "name": "validOnlyForThis",
            "baseName": "validOnlyForThis",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CouponRestriction.attributeTypeMap;
    }
}

export class CouponTierAmount {
    /**
    * The amount of subtotal discount
    */
    'discountAmount'?: number;
    /**
    * The amount of subtotal required to receive the discount amount
    */
    'subtotalAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "subtotalAmount",
            "baseName": "subtotal_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponTierAmount.attributeTypeMap;
    }
}

export class CouponTierItemDiscount {
    /**
    * The amount of subtotal discount
    */
    'discountAmount'?: number;
    /**
    * A list of items which will receive this discount.
    */
    'items'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CouponTierItemDiscount.attributeTypeMap;
    }
}

export class CouponTierPercent {
    /**
    * The percent of subtotal discount
    */
    'discountPercent'?: number;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "subtotalAmount",
            "baseName": "subtotal_amount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponTierPercent.attributeTypeMap;
    }
}

export class CouponTierQuantityAmount {
    /**
    * The amount of discount per item.
    */
    'discountAmount'?: number;
    /**
    * The quantity of item purchased (in units)
    */
    'itemQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountAmount",
            "baseName": "discount_amount",
            "type": "number"
        },
        {
            "name": "itemQuantity",
            "baseName": "item_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponTierQuantityAmount.attributeTypeMap;
    }
}

export class CouponTierQuantityPercent {
    /**
    * The percent of discount per item.
    */
    'discountPercent'?: number;
    /**
    * The quantity of item purchased (in units)
    */
    'itemQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discountPercent",
            "baseName": "discount_percent",
            "type": "number"
        },
        {
            "name": "itemQuantity",
            "baseName": "item_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CouponTierQuantityPercent.attributeTypeMap;
    }
}

export class CouponTieredAmountOffItem {
    /**
    * The item being discounted by this coupon.
    */
    'item'?: string;
    /**
    * The maximum amount of total discount by this coupon.
    */
    'limit'?: number;
    /**
    * A list of discount tiers.
    */
    'tiers'?: Array<CouponTierQuantityAmount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "item",
            "baseName": "item",
            "type": "string"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<CouponTierQuantityAmount>"
        }    ];

    static getAttributeTypeMap() {
        return CouponTieredAmountOffItem.attributeTypeMap;
    }
}

export class CouponTieredAmountOffSubtotal {
    /**
    * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
    */
    'items'?: Array<string>;
    /**
    * A list of discount tiers.
    */
    'tiers'?: Array<CouponTierAmount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<CouponTierAmount>"
        }    ];

    static getAttributeTypeMap() {
        return CouponTieredAmountOffSubtotal.attributeTypeMap;
    }
}

export class CouponTieredPercentOffItems {
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items'?: Array<string>;
    /**
    * The maximum amount of total discount by this coupon.
    */
    'limit'?: number;
    /**
    * A list of discount tiers.
    */
    'tiers'?: Array<CouponTierQuantityPercent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<CouponTierQuantityPercent>"
        }    ];

    static getAttributeTypeMap() {
        return CouponTieredPercentOffItems.attributeTypeMap;
    }
}

export class CouponTieredPercentOffShipping {
    /**
    * One or more shipping methods that may receive this discount
    */
    'shippingMethods'?: Array<string>;
    /**
    * A list of discount tiers.
    */
    'tiers'?: Array<CouponTierPercent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shippingMethods",
            "baseName": "shipping_methods",
            "type": "Array<string>"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<CouponTierPercent>"
        }    ];

    static getAttributeTypeMap() {
        return CouponTieredPercentOffShipping.attributeTypeMap;
    }
}

export class CouponTieredPercentOffSubtotal {
    /**
    * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
    */
    'items'?: Array<string>;
    /**
    * A list of discount tiers.
    */
    'tiers'?: Array<CouponTierPercent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<string>"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<CouponTierPercent>"
        }    ];

    static getAttributeTypeMap() {
        return CouponTieredPercentOffSubtotal.attributeTypeMap;
    }
}

export class CouponsResponse {
    'coupons'?: Array<Coupon>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "coupons",
            "baseName": "coupons",
            "type": "Array<Coupon>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return CouponsResponse.attributeTypeMap;
    }
}

export class Currency {
    /**
    * Currency code of the localized value
    */
    'currencyCode'?: string;
    /**
    * Exchange rate used to localize
    */
    'exchangeRate'?: number;
    /**
    * Value localized to the customer
    */
    'localized'?: number;
    /**
    * Value localized and formatted for the customer
    */
    'localizedFormatted'?: string;
    /**
    * Value in base currency
    */
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchange_rate",
            "type": "number"
        },
        {
            "name": "localized",
            "baseName": "localized",
            "type": "number"
        },
        {
            "name": "localizedFormatted",
            "baseName": "localized_formatted",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Currency.attributeTypeMap;
    }
}

export class Customer {
    'activity'?: CustomerActivity;
    /**
    * Affiliate oid
    */
    'affiliateOid'?: number;
    /**
    * Allow 3rd party billing
    */
    'allow3rdPartyBilling'?: boolean;
    /**
    * Allow COD
    */
    'allowCod'?: boolean;
    /**
    * Allow purchase orders by this customer
    */
    'allowPurchaseOrder'?: boolean;
    /**
    * Allow quote request
    */
    'allowQuoteRequest'?: boolean;
    /**
    * Allow selection of residential or business address type
    */
    'allowSelectionOfAddressType'?: boolean;
    /**
    * Attachments
    */
    'attachments'?: Array<CustomerAttachment>;
    /**
    * Auto approve COD
    */
    'autoApproveCod'?: boolean;
    /**
    * Auto approve purchase orders by this customer
    */
    'autoApprovePurchaseOrder'?: boolean;
    /**
    * Automatic merchant notes are added to every order placed
    */
    'automaticMerchantNotes'?: string;
    /**
    * Billing addresses for this customer
    */
    'billing'?: Array<CustomerBilling>;
    /**
    * Business notes (internally visible only)
    */
    'businessNotes'?: string;
    /**
    * Credit Cards for this customer
    */
    'cards'?: Array<CustomerCard>;
    /**
    * Additional emails to CC notification
    */
    'ccEmails'?: Array<CustomerEmail>;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid'?: number;
    /**
    * DHL account number
    */
    'dhlAccountNumber'?: string;
    /**
    * DHL duty account number
    */
    'dhlDutyAccountNumber'?: string;
    /**
    * Email address of this customer profile
    */
    'email'?: string;
    /**
    * Exempt shipping handling charge
    */
    'exemptShippingHandlingCharge'?: boolean;
    /**
    * FedEx account number
    */
    'fedexAccountNumber'?: string;
    /**
    * This customer always receives free shipping
    */
    'freeShipping'?: boolean;
    /**
    * If free_shipping is true, this is the minimum subtotal required for free shipping
    */
    'freeShippingMinimum'?: number;
    /**
    * Last modified by
    */
    'lastModifiedBy'?: string;
    /**
    * Last modified date
    */
    'lastModifiedDts'?: string;
    'loyalty'?: CustomerLoyalty;
    /**
    * Maximum item count
    */
    'maximumItemCount'?: number;
    /**
    * Minimum item count
    */
    'minimumItemCount'?: number;
    /**
    * Minimum subtotal
    */
    'minimumSubtotal'?: number;
    /**
    * No coupons
    */
    'noCoupons'?: boolean;
    /**
    * No free shipping regardless of coupons or item level settings
    */
    'noFreeShipping'?: boolean;
    /**
    * No realtime charge
    */
    'noRealtimeCharge'?: boolean;
    /**
    * Orders associated with this customer profile
    */
    'orders'?: Array<Order>;
    'ordersSummary'?: CustomerOrdersSummary;
    /**
    * Password (may only be set, never read)
    */
    'password'?: string;
    /**
    * Pricing tiers for this customer
    */
    'pricingTiers'?: Array<CustomerPricingTier>;
    'privacy'?: CustomerPrivacy;
    /**
    * QuickBooks class to import this customer as
    */
    'qbClass'?: string;
    /**
    * QuickBooks name to import this customer as
    */
    'qbCode'?: string;
    /**
    * Quotes associated with this customer profile
    */
    'quotes'?: Array<Order>;
    'quotesSummary'?: CustomerQuotesSummary;
    /**
    * Referral Source
    */
    'referralSource'?: string;
    'reviewer'?: CustomerReviewer;
    /**
    * Sales rep code
    */
    'salesRepCode'?: string;
    /**
    * Send signup notification, if true during customer creation, will send a notification.
    */
    'sendSignupNotification'?: boolean;
    /**
    * Shipping addresses for this customer
    */
    'shipping'?: Array<CustomerShipping>;
    /**
    * Signup date
    */
    'signupDts'?: string;
    /**
    * Software entitlements owned by this customer
    */
    'softwareEntitlements'?: Array<CustomerSoftwareEntitlement>;
    /**
    * Suppress buySAFE (deprecated)
    */
    'suppressBuysafe'?: boolean;
    /**
    * Tags for this customer
    */
    'tags'?: Array<CustomerTag>;
    'taxCodes'?: CustomerTaxCodes;
    /**
    * True if the customer is tax exempt
    */
    'taxExempt'?: boolean;
    /**
    * Tax ID
    */
    'taxId'?: string;
    /**
    * Terms for this customer
    */
    'terms'?: string;
    /**
    * True if the customer should be tracked separately in QuickBooks
    */
    'trackSeparately'?: boolean;
    /**
    * Unapproved
    */
    'unapproved'?: boolean;
    /**
    * UPS account number
    */
    'upsAccountNumber'?: string;
    /**
    * Website url
    */
    'websiteUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activity",
            "baseName": "activity",
            "type": "CustomerActivity"
        },
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "allow3rdPartyBilling",
            "baseName": "allow_3rd_party_billing",
            "type": "boolean"
        },
        {
            "name": "allowCod",
            "baseName": "allow_cod",
            "type": "boolean"
        },
        {
            "name": "allowPurchaseOrder",
            "baseName": "allow_purchase_order",
            "type": "boolean"
        },
        {
            "name": "allowQuoteRequest",
            "baseName": "allow_quote_request",
            "type": "boolean"
        },
        {
            "name": "allowSelectionOfAddressType",
            "baseName": "allow_selection_of_address_type",
            "type": "boolean"
        },
        {
            "name": "attachments",
            "baseName": "attachments",
            "type": "Array<CustomerAttachment>"
        },
        {
            "name": "autoApproveCod",
            "baseName": "auto_approve_cod",
            "type": "boolean"
        },
        {
            "name": "autoApprovePurchaseOrder",
            "baseName": "auto_approve_purchase_order",
            "type": "boolean"
        },
        {
            "name": "automaticMerchantNotes",
            "baseName": "automatic_merchant_notes",
            "type": "string"
        },
        {
            "name": "billing",
            "baseName": "billing",
            "type": "Array<CustomerBilling>"
        },
        {
            "name": "businessNotes",
            "baseName": "business_notes",
            "type": "string"
        },
        {
            "name": "cards",
            "baseName": "cards",
            "type": "Array<CustomerCard>"
        },
        {
            "name": "ccEmails",
            "baseName": "cc_emails",
            "type": "Array<CustomerEmail>"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "dhlAccountNumber",
            "baseName": "dhl_account_number",
            "type": "string"
        },
        {
            "name": "dhlDutyAccountNumber",
            "baseName": "dhl_duty_account_number",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "exemptShippingHandlingCharge",
            "baseName": "exempt_shipping_handling_charge",
            "type": "boolean"
        },
        {
            "name": "fedexAccountNumber",
            "baseName": "fedex_account_number",
            "type": "string"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "boolean"
        },
        {
            "name": "freeShippingMinimum",
            "baseName": "free_shipping_minimum",
            "type": "number"
        },
        {
            "name": "lastModifiedBy",
            "baseName": "last_modified_by",
            "type": "string"
        },
        {
            "name": "lastModifiedDts",
            "baseName": "last_modified_dts",
            "type": "string"
        },
        {
            "name": "loyalty",
            "baseName": "loyalty",
            "type": "CustomerLoyalty"
        },
        {
            "name": "maximumItemCount",
            "baseName": "maximum_item_count",
            "type": "number"
        },
        {
            "name": "minimumItemCount",
            "baseName": "minimum_item_count",
            "type": "number"
        },
        {
            "name": "minimumSubtotal",
            "baseName": "minimum_subtotal",
            "type": "number"
        },
        {
            "name": "noCoupons",
            "baseName": "no_coupons",
            "type": "boolean"
        },
        {
            "name": "noFreeShipping",
            "baseName": "no_free_shipping",
            "type": "boolean"
        },
        {
            "name": "noRealtimeCharge",
            "baseName": "no_realtime_charge",
            "type": "boolean"
        },
        {
            "name": "orders",
            "baseName": "orders",
            "type": "Array<Order>"
        },
        {
            "name": "ordersSummary",
            "baseName": "orders_summary",
            "type": "CustomerOrdersSummary"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "pricingTiers",
            "baseName": "pricing_tiers",
            "type": "Array<CustomerPricingTier>"
        },
        {
            "name": "privacy",
            "baseName": "privacy",
            "type": "CustomerPrivacy"
        },
        {
            "name": "qbClass",
            "baseName": "qb_class",
            "type": "string"
        },
        {
            "name": "qbCode",
            "baseName": "qb_code",
            "type": "string"
        },
        {
            "name": "quotes",
            "baseName": "quotes",
            "type": "Array<Order>"
        },
        {
            "name": "quotesSummary",
            "baseName": "quotes_summary",
            "type": "CustomerQuotesSummary"
        },
        {
            "name": "referralSource",
            "baseName": "referral_source",
            "type": "string"
        },
        {
            "name": "reviewer",
            "baseName": "reviewer",
            "type": "CustomerReviewer"
        },
        {
            "name": "salesRepCode",
            "baseName": "sales_rep_code",
            "type": "string"
        },
        {
            "name": "sendSignupNotification",
            "baseName": "send_signup_notification",
            "type": "boolean"
        },
        {
            "name": "shipping",
            "baseName": "shipping",
            "type": "Array<CustomerShipping>"
        },
        {
            "name": "signupDts",
            "baseName": "signup_dts",
            "type": "string"
        },
        {
            "name": "softwareEntitlements",
            "baseName": "software_entitlements",
            "type": "Array<CustomerSoftwareEntitlement>"
        },
        {
            "name": "suppressBuysafe",
            "baseName": "suppress_buysafe",
            "type": "boolean"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<CustomerTag>"
        },
        {
            "name": "taxCodes",
            "baseName": "tax_codes",
            "type": "CustomerTaxCodes"
        },
        {
            "name": "taxExempt",
            "baseName": "tax_exempt",
            "type": "boolean"
        },
        {
            "name": "taxId",
            "baseName": "tax_id",
            "type": "string"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "trackSeparately",
            "baseName": "track_separately",
            "type": "boolean"
        },
        {
            "name": "unapproved",
            "baseName": "unapproved",
            "type": "boolean"
        },
        {
            "name": "upsAccountNumber",
            "baseName": "ups_account_number",
            "type": "string"
        },
        {
            "name": "websiteUrl",
            "baseName": "website_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Customer.attributeTypeMap;
    }
}

export class CustomerActivity {
    'activities'?: Array<Activity>;
    'memberships'?: Array<ListSegmentMembership>;
    'metrics'?: Array<Metric>;
    'propertiesList'?: Array<Property>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activities",
            "baseName": "activities",
            "type": "Array<Activity>"
        },
        {
            "name": "memberships",
            "baseName": "memberships",
            "type": "Array<ListSegmentMembership>"
        },
        {
            "name": "metrics",
            "baseName": "metrics",
            "type": "Array<Metric>"
        },
        {
            "name": "propertiesList",
            "baseName": "properties_list",
            "type": "Array<Property>"
        }    ];

    static getAttributeTypeMap() {
        return CustomerActivity.attributeTypeMap;
    }
}

export class CustomerAffiliate {
    /**
    * Affiliate object identifier
    */
    'affiliateOid'?: number;
    /**
    * email
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerAffiliate.attributeTypeMap;
    }
}

export class CustomerAttachment {
    /**
    * Attachment identifier
    */
    'customerProfileAttachmentOid'?: number;
    /**
    * Description
    */
    'description'?: string;
    /**
    * File name
    */
    'fileName'?: string;
    /**
    * Mime typoe
    */
    'mimeType'?: string;
    /**
    * Upload date/time
    */
    'uploadDts'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerProfileAttachmentOid",
            "baseName": "customer_profile_attachment_oid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fileName",
            "baseName": "file_name",
            "type": "string"
        },
        {
            "name": "mimeType",
            "baseName": "mime_type",
            "type": "string"
        },
        {
            "name": "uploadDts",
            "baseName": "upload_dts",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerAttachment.attributeTypeMap;
    }
}

export class CustomerBilling {
    /**
    * Address line 1
    */
    'address1'?: string;
    /**
    * Address line 2
    */
    'address2'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Customer profile billing object identifier
    */
    'customerBillingOid'?: number;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid'?: number;
    /**
    * Day phone
    */
    'dayPhone'?: string;
    /**
    * Default billing
    */
    'defaultBilling'?: boolean;
    /**
    * Evening phone
    */
    'eveningPhone'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Last used date
    */
    'lastUsedDts'?: string;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion'?: string;
    /**
    * Tax County
    */
    'taxCounty'?: string;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "customerBillingOid",
            "baseName": "customer_billing_oid",
            "type": "number"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "dayPhone",
            "baseName": "day_phone",
            "type": "string"
        },
        {
            "name": "defaultBilling",
            "baseName": "default_billing",
            "type": "boolean"
        },
        {
            "name": "eveningPhone",
            "baseName": "evening_phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "lastUsedDts",
            "baseName": "last_used_dts",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "taxCounty",
            "baseName": "tax_county",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerBilling.attributeTypeMap;
    }
}

export class CustomerCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth'?: number;
    /**
    * Card expiration year (four digit year)
    */
    'cardExpirationYear'?: number;
    /**
    * Card number (masked to the last 4)
    */
    'cardNumber'?: string;
    /**
    * Hosted field token for the card number
    */
    'cardNumberToken'?: string;
    /**
    * Card type
    */
    'cardType'?: string;
    /**
    * ID of the stored credit card to use
    */
    'customerProfileCreditCardId'?: number;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid'?: number;
    /**
    * Last used date
    */
    'lastUsedDts'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardExpirationMonth",
            "baseName": "card_expiration_month",
            "type": "number"
        },
        {
            "name": "cardExpirationYear",
            "baseName": "card_expiration_year",
            "type": "number"
        },
        {
            "name": "cardNumber",
            "baseName": "card_number",
            "type": "string"
        },
        {
            "name": "cardNumberToken",
            "baseName": "card_number_token",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "card_type",
            "type": "string"
        },
        {
            "name": "customerProfileCreditCardId",
            "baseName": "customer_profile_credit_card_id",
            "type": "number"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "lastUsedDts",
            "baseName": "last_used_dts",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerCard.attributeTypeMap;
    }
}

export class CustomerEditorValues {
    /**
    * affiliates
    */
    'affiliates'?: Array<CustomerAffiliate>;
    /**
    * card_exp_months
    */
    'cardExpMonths'?: Array<string>;
    /**
    * card_exp_years
    */
    'cardExpYears'?: Array<string>;
    /**
    * card_types
    */
    'cardTypes'?: Array<string>;
    /**
    * countries
    */
    'countries'?: Array<Country>;
    /**
    * qb_classes
    */
    'qbClasses'?: Array<string>;
    /**
    * sales_rep_codes
    */
    'salesRepCodes'?: Array<string>;
    /**
    * terms
    */
    'terms'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliates",
            "baseName": "affiliates",
            "type": "Array<CustomerAffiliate>"
        },
        {
            "name": "cardExpMonths",
            "baseName": "card_exp_months",
            "type": "Array<string>"
        },
        {
            "name": "cardExpYears",
            "baseName": "card_exp_years",
            "type": "Array<string>"
        },
        {
            "name": "cardTypes",
            "baseName": "card_types",
            "type": "Array<string>"
        },
        {
            "name": "countries",
            "baseName": "countries",
            "type": "Array<Country>"
        },
        {
            "name": "qbClasses",
            "baseName": "qb_classes",
            "type": "Array<string>"
        },
        {
            "name": "salesRepCodes",
            "baseName": "sales_rep_codes",
            "type": "Array<string>"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CustomerEditorValues.attributeTypeMap;
    }
}

export class CustomerEmail {
    /**
    * ID of the email
    */
    'customerProfileEmailOid'?: number;
    /**
    * Email
    */
    'email'?: string;
    /**
    * Label
    */
    'label'?: string;
    /**
    * CC this email on receipt notifications
    */
    'receiptNotification'?: boolean;
    /**
    * CC this email on refund notifications
    */
    'refundNotification'?: boolean;
    /**
    * CC this email on shipment notifications
    */
    'shipmentNotification'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerProfileEmailOid",
            "baseName": "customer_profile_email_oid",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "receiptNotification",
            "baseName": "receipt_notification",
            "type": "boolean"
        },
        {
            "name": "refundNotification",
            "baseName": "refund_notification",
            "type": "boolean"
        },
        {
            "name": "shipmentNotification",
            "baseName": "shipment_notification",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomerEmail.attributeTypeMap;
    }
}

export class CustomerEmailListChanges {
    /**
    * Add this customer to these email lists
    */
    'addToLists'?: Array<string>;
    /**
    * Remove this customer from these email lists
    */
    'removeFromLists'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addToLists",
            "baseName": "add_to_lists",
            "type": "Array<string>"
        },
        {
            "name": "removeFromLists",
            "baseName": "remove_from_lists",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CustomerEmailListChanges.attributeTypeMap;
    }
}

export class CustomerLoyalty {
    /**
    * Current Points
    */
    'currentPoints'?: number;
    /**
    * Ledger entries
    */
    'ledgerEntries'?: Array<CustomerLoyaltyLedger>;
    /**
    * Redemptions
    */
    'redemptions'?: Array<CustomerLoyaltyRedemption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currentPoints",
            "baseName": "current_points",
            "type": "number"
        },
        {
            "name": "ledgerEntries",
            "baseName": "ledger_entries",
            "type": "Array<CustomerLoyaltyLedger>"
        },
        {
            "name": "redemptions",
            "baseName": "redemptions",
            "type": "Array<CustomerLoyaltyRedemption>"
        }    ];

    static getAttributeTypeMap() {
        return CustomerLoyalty.attributeTypeMap;
    }
}

export class CustomerLoyaltyLedger {
    /**
    * Created By
    */
    'createdBy'?: string;
    /**
    * Created date
    */
    'createdDts'?: string;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Email
    */
    'email'?: string;
    /**
    * Item Id
    */
    'itemId'?: string;
    /**
    * Item Index
    */
    'itemIndex'?: number;
    /**
    * Ledger date
    */
    'ledgerDts'?: string;
    /**
    * Loyalty campaign oid
    */
    'loyaltyCampaignOid'?: number;
    /**
    * Loyalty ledger oid
    */
    'loyaltyLedgerOid'?: number;
    /**
    * Loyalty points
    */
    'loyaltyPoints'?: number;
    /**
    * Modified By
    */
    'modifiedBy'?: string;
    /**
    * Modified date
    */
    'modifiedDts'?: string;
    /**
    * Order Id
    */
    'orderId'?: string;
    /**
    * Quantity
    */
    'quantity'?: number;
    /**
    * Vesting date
    */
    'vestingDts'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdBy",
            "baseName": "created_by",
            "type": "string"
        },
        {
            "name": "createdDts",
            "baseName": "created_dts",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "itemIndex",
            "baseName": "item_index",
            "type": "number"
        },
        {
            "name": "ledgerDts",
            "baseName": "ledger_dts",
            "type": "string"
        },
        {
            "name": "loyaltyCampaignOid",
            "baseName": "loyalty_campaign_oid",
            "type": "number"
        },
        {
            "name": "loyaltyLedgerOid",
            "baseName": "loyalty_ledger_oid",
            "type": "number"
        },
        {
            "name": "loyaltyPoints",
            "baseName": "loyalty_points",
            "type": "number"
        },
        {
            "name": "modifiedBy",
            "baseName": "modified_by",
            "type": "string"
        },
        {
            "name": "modifiedDts",
            "baseName": "modified_dts",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "vestingDts",
            "baseName": "vesting_dts",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerLoyaltyLedger.attributeTypeMap;
    }
}

export class CustomerLoyaltyRedemption {
    /**
    * Coupon code
    */
    'couponCode'?: string;
    /**
    * Coupon code OID
    */
    'couponCodeOid'?: number;
    /**
    * Coupon used
    */
    'couponUsed'?: boolean;
    /**
    * Description for customer
    */
    'descriptionForCustomer'?: string;
    /**
    * Expiration date
    */
    'expirationDts'?: string;
    /**
    * Gift certificate code
    */
    'giftCertificateCode'?: string;
    /**
    * Gift certificate oid
    */
    'giftCertificateOid'?: number;
    /**
    * Loyalty ledger OID
    */
    'loyaltyLedgerOid'?: number;
    /**
    * Loyalty points
    */
    'loyaltyPoints'?: number;
    /**
    * Loyalty redemption OID
    */
    'loyaltyRedemptionOid'?: number;
    /**
    * Order id
    */
    'orderId'?: string;
    /**
    * Redemption date
    */
    'redemptionDts'?: string;
    /**
    * Remaining balance
    */
    'remainingBalance'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "couponCode",
            "baseName": "coupon_code",
            "type": "string"
        },
        {
            "name": "couponCodeOid",
            "baseName": "coupon_code_oid",
            "type": "number"
        },
        {
            "name": "couponUsed",
            "baseName": "coupon_used",
            "type": "boolean"
        },
        {
            "name": "descriptionForCustomer",
            "baseName": "description_for_customer",
            "type": "string"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "giftCertificateCode",
            "baseName": "gift_certificate_code",
            "type": "string"
        },
        {
            "name": "giftCertificateOid",
            "baseName": "gift_certificate_oid",
            "type": "number"
        },
        {
            "name": "loyaltyLedgerOid",
            "baseName": "loyalty_ledger_oid",
            "type": "number"
        },
        {
            "name": "loyaltyPoints",
            "baseName": "loyalty_points",
            "type": "number"
        },
        {
            "name": "loyaltyRedemptionOid",
            "baseName": "loyalty_redemption_oid",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "redemptionDts",
            "baseName": "redemption_dts",
            "type": "string"
        },
        {
            "name": "remainingBalance",
            "baseName": "remaining_balance",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerLoyaltyRedemption.attributeTypeMap;
    }
}

export class CustomerOrdersSummary {
    /**
    * First order date
    */
    'firstOrderDts'?: string;
    /**
    * Last order date
    */
    'lastOrderDts'?: string;
    /**
    * Total number of orders
    */
    'orderCount'?: number;
    /**
    * Total amount associated with the orders
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstOrderDts",
            "baseName": "first_order_dts",
            "type": "string"
        },
        {
            "name": "lastOrderDts",
            "baseName": "last_order_dts",
            "type": "string"
        },
        {
            "name": "orderCount",
            "baseName": "order_count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerOrdersSummary.attributeTypeMap;
    }
}

export class CustomerPricingTier {
    /**
    * Name
    */
    'name'?: string;
    /**
    * Pricing Tier Oid
    */
    'pricingTierOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "pricingTierOid",
            "baseName": "pricing_tier_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerPricingTier.attributeTypeMap;
    }
}

export class CustomerPrivacy {
    /**
    * Last update date
    */
    'lastUpdateDts'?: string;
    /**
    * The customer has opted in to marketing
    */
    'marketing'?: boolean;
    /**
    * The customer has opted in to preference tracking
    */
    'preference'?: boolean;
    /**
    * The customer has opted in to statistics collection
    */
    'statistics'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastUpdateDts",
            "baseName": "last_update_dts",
            "type": "string"
        },
        {
            "name": "marketing",
            "baseName": "marketing",
            "type": "boolean"
        },
        {
            "name": "preference",
            "baseName": "preference",
            "type": "boolean"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomerPrivacy.attributeTypeMap;
    }
}

export class CustomerQuery {
    /**
    * All tags the customer must have
    */
    'allTags'?: Array<string>;
    /**
    * Any of these tags the customer must have
    */
    'anyTags'?: Array<string>;
    /**
    * Billing city
    */
    'billingCity'?: string;
    /**
    * Billing company
    */
    'billingCompany'?: string;
    /**
    * Billing country code
    */
    'billingCountryCode'?: string;
    /**
    * Billing day phone
    */
    'billingDayPhone'?: string;
    /**
    * Billing evening phone
    */
    'billingEveningPhone'?: string;
    /**
    * Billing first name
    */
    'billingFirstName'?: string;
    /**
    * Billing last name
    */
    'billingLastName'?: string;
    /**
    * Billing postal code
    */
    'billingPostalCode'?: string;
    /**
    * Billing state
    */
    'billingState'?: string;
    /**
    * Email address of this customer profile
    */
    'email'?: string;
    /**
    * Last modified date end
    */
    'lastModifiedDtsEnd'?: string;
    /**
    * Last modified date start
    */
    'lastModifiedDtsStart'?: string;
    /**
    * Pricing tier name
    */
    'pricingTierName'?: string;
    /**
    * Pricing tier oid
    */
    'pricingTierOid'?: number;
    /**
    * QuickBooks class to import this customer as
    */
    'qbClass'?: string;
    /**
    * QuickBooks name to import this customer as
    */
    'quickbooksCode'?: string;
    /**
    * Billing city
    */
    'shippingCity'?: string;
    /**
    * Billing company
    */
    'shippingCompany'?: string;
    /**
    * Billing country code
    */
    'shippingCountryCode'?: string;
    /**
    * Billing day phone
    */
    'shippingDayPhone'?: string;
    /**
    * Billing evening phone
    */
    'shippingEveningPhone'?: string;
    /**
    * Billing first name
    */
    'shippingFirstName'?: string;
    /**
    * Billing last name
    */
    'shippingLastName'?: string;
    /**
    * Billing postal code
    */
    'shippingPostalCode'?: string;
    /**
    * Billing state
    */
    'shippingState'?: string;
    /**
    * Signup date end
    */
    'signupDtsEnd'?: string;
    /**
    * Signup date start
    */
    'signupDtsStart'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allTags",
            "baseName": "all_tags",
            "type": "Array<string>"
        },
        {
            "name": "anyTags",
            "baseName": "any_tags",
            "type": "Array<string>"
        },
        {
            "name": "billingCity",
            "baseName": "billing_city",
            "type": "string"
        },
        {
            "name": "billingCompany",
            "baseName": "billing_company",
            "type": "string"
        },
        {
            "name": "billingCountryCode",
            "baseName": "billing_country_code",
            "type": "string"
        },
        {
            "name": "billingDayPhone",
            "baseName": "billing_day_phone",
            "type": "string"
        },
        {
            "name": "billingEveningPhone",
            "baseName": "billing_evening_phone",
            "type": "string"
        },
        {
            "name": "billingFirstName",
            "baseName": "billing_first_name",
            "type": "string"
        },
        {
            "name": "billingLastName",
            "baseName": "billing_last_name",
            "type": "string"
        },
        {
            "name": "billingPostalCode",
            "baseName": "billing_postal_code",
            "type": "string"
        },
        {
            "name": "billingState",
            "baseName": "billing_state",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "lastModifiedDtsEnd",
            "baseName": "last_modified_dts_end",
            "type": "string"
        },
        {
            "name": "lastModifiedDtsStart",
            "baseName": "last_modified_dts_start",
            "type": "string"
        },
        {
            "name": "pricingTierName",
            "baseName": "pricing_tier_name",
            "type": "string"
        },
        {
            "name": "pricingTierOid",
            "baseName": "pricing_tier_oid",
            "type": "number"
        },
        {
            "name": "qbClass",
            "baseName": "qb_class",
            "type": "string"
        },
        {
            "name": "quickbooksCode",
            "baseName": "quickbooks_code",
            "type": "string"
        },
        {
            "name": "shippingCity",
            "baseName": "shipping_city",
            "type": "string"
        },
        {
            "name": "shippingCompany",
            "baseName": "shipping_company",
            "type": "string"
        },
        {
            "name": "shippingCountryCode",
            "baseName": "shipping_country_code",
            "type": "string"
        },
        {
            "name": "shippingDayPhone",
            "baseName": "shipping_day_phone",
            "type": "string"
        },
        {
            "name": "shippingEveningPhone",
            "baseName": "shipping_evening_phone",
            "type": "string"
        },
        {
            "name": "shippingFirstName",
            "baseName": "shipping_first_name",
            "type": "string"
        },
        {
            "name": "shippingLastName",
            "baseName": "shipping_last_name",
            "type": "string"
        },
        {
            "name": "shippingPostalCode",
            "baseName": "shipping_postal_code",
            "type": "string"
        },
        {
            "name": "shippingState",
            "baseName": "shipping_state",
            "type": "string"
        },
        {
            "name": "signupDtsEnd",
            "baseName": "signup_dts_end",
            "type": "string"
        },
        {
            "name": "signupDtsStart",
            "baseName": "signup_dts_start",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerQuery.attributeTypeMap;
    }
}

export class CustomerQuotesSummary {
    /**
    * First quote date
    */
    'firstQuoteDts'?: string;
    /**
    * Last quote date
    */
    'lastQuoteDts'?: string;
    /**
    * Total number of quote
    */
    'quoteCount'?: number;
    /**
    * Total amount associated with the quotes
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstQuoteDts",
            "baseName": "first_quote_dts",
            "type": "string"
        },
        {
            "name": "lastQuoteDts",
            "baseName": "last_quote_dts",
            "type": "string"
        },
        {
            "name": "quoteCount",
            "baseName": "quote_count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerQuotesSummary.attributeTypeMap;
    }
}

export class CustomerResponse {
    'customer'?: Customer;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Customer"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return CustomerResponse.attributeTypeMap;
    }
}

export class CustomerReviewer {
    /**
    * True if reviewes from this customer profile should automatically be approved
    */
    'autoApprove'?: boolean;
    /**
    * Average overall rating of items reviewed
    */
    'averageOverallRating'?: number;
    /**
    * True if the customer is an expert
    */
    'expert'?: boolean;
    /**
    * First review
    */
    'firstReview'?: string;
    /**
    * Last review
    */
    'lastReview'?: string;
    /**
    * Location of the reviewer
    */
    'location'?: string;
    /**
    * Nickname of the reviewer
    */
    'nickname'?: string;
    /**
    * Number of helpful review votes
    */
    'numberHelpfulReviewVotes'?: number;
    /**
    * Rank of this reviewer
    */
    'rank'?: number;
    /**
    * Number of reviews contributed
    */
    'reviewsContributed'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoApprove",
            "baseName": "auto_approve",
            "type": "boolean"
        },
        {
            "name": "averageOverallRating",
            "baseName": "average_overall_rating",
            "type": "number"
        },
        {
            "name": "expert",
            "baseName": "expert",
            "type": "boolean"
        },
        {
            "name": "firstReview",
            "baseName": "first_review",
            "type": "string"
        },
        {
            "name": "lastReview",
            "baseName": "last_review",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "nickname",
            "baseName": "nickname",
            "type": "string"
        },
        {
            "name": "numberHelpfulReviewVotes",
            "baseName": "number_helpful_review_votes",
            "type": "number"
        },
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        },
        {
            "name": "reviewsContributed",
            "baseName": "reviews_contributed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CustomerReviewer.attributeTypeMap;
    }
}

export class CustomerShipping {
    /**
    * Address line 1
    */
    'address1'?: string;
    /**
    * Address line 2
    */
    'address2'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid'?: number;
    /**
    * Customer profile shipping object identifier
    */
    'customerShippingOid'?: number;
    /**
    * Day phone
    */
    'dayPhone'?: string;
    /**
    * Default shipping
    */
    'defaultShipping'?: boolean;
    /**
    * Evening phone
    */
    'eveningPhone'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Last used date
    */
    'lastUsedDts'?: string;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion'?: string;
    /**
    * Tax County
    */
    'taxCounty'?: string;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "customerShippingOid",
            "baseName": "customer_shipping_oid",
            "type": "number"
        },
        {
            "name": "dayPhone",
            "baseName": "day_phone",
            "type": "string"
        },
        {
            "name": "defaultShipping",
            "baseName": "default_shipping",
            "type": "boolean"
        },
        {
            "name": "eveningPhone",
            "baseName": "evening_phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "lastUsedDts",
            "baseName": "last_used_dts",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "taxCounty",
            "baseName": "tax_county",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerShipping.attributeTypeMap;
    }
}

export class CustomerSoftwareEntitlement {
    /**
    * Activation Code Associated with the software
    */
    'activationCode'?: string;
    /**
    * Date/time when the activation code was created
    */
    'activationDts'?: string;
    /**
    * Customer profile software entitlement object identifier
    */
    'customerSoftwareEntitlementOid'?: number;
    /**
    * Date/time when the activation code will expire
    */
    'expirationDts'?: string;
    /**
    * Item description used to purchase this software.
    */
    'purchasedViaItemDescription'?: string;
    /**
    * Item ID used to purchase this software.
    */
    'purchasedViaItemId'?: string;
    /**
    * Order ID used to purchase this software.
    */
    'purchasedViaOrderId'?: string;
    /**
    * SKU of the software
    */
    'softwareSku'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activationCode",
            "baseName": "activation_code",
            "type": "string"
        },
        {
            "name": "activationDts",
            "baseName": "activation_dts",
            "type": "string"
        },
        {
            "name": "customerSoftwareEntitlementOid",
            "baseName": "customer_software_entitlement_oid",
            "type": "number"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "purchasedViaItemDescription",
            "baseName": "purchased_via_item_description",
            "type": "string"
        },
        {
            "name": "purchasedViaItemId",
            "baseName": "purchased_via_item_id",
            "type": "string"
        },
        {
            "name": "purchasedViaOrderId",
            "baseName": "purchased_via_order_id",
            "type": "string"
        },
        {
            "name": "softwareSku",
            "baseName": "software_sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerSoftwareEntitlement.attributeTypeMap;
    }
}

export class CustomerTag {
    /**
    * Tag Value
    */
    'tagValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tagValue",
            "baseName": "tag_value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTag.attributeTypeMap;
    }
}

export class CustomerTaxCodes {
    /**
    * Avalara customer code
    */
    'avalaraCustomerCode'?: string;
    /**
    * Avalara entity use code
    */
    'avalaraEntityUseCode'?: string;
    /**
    * Sovos customer code
    */
    'sovosCustomerCode'?: string;
    /**
    * TaxJar customer id
    */
    'taxjarCustomerId'?: string;
    /**
    * TaxJar exemption type
    */
    'taxjarExemptionType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avalaraCustomerCode",
            "baseName": "avalara_customer_code",
            "type": "string"
        },
        {
            "name": "avalaraEntityUseCode",
            "baseName": "avalara_entity_use_code",
            "type": "string"
        },
        {
            "name": "sovosCustomerCode",
            "baseName": "sovos_customer_code",
            "type": "string"
        },
        {
            "name": "taxjarCustomerId",
            "baseName": "taxjar_customer_id",
            "type": "string"
        },
        {
            "name": "taxjarExemptionType",
            "baseName": "taxjar_exemption_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomerTaxCodes.attributeTypeMap;
    }
}

export class CustomersResponse {
    'customers'?: Array<Customer>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customers",
            "baseName": "customers",
            "type": "Array<Customer>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return CustomersResponse.attributeTypeMap;
    }
}

export class DataTablesServerSideResponse {
    'data'?: Array<Customer>;
    'draw'?: number;
    'recordsFiltered'?: number;
    'recordsTotal'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Customer>"
        },
        {
            "name": "draw",
            "baseName": "draw",
            "type": "number"
        },
        {
            "name": "recordsFiltered",
            "baseName": "recordsFiltered",
            "type": "number"
        },
        {
            "name": "recordsTotal",
            "baseName": "recordsTotal",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DataTablesServerSideResponse.attributeTypeMap;
    }
}

export class Distance {
    /**
    * Unit of measure
    */
    'uom'?: Distance.UomEnum;
    /**
    * The distance measured in UOM
    */
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uom",
            "baseName": "uom",
            "type": "Distance.UomEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Distance.attributeTypeMap;
    }
}

export namespace Distance {
    export enum UomEnum {
        IN = <any> 'IN',
        CM = <any> 'CM'
    }
}
export class DistributionCenter {
    /**
    * Address line 1 of the distribution center
    */
    'address1'?: string;
    /**
    * Address line 2 of the distribution center
    */
    'address2'?: string;
    /**
    * City of the distribution center
    */
    'city'?: string;
    /**
    * Unique code for this distribution center
    */
    'code'?: string;
    /**
    * Country code of the distribution center
    */
    'countryCode'?: string;
    /**
    * True if this is the default distribution center on the account
    */
    'defaultCenter'?: boolean;
    /**
    * True if this distribution center handles all new items by default
    */
    'defaultHandlesAllItems'?: boolean;
    /**
    * Distribution center object identifier
    */
    'distributionCenterOid'?: number;
    /**
    * DUNS number assigned to this distribution center (EDI)
    */
    'duns'?: string;
    /**
    * Estimate shipments for this distribution center as if they came from the other distribution center
    */
    'estimateFromDistributionCenterOid'?: number;
    /**
    * Password associated with the virtual FTP
    */
    'ftpPassword'?: string;
    /**
    * The number of minutes to hold a shipment
    */
    'holdBeforeShipmentMinutes'?: number;
    /**
    * True if the shipment should be held before transmission and require a manual release
    */
    'holdBeforeTransmission'?: boolean;
    'holdAutoOrderBeforeShipmentMinutes'?: number;
    /**
    * Latitude where the distribution center is located
    */
    'latitude'?: number;
    /**
    * Longitude where the distribution center is located
    */
    'longitude'?: number;
    /**
    * Name of this distribution center
    */
    'name'?: string;
    /**
    * True if this distribution center does not handle customer direct shipments
    */
    'noCustomerDirectShipments'?: boolean;
    /**
    * True if this distribution center is not allowed to participate in a split shipment.
    */
    'noSplitShipment'?: boolean;
    /**
    * Postal code of the distribution center
    */
    'postalCode'?: string;
    /**
    * The number of processing days required before an order ships
    */
    'processDays'?: number;
    /**
    * The time (EST) after which inventory updates will be processed
    */
    'processInventoryStartTime'?: string;
    /**
    * The time (EST) before which inventory updates will be processed
    */
    'processInventoryStopTime'?: string;
    /**
    * True if ASNs are required for this distribution center (EDI)
    */
    'requireAsn'?: boolean;
    /**
    * True if we should send the kit instead of the components
    */
    'sendKitInsteadOfComponents'?: boolean;
    /**
    * The time (EST) after which shipments will not be processed on Friday
    */
    'shipmentCutoffTimeFriday'?: string;
    /**
    * The time (EST) after which shipments will not be processed on Monday
    */
    'shipmentCutoffTimeMonday'?: string;
    /**
    * The time (EST) after which shipments will not be processed on Saturday
    */
    'shipmentCutoffTimeSaturday'?: string;
    /**
    * The time (EST) after which shipments will not be processed on Sunday
    */
    'shipmentCutoffTimeSunday'?: string;
    /**
    * The time (EST) after which shipments will not be processed on Thursday
    */
    'shipmentCutoffTimeThursday'?: string;
    /**
    * The time (EST) after which shipments will not be processed on Tuesday
    */
    'shipmentCutoffTimeTuesday'?: string;
    /**
    * The time (EST) after which shipments will not be processed on Wednesday
    */
    'shipmentCutoffTimeWednesday'?: string;
    /**
    * State of the distribution center
    */
    'state'?: string;
    /**
    * Transport mechanism for this distribution center
    */
    'transport'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "defaultCenter",
            "baseName": "default_center",
            "type": "boolean"
        },
        {
            "name": "defaultHandlesAllItems",
            "baseName": "default_handles_all_items",
            "type": "boolean"
        },
        {
            "name": "distributionCenterOid",
            "baseName": "distribution_center_oid",
            "type": "number"
        },
        {
            "name": "duns",
            "baseName": "duns",
            "type": "string"
        },
        {
            "name": "estimateFromDistributionCenterOid",
            "baseName": "estimate_from_distribution_center_oid",
            "type": "number"
        },
        {
            "name": "ftpPassword",
            "baseName": "ftp_password",
            "type": "string"
        },
        {
            "name": "holdBeforeShipmentMinutes",
            "baseName": "hold_before_shipment_minutes",
            "type": "number"
        },
        {
            "name": "holdBeforeTransmission",
            "baseName": "hold_before_transmission",
            "type": "boolean"
        },
        {
            "name": "holdAutoOrderBeforeShipmentMinutes",
            "baseName": "holdAutoOrderBeforeShipmentMinutes",
            "type": "number"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "noCustomerDirectShipments",
            "baseName": "no_customer_direct_shipments",
            "type": "boolean"
        },
        {
            "name": "noSplitShipment",
            "baseName": "no_split_shipment",
            "type": "boolean"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "processDays",
            "baseName": "process_days",
            "type": "number"
        },
        {
            "name": "processInventoryStartTime",
            "baseName": "process_inventory_start_time",
            "type": "string"
        },
        {
            "name": "processInventoryStopTime",
            "baseName": "process_inventory_stop_time",
            "type": "string"
        },
        {
            "name": "requireAsn",
            "baseName": "require_asn",
            "type": "boolean"
        },
        {
            "name": "sendKitInsteadOfComponents",
            "baseName": "send_kit_instead_of_components",
            "type": "boolean"
        },
        {
            "name": "shipmentCutoffTimeFriday",
            "baseName": "shipment_cutoff_time_friday",
            "type": "string"
        },
        {
            "name": "shipmentCutoffTimeMonday",
            "baseName": "shipment_cutoff_time_monday",
            "type": "string"
        },
        {
            "name": "shipmentCutoffTimeSaturday",
            "baseName": "shipment_cutoff_time_saturday",
            "type": "string"
        },
        {
            "name": "shipmentCutoffTimeSunday",
            "baseName": "shipment_cutoff_time_sunday",
            "type": "string"
        },
        {
            "name": "shipmentCutoffTimeThursday",
            "baseName": "shipment_cutoff_time_thursday",
            "type": "string"
        },
        {
            "name": "shipmentCutoffTimeTuesday",
            "baseName": "shipment_cutoff_time_tuesday",
            "type": "string"
        },
        {
            "name": "shipmentCutoffTimeWednesday",
            "baseName": "shipment_cutoff_time_wednesday",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "transport",
            "baseName": "transport",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DistributionCenter.attributeTypeMap;
    }
}

export class DistributionCentersResponse {
    'distributionCenters'?: Array<DistributionCenter>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "distributionCenters",
            "baseName": "distribution_centers",
            "type": "Array<DistributionCenter>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return DistributionCentersResponse.attributeTypeMap;
    }
}

export class EmailBaseTemplateListResponse {
    'templatePaths'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templatePaths",
            "baseName": "templatePaths",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EmailBaseTemplateListResponse.attributeTypeMap;
    }
}

export class EmailCampaign {
    /**
    * Click rate of emails
    */
    'clickRateFormatted'?: string;
    /**
    * Created date
    */
    'createdDts'?: string;
    /**
    * True if this campaign was deleted
    */
    'deleted'?: boolean;
    /**
    * Email campaign UUID
    */
    'emailCampaignUuid'?: string;
    /**
    * Email communication sequence UUID
    */
    'emailCommunicationSequenceUuid'?: string;
    /**
    * True if the customer should end the flow once they purchase
    */
    'endOnceCustomerPurchases'?: boolean;
    /**
    * User of the sending address
    */
    'espDomainUser'?: string;
    /**
    * UUID of the sending domain
    */
    'espDomainUuid'?: string;
    /**
    * Friendly name of the sending email
    */
    'espFriendlyName'?: string;
    /**
    * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
    */
    'libraryItemOid'?: number;
    /**
    * List and segment memberships
    */
    'memberships'?: Array<EmailListSegmentMembership>;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Name of email campaign
    */
    'name'?: string;
    /**
    * Open rate of emails
    */
    'openRateFormatted'?: string;
    /**
    * True if this campaign is prevented from sending at this time due to spam complaints.
    */
    'preventSendingDueToSpam'?: boolean;
    /**
    * Revenue associated with campaign
    */
    'revenueFormatted'?: string;
    /**
    * Scheduled date
    */
    'scheduledDts'?: string;
    /**
    * URL to a large full length screenshot
    */
    'screenshotLargeFullUrl'?: string;
    /**
    * Status of the campaign of draft, archived, and sent
    */
    'status'?: string;
    /**
    * Timestamp when the last status change happened
    */
    'statusDts'?: string;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clickRateFormatted",
            "baseName": "click_rate_formatted",
            "type": "string"
        },
        {
            "name": "createdDts",
            "baseName": "created_dts",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "emailCampaignUuid",
            "baseName": "email_campaign_uuid",
            "type": "string"
        },
        {
            "name": "emailCommunicationSequenceUuid",
            "baseName": "email_communication_sequence_uuid",
            "type": "string"
        },
        {
            "name": "endOnceCustomerPurchases",
            "baseName": "end_once_customer_purchases",
            "type": "boolean"
        },
        {
            "name": "espDomainUser",
            "baseName": "esp_domain_user",
            "type": "string"
        },
        {
            "name": "espDomainUuid",
            "baseName": "esp_domain_uuid",
            "type": "string"
        },
        {
            "name": "espFriendlyName",
            "baseName": "esp_friendly_name",
            "type": "string"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        },
        {
            "name": "memberships",
            "baseName": "memberships",
            "type": "Array<EmailListSegmentMembership>"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "openRateFormatted",
            "baseName": "open_rate_formatted",
            "type": "string"
        },
        {
            "name": "preventSendingDueToSpam",
            "baseName": "prevent_sending_due_to_spam",
            "type": "boolean"
        },
        {
            "name": "revenueFormatted",
            "baseName": "revenue_formatted",
            "type": "string"
        },
        {
            "name": "scheduledDts",
            "baseName": "scheduled_dts",
            "type": "string"
        },
        {
            "name": "screenshotLargeFullUrl",
            "baseName": "screenshot_large_full_url",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "statusDts",
            "baseName": "status_dts",
            "type": "string"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailCampaign.attributeTypeMap;
    }
}

export class EmailCampaignResponse {
    'campaign'?: EmailCampaign;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaign",
            "baseName": "campaign",
            "type": "EmailCampaign"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCampaignResponse.attributeTypeMap;
    }
}

export class EmailCampaignsResponse {
    'campaigns'?: Array<EmailCampaign>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "campaigns",
            "baseName": "campaigns",
            "type": "Array<EmailCampaign>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCampaignsResponse.attributeTypeMap;
    }
}

export class EmailClick {
    /**
    * Click Count
    */
    'clickCount'?: number;
    /**
    * url
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clickCount",
            "baseName": "click_count",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailClick.attributeTypeMap;
    }
}

export class EmailClicksResponse {
    'clicks'?: Array<EmailClick>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clicks",
            "baseName": "clicks",
            "type": "Array<EmailClick>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailClicksResponse.attributeTypeMap;
    }
}

export class EmailCommseq {
    /**
    * Array of steps
    */
    'emailCommunicationSequenceSteps'?: Array<EmailCommseqStep>;
    /**
    * Email commseq UUID
    */
    'emailCommunicationSequenceUuid'?: string;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailCommunicationSequenceSteps",
            "baseName": "email_communication_sequence_steps",
            "type": "Array<EmailCommseqStep>"
        },
        {
            "name": "emailCommunicationSequenceUuid",
            "baseName": "email_communication_sequence_uuid",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseq.attributeTypeMap;
    }
}

export class EmailCommseqEmail {
    /**
    * Deleted
    */
    'deleted'?: boolean;
    /**
    * Edited by user
    */
    'editedByUser'?: string;
    /**
    * Email communication sequence email uuid
    */
    'emailCommunicationSequenceEmailUuid'?: string;
    /**
    * Email commseq UUID
    */
    'emailCommunicationSequenceUuid'?: string;
    /**
    * Email container cjson
    */
    'emailContainerCjson'?: string;
    /**
    * Timestamp the last time the container was modified.
    */
    'emailContainerCjsonLastModifiedDts'?: string;
    /**
    * Email template virtual path
    */
    'emailTemplateVmPath'?: string;
    /**
    * Filter profile equation json
    */
    'filterProfileEquationJson'?: string;
    /**
    * Individually render
    */
    'individuallyRender'?: boolean;
    /**
    * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
    */
    'libraryItemOid'?: number;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * True if the content of this email is pending review by UltraCart
    */
    'pendingReview'?: boolean;
    /**
    * Preview text
    */
    'previewText'?: string;
    /**
    * True if the content of this email was rejected during review by UltraCart
    */
    'rejected'?: boolean;
    /**
    * True if the content of this email is requires review by UltraCart
    */
    'requiresReview'?: boolean;
    /**
    * URL to screenshot in large form factor full page
    */
    'screenshotLargeFullUrl'?: string;
    /**
    * URL to screenshot in large form factor viewport
    */
    'screenshotLargeViewportUrl'?: string;
    /**
    * URL to screenshot in small form factor full page
    */
    'screenshotSmallFullUrl'?: string;
    /**
    * URL to screenshot in small form factor viewport
    */
    'screenshotSmallViewportUrl'?: string;
    /**
    * Smart sending
    */
    'smartSending'?: boolean;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * Subject
    */
    'subject'?: string;
    /**
    * Transactional email
    */
    'transactionalEmail'?: boolean;
    /**
    * Version
    */
    'version'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "editedByUser",
            "baseName": "edited_by_user",
            "type": "string"
        },
        {
            "name": "emailCommunicationSequenceEmailUuid",
            "baseName": "email_communication_sequence_email_uuid",
            "type": "string"
        },
        {
            "name": "emailCommunicationSequenceUuid",
            "baseName": "email_communication_sequence_uuid",
            "type": "string"
        },
        {
            "name": "emailContainerCjson",
            "baseName": "email_container_cjson",
            "type": "string"
        },
        {
            "name": "emailContainerCjsonLastModifiedDts",
            "baseName": "email_container_cjson_last_modified_dts",
            "type": "string"
        },
        {
            "name": "emailTemplateVmPath",
            "baseName": "email_template_vm_path",
            "type": "string"
        },
        {
            "name": "filterProfileEquationJson",
            "baseName": "filter_profile_equation_json",
            "type": "string"
        },
        {
            "name": "individuallyRender",
            "baseName": "individually_render",
            "type": "boolean"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "pendingReview",
            "baseName": "pending_review",
            "type": "boolean"
        },
        {
            "name": "previewText",
            "baseName": "preview_text",
            "type": "string"
        },
        {
            "name": "rejected",
            "baseName": "rejected",
            "type": "boolean"
        },
        {
            "name": "requiresReview",
            "baseName": "requires_review",
            "type": "boolean"
        },
        {
            "name": "screenshotLargeFullUrl",
            "baseName": "screenshot_large_full_url",
            "type": "string"
        },
        {
            "name": "screenshotLargeViewportUrl",
            "baseName": "screenshot_large_viewport_url",
            "type": "string"
        },
        {
            "name": "screenshotSmallFullUrl",
            "baseName": "screenshot_small_full_url",
            "type": "string"
        },
        {
            "name": "screenshotSmallViewportUrl",
            "baseName": "screenshot_small_viewport_url",
            "type": "string"
        },
        {
            "name": "smartSending",
            "baseName": "smart_sending",
            "type": "boolean"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "transactionalEmail",
            "baseName": "transactional_email",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqEmail.attributeTypeMap;
    }
}

export class EmailCommseqEmailResponse {
    'email'?: EmailCommseqEmail;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "EmailCommseqEmail"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqEmailResponse.attributeTypeMap;
    }
}

export class EmailCommseqEmailSendTestRequest {
    'cartId'?: string;
    'cartItemIds'?: Array<string>;
    'espCommseqEmailUuid'?: string;
    'espCommseqStepUuid'?: string;
    'espCommseqUuid'?: string;
    'name'?: string;
    'orderId'?: string;
    'pleaseReview'?: boolean;
    'sendToAdditionalEmails'?: Array<string>;
    'sendToLoggedInUser'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cartId",
            "baseName": "cart_id",
            "type": "string"
        },
        {
            "name": "cartItemIds",
            "baseName": "cart_item_ids",
            "type": "Array<string>"
        },
        {
            "name": "espCommseqEmailUuid",
            "baseName": "esp_commseq_email_uuid",
            "type": "string"
        },
        {
            "name": "espCommseqStepUuid",
            "baseName": "esp_commseq_step_uuid",
            "type": "string"
        },
        {
            "name": "espCommseqUuid",
            "baseName": "esp_commseq_uuid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "pleaseReview",
            "baseName": "please_review",
            "type": "boolean"
        },
        {
            "name": "sendToAdditionalEmails",
            "baseName": "send_to_additional_emails",
            "type": "Array<string>"
        },
        {
            "name": "sendToLoggedInUser",
            "baseName": "send_to_logged_in_user",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqEmailSendTestRequest.attributeTypeMap;
    }
}

export class EmailCommseqEmailSendTestResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqEmailSendTestResponse.attributeTypeMap;
    }
}

export class EmailCommseqEmailsRequest {
    'error'?: Error;
    'espCommseqEmailUuids'?: Array<string>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "espCommseqEmailUuids",
            "baseName": "esp_commseq_email_uuids",
            "type": "Array<string>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqEmailsRequest.attributeTypeMap;
    }
}

export class EmailCommseqEmailsResponse {
    'emails'?: Array<EmailCommseqEmail>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<EmailCommseqEmail>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqEmailsResponse.attributeTypeMap;
    }
}

export class EmailCommseqPostcard {
    /**
    * Deleted
    */
    'deleted'?: boolean;
    /**
    * Edited by user
    */
    'editedByUser'?: string;
    /**
    * communication sequence postcard uuid
    */
    'emailCommunicationSequencePostcardUuid'?: string;
    /**
    * Filter profile equation json
    */
    'filterProfileEquationJson'?: string;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Postcard back container cjson
    */
    'postcardBackContainerCjson'?: string;
    /**
    * Postcard back container uuid
    */
    'postcardBackContainerUuid'?: string;
    /**
    * Timestamp the last time the container was modified.
    */
    'postcardContainerCjsonLastModifiedDts'?: string;
    /**
    * Postcard front container cjson
    */
    'postcardFrontContainerCjson'?: string;
    /**
    * Postcard front container uuid
    */
    'postcardFrontContainerUuid'?: string;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "editedByUser",
            "baseName": "edited_by_user",
            "type": "string"
        },
        {
            "name": "emailCommunicationSequencePostcardUuid",
            "baseName": "email_communication_sequence_postcard_uuid",
            "type": "string"
        },
        {
            "name": "filterProfileEquationJson",
            "baseName": "filter_profile_equation_json",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "postcardBackContainerCjson",
            "baseName": "postcard_back_container_cjson",
            "type": "string"
        },
        {
            "name": "postcardBackContainerUuid",
            "baseName": "postcard_back_container_uuid",
            "type": "string"
        },
        {
            "name": "postcardContainerCjsonLastModifiedDts",
            "baseName": "postcard_container_cjson_last_modified_dts",
            "type": "string"
        },
        {
            "name": "postcardFrontContainerCjson",
            "baseName": "postcard_front_container_cjson",
            "type": "string"
        },
        {
            "name": "postcardFrontContainerUuid",
            "baseName": "postcard_front_container_uuid",
            "type": "string"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqPostcard.attributeTypeMap;
    }
}

export class EmailCommseqPostcardResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'postcard'?: EmailCommseqPostcard;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "postcard",
            "baseName": "postcard",
            "type": "EmailCommseqPostcard"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqPostcardResponse.attributeTypeMap;
    }
}

export class EmailCommseqPostcardSendTestRequest {
    'address1'?: string;
    'address2'?: string;
    'cartId'?: string;
    'cartItemIds'?: Array<string>;
    'city'?: string;
    'espCommseqPostcardUuid'?: string;
    'espCommseqStepUuid'?: string;
    'espCommseqUuid'?: string;
    'name'?: string;
    'orderId'?: string;
    'postalCode'?: string;
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address_1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address_2",
            "type": "string"
        },
        {
            "name": "cartId",
            "baseName": "cart_id",
            "type": "string"
        },
        {
            "name": "cartItemIds",
            "baseName": "cart_item_ids",
            "type": "Array<string>"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "espCommseqPostcardUuid",
            "baseName": "esp_commseq_postcard_uuid",
            "type": "string"
        },
        {
            "name": "espCommseqStepUuid",
            "baseName": "esp_commseq_step_uuid",
            "type": "string"
        },
        {
            "name": "espCommseqUuid",
            "baseName": "esp_commseq_uuid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqPostcardSendTestRequest.attributeTypeMap;
    }
}

export class EmailCommseqPostcardSendTestResponse {
    'backThumbnail'?: string;
    'error'?: Error;
    'frontThumbnail'?: string;
    'metadata'?: ResponseMetadata;
    'renderedPdf'?: string;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "backThumbnail",
            "baseName": "backThumbnail",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "frontThumbnail",
            "baseName": "frontThumbnail",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "renderedPdf",
            "baseName": "renderedPdf",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqPostcardSendTestResponse.attributeTypeMap;
    }
}

export class EmailCommseqPostcardsRequest {
    'espCommseqPostcardUuids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "espCommseqPostcardUuids",
            "baseName": "esp_commseq_postcard_uuids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqPostcardsRequest.attributeTypeMap;
    }
}

export class EmailCommseqPostcardsResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'postcards'?: Array<EmailCommseqPostcard>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "postcards",
            "baseName": "postcards",
            "type": "Array<EmailCommseqPostcard>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqPostcardsResponse.attributeTypeMap;
    }
}

export class EmailCommseqResponse {
    'communicationSequence'?: EmailCommseq;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "communicationSequence",
            "baseName": "communication_sequence",
            "type": "EmailCommseq"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqResponse.attributeTypeMap;
    }
}

export class EmailCommseqStat {
    /**
    * Count of clicked emails
    */
    'clickCount'?: number;
    /**
    * Count of clicked emails, formatted
    */
    'clickCountFormatted'?: string;
    /**
    * Count of conversion
    */
    'conversionCount'?: number;
    /**
    * Count of conversions, formatted
    */
    'conversionCountFormatted'?: string;
    /**
    * Count of delivered emails
    */
    'deliveredCount'?: number;
    /**
    * Count of delivered emails, formatted
    */
    'deliveredCountFormatted'?: string;
    /**
    * UUID associated with the communication sequence
    */
    'emailCommunicationSequenceUuid'?: string;
    /**
    * Count of customers that finished the sequence
    */
    'finishedCount'?: number;
    /**
    * Count of customers that finished the sequence, formatted
    */
    'finishedCountFormatted'?: string;
    /**
    * Count of customers in progress
    */
    'inProgressCount'?: number;
    /**
    * Count of customers in progress, formatted
    */
    'inProgressCountFormatted'?: string;
    /**
    * Count of emails kicked
    */
    'kickboxCount'?: number;
    /**
    * Count of emails kicked, formatted
    */
    'kickboxCountFormatted'?: string;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Count of opened emails
    */
    'openCount'?: number;
    /**
    * Count of opened emails, formatted
    */
    'openCountFormatted'?: string;
    /**
    * Count of orders
    */
    'orderCount'?: number;
    /**
    * Count of orders, formatted
    */
    'orderCountFormatted'?: string;
    /**
    * Count of emails permanently bounced
    */
    'permanentBounceCount'?: number;
    /**
    * Count of emails permanently bounced, formatted
    */
    'permanentBounceCountFormatted'?: string;
    /**
    * Profit
    */
    'profit'?: number;
    /**
    * Profit, formatted
    */
    'profitFormatted'?: string;
    /**
    * Revenue
    */
    'revenue'?: number;
    /**
    * Revenue, formatted
    */
    'revenueFormatted'?: string;
    /**
    * Count of emails sent
    */
    'sendCount'?: number;
    /**
    * Count of emails sent, formatted
    */
    'sendCountFormatted'?: string;
    /**
    * Count of skipped emails
    */
    'skippedCount'?: number;
    /**
    * Count of skipped emails, formatted
    */
    'skippedCountFormatted'?: string;
    /**
    * Count of emails classified as spam
    */
    'spamCount'?: number;
    /**
    * Count of emails classified as spam, formatted
    */
    'spamCountFormatted'?: string;
    /**
    * Count of customers that started the sequence
    */
    'startedCount'?: number;
    /**
    * Count of customers that started the sequence, formatted
    */
    'startedCountFormatted'?: string;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * Count of unsubscribes caused
    */
    'unsubscribeCount'?: number;
    /**
    * Count of unsubscribes caused, formatted
    */
    'unsubscribeCountFormatted'?: string;
    /**
    * Count of views
    */
    'viewCount'?: number;
    /**
    * Count of views, formatted
    */
    'viewCountFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clickCount",
            "baseName": "click_count",
            "type": "number"
        },
        {
            "name": "clickCountFormatted",
            "baseName": "click_count_formatted",
            "type": "string"
        },
        {
            "name": "conversionCount",
            "baseName": "conversion_count",
            "type": "number"
        },
        {
            "name": "conversionCountFormatted",
            "baseName": "conversion_count_formatted",
            "type": "string"
        },
        {
            "name": "deliveredCount",
            "baseName": "delivered_count",
            "type": "number"
        },
        {
            "name": "deliveredCountFormatted",
            "baseName": "delivered_count_formatted",
            "type": "string"
        },
        {
            "name": "emailCommunicationSequenceUuid",
            "baseName": "email_communication_sequence_uuid",
            "type": "string"
        },
        {
            "name": "finishedCount",
            "baseName": "finished_count",
            "type": "number"
        },
        {
            "name": "finishedCountFormatted",
            "baseName": "finished_count_formatted",
            "type": "string"
        },
        {
            "name": "inProgressCount",
            "baseName": "in_progress_count",
            "type": "number"
        },
        {
            "name": "inProgressCountFormatted",
            "baseName": "in_progress_count_formatted",
            "type": "string"
        },
        {
            "name": "kickboxCount",
            "baseName": "kickbox_count",
            "type": "number"
        },
        {
            "name": "kickboxCountFormatted",
            "baseName": "kickbox_count_formatted",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "openCount",
            "baseName": "open_count",
            "type": "number"
        },
        {
            "name": "openCountFormatted",
            "baseName": "open_count_formatted",
            "type": "string"
        },
        {
            "name": "orderCount",
            "baseName": "order_count",
            "type": "number"
        },
        {
            "name": "orderCountFormatted",
            "baseName": "order_count_formatted",
            "type": "string"
        },
        {
            "name": "permanentBounceCount",
            "baseName": "permanent_bounce_count",
            "type": "number"
        },
        {
            "name": "permanentBounceCountFormatted",
            "baseName": "permanent_bounce_count_formatted",
            "type": "string"
        },
        {
            "name": "profit",
            "baseName": "profit",
            "type": "number"
        },
        {
            "name": "profitFormatted",
            "baseName": "profit_formatted",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "revenueFormatted",
            "baseName": "revenue_formatted",
            "type": "string"
        },
        {
            "name": "sendCount",
            "baseName": "send_count",
            "type": "number"
        },
        {
            "name": "sendCountFormatted",
            "baseName": "send_count_formatted",
            "type": "string"
        },
        {
            "name": "skippedCount",
            "baseName": "skipped_count",
            "type": "number"
        },
        {
            "name": "skippedCountFormatted",
            "baseName": "skipped_count_formatted",
            "type": "string"
        },
        {
            "name": "spamCount",
            "baseName": "spam_count",
            "type": "number"
        },
        {
            "name": "spamCountFormatted",
            "baseName": "spam_count_formatted",
            "type": "string"
        },
        {
            "name": "startedCount",
            "baseName": "started_count",
            "type": "number"
        },
        {
            "name": "startedCountFormatted",
            "baseName": "started_count_formatted",
            "type": "string"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "unsubscribeCount",
            "baseName": "unsubscribe_count",
            "type": "number"
        },
        {
            "name": "unsubscribeCountFormatted",
            "baseName": "unsubscribe_count_formatted",
            "type": "string"
        },
        {
            "name": "viewCount",
            "baseName": "view_count",
            "type": "number"
        },
        {
            "name": "viewCountFormatted",
            "baseName": "view_count_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqStat.attributeTypeMap;
    }
}

export class EmailCommseqStatResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'stats'?: EmailCommseqStat;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "EmailCommseqStat"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqStatResponse.attributeTypeMap;
    }
}

export class EmailCommseqStep {
    /**
    * Array of child steps for the alternate path
    */
    'altChildEmailCommunicationSequenceSteps'?: Array<EmailCommseqStep>;
    /**
    * Array of child steps
    */
    'childEmailCommunicationSequenceSteps'?: Array<EmailCommseqStep>;
    /**
    * Email commseq step UUID
    */
    'emailCommunicationSequenceStepUuid'?: string;
    /**
    * True if the content of the email associated with this step is pending review by UltraCart
    */
    'emailPendingReview'?: boolean;
    /**
    * True if the content of the email associated with this step was rejected during review by UltraCart
    */
    'emailRejected'?: boolean;
    /**
    * True if the content of the email associated with this step requires review by UltraCart
    */
    'emailRequiresReview'?: boolean;
    /**
    * Filter profile equation JSON
    */
    'filterProfileEquationJson'?: string;
    /**
    * Internal merchant notes
    */
    'merchantNotes'?: string;
    /**
    * Arbitrary Configuration for a step
    */
    'stepConfigJson'?: string;
    /**
    * Type of step
    */
    'type'?: EmailCommseqStep.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "altChildEmailCommunicationSequenceSteps",
            "baseName": "alt_child_email_communication_sequence_steps",
            "type": "Array<EmailCommseqStep>"
        },
        {
            "name": "childEmailCommunicationSequenceSteps",
            "baseName": "child_email_communication_sequence_steps",
            "type": "Array<EmailCommseqStep>"
        },
        {
            "name": "emailCommunicationSequenceStepUuid",
            "baseName": "email_communication_sequence_step_uuid",
            "type": "string"
        },
        {
            "name": "emailPendingReview",
            "baseName": "email_pending_review",
            "type": "boolean"
        },
        {
            "name": "emailRejected",
            "baseName": "email_rejected",
            "type": "boolean"
        },
        {
            "name": "emailRequiresReview",
            "baseName": "email_requires_review",
            "type": "boolean"
        },
        {
            "name": "filterProfileEquationJson",
            "baseName": "filter_profile_equation_json",
            "type": "string"
        },
        {
            "name": "merchantNotes",
            "baseName": "merchant_notes",
            "type": "string"
        },
        {
            "name": "stepConfigJson",
            "baseName": "step_config_json",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "EmailCommseqStep.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqStep.attributeTypeMap;
    }
}

export namespace EmailCommseqStep {
    export enum TypeEnum {
        Begin = <any> 'begin',
        Wait = <any> 'wait',
        Email = <any> 'email',
        Merge = <any> 'merge',
        Condition = <any> 'condition',
        End = <any> 'end'
    }
}
export class EmailCommseqsResponse {
    'communicationSequences'?: Array<EmailCommseq>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "communicationSequences",
            "baseName": "communication_sequences",
            "type": "Array<EmailCommseq>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCommseqsResponse.attributeTypeMap;
    }
}

export class EmailCustomer {
    /**
    * True if the customer is flagged as active within StoreFront Communications
    */
    'active'?: boolean;
    /**
    * Email
    */
    'email'?: string;
    /**
    * Email customer UUID
    */
    'emailCustomerUuid'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * True if the customer has globally unsubscribed from all communication.
    */
    'globalUnsubscribe'?: boolean;
    /**
    * Last interaction
    */
    'lastInteractionDts'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * UUIDs of the lists they are subscribed to
    */
    'listUuids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailCustomerUuid",
            "baseName": "email_customer_uuid",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "globalUnsubscribe",
            "baseName": "global_unsubscribe",
            "type": "boolean"
        },
        {
            "name": "lastInteractionDts",
            "baseName": "last_interaction_dts",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "listUuids",
            "baseName": "list_uuids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EmailCustomer.attributeTypeMap;
    }
}

export class EmailCustomerEditorUrlResponse {
    'editorUrl'?: string;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "editorUrl",
            "baseName": "editor_url",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailCustomerEditorUrlResponse.attributeTypeMap;
    }
}

export class EmailCustomersResponse {
    /**
    * Customers on the page
    */
    'customers'?: Array<EmailCustomer>;
    /**
    * Page number (one based offset)
    */
    'pageNumber'?: number;
    /**
    * Number of records per page
    */
    'pageSize'?: number;
    /**
    * Total customers
    */
    'totalCustomers'?: number;
    /**
    * Total number of pages
    */
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customers",
            "baseName": "customers",
            "type": "Array<EmailCustomer>"
        },
        {
            "name": "pageNumber",
            "baseName": "page_number",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "page_size",
            "type": "number"
        },
        {
            "name": "totalCustomers",
            "baseName": "total_customers",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailCustomersResponse.attributeTypeMap;
    }
}

export class EmailDashboardActivity {
    /**
    * Type of action such as add, remove, subscribe, unsubscribe
    */
    'action'?: string;
    /**
    * Date/time of the activity
    */
    'activityDts'?: string;
    /**
    * List or segment name
    */
    'destinationName'?: string;
    /**
    * List or segment uuid
    */
    'destinationUuid'?: string;
    /**
    * Email address
    */
    'email'?: string;
    /**
    * true if activity is related to list
    */
    'isList'?: boolean;
    /**
    * true if activity is related to segment
    */
    'isSegment'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "activityDts",
            "baseName": "activity_dts",
            "type": "string"
        },
        {
            "name": "destinationName",
            "baseName": "destination_name",
            "type": "string"
        },
        {
            "name": "destinationUuid",
            "baseName": "destination_uuid",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "isList",
            "baseName": "is_list",
            "type": "boolean"
        },
        {
            "name": "isSegment",
            "baseName": "is_segment",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EmailDashboardActivity.attributeTypeMap;
    }
}

export class EmailDashboardActivityResponse {
    'activity'?: Array<EmailDashboardActivity>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activity",
            "baseName": "activity",
            "type": "Array<EmailDashboardActivity>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailDashboardActivityResponse.attributeTypeMap;
    }
}

export class EmailDashboardStatsResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'stats'?: Array<EmailStat>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "Array<EmailStat>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailDashboardStatsResponse.attributeTypeMap;
    }
}

export class EmailDomain {
    'comment'?: string;
    'dkim'?: Array<VerificationRecord>;
    'dkimStatus'?: string;
    'domain'?: string;
    'espDomainUuid'?: string;
    'identityStatus'?: string;
    'merchantId'?: string;
    'provider'?: string;
    'startDkimDts'?: string;
    'startIdentityDts'?: string;
    'verification'?: VerificationRecord;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "dkim",
            "baseName": "dkim",
            "type": "Array<VerificationRecord>"
        },
        {
            "name": "dkimStatus",
            "baseName": "dkim_status",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        },
        {
            "name": "espDomainUuid",
            "baseName": "esp_domain_uuid",
            "type": "string"
        },
        {
            "name": "identityStatus",
            "baseName": "identity_status",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        },
        {
            "name": "startDkimDts",
            "baseName": "start_dkim_dts",
            "type": "string"
        },
        {
            "name": "startIdentityDts",
            "baseName": "start_identity_dts",
            "type": "string"
        },
        {
            "name": "verification",
            "baseName": "verification",
            "type": "VerificationRecord"
        }    ];

    static getAttributeTypeMap() {
        return EmailDomain.attributeTypeMap;
    }
}

export class EmailEditorTokenResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'token'?: string;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailEditorTokenResponse.attributeTypeMap;
    }
}

export class EmailFlow {
    /**
    * True if a customer may be enrolled in this flow multiple times
    */
    'allowMultipleConcurrentEnrollments'?: boolean;
    /**
    * True if the flow is currently performing a back population.
    */
    'backPopulating'?: boolean;
    /**
    * Click rate of emails, formatted
    */
    'clickRateFormatted'?: string;
    /**
    * Created date
    */
    'createdDts'?: string;
    /**
    * True if this campaign was deleted
    */
    'deleted'?: boolean;
    /**
    * Email communication sequence UUID
    */
    'emailCommunicationSequenceUuid'?: string;
    /**
    * Email flow UUID
    */
    'emailFlowUuid'?: string;
    /**
    * True if the customer should end the flow once they purchase
    */
    'endOnceCustomerPurchases'?: boolean;
    /**
    * Number of enrolled customers.
    */
    'enrolledCustomers'?: number;
    /**
    * Username of sending email
    */
    'espDomainUser'?: string;
    /**
    * UUID of sending domain
    */
    'espDomainUuid'?: string;
    /**
    * Friendly name of the sending email
    */
    'espFriendlyName'?: string;
    /**
    * File profile equation json
    */
    'filterProfileEquationJson'?: string;
    /**
    * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
    */
    'libraryItemOid'?: number;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Name of email flow
    */
    'name'?: string;
    /**
    * Open rate of emails, formatted
    */
    'openRateFormatted'?: string;
    /**
    * Revenue, formatted
    */
    'revenueFormatted'?: string;
    /**
    * URL to a large full length screenshot
    */
    'screenshotLargeFullUrl'?: string;
    /**
    * Status of the campaign of draft, archived, active, and inactive
    */
    'status'?: string;
    /**
    * Timestamp when the last status change happened
    */
    'statusDts'?: string;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * Trigger parameter
    */
    'triggerParameter'?: string;
    /**
    * Trigger parameter name
    */
    'triggerParameterName'?: string;
    /**
    * Trigger type
    */
    'triggerType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowMultipleConcurrentEnrollments",
            "baseName": "allow_multiple_concurrent_enrollments",
            "type": "boolean"
        },
        {
            "name": "backPopulating",
            "baseName": "back_populating",
            "type": "boolean"
        },
        {
            "name": "clickRateFormatted",
            "baseName": "click_rate_formatted",
            "type": "string"
        },
        {
            "name": "createdDts",
            "baseName": "created_dts",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "emailCommunicationSequenceUuid",
            "baseName": "email_communication_sequence_uuid",
            "type": "string"
        },
        {
            "name": "emailFlowUuid",
            "baseName": "email_flow_uuid",
            "type": "string"
        },
        {
            "name": "endOnceCustomerPurchases",
            "baseName": "end_once_customer_purchases",
            "type": "boolean"
        },
        {
            "name": "enrolledCustomers",
            "baseName": "enrolled_customers",
            "type": "number"
        },
        {
            "name": "espDomainUser",
            "baseName": "esp_domain_user",
            "type": "string"
        },
        {
            "name": "espDomainUuid",
            "baseName": "esp_domain_uuid",
            "type": "string"
        },
        {
            "name": "espFriendlyName",
            "baseName": "esp_friendly_name",
            "type": "string"
        },
        {
            "name": "filterProfileEquationJson",
            "baseName": "filter_profile_equation_json",
            "type": "string"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "openRateFormatted",
            "baseName": "open_rate_formatted",
            "type": "string"
        },
        {
            "name": "revenueFormatted",
            "baseName": "revenue_formatted",
            "type": "string"
        },
        {
            "name": "screenshotLargeFullUrl",
            "baseName": "screenshot_large_full_url",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "statusDts",
            "baseName": "status_dts",
            "type": "string"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "triggerParameter",
            "baseName": "trigger_parameter",
            "type": "string"
        },
        {
            "name": "triggerParameterName",
            "baseName": "trigger_parameter_name",
            "type": "string"
        },
        {
            "name": "triggerType",
            "baseName": "trigger_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailFlow.attributeTypeMap;
    }
}

export class EmailFlowBackPopulateRequest {
    /**
    * The age of the orders that should be considered for order triggers.
    */
    'orderDaysOld'?: number;
    /**
    * True if the age of the event should be considered when reducing the initial flow wait step
    */
    'relativeToEvent'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderDaysOld",
            "baseName": "order_days_old",
            "type": "number"
        },
        {
            "name": "relativeToEvent",
            "baseName": "relative_to_event",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EmailFlowBackPopulateRequest.attributeTypeMap;
    }
}

export class EmailFlowBackPopulateResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailFlowBackPopulateResponse.attributeTypeMap;
    }
}

export class EmailFlowResponse {
    'error'?: Error;
    'flow'?: EmailFlow;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "flow",
            "baseName": "flow",
            "type": "EmailFlow"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailFlowResponse.attributeTypeMap;
    }
}

export class EmailFlowsResponse {
    'error'?: Error;
    'flows'?: Array<EmailFlow>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "flows",
            "baseName": "flows",
            "type": "Array<EmailFlow>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailFlowsResponse.attributeTypeMap;
    }
}

export class EmailGlobalSettings {
    'dedicatedIp'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dedicatedIp",
            "baseName": "dedicated_ip",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EmailGlobalSettings.attributeTypeMap;
    }
}

export class EmailGlobalSettingsResponse {
    'error'?: Error;
    'globalSettings'?: EmailGlobalSettings;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "globalSettings",
            "baseName": "global_settings",
            "type": "EmailGlobalSettings"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailGlobalSettingsResponse.attributeTypeMap;
    }
}

export class EmailGlobalUnsubscribeRequest {
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailGlobalUnsubscribeRequest.attributeTypeMap;
    }
}

export class EmailGlobalUnsubscribeResponse {
    'listsUnsubscribed'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "listsUnsubscribed",
            "baseName": "listsUnsubscribed",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailGlobalUnsubscribeResponse.attributeTypeMap;
    }
}

export class EmailHistogramPropertyNamesResponse {
    'propertyNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "propertyNames",
            "baseName": "property_names",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EmailHistogramPropertyNamesResponse.attributeTypeMap;
    }
}

export class EmailHistogramPropertyValuesResponse {
    'propertyValues'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "propertyValues",
            "baseName": "property_values",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EmailHistogramPropertyValuesResponse.attributeTypeMap;
    }
}

export class EmailList {
    /**
    * True if the current user has the rights to download this list.
    */
    'allowCsvDownload'?: boolean;
    /**
    * Created date
    */
    'createdDts'?: string;
    /**
    * True if this campaign was deleted
    */
    'deleted'?: boolean;
    /**
    * Email list UUID
    */
    'emailListUuid'?: string;
    /**
    * Count of members in this list
    */
    'memberCount'?: number;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Name of email list
    */
    'name'?: string;
    /**
    * Description of list shown to customer.
    */
    'publicDescription'?: string;
    /**
    * True if this list is public
    */
    'publicList'?: boolean;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * Details on the flows or campaigns that use this list.
    */
    'usedBy'?: Array<EmailListSegmentUsedBy>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowCsvDownload",
            "baseName": "allow_csv_download",
            "type": "boolean"
        },
        {
            "name": "createdDts",
            "baseName": "created_dts",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "emailListUuid",
            "baseName": "email_list_uuid",
            "type": "string"
        },
        {
            "name": "memberCount",
            "baseName": "member_count",
            "type": "number"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "publicDescription",
            "baseName": "public_description",
            "type": "string"
        },
        {
            "name": "publicList",
            "baseName": "public_list",
            "type": "boolean"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "usedBy",
            "baseName": "used_by",
            "type": "Array<EmailListSegmentUsedBy>"
        }    ];

    static getAttributeTypeMap() {
        return EmailList.attributeTypeMap;
    }
}

export class EmailListArchiveResponse {
    'error'?: Error;
    'listInUse'?: boolean;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "listInUse",
            "baseName": "list_in_use",
            "type": "boolean"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailListArchiveResponse.attributeTypeMap;
    }
}

export class EmailListCustomer {
    /**
    * Added timestamp
    */
    'addDts'?: string;
    /**
    * Email
    */
    'email'?: string;
    /**
    * Email customer UUID
    */
    'emailCustomerUuid'?: string;
    /**
    * Email list member UUID
    */
    'emailListMemberUuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addDts",
            "baseName": "add_dts",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailCustomerUuid",
            "baseName": "email_customer_uuid",
            "type": "string"
        },
        {
            "name": "emailListMemberUuid",
            "baseName": "email_list_member_uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailListCustomer.attributeTypeMap;
    }
}

export class EmailListCustomersResponse {
    /**
    * Customers on the page
    */
    'customers'?: Array<EmailListCustomer>;
    /**
    * Page number (one based offset)
    */
    'pageNumber'?: number;
    /**
    * Number of records per page
    */
    'pageSize'?: number;
    /**
    * Total customers
    */
    'totalCustomers'?: number;
    /**
    * Total number of pages
    */
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customers",
            "baseName": "customers",
            "type": "Array<EmailListCustomer>"
        },
        {
            "name": "pageNumber",
            "baseName": "page_number",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "page_size",
            "type": "number"
        },
        {
            "name": "totalCustomers",
            "baseName": "total_customers",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailListCustomersResponse.attributeTypeMap;
    }
}

export class EmailListResponse {
    'error'?: Error;
    'list'?: EmailList;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "list",
            "baseName": "list",
            "type": "EmailList"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailListResponse.attributeTypeMap;
    }
}

export class EmailListSegmentMembership {
    /**
    * UUID identifying this email list or null if this is a segment
    */
    'emailListUuid'?: string;
    /**
    * UUID identifying this email segment or null if this is a list
    */
    'emailSegmentUuid'?: string;
    /**
    * true if customers from this list/segment is excluded from membership
    */
    'exclude'?: boolean;
    /**
    * Name of this email list or segment
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailListUuid",
            "baseName": "email_list_uuid",
            "type": "string"
        },
        {
            "name": "emailSegmentUuid",
            "baseName": "email_segment_uuid",
            "type": "string"
        },
        {
            "name": "exclude",
            "baseName": "exclude",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailListSegmentMembership.attributeTypeMap;
    }
}

export class EmailListSegmentUsedBy {
    /**
    * Email campaign UUID
    */
    'emailCampaignUuid'?: string;
    /**
    * Email flow UUID
    */
    'emailFlowUuid'?: string;
    /**
    * Name of the list or segment.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailCampaignUuid",
            "baseName": "email_campaign_uuid",
            "type": "string"
        },
        {
            "name": "emailFlowUuid",
            "baseName": "email_flow_uuid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailListSegmentUsedBy.attributeTypeMap;
    }
}

export class EmailListSubscribeResponse {
    'added'?: number;
    'memberCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "added",
            "baseName": "added",
            "type": "number"
        },
        {
            "name": "memberCount",
            "baseName": "memberCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailListSubscribeResponse.attributeTypeMap;
    }
}

export class EmailListsResponse {
    'error'?: Error;
    'lists'?: Array<EmailList>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<EmailList>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailListsResponse.attributeTypeMap;
    }
}

export class EmailOrder {
    /**
    * email
    */
    'email'?: string;
    /**
    * order_dts
    */
    'orderDts'?: string;
    /**
    * order_id
    */
    'orderId'?: string;
    'total'?: Currency;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "orderDts",
            "baseName": "order_dts",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Currency"
        }    ];

    static getAttributeTypeMap() {
        return EmailOrder.attributeTypeMap;
    }
}

export class EmailOrdersResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'orders'?: Array<EmailOrder>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "orders",
            "baseName": "orders",
            "type": "Array<EmailOrder>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailOrdersResponse.attributeTypeMap;
    }
}

export class EmailPerformance {
    /**
    * Active customers.  The value will be -1 if calculation is pending.
    */
    'activeCustomers'?: number;
    /**
    * Actual customers that they have regardless of active state.  The value will be -1 if calculation is pending.
    */
    'actualCustomers'?: number;
    /**
    * Bounce count
    */
    'bounceCount'?: number;
    /**
    * bounce percentage rate based upon our look back window.  This should be under five percent or the account will be paused for sending.
    */
    'bouncePercentage'?: number;
    /**
    * bounce percentage rate (formatted) based upon our look back window.  This should be under five percent or the account will be paused for sending.
    */
    'bouncePercentageFormatted'?: string;
    'customerHistogram'?: EmailPerformanceCustomerHistogram;
    /**
    * Daily statistics used for charting
    */
    'dailyStats'?: Array<EmailPerformanceDaily>;
    /**
    * Delivered count
    */
    'deliveredCount'?: number;
    /**
    * Maximum active customers allowed under their billing plan
    */
    'maxActiveCustomers'?: number;
    /**
    * Max emails per day
    */
    'maxEmailsPerDay'?: number;
    /**
    * Max emails per hour
    */
    'maxEmailsPerHour'?: number;
    /**
    * Max emails per month
    */
    'maxEmailsPerMonth'?: number;
    /**
    * True if campaign/flow emails are paused due to spam complaints.
    */
    'pausedForSpam'?: boolean;
    /**
    * Revenue
    */
    'revenue'?: number;
    /**
    * Sent emails last 24 hours
    */
    'sentEmailsPerDay'?: number;
    /**
    * Sent emails last hour
    */
    'sentEmailsPerHour'?: number;
    /**
    * Sent emails last 31 days
    */
    'sentEmailsPerMonth'?: number;
    /**
    * Total sequence (campaign/flow) emails sent
    */
    'sequenceSendCount'?: number;
    /**
    * Spam complaints
    */
    'spamCount'?: number;
    /**
    * Spam percentage rate based upon our look back window.  This should be under one half a percent or the account will be paused for sending.
    */
    'spamPercentage'?: number;
    /**
    * Spam percentage rate (formatted) based upon our look back window.  This should be under one half a percent or the account will be paused for sending.
    */
    'spamPercentageFormatted'?: string;
    /**
    * Total transactions emails sent
    */
    'transactionalSendCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeCustomers",
            "baseName": "active_customers",
            "type": "number"
        },
        {
            "name": "actualCustomers",
            "baseName": "actual_customers",
            "type": "number"
        },
        {
            "name": "bounceCount",
            "baseName": "bounce_count",
            "type": "number"
        },
        {
            "name": "bouncePercentage",
            "baseName": "bounce_percentage",
            "type": "number"
        },
        {
            "name": "bouncePercentageFormatted",
            "baseName": "bounce_percentage_formatted",
            "type": "string"
        },
        {
            "name": "customerHistogram",
            "baseName": "customer_histogram",
            "type": "EmailPerformanceCustomerHistogram"
        },
        {
            "name": "dailyStats",
            "baseName": "daily_stats",
            "type": "Array<EmailPerformanceDaily>"
        },
        {
            "name": "deliveredCount",
            "baseName": "delivered_count",
            "type": "number"
        },
        {
            "name": "maxActiveCustomers",
            "baseName": "max_active_customers",
            "type": "number"
        },
        {
            "name": "maxEmailsPerDay",
            "baseName": "max_emails_per_day",
            "type": "number"
        },
        {
            "name": "maxEmailsPerHour",
            "baseName": "max_emails_per_hour",
            "type": "number"
        },
        {
            "name": "maxEmailsPerMonth",
            "baseName": "max_emails_per_month",
            "type": "number"
        },
        {
            "name": "pausedForSpam",
            "baseName": "paused_for_spam",
            "type": "boolean"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "sentEmailsPerDay",
            "baseName": "sent_emails_per_day",
            "type": "number"
        },
        {
            "name": "sentEmailsPerHour",
            "baseName": "sent_emails_per_hour",
            "type": "number"
        },
        {
            "name": "sentEmailsPerMonth",
            "baseName": "sent_emails_per_month",
            "type": "number"
        },
        {
            "name": "sequenceSendCount",
            "baseName": "sequence_send_count",
            "type": "number"
        },
        {
            "name": "spamCount",
            "baseName": "spam_count",
            "type": "number"
        },
        {
            "name": "spamPercentage",
            "baseName": "spam_percentage",
            "type": "number"
        },
        {
            "name": "spamPercentageFormatted",
            "baseName": "spam_percentage_formatted",
            "type": "string"
        },
        {
            "name": "transactionalSendCount",
            "baseName": "transactional_send_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailPerformance.attributeTypeMap;
    }
}

export class EmailPerformanceCustomerHistogram {
    /**
    * Periods (newest to oldest)
    */
    'periods'?: Array<EmailPerformanceCustomerHistogramPeriod>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "periods",
            "baseName": "periods",
            "type": "Array<EmailPerformanceCustomerHistogramPeriod>"
        }    ];

    static getAttributeTypeMap() {
        return EmailPerformanceCustomerHistogram.attributeTypeMap;
    }
}

export class EmailPerformanceCustomerHistogramPeriod {
    /**
    * Active customers last active in this period
    */
    'active'?: number;
    /**
    * Inactive customers last active in this period
    */
    'inactive'?: number;
    /**
    * Month (1 = January)
    */
    'month'?: number;
    /**
    * Total customers last active in this period
    */
    'total'?: number;
    /**
    * Year (four digits)
    */
    'year'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "number"
        },
        {
            "name": "inactive",
            "baseName": "inactive",
            "type": "number"
        },
        {
            "name": "month",
            "baseName": "month",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "year",
            "baseName": "year",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailPerformanceCustomerHistogramPeriod.attributeTypeMap;
    }
}

export class EmailPerformanceDaily {
    /**
    * Bounce count
    */
    'bounceCount'?: number;
    /**
    * Delivered count
    */
    'deliveredCount'?: number;
    /**
    * Revenue
    */
    'revenue'?: number;
    /**
    * Total sequence (campaign/flow) emails sent
    */
    'sequenceSendCount'?: number;
    /**
    * Spam complaints
    */
    'spamCount'?: number;
    /**
    * The date that these statistcs are for
    */
    'statDts'?: string;
    /**
    * Total transactions emails sent
    */
    'transactionalSendCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bounceCount",
            "baseName": "bounce_count",
            "type": "number"
        },
        {
            "name": "deliveredCount",
            "baseName": "delivered_count",
            "type": "number"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "sequenceSendCount",
            "baseName": "sequence_send_count",
            "type": "number"
        },
        {
            "name": "spamCount",
            "baseName": "spam_count",
            "type": "number"
        },
        {
            "name": "statDts",
            "baseName": "stat_dts",
            "type": "string"
        },
        {
            "name": "transactionalSendCount",
            "baseName": "transactional_send_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailPerformanceDaily.attributeTypeMap;
    }
}

export class EmailPerformanceResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'performance'?: EmailPerformance;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "performance",
            "baseName": "performance",
            "type": "EmailPerformance"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailPerformanceResponse.attributeTypeMap;
    }
}

export class EmailPlan {
    'additionalCustomers'?: number;
    'additionalEmails'?: number;
    'allowListImport'?: boolean;
    'allowTrackingEmails'?: boolean;
    'customerTiers'?: Array<EmailPlanAdditional>;
    'initialSendingLimits'?: number;
    'planCustomers'?: number;
    'planEmails'?: number;
    'planName'?: string;
    'planNameFormatted'?: string;
    'requireOrderWithinLastDays'?: number;
    'revenuePercent'?: number;
    'spamPercentLimit'?: number;
    'totalCustomers'?: number;
    'totalEmails'?: number;
    'upgradeTo'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalCustomers",
            "baseName": "additional_customers",
            "type": "number"
        },
        {
            "name": "additionalEmails",
            "baseName": "additional_emails",
            "type": "number"
        },
        {
            "name": "allowListImport",
            "baseName": "allow_list_import",
            "type": "boolean"
        },
        {
            "name": "allowTrackingEmails",
            "baseName": "allow_tracking_emails",
            "type": "boolean"
        },
        {
            "name": "customerTiers",
            "baseName": "customer_tiers",
            "type": "Array<EmailPlanAdditional>"
        },
        {
            "name": "initialSendingLimits",
            "baseName": "initial_sending_limits",
            "type": "number"
        },
        {
            "name": "planCustomers",
            "baseName": "plan_customers",
            "type": "number"
        },
        {
            "name": "planEmails",
            "baseName": "plan_emails",
            "type": "number"
        },
        {
            "name": "planName",
            "baseName": "plan_name",
            "type": "string"
        },
        {
            "name": "planNameFormatted",
            "baseName": "plan_name_formatted",
            "type": "string"
        },
        {
            "name": "requireOrderWithinLastDays",
            "baseName": "require_order_within_last_days",
            "type": "number"
        },
        {
            "name": "revenuePercent",
            "baseName": "revenue_percent",
            "type": "number"
        },
        {
            "name": "spamPercentLimit",
            "baseName": "spam_percent_limit",
            "type": "number"
        },
        {
            "name": "totalCustomers",
            "baseName": "total_customers",
            "type": "number"
        },
        {
            "name": "totalEmails",
            "baseName": "total_emails",
            "type": "number"
        },
        {
            "name": "upgradeTo",
            "baseName": "upgrade_to",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailPlan.attributeTypeMap;
    }
}

export class EmailPlanAdditional {
    'canDowngrade'?: boolean;
    'canUpgrade'?: boolean;
    'cost'?: number;
    'costFormatted'?: string;
    'customers'?: number;
    'emails'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canDowngrade",
            "baseName": "can_downgrade",
            "type": "boolean"
        },
        {
            "name": "canUpgrade",
            "baseName": "can_upgrade",
            "type": "boolean"
        },
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        },
        {
            "name": "costFormatted",
            "baseName": "cost_formatted",
            "type": "string"
        },
        {
            "name": "customers",
            "baseName": "customers",
            "type": "number"
        },
        {
            "name": "emails",
            "baseName": "emails",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailPlanAdditional.attributeTypeMap;
    }
}

export class EmailPlanResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'plan'?: EmailPlan;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "plan",
            "baseName": "plan",
            "type": "EmailPlan"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailPlanResponse.attributeTypeMap;
    }
}

export class EmailPostcardStat {
    /**
    * Count of clicked emails
    */
    'clickCount'?: number;
    /**
    * Count of clicked emails, formatted
    */
    'clickCountFormatted'?: string;
    /**
    * Count of conversions
    */
    'conversionCount'?: number;
    /**
    * Count of conversions, formatted
    */
    'conversionCountFormatted'?: string;
    /**
    * Count of delivered emails
    */
    'deliveredCount'?: number;
    /**
    * Count of delivered emails, formatted
    */
    'deliveredCountFormatted'?: string;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * List or segment name
    */
    'name'?: string;
    /**
    * Count of orders
    */
    'orderCount'?: number;
    /**
    * Count of orders, formatted
    */
    'orderCountFormatted'?: string;
    /**
    * Profit
    */
    'profit'?: number;
    /**
    * Profit, formatted
    */
    'profitFormatted'?: string;
    /**
    * Count of return to sender
    */
    'returnToSenderCount'?: number;
    /**
    * Count of return to sender, formatted
    */
    'returnToSenderCountFormatted'?: string;
    /**
    * Revenue
    */
    'revenue'?: number;
    /**
    * Revenue, formatted
    */
    'revenueFormatted'?: string;
    /**
    * Count of emails sent
    */
    'sendCount'?: number;
    /**
    * Count of emails sent, formatted
    */
    'sendCountFormatted'?: string;
    /**
    * Count of skipped emails
    */
    'skippedCount'?: number;
    /**
    * Count of skipped emails, formatted
    */
    'skippedCountFormatted'?: string;
    /**
    * Count of emails classified as spam
    */
    'spamCount'?: number;
    /**
    * Count of emails classified as spam, formatted
    */
    'spamCountFormatted'?: string;
    /**
    * Campaign, Flow or None (for anything else)
    */
    'statType'?: string;
    /**
    * Status of campaign or flow
    */
    'status'?: string;
    /**
    * Status dts of campaign or flow
    */
    'statusDts'?: string;
    'steps'?: Array<EmailPostcardStat>;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * Count of emails classified as unsubscribe
    */
    'unsubscribeCount'?: number;
    /**
    * Count of emails classified as unsubscribe, formatted
    */
    'unsubscribeCountFormatted'?: string;
    /**
    * List or segment uuid
    */
    'uuid'?: string;
    /**
    * Count of views
    */
    'viewCount'?: number;
    /**
    * Count of views, formatted
    */
    'viewCountFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clickCount",
            "baseName": "click_count",
            "type": "number"
        },
        {
            "name": "clickCountFormatted",
            "baseName": "click_count_formatted",
            "type": "string"
        },
        {
            "name": "conversionCount",
            "baseName": "conversion_count",
            "type": "number"
        },
        {
            "name": "conversionCountFormatted",
            "baseName": "conversion_count_formatted",
            "type": "string"
        },
        {
            "name": "deliveredCount",
            "baseName": "delivered_count",
            "type": "number"
        },
        {
            "name": "deliveredCountFormatted",
            "baseName": "delivered_count_formatted",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "orderCount",
            "baseName": "order_count",
            "type": "number"
        },
        {
            "name": "orderCountFormatted",
            "baseName": "order_count_formatted",
            "type": "string"
        },
        {
            "name": "profit",
            "baseName": "profit",
            "type": "number"
        },
        {
            "name": "profitFormatted",
            "baseName": "profit_formatted",
            "type": "string"
        },
        {
            "name": "returnToSenderCount",
            "baseName": "return_to_sender_count",
            "type": "number"
        },
        {
            "name": "returnToSenderCountFormatted",
            "baseName": "return_to_sender_count_formatted",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "revenueFormatted",
            "baseName": "revenue_formatted",
            "type": "string"
        },
        {
            "name": "sendCount",
            "baseName": "send_count",
            "type": "number"
        },
        {
            "name": "sendCountFormatted",
            "baseName": "send_count_formatted",
            "type": "string"
        },
        {
            "name": "skippedCount",
            "baseName": "skipped_count",
            "type": "number"
        },
        {
            "name": "skippedCountFormatted",
            "baseName": "skipped_count_formatted",
            "type": "string"
        },
        {
            "name": "spamCount",
            "baseName": "spam_count",
            "type": "number"
        },
        {
            "name": "spamCountFormatted",
            "baseName": "spam_count_formatted",
            "type": "string"
        },
        {
            "name": "statType",
            "baseName": "stat_type",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "statusDts",
            "baseName": "status_dts",
            "type": "string"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<EmailPostcardStat>"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "unsubscribeCount",
            "baseName": "unsubscribe_count",
            "type": "number"
        },
        {
            "name": "unsubscribeCountFormatted",
            "baseName": "unsubscribe_count_formatted",
            "type": "string"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        },
        {
            "name": "viewCount",
            "baseName": "view_count",
            "type": "number"
        },
        {
            "name": "viewCountFormatted",
            "baseName": "view_count_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailPostcardStat.attributeTypeMap;
    }
}

export class EmailSegment {
    /**
    * True if the current user has the rights to download this segment.
    */
    'allowCsvDownload'?: boolean;
    /**
    * True if this StoreFront has the Facebook Analytics app connected and supports them
    */
    'allowFacebookAudiences'?: boolean;
    /**
    * Created date
    */
    'createdDts'?: string;
    /**
    * True if this campaign was deleted
    */
    'deleted'?: boolean;
    /**
    * Email segment UUID
    */
    'emailSegmentUuid'?: string;
    /**
    * True if you want to sync to a facebook custom audience
    */
    'facebookCustomAudience'?: boolean;
    /**
    * File profile equation json
    */
    'filterProfileEquationJson'?: string;
    /**
    * Count of members in this segment
    */
    'memberCount'?: number;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Name of email segment
    */
    'name'?: string;
    /**
    * Rank settings json
    */
    'rankJson'?: string;
    /**
    * True if a rebuild is required because some part of the segment has changed
    */
    'rebuildRequired'?: boolean;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * Details on the flows or campaigns that use this list.
    */
    'usedBy'?: Array<EmailListSegmentUsedBy>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowCsvDownload",
            "baseName": "allow_csv_download",
            "type": "boolean"
        },
        {
            "name": "allowFacebookAudiences",
            "baseName": "allow_facebook_audiences",
            "type": "boolean"
        },
        {
            "name": "createdDts",
            "baseName": "created_dts",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "emailSegmentUuid",
            "baseName": "email_segment_uuid",
            "type": "string"
        },
        {
            "name": "facebookCustomAudience",
            "baseName": "facebook_custom_audience",
            "type": "boolean"
        },
        {
            "name": "filterProfileEquationJson",
            "baseName": "filter_profile_equation_json",
            "type": "string"
        },
        {
            "name": "memberCount",
            "baseName": "member_count",
            "type": "number"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "rankJson",
            "baseName": "rank_json",
            "type": "string"
        },
        {
            "name": "rebuildRequired",
            "baseName": "rebuild_required",
            "type": "boolean"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "usedBy",
            "baseName": "used_by",
            "type": "Array<EmailListSegmentUsedBy>"
        }    ];

    static getAttributeTypeMap() {
        return EmailSegment.attributeTypeMap;
    }
}

export class EmailSegmentArchiveResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'segmentInUse'?: boolean;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "segmentInUse",
            "baseName": "segment_in_use",
            "type": "boolean"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailSegmentArchiveResponse.attributeTypeMap;
    }
}

export class EmailSegmentCustomer {
    /**
    * Added timestamp
    */
    'addDts'?: string;
    /**
    * Email
    */
    'email'?: string;
    /**
    * Email customer UUID
    */
    'emailCustomerUuid'?: string;
    /**
    * Email segment member UUID
    */
    'emailSegmentMemberUuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addDts",
            "baseName": "add_dts",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailCustomerUuid",
            "baseName": "email_customer_uuid",
            "type": "string"
        },
        {
            "name": "emailSegmentMemberUuid",
            "baseName": "email_segment_member_uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailSegmentCustomer.attributeTypeMap;
    }
}

export class EmailSegmentCustomersResponse {
    /**
    * Customers on the page
    */
    'customers'?: Array<EmailSegmentCustomer>;
    /**
    * Page number (one based offset)
    */
    'pageNumber'?: number;
    /**
    * Number of records per page
    */
    'pageSize'?: number;
    /**
    * Total customers
    */
    'totalCustomers'?: number;
    /**
    * Total number of pages
    */
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customers",
            "baseName": "customers",
            "type": "Array<EmailSegmentCustomer>"
        },
        {
            "name": "pageNumber",
            "baseName": "page_number",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "page_size",
            "type": "number"
        },
        {
            "name": "totalCustomers",
            "baseName": "total_customers",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailSegmentCustomersResponse.attributeTypeMap;
    }
}

export class EmailSegmentDownloadPrepareResponse {
    'emailSegmentRebuildUuid'?: string;
    'emailSegmentUuid'?: string;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'percentageComplete'?: number;
    'proceed'?: boolean;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailSegmentRebuildUuid",
            "baseName": "email_segment_rebuild_uuid",
            "type": "string"
        },
        {
            "name": "emailSegmentUuid",
            "baseName": "email_segment_uuid",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "percentageComplete",
            "baseName": "percentage_complete",
            "type": "number"
        },
        {
            "name": "proceed",
            "baseName": "proceed",
            "type": "boolean"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailSegmentDownloadPrepareResponse.attributeTypeMap;
    }
}

export class EmailSegmentResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'segment'?: EmailSegment;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "segment",
            "baseName": "segment",
            "type": "EmailSegment"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailSegmentResponse.attributeTypeMap;
    }
}

export class EmailSegmentsResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'segments'?: Array<EmailSegment>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "segments",
            "baseName": "segments",
            "type": "Array<EmailSegment>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailSegmentsResponse.attributeTypeMap;
    }
}

export class EmailSendingDomainResponse {
    'domain'?: EmailDomain;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domain",
            "baseName": "domain",
            "type": "EmailDomain"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailSendingDomainResponse.attributeTypeMap;
    }
}

export class EmailSendingDomainsResponse {
    'domains'?: Array<EmailDomain>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domains",
            "baseName": "domains",
            "type": "Array<EmailDomain>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailSendingDomainsResponse.attributeTypeMap;
    }
}

export class EmailSettings {
    'marketingEspDomainUser'?: string;
    'marketingEspDomainUuid'?: string;
    'marketingEspFriendlyName'?: string;
    'postcardFromAddress1'?: string;
    'postcardFromAddress2'?: string;
    'postcardFromCity'?: string;
    'postcardFromName'?: string;
    'postcardFromPostalCode'?: string;
    'postcardFromState'?: string;
    'transactionalEspDomainUser'?: string;
    'transactionalEspDomainUuid'?: string;
    'transactionalEspFriendlyName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "marketingEspDomainUser",
            "baseName": "marketing_esp_domain_user",
            "type": "string"
        },
        {
            "name": "marketingEspDomainUuid",
            "baseName": "marketing_esp_domain_uuid",
            "type": "string"
        },
        {
            "name": "marketingEspFriendlyName",
            "baseName": "marketing_esp_friendly_name",
            "type": "string"
        },
        {
            "name": "postcardFromAddress1",
            "baseName": "postcard_from_address1",
            "type": "string"
        },
        {
            "name": "postcardFromAddress2",
            "baseName": "postcard_from_address2",
            "type": "string"
        },
        {
            "name": "postcardFromCity",
            "baseName": "postcard_from_city",
            "type": "string"
        },
        {
            "name": "postcardFromName",
            "baseName": "postcard_from_name",
            "type": "string"
        },
        {
            "name": "postcardFromPostalCode",
            "baseName": "postcard_from_postal_code",
            "type": "string"
        },
        {
            "name": "postcardFromState",
            "baseName": "postcard_from_state",
            "type": "string"
        },
        {
            "name": "transactionalEspDomainUser",
            "baseName": "transactional_esp_domain_user",
            "type": "string"
        },
        {
            "name": "transactionalEspDomainUuid",
            "baseName": "transactional_esp_domain_uuid",
            "type": "string"
        },
        {
            "name": "transactionalEspFriendlyName",
            "baseName": "transactional_esp_friendly_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailSettings.attributeTypeMap;
    }
}

export class EmailSettingsResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'settings'?: EmailSettings;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "EmailSettings"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailSettingsResponse.attributeTypeMap;
    }
}

export class EmailStat {
    /**
    * Count of clicked emails
    */
    'clickCount'?: number;
    /**
    * Count of clicked emails, formatted
    */
    'clickCountFormatted'?: string;
    /**
    * Count of conversions
    */
    'conversionCount'?: number;
    /**
    * Count of conversions, formatted
    */
    'conversionCountFormatted'?: string;
    /**
    * True if campaign/flow has been archived
    */
    'deleted'?: boolean;
    /**
    * Count of delivered emails
    */
    'deliveredCount'?: number;
    /**
    * Count of delivered emails, formatted
    */
    'deliveredCountFormatted'?: string;
    /**
    * Count of emails kicked
    */
    'kickboxCount'?: number;
    /**
    * Count of emails kicked, formatted
    */
    'kickboxCountFormatted'?: string;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * List or segment name
    */
    'name'?: string;
    /**
    * Count of opened emails
    */
    'openCount'?: number;
    /**
    * Count of opened emails, formatted
    */
    'openCountFormatted'?: string;
    /**
    * Count of orders
    */
    'orderCount'?: number;
    /**
    * Count of orders, formatted
    */
    'orderCountFormatted'?: string;
    /**
    * Count of emails permanently bounced
    */
    'permanentBounceCount'?: number;
    /**
    * Count of emails permanently bounced, formatted
    */
    'permanentBounceCountFormatted'?: string;
    /**
    * Profit
    */
    'profit'?: number;
    /**
    * Profit, formatted
    */
    'profitFormatted'?: string;
    /**
    * Revenue
    */
    'revenue'?: number;
    /**
    * Revenue, formatted
    */
    'revenueFormatted'?: string;
    /**
    * Count of emails sent
    */
    'sendCount'?: number;
    /**
    * Count of emails sent, formatted
    */
    'sendCountFormatted'?: string;
    /**
    * Count of skipped emails
    */
    'skippedCount'?: number;
    /**
    * Count of skipped emails, formatted
    */
    'skippedCountFormatted'?: string;
    /**
    * Count of emails classified as spam
    */
    'spamCount'?: number;
    /**
    * Count of emails classified as spam, formatted
    */
    'spamCountFormatted'?: string;
    /**
    * Campaign, Flow or None (for anything else)
    */
    'statType'?: string;
    /**
    * Status of campaign or flow
    */
    'status'?: string;
    /**
    * Status dts of campaign or flow
    */
    'statusDts'?: string;
    /**
    * Step UUID if the statistics are at the step/email level
    */
    'stepUuid'?: string;
    'steps'?: Array<EmailStat>;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * Count of emails classified as unsubscribe
    */
    'unsubscribeCount'?: number;
    /**
    * Count of emails classified as unsubscribe, formatted
    */
    'unsubscribeCountFormatted'?: string;
    /**
    * List/Segment uuid, or Flow/Campaign uuid depending on level of stat aggregation.
    */
    'uuid'?: string;
    /**
    * Count of views
    */
    'viewCount'?: number;
    /**
    * Count of views, formatted
    */
    'viewCountFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clickCount",
            "baseName": "click_count",
            "type": "number"
        },
        {
            "name": "clickCountFormatted",
            "baseName": "click_count_formatted",
            "type": "string"
        },
        {
            "name": "conversionCount",
            "baseName": "conversion_count",
            "type": "number"
        },
        {
            "name": "conversionCountFormatted",
            "baseName": "conversion_count_formatted",
            "type": "string"
        },
        {
            "name": "deleted",
            "baseName": "deleted",
            "type": "boolean"
        },
        {
            "name": "deliveredCount",
            "baseName": "delivered_count",
            "type": "number"
        },
        {
            "name": "deliveredCountFormatted",
            "baseName": "delivered_count_formatted",
            "type": "string"
        },
        {
            "name": "kickboxCount",
            "baseName": "kickbox_count",
            "type": "number"
        },
        {
            "name": "kickboxCountFormatted",
            "baseName": "kickbox_count_formatted",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "openCount",
            "baseName": "open_count",
            "type": "number"
        },
        {
            "name": "openCountFormatted",
            "baseName": "open_count_formatted",
            "type": "string"
        },
        {
            "name": "orderCount",
            "baseName": "order_count",
            "type": "number"
        },
        {
            "name": "orderCountFormatted",
            "baseName": "order_count_formatted",
            "type": "string"
        },
        {
            "name": "permanentBounceCount",
            "baseName": "permanent_bounce_count",
            "type": "number"
        },
        {
            "name": "permanentBounceCountFormatted",
            "baseName": "permanent_bounce_count_formatted",
            "type": "string"
        },
        {
            "name": "profit",
            "baseName": "profit",
            "type": "number"
        },
        {
            "name": "profitFormatted",
            "baseName": "profit_formatted",
            "type": "string"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "revenueFormatted",
            "baseName": "revenue_formatted",
            "type": "string"
        },
        {
            "name": "sendCount",
            "baseName": "send_count",
            "type": "number"
        },
        {
            "name": "sendCountFormatted",
            "baseName": "send_count_formatted",
            "type": "string"
        },
        {
            "name": "skippedCount",
            "baseName": "skipped_count",
            "type": "number"
        },
        {
            "name": "skippedCountFormatted",
            "baseName": "skipped_count_formatted",
            "type": "string"
        },
        {
            "name": "spamCount",
            "baseName": "spam_count",
            "type": "number"
        },
        {
            "name": "spamCountFormatted",
            "baseName": "spam_count_formatted",
            "type": "string"
        },
        {
            "name": "statType",
            "baseName": "stat_type",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "statusDts",
            "baseName": "status_dts",
            "type": "string"
        },
        {
            "name": "stepUuid",
            "baseName": "step_uuid",
            "type": "string"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<EmailStat>"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "unsubscribeCount",
            "baseName": "unsubscribe_count",
            "type": "number"
        },
        {
            "name": "unsubscribeCountFormatted",
            "baseName": "unsubscribe_count_formatted",
            "type": "string"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        },
        {
            "name": "viewCount",
            "baseName": "view_count",
            "type": "number"
        },
        {
            "name": "viewCountFormatted",
            "baseName": "view_count_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailStat.attributeTypeMap;
    }
}

export class EmailStatPostcardSummaryRequest {
    'commseqPostcardUuids'?: Array<string>;
    'days'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commseqPostcardUuids",
            "baseName": "commseq_postcard_uuids",
            "type": "Array<string>"
        },
        {
            "name": "days",
            "baseName": "days",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailStatPostcardSummaryRequest.attributeTypeMap;
    }
}

export class EmailStatPostcardSummaryResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'stats'?: Array<EmailPostcardStat>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "Array<EmailPostcardStat>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailStatPostcardSummaryResponse.attributeTypeMap;
    }
}

export class EmailStatSummaryRequest {
    'commseqEmailUuids'?: Array<string>;
    'commseqStepUuids'?: Array<string>;
    'days'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commseqEmailUuids",
            "baseName": "commseq_email_uuids",
            "type": "Array<string>"
        },
        {
            "name": "commseqStepUuids",
            "baseName": "commseq_step_uuids",
            "type": "Array<string>"
        },
        {
            "name": "days",
            "baseName": "days",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailStatSummaryRequest.attributeTypeMap;
    }
}

export class EmailStatSummaryResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'stats'?: Array<EmailStat>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "Array<EmailStat>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailStatSummaryResponse.attributeTypeMap;
    }
}

export class EmailStepStat {
    /**
    * conversion count (left/default side)
    */
    'leftConversionCount'?: number;
    /**
    * conversion count formatted (left/default side)
    */
    'leftConversionCountFormatted'?: string;
    /**
    * customer count (left/default side)
    */
    'leftCustomerCount'?: number;
    /**
    * customer count formatted (left/default side)
    */
    'leftCustomerCountFormatted'?: string;
    /**
    * order count (left/default side)
    */
    'leftOrderCount'?: number;
    /**
    * order count formatted (left/default side)
    */
    'leftOrderCountFormatted'?: string;
    /**
    * profit (left/default side)
    */
    'leftProfit'?: number;
    /**
    * profit formatted (left/default side)
    */
    'leftProfitFormatted'?: string;
    /**
    * revenue (left/default side)
    */
    'leftRevenue'?: number;
    /**
    * revenue formatted (left/default side)
    */
    'leftRevenueFormatted'?: string;
    /**
    * conversion count (right side)
    */
    'rightConversionCount'?: number;
    /**
    * conversion count formatted (right side)
    */
    'rightConversionCountFormatted'?: string;
    /**
    * customer count (right side)
    */
    'rightCustomerCount'?: number;
    /**
    * customer count formatted (right side)
    */
    'rightCustomerCountFormatted'?: string;
    /**
    * order count (right side)
    */
    'rightOrderCount'?: number;
    /**
    * order count formatted (right side)
    */
    'rightOrderCountFormatted'?: string;
    /**
    * profit (right side)
    */
    'rightProfit'?: number;
    /**
    * profit formatted (right side)
    */
    'rightProfitFormatted'?: string;
    /**
    * revenue (right side)
    */
    'rightRevenue'?: number;
    /**
    * revenue formatted (right side)
    */
    'rightRevenueFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "leftConversionCount",
            "baseName": "left_conversion_count",
            "type": "number"
        },
        {
            "name": "leftConversionCountFormatted",
            "baseName": "left_conversion_count_formatted",
            "type": "string"
        },
        {
            "name": "leftCustomerCount",
            "baseName": "left_customer_count",
            "type": "number"
        },
        {
            "name": "leftCustomerCountFormatted",
            "baseName": "left_customer_count_formatted",
            "type": "string"
        },
        {
            "name": "leftOrderCount",
            "baseName": "left_order_count",
            "type": "number"
        },
        {
            "name": "leftOrderCountFormatted",
            "baseName": "left_order_count_formatted",
            "type": "string"
        },
        {
            "name": "leftProfit",
            "baseName": "left_profit",
            "type": "number"
        },
        {
            "name": "leftProfitFormatted",
            "baseName": "left_profit_formatted",
            "type": "string"
        },
        {
            "name": "leftRevenue",
            "baseName": "left_revenue",
            "type": "number"
        },
        {
            "name": "leftRevenueFormatted",
            "baseName": "left_revenue_formatted",
            "type": "string"
        },
        {
            "name": "rightConversionCount",
            "baseName": "right_conversion_count",
            "type": "number"
        },
        {
            "name": "rightConversionCountFormatted",
            "baseName": "right_conversion_count_formatted",
            "type": "string"
        },
        {
            "name": "rightCustomerCount",
            "baseName": "right_customer_count",
            "type": "number"
        },
        {
            "name": "rightCustomerCountFormatted",
            "baseName": "right_customer_count_formatted",
            "type": "string"
        },
        {
            "name": "rightOrderCount",
            "baseName": "right_order_count",
            "type": "number"
        },
        {
            "name": "rightOrderCountFormatted",
            "baseName": "right_order_count_formatted",
            "type": "string"
        },
        {
            "name": "rightProfit",
            "baseName": "right_profit",
            "type": "number"
        },
        {
            "name": "rightProfitFormatted",
            "baseName": "right_profit_formatted",
            "type": "string"
        },
        {
            "name": "rightRevenue",
            "baseName": "right_revenue",
            "type": "number"
        },
        {
            "name": "rightRevenueFormatted",
            "baseName": "right_revenue_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailStepStat.attributeTypeMap;
    }
}

export class EmailStepStatRequest {
    'commseqStepUuids'?: Array<string>;
    'days'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commseqStepUuids",
            "baseName": "commseq_step_uuids",
            "type": "Array<string>"
        },
        {
            "name": "days",
            "baseName": "days",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return EmailStepStatRequest.attributeTypeMap;
    }
}

export class EmailStepStatResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'stats'?: Array<EmailStepStat>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "Array<EmailStepStat>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailStepStatResponse.attributeTypeMap;
    }
}

export class EmailStepWaitingRequest {
    'commseqStepUuids'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commseqStepUuids",
            "baseName": "commseq_step_uuids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EmailStepWaitingRequest.attributeTypeMap;
    }
}

export class EmailStepWaitingResponse {
    'stepWaitings'?: Array<StepWaiting>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stepWaitings",
            "baseName": "step_waitings",
            "type": "Array<StepWaiting>"
        }    ];

    static getAttributeTypeMap() {
        return EmailStepWaitingResponse.attributeTypeMap;
    }
}

export class EmailTemplate {
    /**
    * Container cjson
    */
    'containerCjson'?: string;
    /**
    * Description of email template
    */
    'description'?: string;
    /**
    * Email template oid
    */
    'emailTemplateOid'?: number;
    /**
    * Email Template VM Path
    */
    'emailTemplateVmPath'?: string;
    /**
    * Merchant ID
    */
    'merchantId'?: string;
    /**
    * Name of email template
    */
    'name'?: string;
    /**
    * Amazon key for preview png image
    */
    'previewAmazonListingKey'?: string;
    /**
    * Sort order (optional)
    */
    'sortOrder'?: number;
    /**
    * StoreFront oid
    */
    'storefrontOid'?: number;
    /**
    * True if this email template is system-wide,false if merchant specific
    */
    'system'?: boolean;
    /**
    * Trigger type
    */
    'triggerType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "containerCjson",
            "baseName": "container_cjson",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "emailTemplateOid",
            "baseName": "email_template_oid",
            "type": "number"
        },
        {
            "name": "emailTemplateVmPath",
            "baseName": "email_template_vm_path",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "previewAmazonListingKey",
            "baseName": "preview_amazon_listing_key",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "number"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "system",
            "baseName": "system",
            "type": "boolean"
        },
        {
            "name": "triggerType",
            "baseName": "trigger_type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailTemplate.attributeTypeMap;
    }
}

export class EmailTemplatesResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'templates'?: Array<EmailTemplate>;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "templates",
            "baseName": "templates",
            "type": "Array<EmailTemplate>"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailTemplatesResponse.attributeTypeMap;
    }
}

export class EmailThirdPartyList {
    /**
    * id
    */
    'id'?: string;
    /**
    * name
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailThirdPartyList.attributeTypeMap;
    }
}

export class EmailThirdPartyListImportRequest {
    /**
    * providers
    */
    'providers'?: Array<EmailThirdPartyProvider>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "providers",
            "baseName": "providers",
            "type": "Array<EmailThirdPartyProvider>"
        }    ];

    static getAttributeTypeMap() {
        return EmailThirdPartyListImportRequest.attributeTypeMap;
    }
}

export class EmailThirdPartyProvider {
    /**
    * URL to the settings screen to connect.  Null if the provider is already connected.
    */
    'connectUrl'?: string;
    /**
    * list_count
    */
    'listCount'?: number;
    /**
    * lists
    */
    'lists'?: Array<EmailThirdPartyList>;
    /**
    * logo_url
    */
    'logoUrl'?: string;
    /**
    * name
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectUrl",
            "baseName": "connect_url",
            "type": "string"
        },
        {
            "name": "listCount",
            "baseName": "list_count",
            "type": "number"
        },
        {
            "name": "lists",
            "baseName": "lists",
            "type": "Array<EmailThirdPartyList>"
        },
        {
            "name": "logoUrl",
            "baseName": "logo_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmailThirdPartyProvider.attributeTypeMap;
    }
}

export class EmailThirdPartyProvidersResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'providers'?: Array<EmailThirdPartyProvider>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "providers",
            "baseName": "providers",
            "type": "Array<EmailThirdPartyProvider>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return EmailThirdPartyProvidersResponse.attributeTypeMap;
    }
}

export class ErrorResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ErrorResponse.attributeTypeMap;
    }
}

export class Experiment {
    /**
    * Contained ID where the experiment element was located
    */
    'containerId'?: string;
    /**
    * Duration in days
    */
    'durationDays'?: number;
    /**
    * End date/time
    */
    'endDts'?: string;
    /**
    * Whether or not traffic is equally weighted or shifts over time during the experiment
    */
    'equalWeighting'?: boolean;
    /**
    * The type of experiment
    */
    'experimentType'?: string;
    /**
    * Experiment id
    */
    'id'?: string;
    /**
    * Experiment name
    */
    'name'?: string;
    /**
    * Notes about the experiment
    */
    'notes'?: string;
    /**
    * Objective that is being optimized
    */
    'objective'?: string;
    /**
    * Objective parameter (such as event name) that is being optimized
    */
    'objectiveParameter'?: string;
    /**
    * Type of optimization
    */
    'optimizationType'?: string;
    /**
    * Total number of sessions in the experiment
    */
    'sessionCount'?: number;
    /**
    * Start date/time
    */
    'startDts'?: string;
    /**
    * Status of the experiment
    */
    'status'?: Experiment.StatusEnum;
    /**
    * Storefront Experiment Oid
    */
    'storefrontExperimentOid'?: number;
    /**
    * Storefront oid
    */
    'storefrontOid'?: number;
    /**
    * URI the experiment was started on
    */
    'uri'?: string;
    /**
    * Variations being tested in the experiment
    */
    'variations'?: Array<ExperimentVariation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "containerId",
            "baseName": "container_id",
            "type": "string"
        },
        {
            "name": "durationDays",
            "baseName": "duration_days",
            "type": "number"
        },
        {
            "name": "endDts",
            "baseName": "end_dts",
            "type": "string"
        },
        {
            "name": "equalWeighting",
            "baseName": "equal_weighting",
            "type": "boolean"
        },
        {
            "name": "experimentType",
            "baseName": "experiment_type",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "objective",
            "baseName": "objective",
            "type": "string"
        },
        {
            "name": "objectiveParameter",
            "baseName": "objective_parameter",
            "type": "string"
        },
        {
            "name": "optimizationType",
            "baseName": "optimization_type",
            "type": "string"
        },
        {
            "name": "sessionCount",
            "baseName": "session_count",
            "type": "number"
        },
        {
            "name": "startDts",
            "baseName": "start_dts",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Experiment.StatusEnum"
        },
        {
            "name": "storefrontExperimentOid",
            "baseName": "storefront_experiment_oid",
            "type": "number"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<ExperimentVariation>"
        }    ];

    static getAttributeTypeMap() {
        return Experiment.attributeTypeMap;
    }
}

export namespace Experiment {
    export enum StatusEnum {
        Running = <any> 'Running',
        Ended = <any> 'Ended',
        Deleted = <any> 'Deleted'
    }
}
export class ExperimentResponse {
    'error'?: Error;
    'experiment'?: Experiment;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "experiment",
            "baseName": "experiment",
            "type": "Experiment"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ExperimentResponse.attributeTypeMap;
    }
}

export class ExperimentVariation {
    /**
    * Total add to cart count for this variation
    */
    'addToCartCount'?: number;
    /**
    * Average duration seconds per session for this variation
    */
    'averageDurationSeconds'?: number;
    /**
    * Average objective value per session for this variation
    */
    'averageObjectivePerSession'?: number;
    /**
    * Average order value for this variation
    */
    'averageOrderValue'?: number;
    /**
    * Total bounce count for this variation
    */
    'bounceCount'?: number;
    /**
    * Conversion rate for this variation
    */
    'conversionRate'?: number;
    /**
    * Total number of seconds spent on the site for this variation
    */
    'durationSecondsSum'?: number;
    /**
    * Total event ocunt for this variation
    */
    'eventCount'?: number;
    /**
    * Total initiate checkout count for this variation
    */
    'initiateCheckoutCount'?: number;
    /**
    * Total order count for this variation
    */
    'orderCount'?: number;
    /**
    * Percentage of the traffic the variation originally started out with
    */
    'originalTrafficPercentage'?: number;
    /**
    * Total page view count for this variation
    */
    'pageViewCount'?: number;
    /**
    * Total revenue for this variation
    */
    'revenue'?: number;
    /**
    * Total sessions for this variation
    */
    'sessionCount'?: number;
    /**
    * Percentage of the traffic this variation is currently receiving
    */
    'trafficPercentage'?: number;
    /**
    * Url of the variation if this experiment is a url experiment.
    */
    'url'?: string;
    /**
    * Name of the variation
    */
    'variationName'?: string;
    /**
    * Variation number
    */
    'variationNumber'?: number;
    /**
    * True if this variation has been declared the winner
    */
    'winner'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addToCartCount",
            "baseName": "add_to_cart_count",
            "type": "number"
        },
        {
            "name": "averageDurationSeconds",
            "baseName": "average_duration_seconds",
            "type": "number"
        },
        {
            "name": "averageObjectivePerSession",
            "baseName": "average_objective_per_session",
            "type": "number"
        },
        {
            "name": "averageOrderValue",
            "baseName": "average_order_value",
            "type": "number"
        },
        {
            "name": "bounceCount",
            "baseName": "bounce_count",
            "type": "number"
        },
        {
            "name": "conversionRate",
            "baseName": "conversion_rate",
            "type": "number"
        },
        {
            "name": "durationSecondsSum",
            "baseName": "duration_seconds_sum",
            "type": "number"
        },
        {
            "name": "eventCount",
            "baseName": "event_count",
            "type": "number"
        },
        {
            "name": "initiateCheckoutCount",
            "baseName": "initiate_checkout_count",
            "type": "number"
        },
        {
            "name": "orderCount",
            "baseName": "order_count",
            "type": "number"
        },
        {
            "name": "originalTrafficPercentage",
            "baseName": "original_traffic_percentage",
            "type": "number"
        },
        {
            "name": "pageViewCount",
            "baseName": "page_view_count",
            "type": "number"
        },
        {
            "name": "revenue",
            "baseName": "revenue",
            "type": "number"
        },
        {
            "name": "sessionCount",
            "baseName": "session_count",
            "type": "number"
        },
        {
            "name": "trafficPercentage",
            "baseName": "traffic_percentage",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "variationName",
            "baseName": "variation_name",
            "type": "string"
        },
        {
            "name": "variationNumber",
            "baseName": "variation_number",
            "type": "number"
        },
        {
            "name": "winner",
            "baseName": "winner",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ExperimentVariation.attributeTypeMap;
    }
}

export class ExperimentsResponse {
    'error'?: Error;
    'experiments'?: Array<Experiment>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "experiments",
            "baseName": "experiments",
            "type": "Array<Experiment>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ExperimentsResponse.attributeTypeMap;
    }
}

export class FulfillmentInventory {
    'itemId'?: string;
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemId",
            "baseName": "itemId",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentInventory.attributeTypeMap;
    }
}

export class FulfillmentShipment {
    /**
    * Fees charged by the fulfillment company other than the shipping cost to process the order.
    */
    'fulfillmentFee'?: number;
    /**
    * Order ID that was shipped
    */
    'orderId'?: string;
    /**
    * The cost of the packaging used to sent this shipment
    */
    'packageCost'?: number;
    /**
    * The actual total cost of shipping this order
    */
    'shippingCost'?: number;
    /**
    * Tracking numbers associated with the shipment
    */
    'trackingNumbers'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fulfillmentFee",
            "baseName": "fulfillment_fee",
            "type": "number"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "packageCost",
            "baseName": "package_cost",
            "type": "number"
        },
        {
            "name": "shippingCost",
            "baseName": "shipping_cost",
            "type": "number"
        },
        {
            "name": "trackingNumbers",
            "baseName": "tracking_numbers",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FulfillmentShipment.attributeTypeMap;
    }
}

export class GeocodeRequest {
    /**
    * address
    */
    'address'?: string;
    /**
    * city
    */
    'city'?: string;
    /**
    * country_code
    */
    'countryCode'?: string;
    /**
    * postal_code
    */
    'postalCode'?: string;
    /**
    * state
    */
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GeocodeRequest.attributeTypeMap;
    }
}

export class GeocodeResponse {
    'error'?: Error;
    'latitude'?: number;
    'longitude'?: number;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return GeocodeResponse.attributeTypeMap;
    }
}

export class Group {
    /**
    * The unique object identifier (oid for short) for this group
    */
    'groupOid'?: number;
    /**
    * The name of this group.
    */
    'name'?: string;
    /**
    * A list of notifications the user receives.
    */
    'notifications'?: Array<Notification>;
    /**
    * A list of permissions the user enjoys for accessing the backend of UltraCart.
    */
    'permissions'?: Array<Permission>;
    /**
    * A list of users that belong to this group.
    */
    'users'?: Array<GroupUserMembership>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupOid",
            "baseName": "group_oid",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "Array<Notification>"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Array<Permission>"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<GroupUserMembership>"
        }    ];

    static getAttributeTypeMap() {
        return Group.attributeTypeMap;
    }
}

export class GroupResponse {
    'error'?: Error;
    'group'?: Group;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Group"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return GroupResponse.attributeTypeMap;
    }
}

export class GroupUserMembership {
    /**
    * The email for this user.
    */
    'email'?: string;
    /**
    * The full name for this user.
    */
    'fullName'?: string;
    /**
    * The login for this user.
    */
    'login'?: string;
    /**
    * True if this user belongs to the parent group, false otherwise.
    */
    'member'?: boolean;
    /**
    * The user id for this user.
    */
    'userId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "boolean"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GroupUserMembership.attributeTypeMap;
    }
}

export class GroupsResponse {
    'error'?: Error;
    'groups'?: Array<Group>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<Group>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return GroupsResponse.attributeTypeMap;
    }
}

export class HTTPHeader {
    /**
    * Name of the HTTP header
    */
    'name'?: string;
    /**
    * Value of the HTTP header
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HTTPHeader.attributeTypeMap;
    }
}

export class Item {
    'accounting'?: ItemAccounting;
    'amember'?: ItemAmember;
    'autoOrder'?: ItemAutoOrder;
    'ccbill'?: ItemCCBill;
    /**
    * Channel Partner Item Mapping
    */
    'channelPartnerMappings'?: Array<ItemChannelPartnerMapping>;
    'chargeback'?: ItemChargeback;
    'checkout'?: ItemCheckout;
    'content'?: ItemContent;
    /**
    * Date/time of creation
    */
    'creationDts'?: string;
    /**
    * Description of the item up to 500 characters.
    */
    'description'?: string;
    /**
    * Description translated text instance id
    */
    'descriptionTranslatedTextInstanceOid'?: number;
    'digitalDelivery'?: ItemDigitalDelivery;
    'ebay'?: ItemEbay;
    'emailNotifications'?: ItemEmailNotifications;
    'enrollment123'?: ItemEnrollment123;
    'giftCertificate'?: ItemGiftCertificate;
    'googleProductSearch'?: ItemGoogleProductSearch;
    'identifiers'?: ItemIdentifiers;
    /**
    * True if this item is inactive and can not be purchased
    */
    'inactive'?: boolean;
    'instantPaymentNotifications'?: ItemInstantPaymentNotifications;
    'internal'?: ItemInternal;
    /**
    * True if this item is a kit
    */
    'kit'?: boolean;
    /**
    * True if this item can only be usd as a kit component
    */
    'kitComponentOnly'?: boolean;
    'kitDefinition'?: ItemKitDefinition;
    /**
    * Date/time of last modification
    */
    'lastModifiedDts'?: string;
    /**
    * UltraCart merchant ID owning item
    */
    'merchantId'?: string;
    /**
    * Unique item id assigned to this item
    */
    'merchantItemId'?: string;
    /**
    * Unique object identifier for this item
    */
    'merchantItemOid'?: number;
    /**
    * Options
    */
    'options'?: Array<ItemOption>;
    /**
    * Parent category of the item.  Zero indicates the root folder.
    */
    'parentCategoryId'?: number;
    /**
    * Parent category path.  / indicates the root folder.
    */
    'parentCategoryPath'?: string;
    'paymentProcessing'?: ItemPaymentProcessing;
    'physical'?: ItemPhysical;
    'pricing'?: ItemPricing;
    /**
    * Properties
    */
    'properties'?: Array<ItemProperty>;
    'realtimePricing'?: ItemRealtimePricing;
    /**
    * Number of days to recommend replenishment after.  Null is not configured.  Set to zero to disable.
    */
    'recommendReplenishmentDays'?: number;
    'related'?: ItemRelated;
    'reporting'?: ItemReporting;
    'restriction'?: ItemRestriction;
    'revguard'?: ItemRevguard;
    'reviews'?: ItemReviews;
    'salesforce'?: ItemSalesforce;
    'shipping'?: ItemShipping;
    'tags'?: ItemTags;
    'tax'?: ItemTax;
    /**
    * 3rd Party Email Marketing
    */
    'thirdPartyEmailMarketing'?: Array<ItemThirdPartyEmailMarketing>;
    /**
    * Variant Items
    */
    'variantItems'?: Array<ItemVariantItem>;
    /**
    * Variations
    */
    'variations'?: Array<ItemVariation>;
    'wishlistMember'?: ItemWishlistMember;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accounting",
            "baseName": "accounting",
            "type": "ItemAccounting"
        },
        {
            "name": "amember",
            "baseName": "amember",
            "type": "ItemAmember"
        },
        {
            "name": "autoOrder",
            "baseName": "auto_order",
            "type": "ItemAutoOrder"
        },
        {
            "name": "ccbill",
            "baseName": "ccbill",
            "type": "ItemCCBill"
        },
        {
            "name": "channelPartnerMappings",
            "baseName": "channelPartnerMappings",
            "type": "Array<ItemChannelPartnerMapping>"
        },
        {
            "name": "chargeback",
            "baseName": "chargeback",
            "type": "ItemChargeback"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "ItemCheckout"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "ItemContent"
        },
        {
            "name": "creationDts",
            "baseName": "creation_dts",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "descriptionTranslatedTextInstanceOid",
            "baseName": "description_translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "digitalDelivery",
            "baseName": "digital_delivery",
            "type": "ItemDigitalDelivery"
        },
        {
            "name": "ebay",
            "baseName": "ebay",
            "type": "ItemEbay"
        },
        {
            "name": "emailNotifications",
            "baseName": "email_notifications",
            "type": "ItemEmailNotifications"
        },
        {
            "name": "enrollment123",
            "baseName": "enrollment123",
            "type": "ItemEnrollment123"
        },
        {
            "name": "giftCertificate",
            "baseName": "gift_certificate",
            "type": "ItemGiftCertificate"
        },
        {
            "name": "googleProductSearch",
            "baseName": "google_product_search",
            "type": "ItemGoogleProductSearch"
        },
        {
            "name": "identifiers",
            "baseName": "identifiers",
            "type": "ItemIdentifiers"
        },
        {
            "name": "inactive",
            "baseName": "inactive",
            "type": "boolean"
        },
        {
            "name": "instantPaymentNotifications",
            "baseName": "instant_payment_notifications",
            "type": "ItemInstantPaymentNotifications"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "ItemInternal"
        },
        {
            "name": "kit",
            "baseName": "kit",
            "type": "boolean"
        },
        {
            "name": "kitComponentOnly",
            "baseName": "kit_component_only",
            "type": "boolean"
        },
        {
            "name": "kitDefinition",
            "baseName": "kit_definition",
            "type": "ItemKitDefinition"
        },
        {
            "name": "lastModifiedDts",
            "baseName": "last_modified_dts",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "merchantItemId",
            "baseName": "merchant_item_id",
            "type": "string"
        },
        {
            "name": "merchantItemOid",
            "baseName": "merchant_item_oid",
            "type": "number"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<ItemOption>"
        },
        {
            "name": "parentCategoryId",
            "baseName": "parent_category_id",
            "type": "number"
        },
        {
            "name": "parentCategoryPath",
            "baseName": "parent_category_path",
            "type": "string"
        },
        {
            "name": "paymentProcessing",
            "baseName": "payment_processing",
            "type": "ItemPaymentProcessing"
        },
        {
            "name": "physical",
            "baseName": "physical",
            "type": "ItemPhysical"
        },
        {
            "name": "pricing",
            "baseName": "pricing",
            "type": "ItemPricing"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<ItemProperty>"
        },
        {
            "name": "realtimePricing",
            "baseName": "realtime_pricing",
            "type": "ItemRealtimePricing"
        },
        {
            "name": "recommendReplenishmentDays",
            "baseName": "recommend_replenishment_days",
            "type": "number"
        },
        {
            "name": "related",
            "baseName": "related",
            "type": "ItemRelated"
        },
        {
            "name": "reporting",
            "baseName": "reporting",
            "type": "ItemReporting"
        },
        {
            "name": "restriction",
            "baseName": "restriction",
            "type": "ItemRestriction"
        },
        {
            "name": "revguard",
            "baseName": "revguard",
            "type": "ItemRevguard"
        },
        {
            "name": "reviews",
            "baseName": "reviews",
            "type": "ItemReviews"
        },
        {
            "name": "salesforce",
            "baseName": "salesforce",
            "type": "ItemSalesforce"
        },
        {
            "name": "shipping",
            "baseName": "shipping",
            "type": "ItemShipping"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "ItemTags"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "ItemTax"
        },
        {
            "name": "thirdPartyEmailMarketing",
            "baseName": "third_party_email_marketing",
            "type": "Array<ItemThirdPartyEmailMarketing>"
        },
        {
            "name": "variantItems",
            "baseName": "variant_items",
            "type": "Array<ItemVariantItem>"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<ItemVariation>"
        },
        {
            "name": "wishlistMember",
            "baseName": "wishlist_member",
            "type": "ItemWishlistMember"
        }    ];

    static getAttributeTypeMap() {
        return Item.attributeTypeMap;
    }
}

export class ItemAccounting {
    /**
    * QuickBooks item name if different than the item id
    */
    'accountingCode'?: string;
    /**
    * QuickBooks class if you are classifying items on your invoices/receipts
    */
    'qbClass'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "qbClass",
            "baseName": "qb_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemAccounting.attributeTypeMap;
    }
}

export class ItemAmember {
    /**
    * The number of days that the customer should be given access to the item
    */
    'amemberPaymentDurationDays'?: number;
    /**
    * A-member product id give customer access to when they purchase this item
    */
    'amemberProductId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amemberPaymentDurationDays",
            "baseName": "amember_payment_duration_days",
            "type": "number"
        },
        {
            "name": "amemberProductId",
            "baseName": "amember_product_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemAmember.attributeTypeMap;
    }
}

export class ItemAutoOrder {
    /**
    * Amount to try and authorize for the future rebill
    */
    'authFutureAmount'?: number;
    /**
    * Amount to try and test authorize
    */
    'authTestAmount'?: number;
    /**
    * Item id to attempt charging the customer for if they cancel
    */
    'autoOrderCancelItemId'?: string;
    /**
    * Item object identifier to attempt charging the customer for if they cancel
    */
    'autoOrderCancelItemOid'?: number;
    /**
    * List of downgrade items presented to customer service representatives
    */
    'autoOrderDowngradeItems'?: Array<string>;
    /**
    * True if the rebill processing of this item is paused
    */
    'autoOrderPaused'?: boolean;
    /**
    * The user selectable schedules that are available
    */
    'autoOrderSchedules'?: Array<string>;
    /**
    * List of upgrade items presented to customer service representatives
    */
    'autoOrderUpgradeItems'?: Array<string>;
    /**
    * True if this item uses a fixed upsell step schedule
    */
    'autoOrderUpsell'?: boolean;
    /**
    * Do not send the easy cancel email to the customer
    */
    'autoOrderUpsellNoEasyCancel'?: boolean;
    /**
    * Limit the purchase of this item to one per customer
    */
    'autoOrderUpsellOnePerCustomer'?: boolean;
    /**
    * True if this item can be automatically ordered by the customer
    */
    'autoOrderable'?: boolean;
    /**
    * True if other auto orders for this customer should be canceled when this item is ordered
    */
    'cancelOtherAutoOrders'?: boolean;
    /**
    * True if the customer should be given free shipping
    */
    'freeShippingAutoOrder'?: boolean;
    /**
    * True if other auto orders for this customer should refunded if this item is refunded.
    */
    'refundOtherAutoOrders'?: boolean;
    /**
    * The rebill steps if this auto order is an upsell
    */
    'steps'?: Array<ItemAutoOrderStep>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authFutureAmount",
            "baseName": "auth_future_amount",
            "type": "number"
        },
        {
            "name": "authTestAmount",
            "baseName": "auth_test_amount",
            "type": "number"
        },
        {
            "name": "autoOrderCancelItemId",
            "baseName": "auto_order_cancel_item_id",
            "type": "string"
        },
        {
            "name": "autoOrderCancelItemOid",
            "baseName": "auto_order_cancel_item_oid",
            "type": "number"
        },
        {
            "name": "autoOrderDowngradeItems",
            "baseName": "auto_order_downgrade_items",
            "type": "Array<string>"
        },
        {
            "name": "autoOrderPaused",
            "baseName": "auto_order_paused",
            "type": "boolean"
        },
        {
            "name": "autoOrderSchedules",
            "baseName": "auto_order_schedules",
            "type": "Array<string>"
        },
        {
            "name": "autoOrderUpgradeItems",
            "baseName": "auto_order_upgrade_items",
            "type": "Array<string>"
        },
        {
            "name": "autoOrderUpsell",
            "baseName": "auto_order_upsell",
            "type": "boolean"
        },
        {
            "name": "autoOrderUpsellNoEasyCancel",
            "baseName": "auto_order_upsell_no_easy_cancel",
            "type": "boolean"
        },
        {
            "name": "autoOrderUpsellOnePerCustomer",
            "baseName": "auto_order_upsell_one_per_customer",
            "type": "boolean"
        },
        {
            "name": "autoOrderable",
            "baseName": "auto_orderable",
            "type": "boolean"
        },
        {
            "name": "cancelOtherAutoOrders",
            "baseName": "cancel_other_auto_orders",
            "type": "boolean"
        },
        {
            "name": "freeShippingAutoOrder",
            "baseName": "free_shipping_auto_order",
            "type": "boolean"
        },
        {
            "name": "refundOtherAutoOrders",
            "baseName": "refund_other_auto_orders",
            "type": "boolean"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<ItemAutoOrderStep>"
        }    ];

    static getAttributeTypeMap() {
        return ItemAutoOrder.attributeTypeMap;
    }
}

export class ItemAutoOrderStep {
    /**
    * If the schedule is arbitrary, then this is the number of days
    */
    'arbitraryScheduleDays'?: number;
    /**
    * Arbitrary unit cost used to override the regular item cost
    */
    'arbitraryUnitCost'?: number;
    /**
    * Arbitrary unit costs schedules for more advanced discounting by rebill attempt
    */
    'arbitraryUnitCostSchedules'?: Array<ItemAutoOrderStepArbitraryUnitCostSchedule>;
    /**
    * Grand-father pricing configuration if the rebill schedule has changed over time
    */
    'grandfatherPricing'?: Array<ItemAutoOrderStepGrandfatherPricing>;
    /**
    * Managed by (defaults to UltraCart)
    */
    'managedBy'?: string;
    /**
    * Number of days to pause
    */
    'pauseDays'?: number;
    /**
    * Wait for this step to happen until the specified date
    */
    'pauseUntilDate'?: string;
    /**
    * If set, a pre-shipment notice is sent to the customer this many days in advance
    */
    'preshipmentNoticeDays'?: number;
    /**
    * Item id to rebill
    */
    'recurringMerchantItemId'?: string;
    /**
    * Item object identifier to rebill
    */
    'recurringMerchantItemOid'?: number;
    /**
    * Number of times to rebill.  Last step can be null for infinite
    */
    'repeatCount'?: number;
    /**
    * Frequency of the rebill
    */
    'schedule'?: string;
    /**
    * Email list name to subscribe the customer to when the rebill occurs
    */
    'subscribeEmailListName'?: string;
    /**
    * Email list identifier to subscribe the customer to when this rebill occurs
    */
    'subscribeEmailListOid'?: number;
    /**
    * Type of step (item or pause)
    */
    'type'?: ItemAutoOrderStep.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "arbitraryScheduleDays",
            "baseName": "arbitrary_schedule_days",
            "type": "number"
        },
        {
            "name": "arbitraryUnitCost",
            "baseName": "arbitrary_unit_cost",
            "type": "number"
        },
        {
            "name": "arbitraryUnitCostSchedules",
            "baseName": "arbitrary_unit_cost_schedules",
            "type": "Array<ItemAutoOrderStepArbitraryUnitCostSchedule>"
        },
        {
            "name": "grandfatherPricing",
            "baseName": "grandfather_pricing",
            "type": "Array<ItemAutoOrderStepGrandfatherPricing>"
        },
        {
            "name": "managedBy",
            "baseName": "managed_by",
            "type": "string"
        },
        {
            "name": "pauseDays",
            "baseName": "pause_days",
            "type": "number"
        },
        {
            "name": "pauseUntilDate",
            "baseName": "pause_until_date",
            "type": "string"
        },
        {
            "name": "preshipmentNoticeDays",
            "baseName": "preshipment_notice_days",
            "type": "number"
        },
        {
            "name": "recurringMerchantItemId",
            "baseName": "recurring_merchant_item_id",
            "type": "string"
        },
        {
            "name": "recurringMerchantItemOid",
            "baseName": "recurring_merchant_item_oid",
            "type": "number"
        },
        {
            "name": "repeatCount",
            "baseName": "repeat_count",
            "type": "number"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "string"
        },
        {
            "name": "subscribeEmailListName",
            "baseName": "subscribe_email_list_name",
            "type": "string"
        },
        {
            "name": "subscribeEmailListOid",
            "baseName": "subscribe_email_list_oid",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ItemAutoOrderStep.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return ItemAutoOrderStep.attributeTypeMap;
    }
}

export namespace ItemAutoOrderStep {
    export enum TypeEnum {
        Item = <any> 'item',
        Pause = <any> 'pause'
    }
}
export class ItemAutoOrderStepArbitraryUnitCostSchedule {
    /**
    * Arbitrary unit cost
    */
    'arbitraryUnitCost'?: number;
    /**
    * Retry days
    */
    'retryDays'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "arbitraryUnitCost",
            "baseName": "arbitrary_unit_cost",
            "type": "number"
        },
        {
            "name": "retryDays",
            "baseName": "retry_days",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemAutoOrderStepArbitraryUnitCostSchedule.attributeTypeMap;
    }
}

export class ItemAutoOrderStepGrandfatherPricing {
    /**
    * On or before date
    */
    'onOrBeforeDate'?: string;
    /**
    * Unit cost
    */
    'unitCost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "onOrBeforeDate",
            "baseName": "on_or_before_date",
            "type": "string"
        },
        {
            "name": "unitCost",
            "baseName": "unit_cost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemAutoOrderStepGrandfatherPricing.attributeTypeMap;
    }
}

export class ItemCCBill {
    /**
    * Allowed currencies
    */
    'ccbillAllowedCurrencies'?: string;
    /**
    * Allowed types
    */
    'ccbillAllowedTypes'?: string;
    /**
    * Currency code
    */
    'ccbillCurrencyCode'?: string;
    /**
    * Form name
    */
    'ccbillFormName'?: string;
    /**
    * Sub-account id
    */
    'ccbillSubaccountId'?: string;
    /**
    * Subscription type id
    */
    'ccbillSubscriptionTypeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ccbillAllowedCurrencies",
            "baseName": "ccbill_allowed_currencies",
            "type": "string"
        },
        {
            "name": "ccbillAllowedTypes",
            "baseName": "ccbill_allowed_types",
            "type": "string"
        },
        {
            "name": "ccbillCurrencyCode",
            "baseName": "ccbill_currency_code",
            "type": "string"
        },
        {
            "name": "ccbillFormName",
            "baseName": "ccbill_form_name",
            "type": "string"
        },
        {
            "name": "ccbillSubaccountId",
            "baseName": "ccbill_subaccount_id",
            "type": "string"
        },
        {
            "name": "ccbillSubscriptionTypeId",
            "baseName": "ccbill_subscription_type_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemCCBill.attributeTypeMap;
    }
}

export class ItemChannelPartnerMapping {
    /**
    * Barcode UA (EDI only)
    */
    'barcodeUa'?: string;
    /**
    * Barcode UC (EDI only)
    */
    'barcodeUc'?: string;
    /**
    * Barcode UI (EDI only)
    */
    'barcodeUi'?: string;
    /**
    * Barcode UK (EDI only)
    */
    'barcodeUk'?: string;
    /**
    * Buyer catalog number (EDI only)
    */
    'buyerCatalogNumber'?: string;
    /**
    * Buyer DPCI (EDI only)
    */
    'buyerDpci'?: string;
    /**
    * Buyer item number (EDI only)
    */
    'buyerItemNumber'?: string;
    /**
    * Channel partner code
    */
    'channelPartnerCode'?: string;
    /**
    * Channel partner object identifier
    */
    'channelPartnerOid'?: number;
    /**
    * From Item ID
    */
    'fromItemId'?: string;
    /**
    * From SKU
    */
    'fromSku'?: string;
    /**
    * Mutually defined number (EDI only)
    */
    'mutuallyDefinedNumber'?: string;
    /**
    * Ratio (Channel Partner)
    */
    'quantityRatioCp'?: number;
    /**
    * Ratio (UltraCart)
    */
    'quantityRatioUc'?: number;
    /**
    * SKU
    */
    'sku'?: string;
    /**
    * Unit of measure
    */
    'unitOfMeasure'?: string;
    /**
    * Vendor number (EDI only)
    */
    'vendorNumber'?: string;
    /**
    * Vendor style number (EDI only)
    */
    'vendorStyleNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "barcodeUa",
            "baseName": "barcode_ua",
            "type": "string"
        },
        {
            "name": "barcodeUc",
            "baseName": "barcode_uc",
            "type": "string"
        },
        {
            "name": "barcodeUi",
            "baseName": "barcode_ui",
            "type": "string"
        },
        {
            "name": "barcodeUk",
            "baseName": "barcode_uk",
            "type": "string"
        },
        {
            "name": "buyerCatalogNumber",
            "baseName": "buyer_catalog_number",
            "type": "string"
        },
        {
            "name": "buyerDpci",
            "baseName": "buyer_dpci",
            "type": "string"
        },
        {
            "name": "buyerItemNumber",
            "baseName": "buyer_item_number",
            "type": "string"
        },
        {
            "name": "channelPartnerCode",
            "baseName": "channel_partner_code",
            "type": "string"
        },
        {
            "name": "channelPartnerOid",
            "baseName": "channel_partner_oid",
            "type": "number"
        },
        {
            "name": "fromItemId",
            "baseName": "from_item_id",
            "type": "string"
        },
        {
            "name": "fromSku",
            "baseName": "from_sku",
            "type": "string"
        },
        {
            "name": "mutuallyDefinedNumber",
            "baseName": "mutually_defined_number",
            "type": "string"
        },
        {
            "name": "quantityRatioCp",
            "baseName": "quantity_ratio_cp",
            "type": "number"
        },
        {
            "name": "quantityRatioUc",
            "baseName": "quantity_ratio_uc",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "unitOfMeasure",
            "baseName": "unit_of_measure",
            "type": "string"
        },
        {
            "name": "vendorNumber",
            "baseName": "vendor_number",
            "type": "string"
        },
        {
            "name": "vendorStyleNumber",
            "baseName": "vendor_style_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemChannelPartnerMapping.attributeTypeMap;
    }
}

export class ItemChargeback {
    /**
    * Addendums
    */
    'addendums'?: Array<ItemChargebackAddendum>;
    /**
    * Adjustment requests
    */
    'adjustmentRequests'?: Array<ItemChargebackAdjustmentRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addendums",
            "baseName": "addendums",
            "type": "Array<ItemChargebackAddendum>"
        },
        {
            "name": "adjustmentRequests",
            "baseName": "adjustment_requests",
            "type": "Array<ItemChargebackAdjustmentRequest>"
        }    ];

    static getAttributeTypeMap() {
        return ItemChargeback.attributeTypeMap;
    }
}

export class ItemChargebackAddendum {
    /**
    * Chargeback addendum object identifier
    */
    'chargebackAddendumOid'?: number;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Size of the file
    */
    'fileSize'?: number;
    /**
    * Number of pages
    */
    'pages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "chargebackAddendumOid",
            "baseName": "chargeback_addendum_oid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fileSize",
            "baseName": "file_size",
            "type": "number"
        },
        {
            "name": "pages",
            "baseName": "pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemChargebackAddendum.attributeTypeMap;
    }
}

export class ItemChargebackAdjustmentRequest {
    /**
    * Chargeback adjustment request object identifier
    */
    'chargebackAdjustmentRequestOid'?: number;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Reason code
    */
    'reasonCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "chargebackAdjustmentRequestOid",
            "baseName": "chargeback_adjustment_request_oid",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reason_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemChargebackAdjustmentRequest.attributeTypeMap;
    }
}

export class ItemCheckout {
    /**
    * True to suppress buySAFE (deprecated)
    */
    'suppressBuysafe'?: boolean;
    /**
    * Terms for purchasing this item
    */
    'terms'?: string;
    /**
    * Terms translated text instance identifier
    */
    'termsTranslatedTextInstanceOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "suppressBuysafe",
            "baseName": "suppress_buysafe",
            "type": "boolean"
        },
        {
            "name": "terms",
            "baseName": "terms",
            "type": "string"
        },
        {
            "name": "termsTranslatedTextInstanceOid",
            "baseName": "terms_translated_text_instance_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemCheckout.attributeTypeMap;
    }
}

export class ItemContent {
    /**
    * StoreFront assignments
    */
    'assignments'?: Array<ItemContentAssignment>;
    /**
    * StoreFront attributes
    */
    'attributes'?: Array<ItemContentAttribute>;
    /**
    * Custom Thank You URL
    */
    'customThankYouUrl'?: string;
    /**
    * Exclude from search
    */
    'excludeFromSearch'?: boolean;
    /**
    * Exclude from the top sellers list in the StoreFront
    */
    'excludeFromTopSellers'?: boolean;
    /**
    * Extended description (max 2000 characters)
    */
    'extendedDescription'?: string;
    /**
    * Extneded description text translation instance identifier
    */
    'extendedDescriptionTranslatedTextInstanceOid'?: number;
    /**
    * Multimedia
    */
    'multimedia'?: Array<ItemContentMultimedia>;
    /**
    * True if the item is new
    */
    'newItem'?: boolean;
    /**
    * The date the item should no longer be considered new
    */
    'newItemEnd'?: string;
    /**
    * The date the item should start being considered new
    */
    'newItemStart'?: string;
    /**
    * Legacy view URL (not used by StoreFronts)
    */
    'viewUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignments",
            "baseName": "assignments",
            "type": "Array<ItemContentAssignment>"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<ItemContentAttribute>"
        },
        {
            "name": "customThankYouUrl",
            "baseName": "custom_thank_you_url",
            "type": "string"
        },
        {
            "name": "excludeFromSearch",
            "baseName": "exclude_from_search",
            "type": "boolean"
        },
        {
            "name": "excludeFromTopSellers",
            "baseName": "exclude_from_top_sellers",
            "type": "boolean"
        },
        {
            "name": "extendedDescription",
            "baseName": "extended_description",
            "type": "string"
        },
        {
            "name": "extendedDescriptionTranslatedTextInstanceOid",
            "baseName": "extended_description_translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "multimedia",
            "baseName": "multimedia",
            "type": "Array<ItemContentMultimedia>"
        },
        {
            "name": "newItem",
            "baseName": "new_item",
            "type": "boolean"
        },
        {
            "name": "newItemEnd",
            "baseName": "new_item_end",
            "type": "string"
        },
        {
            "name": "newItemStart",
            "baseName": "new_item_start",
            "type": "string"
        },
        {
            "name": "viewUrl",
            "baseName": "view_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemContent.attributeTypeMap;
    }
}

export class ItemContentAssignment {
    /**
    * Page (group) object identifier
    */
    'groupOid'?: number;
    /**
    * Page (group) path
    */
    'groupPath'?: string;
    /**
    * StoreFront host name
    */
    'host'?: string;
    /**
    * Sort order (optional)
    */
    'sortOrder'?: number;
    /**
    * URL part if the item id is not used
    */
    'urlPart'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupOid",
            "baseName": "group_oid",
            "type": "number"
        },
        {
            "name": "groupPath",
            "baseName": "group_path",
            "type": "string"
        },
        {
            "name": "host",
            "baseName": "host",
            "type": "string"
        },
        {
            "name": "sortOrder",
            "baseName": "sort_order",
            "type": "number"
        },
        {
            "name": "urlPart",
            "baseName": "url_part",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemContentAssignment.attributeTypeMap;
    }
}

export class ItemContentAttribute {
    /**
    * Attribute name
    */
    'name'?: string;
    /**
    * Attribute translated text instance identifier
    */
    'translatedTextInstanceOid'?: number;
    /**
    * Attribute type
    */
    'type'?: string;
    /**
    * Attribute value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "translatedTextInstanceOid",
            "baseName": "translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemContentAttribute.attributeTypeMap;
    }
}

export class ItemContentMultimedia {
    /**
    * URL where the image can be downloaded from the cloud
    */
    'cloudUrl'?: string;
    /**
    * Expiration date of the cloud URL
    */
    'cloudUrlExpiration'?: string;
    /**
    * Code assigned to the file
    */
    'code'?: string;
    /**
    * Description
    */
    'description'?: string;
    /**
    * True to exclude from multimedia gallery
    */
    'excludeFromGallery'?: boolean;
    /**
    * File name
    */
    'fileName'?: string;
    /**
    * Height of the image
    */
    'height'?: number;
    /**
    * Item multimedia object identifier
    */
    'merchantItemMultimediaOid'?: number;
    /**
    * True if the multimedia is an orphan of the active StoreFront themes
    */
    'orphan'?: boolean;
    /**
    * True if the object is a place holder that can be populated
    */
    'placeholder'?: boolean;
    /**
    * Temporary multimedia object identifier assigned if uploading new multimedia
    */
    'tempMultimediaOid'?: number;
    /**
    * Thumbnails of this image
    */
    'thumbnails'?: Array<ItemContentMultimediaThumbnail>;
    /**
    * Type of file
    */
    'type'?: ItemContentMultimedia.TypeEnum;
    /**
    * URL to download file (on new multimedia record this can be a URL for UltraCart to fetch)
    */
    'url'?: string;
    /**
    * Width of the image
    */
    'width'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cloudUrl",
            "baseName": "cloud_url",
            "type": "string"
        },
        {
            "name": "cloudUrlExpiration",
            "baseName": "cloud_url_expiration",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "excludeFromGallery",
            "baseName": "exclude_from_gallery",
            "type": "boolean"
        },
        {
            "name": "fileName",
            "baseName": "file_name",
            "type": "string"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "merchantItemMultimediaOid",
            "baseName": "merchant_item_multimedia_oid",
            "type": "number"
        },
        {
            "name": "orphan",
            "baseName": "orphan",
            "type": "boolean"
        },
        {
            "name": "placeholder",
            "baseName": "placeholder",
            "type": "boolean"
        },
        {
            "name": "tempMultimediaOid",
            "baseName": "temp_multimedia_oid",
            "type": "number"
        },
        {
            "name": "thumbnails",
            "baseName": "thumbnails",
            "type": "Array<ItemContentMultimediaThumbnail>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ItemContentMultimedia.TypeEnum"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemContentMultimedia.attributeTypeMap;
    }
}

export namespace ItemContentMultimedia {
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}
export class ItemContentMultimediaThumbnail {
    /**
    * Height of the thumbnail
    */
    'height'?: number;
    /**
    * HTTP URL to view the thumbnail
    */
    'httpUrl'?: string;
    /**
    * HTTPS URL to view the thumbnail
    */
    'httpsUrl'?: string;
    /**
    * True if PNG, false if JPEG
    */
    'pngFormat'?: boolean;
    /**
    * True if the thumbnail is square
    */
    'square'?: boolean;
    /**
    * Width of the thumbnail
    */
    'width'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "httpUrl",
            "baseName": "http_url",
            "type": "string"
        },
        {
            "name": "httpsUrl",
            "baseName": "https_url",
            "type": "string"
        },
        {
            "name": "pngFormat",
            "baseName": "png_format",
            "type": "boolean"
        },
        {
            "name": "square",
            "baseName": "square",
            "type": "boolean"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemContentMultimediaThumbnail.attributeTypeMap;
    }
}

export class ItemDigitalDelivery {
    /**
    * Description of the activation code
    */
    'activationCodeDescription'?: string;
    /**
    * The number of activation codes whcih should generate a warning email
    */
    'activationCodeLowWarning'?: number;
    /**
    * The URL to retrieve activation codes from in real-time
    */
    'activationCodeRealtimeUrl'?: string;
    /**
    * Shared secret used when communicating with the real-time URL
    */
    'activationCodeSharedSecret'?: string;
    /**
    * Type of activation code
    */
    'activationCodeType'?: string;
    /**
    * Digital items that customer can download when this item is purchased
    */
    'digitalItems'?: Array<ItemDigitalItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activationCodeDescription",
            "baseName": "activation_code_description",
            "type": "string"
        },
        {
            "name": "activationCodeLowWarning",
            "baseName": "activation_code_low_warning",
            "type": "number"
        },
        {
            "name": "activationCodeRealtimeUrl",
            "baseName": "activation_code_realtime_url",
            "type": "string"
        },
        {
            "name": "activationCodeSharedSecret",
            "baseName": "activation_code_shared_secret",
            "type": "string"
        },
        {
            "name": "activationCodeType",
            "baseName": "activation_code_type",
            "type": "string"
        },
        {
            "name": "digitalItems",
            "baseName": "digital_items",
            "type": "Array<ItemDigitalItem>"
        }    ];

    static getAttributeTypeMap() {
        return ItemDigitalDelivery.attributeTypeMap;
    }
}

export class ItemDigitalItem {
    /**
    * File creation date
    */
    'creationDts'?: string;
    /**
    * Description of the digital item
    */
    'description'?: string;
    /**
    * File size
    */
    'fileSize'?: number;
    /**
    * Mime type associated with the file
    */
    'mimeType'?: string;
    /**
    * Original filename
    */
    'originalFilename'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creationDts",
            "baseName": "creation_dts",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fileSize",
            "baseName": "file_size",
            "type": "number"
        },
        {
            "name": "mimeType",
            "baseName": "mime_type",
            "type": "string"
        },
        {
            "name": "originalFilename",
            "baseName": "original_filename",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemDigitalItem.attributeTypeMap;
    }
}

export class ItemEbay {
    /**
    * True if the item is active for listing
    */
    'active'?: boolean;
    /**
    * e-Bay category ID
    */
    'categoryId'?: number;
    /**
    * Answers to category specific questions
    */
    'categorySpecifics'?: Array<ItemEbayCategorySpecific>;
    /**
    * Description of the condition (e-Bay constant)
    */
    'conditionDescription'?: string;
    /**
    * Numerical ID of the condition (e-Bay constant)
    */
    'conditionId'?: number;
    /**
    * Number of consecutive failures trying to list this item
    */
    'consecutiveFailures'?: number;
    /**
    * e-Bay Store category 1
    */
    'customCategory1'?: number;
    /**
    * e-Bay Store category 2
    */
    'customCategory2'?: number;
    /**
    * Maximum number of days it will take to ship the item
    */
    'dispatchTimeMax'?: number;
    /**
    * Domestic 1 method additional item cost
    */
    'domestic1AdditionalCost'?: number;
    /**
    * Domestic 1 method first item cost
    */
    'domestic1FirstCost'?: number;
    /**
    * Domestic 2 method additional item cost
    */
    'domestic2AdditionalCost'?: number;
    /**
    * Domestic 2 method first item cost
    */
    'domestic2FirstCost'?: number;
    /**
    * Domestic 3 method additional item cost
    */
    'domestic3AdditionalCost'?: number;
    /**
    * Domestic 3 method first item cost
    */
    'domestic3FirstCost'?: number;
    /**
    * Domestic 4 method additional item cost
    */
    'domestic4AdditionalCost'?: number;
    /**
    * Domestic 4 method first item cost
    */
    'domestic4FirstCost'?: number;
    /**
    * If listed, this is the e-Bay auction id
    */
    'ebayAuctionId'?: string;
    /**
    * e-Bay specific inventory
    */
    'ebaySpecificInventory'?: number;
    /**
    * The template name to use hwen rendering the e-Bay listing
    */
    'ebayTemplateName'?: string;
    /**
    * The template object identifier to use when rendering the e-Bay listing
    */
    'ebayTemplateOid'?: number;
    /**
    * Date/time of the auction end
    */
    'endTime'?: string;
    /**
    * True if item receives free shipping
    */
    'freeShipping'?: boolean;
    /**
    * The method that is free for free shipping
    */
    'freeShippingMethod'?: string;
    /**
    * International 1 method additional item cost
    */
    'international1AdditionalCost'?: number;
    /**
    * International 1 method first item cost
    */
    'international1FirstCost'?: number;
    /**
    * International 2 method additional item cost
    */
    'international2AdditionalCost'?: number;
    /**
    * International 2 method first item cost
    */
    'international2FirstCost'?: number;
    /**
    * International 3 method additional item cost
    */
    'international3AdditionalCost'?: number;
    /**
    * International 3 method first item cost
    */
    'international3FirstCost'?: number;
    /**
    * International 4 method additional item cost
    */
    'international4AdditionalCost'?: number;
    /**
    * International 4 method first item cost
    */
    'international4FirstCost'?: number;
    /**
    * Date/time of the last status check
    */
    'lastStatusDts'?: string;
    /**
    * Current listing dispatch time maximum
    */
    'listedDispatchTimeMax'?: number;
    /**
    * The template object identifier used for the listing
    */
    'listedEbayTemplateOid'?: number;
    /**
    * Date/time of the listing
    */
    'listingDts'?: string;
    /**
    * The duration of the listing
    */
    'listingDuration'?: string;
    /**
    * Price to list the item at
    */
    'listingPrice'?: number;
    /**
    * The price to list the item at if different than the regular UltraCart item price
    */
    'listingPriceOverride'?: number;
    /**
    * The type of e-Bay listing
    */
    'listingType'?: string;
    'marketplaceAnalysis'?: ItemEbayMarketPlaceAnalysis;
    /**
    * True if marketplace analysis should be performed
    */
    'marketplaceAnalysisPerform'?: boolean;
    /**
    * Marketplace FVF percentage
    */
    'marketplaceFinalValueFeePercentage'?: number;
    /**
    * Date/time of the marketplace analysis last check
    */
    'marketplaceLastCheckDts'?: string;
    /**
    * True if we are the lowest offer in the marketplace
    */
    'marketplaceLowest'?: boolean;
    /**
    * True if another seller is violating MAP
    */
    'marketplaceMapViolation'?: boolean;
    /**
    * Marketplace multiplier
    */
    'marketplaceMultiplier'?: number;
    /**
    * Marketplace other price
    */
    'marketplaceOtherPrice'?: number;
    /**
    * Marketplace other seller
    */
    'marketplaceOtherSeller'?: string;
    /**
    * Marketplace other shipping
    */
    'marketplaceOtherShipping'?: number;
    /**
    * Marketplace other total
    */
    'marketplaceOtherTotal'?: number;
    /**
    * Marketplace our additional profit potential
    */
    'marketplaceOurAdditionalProfitPotential'?: number;
    /**
    * Marketplace our price
    */
    'marketplaceOurPrice'?: number;
    /**
    * Marketplace our profit
    */
    'marketplaceOurProfit'?: number;
    /**
    * Marketplace our shipping
    */
    'marketplaceOurShipping'?: number;
    /**
    * Marketplace our total
    */
    'marketplaceOurTotal'?: number;
    /**
    * Marketplace overhead
    */
    'marketplaceOverhead'?: number;
    /**
    * True if our listing is profitable to sell
    */
    'marketplaceProfitable'?: boolean;
    /**
    * Date/time for the next attempt to list
    */
    'nextAttemptDts'?: string;
    /**
    * The next listing duration to use when the current listing ends.
    */
    'nextListingDuration'?: string;
    /**
    * True if the item should not qualify for promotional shipping
    */
    'noPromotionalShipping'?: boolean;
    /**
    * Packaging and handling costs
    */
    'packagingHandlingCosts'?: number;
    /**
    * Previous e-Bay auction id
    */
    'previousEbayAuctionId'?: string;
    /**
    * Quantity available of the item
    */
    'quantity'?: number;
    /**
    * Reserve price
    */
    'reservePrice'?: number;
    /**
    * How to send the item dimensions and weights to e-Bay
    */
    'sendDimensionsAndWeight'?: string;
    /**
    * Date/time of the auction start
    */
    'startTime'?: string;
    /**
    * Status of the item's listing
    */
    'status'?: string;
    /**
    * Typical number of days it will take to ship the item
    */
    'targetDispatchTimeMax'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "categoryId",
            "baseName": "category_id",
            "type": "number"
        },
        {
            "name": "categorySpecifics",
            "baseName": "category_specifics",
            "type": "Array<ItemEbayCategorySpecific>"
        },
        {
            "name": "conditionDescription",
            "baseName": "condition_description",
            "type": "string"
        },
        {
            "name": "conditionId",
            "baseName": "condition_id",
            "type": "number"
        },
        {
            "name": "consecutiveFailures",
            "baseName": "consecutive_failures",
            "type": "number"
        },
        {
            "name": "customCategory1",
            "baseName": "custom_category1",
            "type": "number"
        },
        {
            "name": "customCategory2",
            "baseName": "custom_category2",
            "type": "number"
        },
        {
            "name": "dispatchTimeMax",
            "baseName": "dispatch_time_max",
            "type": "number"
        },
        {
            "name": "domestic1AdditionalCost",
            "baseName": "domestic_1_additional_cost",
            "type": "number"
        },
        {
            "name": "domestic1FirstCost",
            "baseName": "domestic_1_first_cost",
            "type": "number"
        },
        {
            "name": "domestic2AdditionalCost",
            "baseName": "domestic_2_additional_cost",
            "type": "number"
        },
        {
            "name": "domestic2FirstCost",
            "baseName": "domestic_2_first_cost",
            "type": "number"
        },
        {
            "name": "domestic3AdditionalCost",
            "baseName": "domestic_3_additional_cost",
            "type": "number"
        },
        {
            "name": "domestic3FirstCost",
            "baseName": "domestic_3_first_cost",
            "type": "number"
        },
        {
            "name": "domestic4AdditionalCost",
            "baseName": "domestic_4_additional_cost",
            "type": "number"
        },
        {
            "name": "domestic4FirstCost",
            "baseName": "domestic_4_first_cost",
            "type": "number"
        },
        {
            "name": "ebayAuctionId",
            "baseName": "ebay_auction_id",
            "type": "string"
        },
        {
            "name": "ebaySpecificInventory",
            "baseName": "ebay_specific_inventory",
            "type": "number"
        },
        {
            "name": "ebayTemplateName",
            "baseName": "ebay_template_name",
            "type": "string"
        },
        {
            "name": "ebayTemplateOid",
            "baseName": "ebay_template_oid",
            "type": "number"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "string"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "boolean"
        },
        {
            "name": "freeShippingMethod",
            "baseName": "free_shipping_method",
            "type": "string"
        },
        {
            "name": "international1AdditionalCost",
            "baseName": "international_1_additional_cost",
            "type": "number"
        },
        {
            "name": "international1FirstCost",
            "baseName": "international_1_first_cost",
            "type": "number"
        },
        {
            "name": "international2AdditionalCost",
            "baseName": "international_2_additional_cost",
            "type": "number"
        },
        {
            "name": "international2FirstCost",
            "baseName": "international_2_first_cost",
            "type": "number"
        },
        {
            "name": "international3AdditionalCost",
            "baseName": "international_3_additional_cost",
            "type": "number"
        },
        {
            "name": "international3FirstCost",
            "baseName": "international_3_first_cost",
            "type": "number"
        },
        {
            "name": "international4AdditionalCost",
            "baseName": "international_4_additional_cost",
            "type": "number"
        },
        {
            "name": "international4FirstCost",
            "baseName": "international_4_first_cost",
            "type": "number"
        },
        {
            "name": "lastStatusDts",
            "baseName": "last_status_dts",
            "type": "string"
        },
        {
            "name": "listedDispatchTimeMax",
            "baseName": "listed_dispatch_time_max",
            "type": "number"
        },
        {
            "name": "listedEbayTemplateOid",
            "baseName": "listed_ebay_template_oid",
            "type": "number"
        },
        {
            "name": "listingDts",
            "baseName": "listing_dts",
            "type": "string"
        },
        {
            "name": "listingDuration",
            "baseName": "listing_duration",
            "type": "string"
        },
        {
            "name": "listingPrice",
            "baseName": "listing_price",
            "type": "number"
        },
        {
            "name": "listingPriceOverride",
            "baseName": "listing_price_override",
            "type": "number"
        },
        {
            "name": "listingType",
            "baseName": "listing_type",
            "type": "string"
        },
        {
            "name": "marketplaceAnalysis",
            "baseName": "marketplace_analysis",
            "type": "ItemEbayMarketPlaceAnalysis"
        },
        {
            "name": "marketplaceAnalysisPerform",
            "baseName": "marketplace_analysis_perform",
            "type": "boolean"
        },
        {
            "name": "marketplaceFinalValueFeePercentage",
            "baseName": "marketplace_final_value_fee_percentage",
            "type": "number"
        },
        {
            "name": "marketplaceLastCheckDts",
            "baseName": "marketplace_last_check_dts",
            "type": "string"
        },
        {
            "name": "marketplaceLowest",
            "baseName": "marketplace_lowest",
            "type": "boolean"
        },
        {
            "name": "marketplaceMapViolation",
            "baseName": "marketplace_map_violation",
            "type": "boolean"
        },
        {
            "name": "marketplaceMultiplier",
            "baseName": "marketplace_multiplier",
            "type": "number"
        },
        {
            "name": "marketplaceOtherPrice",
            "baseName": "marketplace_other_price",
            "type": "number"
        },
        {
            "name": "marketplaceOtherSeller",
            "baseName": "marketplace_other_seller",
            "type": "string"
        },
        {
            "name": "marketplaceOtherShipping",
            "baseName": "marketplace_other_shipping",
            "type": "number"
        },
        {
            "name": "marketplaceOtherTotal",
            "baseName": "marketplace_other_total",
            "type": "number"
        },
        {
            "name": "marketplaceOurAdditionalProfitPotential",
            "baseName": "marketplace_our_additional_profit_potential",
            "type": "number"
        },
        {
            "name": "marketplaceOurPrice",
            "baseName": "marketplace_our_price",
            "type": "number"
        },
        {
            "name": "marketplaceOurProfit",
            "baseName": "marketplace_our_profit",
            "type": "number"
        },
        {
            "name": "marketplaceOurShipping",
            "baseName": "marketplace_our_shipping",
            "type": "number"
        },
        {
            "name": "marketplaceOurTotal",
            "baseName": "marketplace_our_total",
            "type": "number"
        },
        {
            "name": "marketplaceOverhead",
            "baseName": "marketplace_overhead",
            "type": "number"
        },
        {
            "name": "marketplaceProfitable",
            "baseName": "marketplace_profitable",
            "type": "boolean"
        },
        {
            "name": "nextAttemptDts",
            "baseName": "next_attempt_dts",
            "type": "string"
        },
        {
            "name": "nextListingDuration",
            "baseName": "next_listing_duration",
            "type": "string"
        },
        {
            "name": "noPromotionalShipping",
            "baseName": "no_promotional_shipping",
            "type": "boolean"
        },
        {
            "name": "packagingHandlingCosts",
            "baseName": "packaging_handling_costs",
            "type": "number"
        },
        {
            "name": "previousEbayAuctionId",
            "baseName": "previous_ebay_auction_id",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "reservePrice",
            "baseName": "reserve_price",
            "type": "number"
        },
        {
            "name": "sendDimensionsAndWeight",
            "baseName": "send_dimensions_and_weight",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "targetDispatchTimeMax",
            "baseName": "target_dispatch_time_max",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemEbay.attributeTypeMap;
    }
}

export class ItemEbayCategorySpecific {
    /**
    * Name of the category specification field
    */
    'name'?: string;
    /**
    * Value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemEbayCategorySpecific.attributeTypeMap;
    }
}

export class ItemEbayMarketListing {
    /**
    * Auction ID
    */
    'auctionId'?: string;
    /**
    * Price
    */
    'price'?: number;
    /**
    * Seller
    */
    'seller'?: string;
    /**
    * Shipping
    */
    'shipping'?: number;
    /**
    * Total
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auctionId",
            "baseName": "auction_id",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "seller",
            "baseName": "seller",
            "type": "string"
        },
        {
            "name": "shipping",
            "baseName": "shipping",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemEbayMarketListing.attributeTypeMap;
    }
}

export class ItemEbayMarketPlaceAnalysis {
    /**
    * Adjusted price
    */
    'adjustedPrice'?: number;
    /**
    * Adjusted shipping
    */
    'adjustedShipping'?: number;
    /**
    * Adjusted total
    */
    'adjustedTotal'?: number;
    /**
    * Cost of goods sold
    */
    'cogs'?: number;
    /**
    * Final value fee
    */
    'finalValueFee'?: number;
    /**
    * Minimum advertised price
    */
    'minimumAdvertisedPrice'?: number;
    /**
    * Other listings
    */
    'otherListings'?: Array<ItemEbayMarketListing>;
    'ourListing'?: ItemEbayMarketListing;
    /**
    * Overhead
    */
    'overhead'?: number;
    /**
    * Profit potential
    */
    'profitPotential'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "adjustedPrice",
            "baseName": "adjusted_price",
            "type": "number"
        },
        {
            "name": "adjustedShipping",
            "baseName": "adjusted_shipping",
            "type": "number"
        },
        {
            "name": "adjustedTotal",
            "baseName": "adjusted_total",
            "type": "number"
        },
        {
            "name": "cogs",
            "baseName": "cogs",
            "type": "number"
        },
        {
            "name": "finalValueFee",
            "baseName": "final_value_fee",
            "type": "number"
        },
        {
            "name": "minimumAdvertisedPrice",
            "baseName": "minimum_advertised_price",
            "type": "number"
        },
        {
            "name": "otherListings",
            "baseName": "other_listings",
            "type": "Array<ItemEbayMarketListing>"
        },
        {
            "name": "ourListing",
            "baseName": "our_listing",
            "type": "ItemEbayMarketListing"
        },
        {
            "name": "overhead",
            "baseName": "overhead",
            "type": "number"
        },
        {
            "name": "profitPotential",
            "baseName": "profit_potential",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemEbayMarketPlaceAnalysis.attributeTypeMap;
    }
}

export class ItemEmailNotifications {
    /**
    * Skip receipt email to customer
    */
    'skipReceipt'?: boolean;
    /**
    * Skip shipment notification to customer
    */
    'skipShipmentNotification'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "skipReceipt",
            "baseName": "skip_receipt",
            "type": "boolean"
        },
        {
            "name": "skipShipmentNotification",
            "baseName": "skip_shipment_notification",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemEmailNotifications.attributeTypeMap;
    }
}

export class ItemEnrollment123 {
    /**
    * Enrolment 123 product code
    */
    'enrollment123ProductCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enrollment123ProductCode",
            "baseName": "enrollment123_product_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemEnrollment123.attributeTypeMap;
    }
}

export class ItemGiftCertificate {
    /**
    * True if the purchase of this item generates a gift certificate
    */
    'giftCertificate'?: boolean;
    /**
    * The number of days that the gift certificate is good for (optional)
    */
    'giftCertificateExpirationDays'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "giftCertificate",
            "baseName": "gift_certificate",
            "type": "boolean"
        },
        {
            "name": "giftCertificateExpirationDays",
            "baseName": "gift_certificate_expiration_days",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemGiftCertificate.attributeTypeMap;
    }
}

export class ItemGoogleProductSearch {
    /**
    * Adwords grouping
    */
    'adwordsGrouping'?: string;
    /**
    * Adwords label 1
    */
    'adwordsLabel1'?: string;
    /**
    * Adwords label 2
    */
    'adwordsLabel2'?: string;
    /**
    * Adwords label 3
    */
    'adwordsLabel3'?: string;
    /**
    * Adwords label 4
    */
    'adwordsLabel4'?: string;
    /**
    * Adwords label 5
    */
    'adwordsLabel5'?: string;
    /**
    * Age group
    */
    'ageGroup'?: string;
    /**
    * Available at physical store
    */
    'availableAtPhysicalStore'?: boolean;
    /**
    * Book - author
    */
    'bookAuthor'?: string;
    /**
    * Book - format
    */
    'bookFormat'?: string;
    /**
    * Bood - ISBN
    */
    'bookIsbn'?: string;
    /**
    * Book - publisher
    */
    'bookPublisher'?: string;
    /**
    * Category description
    */
    'categoryDescription'?: string;
    /**
    * Color
    */
    'color'?: string;
    /**
    * Condition
    */
    'condition'?: string;
    /**
    * Custom label 0
    */
    'customLabel0'?: string;
    /**
    * Custom label 1
    */
    'customLabel1'?: string;
    /**
    * Custom label 2
    */
    'customLabel2'?: string;
    /**
    * Custom label 3
    */
    'customLabel3'?: string;
    /**
    * Custom label 4
    */
    'customLabel4'?: string;
    /**
    * Gender
    */
    'gender'?: string;
    /**
    * Google product category
    */
    'googleProductCategory'?: string;
    /**
    * Music - artist
    */
    'musicArtist'?: string;
    /**
    * Music - format
    */
    'musicFormat'?: string;
    /**
    * Music - release date
    */
    'musicReleaseDate'?: string;
    /**
    * Omit from feed
    */
    'omitFromFeed'?: boolean;
    /**
    * Product type
    */
    'productType'?: string;
    /**
    * Promotion ID 1
    */
    'promotionId1'?: string;
    /**
    * Promotion ID 10
    */
    'promotionId10'?: string;
    /**
    * Promotion ID 2
    */
    'promotionId2'?: string;
    /**
    * Promotion ID 3
    */
    'promotionId3'?: string;
    /**
    * Promotion ID 4
    */
    'promotionId4'?: string;
    /**
    * Promotion ID 5
    */
    'promotionId5'?: string;
    /**
    * Promotion ID 6
    */
    'promotionId6'?: string;
    /**
    * Promotion ID 7
    */
    'promotionId7'?: string;
    /**
    * Promotion ID 8
    */
    'promotionId8'?: string;
    /**
    * Promotion ID 9
    */
    'promotionId9'?: string;
    /**
    * Search date/time
    */
    'searchDts'?: string;
    /**
    * Search lowest price
    */
    'searchLowestPrice'?: number;
    /**
    * Search lowest URL
    */
    'searchLowestUrl'?: string;
    /**
    * Search position
    */
    'searchPosition'?: number;
    'shippingLabel'?: string;
    /**
    * Size
    */
    'size'?: string;
    /**
    * Video - director
    */
    'videoDirector'?: string;
    /**
    * Video - format
    */
    'videoFormat'?: string;
    /**
    * Video - rating
    */
    'videoRating'?: string;
    /**
    * Video - release date
    */
    'videoReleaseDate'?: string;
    /**
    * Video - starring
    */
    'videoStarring'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "adwordsGrouping",
            "baseName": "adwords_grouping",
            "type": "string"
        },
        {
            "name": "adwordsLabel1",
            "baseName": "adwords_label1",
            "type": "string"
        },
        {
            "name": "adwordsLabel2",
            "baseName": "adwords_label2",
            "type": "string"
        },
        {
            "name": "adwordsLabel3",
            "baseName": "adwords_label3",
            "type": "string"
        },
        {
            "name": "adwordsLabel4",
            "baseName": "adwords_label4",
            "type": "string"
        },
        {
            "name": "adwordsLabel5",
            "baseName": "adwords_label5",
            "type": "string"
        },
        {
            "name": "ageGroup",
            "baseName": "age_group",
            "type": "string"
        },
        {
            "name": "availableAtPhysicalStore",
            "baseName": "available_at_physical_store",
            "type": "boolean"
        },
        {
            "name": "bookAuthor",
            "baseName": "book_author",
            "type": "string"
        },
        {
            "name": "bookFormat",
            "baseName": "book_format",
            "type": "string"
        },
        {
            "name": "bookIsbn",
            "baseName": "book_isbn",
            "type": "string"
        },
        {
            "name": "bookPublisher",
            "baseName": "book_publisher",
            "type": "string"
        },
        {
            "name": "categoryDescription",
            "baseName": "category_description",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "condition",
            "baseName": "condition",
            "type": "string"
        },
        {
            "name": "customLabel0",
            "baseName": "custom_label0",
            "type": "string"
        },
        {
            "name": "customLabel1",
            "baseName": "custom_label1",
            "type": "string"
        },
        {
            "name": "customLabel2",
            "baseName": "custom_label2",
            "type": "string"
        },
        {
            "name": "customLabel3",
            "baseName": "custom_label3",
            "type": "string"
        },
        {
            "name": "customLabel4",
            "baseName": "custom_label4",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "googleProductCategory",
            "baseName": "google_product_category",
            "type": "string"
        },
        {
            "name": "musicArtist",
            "baseName": "music_artist",
            "type": "string"
        },
        {
            "name": "musicFormat",
            "baseName": "music_format",
            "type": "string"
        },
        {
            "name": "musicReleaseDate",
            "baseName": "music_release_date",
            "type": "string"
        },
        {
            "name": "omitFromFeed",
            "baseName": "omit_from_feed",
            "type": "boolean"
        },
        {
            "name": "productType",
            "baseName": "product_type",
            "type": "string"
        },
        {
            "name": "promotionId1",
            "baseName": "promotion_id1",
            "type": "string"
        },
        {
            "name": "promotionId10",
            "baseName": "promotion_id10",
            "type": "string"
        },
        {
            "name": "promotionId2",
            "baseName": "promotion_id2",
            "type": "string"
        },
        {
            "name": "promotionId3",
            "baseName": "promotion_id3",
            "type": "string"
        },
        {
            "name": "promotionId4",
            "baseName": "promotion_id4",
            "type": "string"
        },
        {
            "name": "promotionId5",
            "baseName": "promotion_id5",
            "type": "string"
        },
        {
            "name": "promotionId6",
            "baseName": "promotion_id6",
            "type": "string"
        },
        {
            "name": "promotionId7",
            "baseName": "promotion_id7",
            "type": "string"
        },
        {
            "name": "promotionId8",
            "baseName": "promotion_id8",
            "type": "string"
        },
        {
            "name": "promotionId9",
            "baseName": "promotion_id9",
            "type": "string"
        },
        {
            "name": "searchDts",
            "baseName": "search_dts",
            "type": "string"
        },
        {
            "name": "searchLowestPrice",
            "baseName": "search_lowest_price",
            "type": "number"
        },
        {
            "name": "searchLowestUrl",
            "baseName": "search_lowest_url",
            "type": "string"
        },
        {
            "name": "searchPosition",
            "baseName": "search_position",
            "type": "number"
        },
        {
            "name": "shippingLabel",
            "baseName": "shippingLabel",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "string"
        },
        {
            "name": "videoDirector",
            "baseName": "video_director",
            "type": "string"
        },
        {
            "name": "videoFormat",
            "baseName": "video_format",
            "type": "string"
        },
        {
            "name": "videoRating",
            "baseName": "video_rating",
            "type": "string"
        },
        {
            "name": "videoReleaseDate",
            "baseName": "video_release_date",
            "type": "string"
        },
        {
            "name": "videoStarring",
            "baseName": "video_starring",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemGoogleProductSearch.attributeTypeMap;
    }
}

export class ItemIdentifiers {
    /**
    * Barcode
    */
    'barcode'?: string;
    /**
    * Manufacturer Name
    */
    'manufacturerName'?: string;
    /**
    * Manufacturer SKU
    */
    'manufacturerSku'?: string;
    /**
    * UNSPSC
    */
    'unspsc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "barcode",
            "baseName": "barcode",
            "type": "string"
        },
        {
            "name": "manufacturerName",
            "baseName": "manufacturer_name",
            "type": "string"
        },
        {
            "name": "manufacturerSku",
            "baseName": "manufacturer_sku",
            "type": "string"
        },
        {
            "name": "unspsc",
            "baseName": "unspsc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemIdentifiers.attributeTypeMap;
    }
}

export class ItemInstantPaymentNotification {
    /**
    * True for HTTP POST instead of GET
    */
    'postOperation'?: boolean;
    /**
    * Successful response text
    */
    'successfulResponseText'?: string;
    /**
    * URL
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "postOperation",
            "baseName": "post_operation",
            "type": "boolean"
        },
        {
            "name": "successfulResponseText",
            "baseName": "successful_response_text",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemInstantPaymentNotification.attributeTypeMap;
    }
}

export class ItemInstantPaymentNotifications {
    /**
    * Notifications
    */
    'notifications'?: Array<ItemInstantPaymentNotification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "Array<ItemInstantPaymentNotification>"
        }    ];

    static getAttributeTypeMap() {
        return ItemInstantPaymentNotifications.attributeTypeMap;
    }
}

export class ItemInternal {
    /**
    * Memo
    */
    'memo'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "memo",
            "baseName": "memo",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemInternal.attributeTypeMap;
    }
}

export class ItemKitComponent {
    /**
    * Component item cost
    */
    'componentCost'?: number;
    /**
    * Component item description
    */
    'componentDescription'?: string;
    /**
    * Component item ID
    */
    'componentMerchantItemId'?: string;
    /**
    * Component item object identifier
    */
    'componentMerchantItemOid'?: number;
    /**
    * Quantity
    */
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "componentCost",
            "baseName": "component_cost",
            "type": "number"
        },
        {
            "name": "componentDescription",
            "baseName": "component_description",
            "type": "string"
        },
        {
            "name": "componentMerchantItemId",
            "baseName": "component_merchant_item_id",
            "type": "string"
        },
        {
            "name": "componentMerchantItemOid",
            "baseName": "component_merchant_item_oid",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemKitComponent.attributeTypeMap;
    }
}

export class ItemKitDefinition {
    /**
    * Components
    */
    'components'?: Array<ItemKitComponent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "components",
            "baseName": "components",
            "type": "Array<ItemKitComponent>"
        }    ];

    static getAttributeTypeMap() {
        return ItemKitDefinition.attributeTypeMap;
    }
}

export class ItemOption {
    /**
    * Cost if specified
    */
    'costIfSpecified'?: number;
    /**
    * Cost per letter
    */
    'costPerLetter'?: number;
    /**
    * Cost per line
    */
    'costPerLine'?: number;
    /**
    * Ignore this option on the order if the default value is selected
    */
    'ignoreIfDefault'?: boolean;
    /**
    * Label
    */
    'label'?: string;
    /**
    * Label translated text instance ID
    */
    'labelTranslatedTextInstanceOid'?: number;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Name translated text instance ID
    */
    'nameTranslatedTextInstanceOid'?: number;
    /**
    * One time fee
    */
    'oneTimeFee'?: boolean;
    /**
    * Option object identifier
    */
    'optionOid'?: number;
    /**
    * True if the customer is required to specify an answer
    */
    'required'?: boolean;
    /**
    * True if this is a system option
    */
    'systemOption'?: boolean;
    /**
    * Type of option
    */
    'type'?: ItemOption.TypeEnum;
    /**
    * Values
    */
    'values'?: Array<ItemOptionValue>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "costIfSpecified",
            "baseName": "cost_if_specified",
            "type": "number"
        },
        {
            "name": "costPerLetter",
            "baseName": "cost_per_letter",
            "type": "number"
        },
        {
            "name": "costPerLine",
            "baseName": "cost_per_line",
            "type": "number"
        },
        {
            "name": "ignoreIfDefault",
            "baseName": "ignore_if_default",
            "type": "boolean"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "labelTranslatedTextInstanceOid",
            "baseName": "label_translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nameTranslatedTextInstanceOid",
            "baseName": "name_translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "oneTimeFee",
            "baseName": "one_time_fee",
            "type": "boolean"
        },
        {
            "name": "optionOid",
            "baseName": "option_oid",
            "type": "number"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "systemOption",
            "baseName": "system_option",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ItemOption.TypeEnum"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<ItemOptionValue>"
        }    ];

    static getAttributeTypeMap() {
        return ItemOption.attributeTypeMap;
    }
}

export namespace ItemOption {
    export enum TypeEnum {
        Dropdown = <any> 'dropdown',
        FileAttachment = <any> 'file attachment',
        Fixed = <any> 'fixed',
        Hidden = <any> 'hidden',
        Multiline = <any> 'multiline',
        Radio = <any> 'radio',
        Single = <any> 'single'
    }
}
export class ItemOptionValue {
    /**
    * Additional dimensions application
    */
    'additionalDimensionApplication'?: ItemOptionValue.AdditionalDimensionApplicationEnum;
    /**
    * Additional items to add to the order if this value is selected
    */
    'additionalItems'?: Array<ItemOptionValueAdditionalItem>;
    /**
    * Cost change
    */
    'costChange'?: number;
    /**
    * True if default value
    */
    'defaultValue'?: boolean;
    /**
    * Digital items to allow the customer to download if this option value is selected
    */
    'digitalItems'?: Array<ItemOptionValueDigitalItem>;
    'height'?: Distance;
    'length'?: Distance;
    /**
    * Multimedia object identifier associated with this option value
    */
    'merchantItemMultimediaOid'?: number;
    /**
    * Option value object identifier
    */
    'optionValueOid'?: number;
    /**
    * Percentage cost change
    */
    'percentCostChange'?: number;
    /**
    * Translated text instance id
    */
    'translatedTextInstanceOid'?: number;
    /**
    * Value
    */
    'value'?: string;
    'weightChange'?: Weight;
    /**
    * Percentage weight change
    */
    'weightChangePercent'?: number;
    'width'?: Distance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalDimensionApplication",
            "baseName": "additional_dimension_application",
            "type": "ItemOptionValue.AdditionalDimensionApplicationEnum"
        },
        {
            "name": "additionalItems",
            "baseName": "additional_items",
            "type": "Array<ItemOptionValueAdditionalItem>"
        },
        {
            "name": "costChange",
            "baseName": "cost_change",
            "type": "number"
        },
        {
            "name": "defaultValue",
            "baseName": "default_value",
            "type": "boolean"
        },
        {
            "name": "digitalItems",
            "baseName": "digital_items",
            "type": "Array<ItemOptionValueDigitalItem>"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "Distance"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "Distance"
        },
        {
            "name": "merchantItemMultimediaOid",
            "baseName": "merchant_item_multimedia_oid",
            "type": "number"
        },
        {
            "name": "optionValueOid",
            "baseName": "option_value_oid",
            "type": "number"
        },
        {
            "name": "percentCostChange",
            "baseName": "percent_cost_change",
            "type": "number"
        },
        {
            "name": "translatedTextInstanceOid",
            "baseName": "translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "weightChange",
            "baseName": "weight_change",
            "type": "Weight"
        },
        {
            "name": "weightChangePercent",
            "baseName": "weight_change_percent",
            "type": "number"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "Distance"
        }    ];

    static getAttributeTypeMap() {
        return ItemOptionValue.attributeTypeMap;
    }
}

export namespace ItemOptionValue {
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}
export class ItemOptionValueAdditionalItem {
    /**
    * Additional item id
    */
    'additionalMerchantItemId'?: string;
    /**
    * Additional item object identifier
    */
    'additionalMerchantItemOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalMerchantItemId",
            "baseName": "additional_merchant_item_id",
            "type": "string"
        },
        {
            "name": "additionalMerchantItemOid",
            "baseName": "additional_merchant_item_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemOptionValueAdditionalItem.attributeTypeMap;
    }
}

export class ItemOptionValueDigitalItem {
    /**
    * Digital item object identifier
    */
    'digitalItemOid'?: number;
    /**
    * Original filename
    */
    'originalFilename'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "digitalItemOid",
            "baseName": "digital_item_oid",
            "type": "number"
        },
        {
            "name": "originalFilename",
            "baseName": "original_filename",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemOptionValueDigitalItem.attributeTypeMap;
    }
}

export class ItemPaymentProcessing {
    /**
    * True if prepaid cards should be blocked from buying this item
    */
    'blockPrepaid'?: boolean;
    /**
    * Credit card transaction type
    */
    'creditCardTransactionType'?: string;
    /**
    * True if no real-time charge should be performed on this item.
    */
    'noRealtimeCharge'?: boolean;
    /**
    * Payment method validity
    */
    'paymentMethodValidity'?: Array<string>;
    /**
    * Rotating transaction gateway codes
    */
    'rotatingTransactionGatewayCodes'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "blockPrepaid",
            "baseName": "block_prepaid",
            "type": "boolean"
        },
        {
            "name": "creditCardTransactionType",
            "baseName": "credit_card_transaction_type",
            "type": "string"
        },
        {
            "name": "noRealtimeCharge",
            "baseName": "no_realtime_charge",
            "type": "boolean"
        },
        {
            "name": "paymentMethodValidity",
            "baseName": "payment_method_validity",
            "type": "Array<string>"
        },
        {
            "name": "rotatingTransactionGatewayCodes",
            "baseName": "rotating_transaction_gateway_codes",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ItemPaymentProcessing.attributeTypeMap;
    }
}

export class ItemPhysical {
    'height'?: Distance;
    'length'?: Distance;
    'weight'?: Weight;
    'width'?: Distance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "height",
            "baseName": "height",
            "type": "Distance"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "Distance"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "Weight"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "Distance"
        }    ];

    static getAttributeTypeMap() {
        return ItemPhysical.attributeTypeMap;
    }
}

export class ItemPricing {
    /**
    * Allow arbitrary cost
    */
    'allowArbitraryCost'?: boolean;
    /**
    * Arbitrary cost velocity code
    */
    'arbitraryCostVelocityCode'?: string;
    /**
    * Cost if customer selects to receive item on auto order.  Set to zero to delete.
    */
    'autoOrderCost'?: number;
    /**
    * Automatic pricing tier name
    */
    'automaticPricingTierName'?: string;
    /**
    * Automatic pricing tier object identifier
    */
    'automaticPricingTierOid'?: number;
    /**
    * Cost of goods sold
    */
    'cogs'?: number;
    /**
    * Cost
    */
    'cost'?: number;
    /**
    * Currency code
    */
    'currencyCode'?: string;
    /**
    * Manufacturer suggested retail price
    */
    'manufacturerSuggestedRetailPrice'?: number;
    /**
    * Maximum arbitrary cost
    */
    'maximumArbitraryCost'?: number;
    /**
    * Minimum advertised price
    */
    'minimumAdvertisedPrice'?: number;
    /**
    * Minimum arbitrary cost
    */
    'minimumArbitraryCost'?: number;
    /**
    * Mix and match group
    */
    'mixAndMatchGroup'?: string;
    /**
    * Mix and match group object identifier
    */
    'mixAndMatchGroupOid'?: number;
    /**
    * Sale cost
    */
    'saleCost'?: number;
    /**
    * Sale end
    */
    'saleEnd'?: string;
    /**
    * Sale start
    */
    'saleStart'?: string;
    /**
    * Tiers
    */
    'tiers'?: Array<ItemPricingTier>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowArbitraryCost",
            "baseName": "allow_arbitrary_cost",
            "type": "boolean"
        },
        {
            "name": "arbitraryCostVelocityCode",
            "baseName": "arbitrary_cost_velocity_code",
            "type": "string"
        },
        {
            "name": "autoOrderCost",
            "baseName": "auto_order_cost",
            "type": "number"
        },
        {
            "name": "automaticPricingTierName",
            "baseName": "automatic_pricing_tier_name",
            "type": "string"
        },
        {
            "name": "automaticPricingTierOid",
            "baseName": "automatic_pricing_tier_oid",
            "type": "number"
        },
        {
            "name": "cogs",
            "baseName": "cogs",
            "type": "number"
        },
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "manufacturerSuggestedRetailPrice",
            "baseName": "manufacturer_suggested_retail_price",
            "type": "number"
        },
        {
            "name": "maximumArbitraryCost",
            "baseName": "maximum_arbitrary_cost",
            "type": "number"
        },
        {
            "name": "minimumAdvertisedPrice",
            "baseName": "minimum_advertised_price",
            "type": "number"
        },
        {
            "name": "minimumArbitraryCost",
            "baseName": "minimum_arbitrary_cost",
            "type": "number"
        },
        {
            "name": "mixAndMatchGroup",
            "baseName": "mix_and_match_group",
            "type": "string"
        },
        {
            "name": "mixAndMatchGroupOid",
            "baseName": "mix_and_match_group_oid",
            "type": "number"
        },
        {
            "name": "saleCost",
            "baseName": "sale_cost",
            "type": "number"
        },
        {
            "name": "saleEnd",
            "baseName": "sale_end",
            "type": "string"
        },
        {
            "name": "saleStart",
            "baseName": "sale_start",
            "type": "string"
        },
        {
            "name": "tiers",
            "baseName": "tiers",
            "type": "Array<ItemPricingTier>"
        }    ];

    static getAttributeTypeMap() {
        return ItemPricing.attributeTypeMap;
    }
}

export class ItemPricingTier {
    /**
    * True if this is the default tier
    */
    'defaultTier'?: boolean;
    /**
    * Discounts
    */
    'discounts'?: Array<ItemPricingTierDiscount>;
    'limit'?: ItemPricingTierLimit;
    /**
    * Pricing tier name
    */
    'name'?: string;
    /**
    * Pricing tier object identifier
    */
    'pricingTierOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultTier",
            "baseName": "default_tier",
            "type": "boolean"
        },
        {
            "name": "discounts",
            "baseName": "discounts",
            "type": "Array<ItemPricingTierDiscount>"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "ItemPricingTierLimit"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "pricingTierOid",
            "baseName": "pricing_tier_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemPricingTier.attributeTypeMap;
    }
}

export class ItemPricingTierDiscount {
    /**
    * Cost
    */
    'cost'?: number;
    /**
    * Quantity
    */
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemPricingTierDiscount.attributeTypeMap;
    }
}

export class ItemPricingTierLimit {
    /**
    * Cumulative order limit
    */
    'cumulativeOrderLimit'?: number;
    /**
    * Individual order limit
    */
    'individualOrderLimit'?: number;
    /**
    * Multiple quantity
    */
    'multipleQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cumulativeOrderLimit",
            "baseName": "cumulative_order_limit",
            "type": "number"
        },
        {
            "name": "individualOrderLimit",
            "baseName": "individual_order_limit",
            "type": "number"
        },
        {
            "name": "multipleQuantity",
            "baseName": "multiple_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemPricingTierLimit.attributeTypeMap;
    }
}

export class ItemProperty {
    /**
    * Expiration of the property
    */
    'expirationDts'?: string;
    /**
    * Property name
    */
    'name'?: string;
    /**
    * Property value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirationDts",
            "baseName": "expirationDts",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemProperty.attributeTypeMap;
    }
}

export class ItemRealtimePricing {
    /**
    * Real-time pricing provider parameters
    */
    'realtimePricingParameter'?: string;
    /**
    * Real-time pricing provider name
    */
    'realtimePricingProvider'?: string;
    /**
    * Real-time pricing provide object identifier
    */
    'realtimePricingProviderOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "realtimePricingParameter",
            "baseName": "realtime_pricing_parameter",
            "type": "string"
        },
        {
            "name": "realtimePricingProvider",
            "baseName": "realtime_pricing_provider",
            "type": "string"
        },
        {
            "name": "realtimePricingProviderOid",
            "baseName": "realtime_pricing_provider_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemRealtimePricing.attributeTypeMap;
    }
}

export class ItemRelated {
    /**
    * True to suppress system calculated relationships
    */
    'noSystemCalculatedRelatedItems'?: boolean;
    /**
    * Not relatable
    */
    'notRelatable'?: boolean;
    /**
    * Related items
    */
    'relatedItems'?: Array<ItemRelatedItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "noSystemCalculatedRelatedItems",
            "baseName": "no_system_calculated_related_items",
            "type": "boolean"
        },
        {
            "name": "notRelatable",
            "baseName": "not_relatable",
            "type": "boolean"
        },
        {
            "name": "relatedItems",
            "baseName": "related_items",
            "type": "Array<ItemRelatedItem>"
        }    ];

    static getAttributeTypeMap() {
        return ItemRelated.attributeTypeMap;
    }
}

export class ItemRelatedItem {
    /**
    * Related item id
    */
    'relatedMerchantItemId'?: string;
    /**
    * Related item object identifier
    */
    'relatedMerchantItemOid'?: number;
    /**
    * Relationship type
    */
    'type'?: ItemRelatedItem.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "relatedMerchantItemId",
            "baseName": "related_merchant_item_id",
            "type": "string"
        },
        {
            "name": "relatedMerchantItemOid",
            "baseName": "related_merchant_item_oid",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ItemRelatedItem.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return ItemRelatedItem.attributeTypeMap;
    }
}

export namespace ItemRelatedItem {
    export enum TypeEnum {
        System = <any> 'System',
        UserDefined = <any> 'UserDefined'
    }
}
export class ItemReporting {
    /**
    * Report as an upsell
    */
    'reportAsUpsell'?: boolean;
    /**
    * Report pickable quantities
    */
    'reportPickableQuantities'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reportAsUpsell",
            "baseName": "report_as_upsell",
            "type": "boolean"
        },
        {
            "name": "reportPickableQuantities",
            "baseName": "report_pickable_quantities",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return ItemReporting.attributeTypeMap;
    }
}

export class ItemResponse {
    'error'?: Error;
    'item'?: Item;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "item",
            "baseName": "item",
            "type": "Item"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ItemResponse.attributeTypeMap;
    }
}

export class ItemRestriction {
    /**
    * Exclude coupons
    */
    'excludeCoupon'?: boolean;
    /**
    * Exclude from free promotion
    */
    'excludeFromFreePromotion'?: boolean;
    /**
    * Items
    */
    'items'?: Array<ItemRestrictionItem>;
    /**
    * Maximum quantity
    */
    'maximumQuantity'?: number;
    /**
    * Minimum quantity (defaults to 1)
    */
    'minimumQuantity'?: number;
    /**
    * Multiple of quantity
    */
    'multipleQuantity'?: number;
    /**
    * One per customer
    */
    'onePerCustomer'?: boolean;
    /**
    * Purchase separately
    */
    'purchaseSeparately'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "excludeCoupon",
            "baseName": "exclude_coupon",
            "type": "boolean"
        },
        {
            "name": "excludeFromFreePromotion",
            "baseName": "exclude_from_free_promotion",
            "type": "boolean"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<ItemRestrictionItem>"
        },
        {
            "name": "maximumQuantity",
            "baseName": "maximum_quantity",
            "type": "number"
        },
        {
            "name": "minimumQuantity",
            "baseName": "minimum_quantity",
            "type": "number"
        },
        {
            "name": "multipleQuantity",
            "baseName": "multiple_quantity",
            "type": "number"
        },
        {
            "name": "onePerCustomer",
            "baseName": "one_per_customer",
            "type": "boolean"
        },
        {
            "name": "purchaseSeparately",
            "baseName": "purchase_separately",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemRestriction.attributeTypeMap;
    }
}

export class ItemRestrictionItem {
    /**
    * Restrict item id
    */
    'restrictMerchantItemId'?: string;
    /**
    * Restrict item object identifier
    */
    'restrictMerchantItemOid'?: number;
    /**
    * Restriction type
    */
    'type'?: ItemRestrictionItem.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "restrictMerchantItemId",
            "baseName": "restrict_merchant_item_id",
            "type": "string"
        },
        {
            "name": "restrictMerchantItemOid",
            "baseName": "restrict_merchant_item_oid",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ItemRestrictionItem.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return ItemRestrictionItem.attributeTypeMap;
    }
}

export namespace ItemRestrictionItem {
    export enum TypeEnum {
        CanNotBePurchasedWith = <any> 'can not be purchased with',
        CanOnlyBePurchasedWith = <any> 'can only be purchased with',
        MustBePurchasedWith = <any> 'must be purchased with'
    }
}
export class ItemRevguard {
    /**
    * Canceled CSR prompt group
    */
    'revguardCanceledCsrPromptGroup'?: number;
    /**
    * IVR prompt group
    */
    'revguardCanceledIvrPromptGroup'?: number;
    /**
    * Canceled web prompt group
    */
    'revguardCanceledWebPromptGroup'?: number;
    /**
    * Client brand
    */
    'revguardClientBrand'?: number;
    /**
    * CSR prompt group
    */
    'revguardCsrPromptGroup'?: number;
    /**
    * IVR prompt group
    */
    'revguardIvrPromptGroup'?: number;
    /**
    * Web prompt group
    */
    'revguardWebPromptGroup'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "revguardCanceledCsrPromptGroup",
            "baseName": "revguard_canceled_csr_prompt_group",
            "type": "number"
        },
        {
            "name": "revguardCanceledIvrPromptGroup",
            "baseName": "revguard_canceled_ivr_prompt_group",
            "type": "number"
        },
        {
            "name": "revguardCanceledWebPromptGroup",
            "baseName": "revguard_canceled_web_prompt_group",
            "type": "number"
        },
        {
            "name": "revguardClientBrand",
            "baseName": "revguard_client_brand",
            "type": "number"
        },
        {
            "name": "revguardCsrPromptGroup",
            "baseName": "revguard_csr_prompt_group",
            "type": "number"
        },
        {
            "name": "revguardIvrPromptGroup",
            "baseName": "revguard_ivr_prompt_group",
            "type": "number"
        },
        {
            "name": "revguardWebPromptGroup",
            "baseName": "revguard_web_prompt_group",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemRevguard.attributeTypeMap;
    }
}

export class ItemReviews {
    /**
    * True if the item has an approved review
    */
    'hasApprovedReview'?: boolean;
    /**
    * True if the item has a review
    */
    'hasReview'?: boolean;
    /**
    * Number of approved reviews
    */
    'reviewCount'?: number;
    /**
    * Overall score of reviews
    */
    'reviewOverall'?: number;
    /**
    * Review template name
    */
    'reviewTemplateName'?: string;
    /**
    * Review template object identifier
    */
    'reviewTemplateOid'?: number;
    /**
    * True if the item is reviewable
    */
    'reviewable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hasApprovedReview",
            "baseName": "has_approved_review",
            "type": "boolean"
        },
        {
            "name": "hasReview",
            "baseName": "has_review",
            "type": "boolean"
        },
        {
            "name": "reviewCount",
            "baseName": "review_count",
            "type": "number"
        },
        {
            "name": "reviewOverall",
            "baseName": "review_overall",
            "type": "number"
        },
        {
            "name": "reviewTemplateName",
            "baseName": "review_template_name",
            "type": "string"
        },
        {
            "name": "reviewTemplateOid",
            "baseName": "review_template_oid",
            "type": "number"
        },
        {
            "name": "reviewable",
            "baseName": "reviewable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemReviews.attributeTypeMap;
    }
}

export class ItemSalesforce {
    /**
    * Salesforce.com pricebook id
    */
    'sfdcPricebookId'?: string;
    /**
    * Salesforce.com product id
    */
    'sfdcProductId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sfdcPricebookId",
            "baseName": "sfdc_pricebook_id",
            "type": "string"
        },
        {
            "name": "sfdcProductId",
            "baseName": "sfdc_product_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemSalesforce.attributeTypeMap;
    }
}

export class ItemShipping {
    /**
    * Allow back order
    */
    'allowBackOrder'?: boolean;
    /**
    * Fulfillment by Amazon.com
    */
    'amazonFba'?: boolean;
    /**
    * Case inner packs
    */
    'caseInnerPacks'?: number;
    /**
    * Case units
    */
    'caseUnits'?: number;
    /**
    * Cases
    */
    'cases'?: Array<ItemShippingCase>;
    /**
    * This item is on pre-order
    */
    'collectSerialNumbers'?: boolean;
    /**
    * Country code of origin for customs forms.  (ISO-3166 two letter code)
    */
    'countryCodeOfOrigin'?: string;
    /**
    * Customs description
    */
    'customsDescription'?: string;
    /**
    * Customs value
    */
    'customsValue'?: number;
    /**
    * Delivery on Friday
    */
    'deliveryOnFriday'?: boolean;
    /**
    * Delivery on Monday
    */
    'deliveryOnMonday'?: boolean;
    /**
    * Delivery on Saturday
    */
    'deliveryOnSaturday'?: boolean;
    /**
    * Delivery on Sunday
    */
    'deliveryOnSunday'?: boolean;
    /**
    * Delivery on Thursday
    */
    'deliveryOnThursday'?: boolean;
    /**
    * Delivery on Tuesday
    */
    'deliveryOnTuesday'?: boolean;
    /**
    * Delivery on Wednesday
    */
    'deliveryOnWednesday'?: boolean;
    /**
    * Destination markups
    */
    'destinationMarkups'?: Array<ItemShippingDestinationMarkup>;
    /**
    * Destination restrictions
    */
    'destinationRestrictions'?: Array<ItemShippingDestinationRestriction>;
    /**
    * Distribution centers
    */
    'distributionCenters'?: Array<ItemShippingDistributionCenter>;
    /**
    * Estimated time of arrival
    */
    'eta'?: string;
    /**
    * Qualifies for free shipping
    */
    'freeShipping'?: boolean;
    /**
    * Freight class
    */
    'freightClass'?: string;
    /**
    * Hazardous material
    */
    'hazmat'?: boolean;
    /**
    * True if this item is made to order
    */
    'madeToOrder'?: boolean;
    /**
    * Number of days lead time it takes to make the item before ite can ship
    */
    'madeToOrderLeadTime'?: number;
    /**
    * Maximum days allowed in transit
    */
    'maxDaysTimeInTransit'?: number;
    /**
    * Methods
    */
    'methods'?: Array<ItemShippingMethod>;
    /**
    * No shipping discounts
    */
    'noShippingDiscount'?: boolean;
    /**
    * Package requirements
    */
    'packageRequirements'?: Array<ItemShippingPackageRequirement>;
    /**
    * Perishable class name
    */
    'perishableClassName'?: string;
    /**
    * Perishable class object identifier
    */
    'perishableClassOid'?: number;
    /**
    * This item is on pre-order
    */
    'preorder'?: boolean;
    /**
    * True to require customer to select a delivery date
    */
    'requireDeliveryDate'?: boolean;
    /**
    * Restrict shipment on Friday
    */
    'restrictShipmentOnFriday'?: boolean;
    /**
    * Restrict shipment on Monday
    */
    'restrictShipmentOnMonday'?: boolean;
    /**
    * Restrict shipment on Saturday
    */
    'restrictShipmentOnSaturday'?: boolean;
    /**
    * Restrict shipment on Sunday
    */
    'restrictShipmentOnSunday'?: boolean;
    /**
    * Restrict shipment on Thursday
    */
    'restrictShipmentOnThursday'?: boolean;
    /**
    * Restrict shipment on Tuesday
    */
    'restrictShipmentOnTuesday'?: boolean;
    /**
    * Restrict shipment on Wednesday
    */
    'restrictShipmentOnWednesday'?: boolean;
    /**
    * Ship this item in a separate box
    */
    'shipSeparately'?: boolean;
    'shipSeparatelyAdditionalWeight'?: Weight;
    'shipSeparatelyHeight'?: Distance;
    'shipSeparatelyLength'?: Distance;
    /**
    * Ship separately package special type
    */
    'shipSeparatelyPackageSpecialType'?: string;
    'shipSeparatelyWidth'?: Distance;
    /**
    * Special product type (USPS Media Mail)
    */
    'specialProductType'?: string;
    /**
    * Track inventory
    */
    'trackInventory'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowBackOrder",
            "baseName": "allow_back_order",
            "type": "boolean"
        },
        {
            "name": "amazonFba",
            "baseName": "amazon_fba",
            "type": "boolean"
        },
        {
            "name": "caseInnerPacks",
            "baseName": "case_inner_packs",
            "type": "number"
        },
        {
            "name": "caseUnits",
            "baseName": "case_units",
            "type": "number"
        },
        {
            "name": "cases",
            "baseName": "cases",
            "type": "Array<ItemShippingCase>"
        },
        {
            "name": "collectSerialNumbers",
            "baseName": "collect_serial_numbers",
            "type": "boolean"
        },
        {
            "name": "countryCodeOfOrigin",
            "baseName": "country_code_of_origin",
            "type": "string"
        },
        {
            "name": "customsDescription",
            "baseName": "customs_description",
            "type": "string"
        },
        {
            "name": "customsValue",
            "baseName": "customs_value",
            "type": "number"
        },
        {
            "name": "deliveryOnFriday",
            "baseName": "delivery_on_friday",
            "type": "boolean"
        },
        {
            "name": "deliveryOnMonday",
            "baseName": "delivery_on_monday",
            "type": "boolean"
        },
        {
            "name": "deliveryOnSaturday",
            "baseName": "delivery_on_saturday",
            "type": "boolean"
        },
        {
            "name": "deliveryOnSunday",
            "baseName": "delivery_on_sunday",
            "type": "boolean"
        },
        {
            "name": "deliveryOnThursday",
            "baseName": "delivery_on_thursday",
            "type": "boolean"
        },
        {
            "name": "deliveryOnTuesday",
            "baseName": "delivery_on_tuesday",
            "type": "boolean"
        },
        {
            "name": "deliveryOnWednesday",
            "baseName": "delivery_on_wednesday",
            "type": "boolean"
        },
        {
            "name": "destinationMarkups",
            "baseName": "destination_markups",
            "type": "Array<ItemShippingDestinationMarkup>"
        },
        {
            "name": "destinationRestrictions",
            "baseName": "destination_restrictions",
            "type": "Array<ItemShippingDestinationRestriction>"
        },
        {
            "name": "distributionCenters",
            "baseName": "distribution_centers",
            "type": "Array<ItemShippingDistributionCenter>"
        },
        {
            "name": "eta",
            "baseName": "eta",
            "type": "string"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "boolean"
        },
        {
            "name": "freightClass",
            "baseName": "freight_class",
            "type": "string"
        },
        {
            "name": "hazmat",
            "baseName": "hazmat",
            "type": "boolean"
        },
        {
            "name": "madeToOrder",
            "baseName": "made_to_order",
            "type": "boolean"
        },
        {
            "name": "madeToOrderLeadTime",
            "baseName": "made_to_order_lead_time",
            "type": "number"
        },
        {
            "name": "maxDaysTimeInTransit",
            "baseName": "max_days_time_in_transit",
            "type": "number"
        },
        {
            "name": "methods",
            "baseName": "methods",
            "type": "Array<ItemShippingMethod>"
        },
        {
            "name": "noShippingDiscount",
            "baseName": "no_shipping_discount",
            "type": "boolean"
        },
        {
            "name": "packageRequirements",
            "baseName": "package_requirements",
            "type": "Array<ItemShippingPackageRequirement>"
        },
        {
            "name": "perishableClassName",
            "baseName": "perishable_class_name",
            "type": "string"
        },
        {
            "name": "perishableClassOid",
            "baseName": "perishable_class_oid",
            "type": "number"
        },
        {
            "name": "preorder",
            "baseName": "preorder",
            "type": "boolean"
        },
        {
            "name": "requireDeliveryDate",
            "baseName": "require_delivery_date",
            "type": "boolean"
        },
        {
            "name": "restrictShipmentOnFriday",
            "baseName": "restrict_shipment_on_friday",
            "type": "boolean"
        },
        {
            "name": "restrictShipmentOnMonday",
            "baseName": "restrict_shipment_on_monday",
            "type": "boolean"
        },
        {
            "name": "restrictShipmentOnSaturday",
            "baseName": "restrict_shipment_on_saturday",
            "type": "boolean"
        },
        {
            "name": "restrictShipmentOnSunday",
            "baseName": "restrict_shipment_on_sunday",
            "type": "boolean"
        },
        {
            "name": "restrictShipmentOnThursday",
            "baseName": "restrict_shipment_on_thursday",
            "type": "boolean"
        },
        {
            "name": "restrictShipmentOnTuesday",
            "baseName": "restrict_shipment_on_tuesday",
            "type": "boolean"
        },
        {
            "name": "restrictShipmentOnWednesday",
            "baseName": "restrict_shipment_on_wednesday",
            "type": "boolean"
        },
        {
            "name": "shipSeparately",
            "baseName": "ship_separately",
            "type": "boolean"
        },
        {
            "name": "shipSeparatelyAdditionalWeight",
            "baseName": "ship_separately_additional_weight",
            "type": "Weight"
        },
        {
            "name": "shipSeparatelyHeight",
            "baseName": "ship_separately_height",
            "type": "Distance"
        },
        {
            "name": "shipSeparatelyLength",
            "baseName": "ship_separately_length",
            "type": "Distance"
        },
        {
            "name": "shipSeparatelyPackageSpecialType",
            "baseName": "ship_separately_package_special_type",
            "type": "string"
        },
        {
            "name": "shipSeparatelyWidth",
            "baseName": "ship_separately_width",
            "type": "Distance"
        },
        {
            "name": "specialProductType",
            "baseName": "special_product_type",
            "type": "string"
        },
        {
            "name": "trackInventory",
            "baseName": "track_inventory",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemShipping.attributeTypeMap;
    }
}

export class ItemShippingCase {
    /**
    * Case label
    */
    'caseLabel'?: string;
    /**
    * Case item id
    */
    'caseMerchantItemId'?: string;
    /**
    * Case item object identifier
    */
    'caseMerchantItemOid'?: number;
    /**
    * Case quantity
    */
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "caseLabel",
            "baseName": "case_label",
            "type": "string"
        },
        {
            "name": "caseMerchantItemId",
            "baseName": "case_merchant_item_id",
            "type": "string"
        },
        {
            "name": "caseMerchantItemOid",
            "baseName": "case_merchant_item_oid",
            "type": "number"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemShippingCase.attributeTypeMap;
    }
}

export class ItemShippingDestinationMarkup {
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode'?: string;
    /**
    * Flat fee
    */
    'flatFee'?: number;
    /**
    * Per item
    */
    'perItem'?: number;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * Shipping method
    */
    'shippingMethod'?: string;
    /**
    * State
    */
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "flatFee",
            "baseName": "flat_fee",
            "type": "number"
        },
        {
            "name": "perItem",
            "baseName": "per_item",
            "type": "number"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "shippingMethod",
            "baseName": "shipping_method",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemShippingDestinationMarkup.attributeTypeMap;
    }
}

export class ItemShippingDestinationRestriction {
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode'?: string;
    /**
    * State
    */
    'state'?: string;
    /**
    * Validity
    */
    'validity'?: ItemShippingDestinationRestriction.ValidityEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "validity",
            "baseName": "validity",
            "type": "ItemShippingDestinationRestriction.ValidityEnum"
        }    ];

    static getAttributeTypeMap() {
        return ItemShippingDestinationRestriction.attributeTypeMap;
    }
}

export namespace ItemShippingDestinationRestriction {
    export enum ValidityEnum {
        ValidOnlyFor = <any> 'valid only for',
        InvalidFor = <any> 'invalid for'
    }
}
export class ItemShippingDistributionCenter {
    /**
    * Allocated to placed orders
    */
    'allocatedToPlacedOrders'?: number;
    /**
    * Allocated to shopping carts
    */
    'allocatedToShoppingCarts'?: number;
    /**
    * Available to allocate
    */
    'availableToAllocate'?: number;
    /**
    * Desired inventory level
    */
    'desiredInventoryLevel'?: number;
    /**
    * Distribution center code
    */
    'distributionCenterCode'?: string;
    /**
    * Distribution center object identifier
    */
    'distributionCenterOid'?: number;
    /**
    * Estimated time of arrival
    */
    'eta'?: string;
    /**
    * True if this distribution center handles this item
    */
    'handles'?: boolean;
    /**
    * Inventory level
    */
    'inventoryLevel'?: number;
    /**
    * Maximum back-order
    */
    'maximumBackorder'?: number;
    /**
    * Reorder inventory level (triggers notification)
    */
    'reorderInventoryLevel'?: number;
    /**
    * SKU
    */
    'sku'?: string;
    /**
    * Stock picking location
    */
    'stockPickingLocation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allocatedToPlacedOrders",
            "baseName": "allocated_to_placed_orders",
            "type": "number"
        },
        {
            "name": "allocatedToShoppingCarts",
            "baseName": "allocated_to_shopping_carts",
            "type": "number"
        },
        {
            "name": "availableToAllocate",
            "baseName": "available_to_allocate",
            "type": "number"
        },
        {
            "name": "desiredInventoryLevel",
            "baseName": "desired_inventory_level",
            "type": "number"
        },
        {
            "name": "distributionCenterCode",
            "baseName": "distribution_center_code",
            "type": "string"
        },
        {
            "name": "distributionCenterOid",
            "baseName": "distribution_center_oid",
            "type": "number"
        },
        {
            "name": "eta",
            "baseName": "eta",
            "type": "string"
        },
        {
            "name": "handles",
            "baseName": "handles",
            "type": "boolean"
        },
        {
            "name": "inventoryLevel",
            "baseName": "inventory_level",
            "type": "number"
        },
        {
            "name": "maximumBackorder",
            "baseName": "maximum_backorder",
            "type": "number"
        },
        {
            "name": "reorderInventoryLevel",
            "baseName": "reorder_inventory_level",
            "type": "number"
        },
        {
            "name": "sku",
            "baseName": "sku",
            "type": "string"
        },
        {
            "name": "stockPickingLocation",
            "baseName": "stock_picking_location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemShippingDistributionCenter.attributeTypeMap;
    }
}

export class ItemShippingMethod {
    /**
    * Cost
    */
    'cost'?: number;
    /**
    * Each additional item markup
    */
    'eachAdditionalItemMarkup'?: number;
    /**
    * Filter to this method if available
    */
    'filterToIfAvailable'?: boolean;
    /**
    * First item markup
    */
    'firstItemMarkup'?: number;
    /**
    * Fixed shipping cost
    */
    'fixedShippingCost'?: number;
    /**
    * Flat fee markup
    */
    'flatFeeMarkup'?: number;
    /**
    * Free shipping
    */
    'freeShipping'?: boolean;
    /**
    * Per item fee markup
    */
    'perItemFeeMarkup'?: number;
    /**
    * Percentage markup
    */
    'percentageMarkup'?: number;
    /**
    * Percentage of item markup
    */
    'percentageOfItemMarkup'?: number;
    /**
    * Relax restrictions on upsell
    */
    'relaxRestrictionsOnUpsell'?: boolean;
    /**
    * Shipping method name
    */
    'shippingMethod'?: string;
    /**
    * Shipping method object identifier
    */
    'shippingMethodOid'?: number;
    /**
    * Shipping method validity
    */
    'shippingMethodValidity'?: ItemShippingMethod.ShippingMethodValidityEnum;
    /**
    * Signature required
    */
    'signatureRequired'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        },
        {
            "name": "eachAdditionalItemMarkup",
            "baseName": "each_additional_item_markup",
            "type": "number"
        },
        {
            "name": "filterToIfAvailable",
            "baseName": "filter_to_if_available",
            "type": "boolean"
        },
        {
            "name": "firstItemMarkup",
            "baseName": "first_item_markup",
            "type": "number"
        },
        {
            "name": "fixedShippingCost",
            "baseName": "fixed_shipping_cost",
            "type": "number"
        },
        {
            "name": "flatFeeMarkup",
            "baseName": "flat_fee_markup",
            "type": "number"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "boolean"
        },
        {
            "name": "perItemFeeMarkup",
            "baseName": "per_item_fee_markup",
            "type": "number"
        },
        {
            "name": "percentageMarkup",
            "baseName": "percentage_markup",
            "type": "number"
        },
        {
            "name": "percentageOfItemMarkup",
            "baseName": "percentage_of_item_markup",
            "type": "number"
        },
        {
            "name": "relaxRestrictionsOnUpsell",
            "baseName": "relax_restrictions_on_upsell",
            "type": "boolean"
        },
        {
            "name": "shippingMethod",
            "baseName": "shipping_method",
            "type": "string"
        },
        {
            "name": "shippingMethodOid",
            "baseName": "shipping_method_oid",
            "type": "number"
        },
        {
            "name": "shippingMethodValidity",
            "baseName": "shipping_method_validity",
            "type": "ItemShippingMethod.ShippingMethodValidityEnum"
        },
        {
            "name": "signatureRequired",
            "baseName": "signature_required",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ItemShippingMethod.attributeTypeMap;
    }
}

export namespace ItemShippingMethod {
    export enum ShippingMethodValidityEnum {
        InvalidFor = <any> 'invalid for',
        ValidFor = <any> 'valid for',
        ValidOnlyFor = <any> 'valid only for'
    }
}
export class ItemShippingPackageRequirement {
    /**
    * Package name
    */
    'packageName'?: string;
    /**
    * Package object identifier
    */
    'packageOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "packageName",
            "baseName": "package_name",
            "type": "string"
        },
        {
            "name": "packageOid",
            "baseName": "package_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemShippingPackageRequirement.attributeTypeMap;
    }
}

export class ItemTag {
    /**
    * tag_tpe
    */
    'tagType'?: ItemTag.TagTypeEnum;
    /**
    * tag_value
    */
    'tagValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tagType",
            "baseName": "tagType",
            "type": "ItemTag.TagTypeEnum"
        },
        {
            "name": "tagValue",
            "baseName": "tagValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemTag.attributeTypeMap;
    }
}

export namespace ItemTag {
    export enum TagTypeEnum {
        Item = <any> 'item',
        Order = <any> 'order',
        Customer = <any> 'customer'
    }
}
export class ItemTags {
    /**
    * tags
    */
    'tags'?: Array<ItemTag>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<ItemTag>"
        }    ];

    static getAttributeTypeMap() {
        return ItemTags.attributeTypeMap;
    }
}

export class ItemTax {
    /**
    * Exemptions
    */
    'exemptions'?: Array<ItemTaxExemption>;
    /**
    * True if tax free
    */
    'taxFree'?: boolean;
    /**
    * Taxable cost if different than regular cost
    */
    'taxableCost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exemptions",
            "baseName": "exemptions",
            "type": "Array<ItemTaxExemption>"
        },
        {
            "name": "taxFree",
            "baseName": "tax_free",
            "type": "boolean"
        },
        {
            "name": "taxableCost",
            "baseName": "taxable_cost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ItemTax.attributeTypeMap;
    }
}

export class ItemTaxExemption {
    /**
    * City
    */
    'city'?: string;
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode'?: string;
    /**
    * County
    */
    'county'?: string;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * State code
    */
    'stateCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateCode",
            "baseName": "state_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemTaxExemption.attributeTypeMap;
    }
}

export class ItemThirdPartyEmailMarketing {
    /**
    * Add tags
    */
    'addTags'?: Array<string>;
    /**
    * Provider name
    */
    'providerName'?: ItemThirdPartyEmailMarketing.ProviderNameEnum;
    /**
    * Remove tags
    */
    'removeTags'?: Array<string>;
    /**
    * Subscribe to lists
    */
    'subscribeLists'?: Array<string>;
    /**
    * Unsubscribe from lists
    */
    'unsubscribeLists'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addTags",
            "baseName": "add_tags",
            "type": "Array<string>"
        },
        {
            "name": "providerName",
            "baseName": "provider_name",
            "type": "ItemThirdPartyEmailMarketing.ProviderNameEnum"
        },
        {
            "name": "removeTags",
            "baseName": "remove_tags",
            "type": "Array<string>"
        },
        {
            "name": "subscribeLists",
            "baseName": "subscribe_lists",
            "type": "Array<string>"
        },
        {
            "name": "unsubscribeLists",
            "baseName": "unsubscribe_lists",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ItemThirdPartyEmailMarketing.attributeTypeMap;
    }
}

export namespace ItemThirdPartyEmailMarketing {
    export enum ProviderNameEnum {
        ActiveCampaign = <any> 'ActiveCampaign',
        AWeber = <any> 'AWeber',
        CampaignMonitor = <any> 'Campaign Monitor',
        ConstantContact = <any> 'ConstantContact',
        Emma = <any> 'Emma',
        GetResponse = <any> 'GetResponse',
        IContact = <any> 'iContact',
        Klaviyo = <any> 'Klaviyo',
        Lyris = <any> 'Lyris',
        LyrisHQ = <any> 'LyrisHQ',
        MailChimp = <any> 'MailChimp',
        SilverPop = <any> 'SilverPop'
    }
}
export class ItemVariantItem {
    /**
    * Description
    */
    'description'?: string;
    /**
    * Multimedia object identifier
    */
    'merchantItemMultimediaOid'?: number;
    /**
    * Variant item id
    */
    'variantMerchantItemId'?: string;
    /**
    * Variant item object identifier
    */
    'variantMerchantItemOid'?: number;
    /**
    * Variation options
    */
    'variationOptions'?: Array<string>;
    /**
    * Variations
    */
    'variations'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "merchantItemMultimediaOid",
            "baseName": "merchant_item_multimedia_oid",
            "type": "number"
        },
        {
            "name": "variantMerchantItemId",
            "baseName": "variant_merchant_item_id",
            "type": "string"
        },
        {
            "name": "variantMerchantItemOid",
            "baseName": "variant_merchant_item_oid",
            "type": "number"
        },
        {
            "name": "variationOptions",
            "baseName": "variation_options",
            "type": "Array<string>"
        },
        {
            "name": "variations",
            "baseName": "variations",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ItemVariantItem.attributeTypeMap;
    }
}

export class ItemVariation {
    /**
    * Default text
    */
    'defaultText'?: string;
    /**
    * Default text translated text instance id
    */
    'defaultTextTranslatedTextInstanceOid'?: number;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Name translated text instance id
    */
    'nameTranslatedTextInstanceOid'?: number;
    /**
    * Options
    */
    'options'?: Array<ItemVariationOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultText",
            "baseName": "default_text",
            "type": "string"
        },
        {
            "name": "defaultTextTranslatedTextInstanceOid",
            "baseName": "default_text_translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nameTranslatedTextInstanceOid",
            "baseName": "name_translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<ItemVariationOption>"
        }    ];

    static getAttributeTypeMap() {
        return ItemVariation.attributeTypeMap;
    }
}

export class ItemVariationOption {
    /**
    * True if default option
    */
    'defaultOption'?: boolean;
    /**
    * Multimedia object identifier
    */
    'merchantItemMultimediaOid'?: number;
    /**
    * Translated text instance id
    */
    'translatedTextInstanceOid'?: number;
    /**
    * Value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultOption",
            "baseName": "default_option",
            "type": "boolean"
        },
        {
            "name": "merchantItemMultimediaOid",
            "baseName": "merchant_item_multimedia_oid",
            "type": "number"
        },
        {
            "name": "translatedTextInstanceOid",
            "baseName": "translated_text_instance_oid",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemVariationOption.attributeTypeMap;
    }
}

export class ItemWishlistMember {
    /**
    * WishList Member instance description
    */
    'wishlistMemberInstanceDescription'?: string;
    /**
    * WishList Member instance object identifier
    */
    'wishlistMemberInstanceOid'?: number;
    /**
    * WishList Member SKU
    */
    'wishlistMemberSku'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "wishlistMemberInstanceDescription",
            "baseName": "wishlist_member_instance_description",
            "type": "string"
        },
        {
            "name": "wishlistMemberInstanceOid",
            "baseName": "wishlist_member_instance_oid",
            "type": "number"
        },
        {
            "name": "wishlistMemberSku",
            "baseName": "wishlist_member_sku",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ItemWishlistMember.attributeTypeMap;
    }
}

export class ItemsRequest {
    /**
    * items
    */
    'items'?: Array<Item>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Item>"
        }    ];

    static getAttributeTypeMap() {
        return ItemsRequest.attributeTypeMap;
    }
}

export class ItemsResponse {
    'error'?: Error;
    /**
    * items
    */
    'items'?: Array<Item>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Item>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ItemsResponse.attributeTypeMap;
    }
}

export class KeyValue {
    /**
    * Optional description of the lookup value
    */
    'description'?: string;
    /**
    * The key or id of this lookup value
    */
    'key'?: string;
    /**
    * The value of this lookup value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KeyValue.attributeTypeMap;
    }
}

export class LibraryFilterValues {
    'categories'?: Array<string>;
    'industries'?: Array<string>;
    'styles'?: Array<string>;
    'types'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categories",
            "baseName": "categories",
            "type": "Array<string>"
        },
        {
            "name": "industries",
            "baseName": "industries",
            "type": "Array<string>"
        },
        {
            "name": "styles",
            "baseName": "styles",
            "type": "Array<string>"
        },
        {
            "name": "types",
            "baseName": "types",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return LibraryFilterValues.attributeTypeMap;
    }
}

export class LibraryFilterValuesResponse {
    'error'?: Error;
    'filterValues'?: LibraryFilterValues;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "filterValues",
            "baseName": "filter_values",
            "type": "LibraryFilterValues"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return LibraryFilterValuesResponse.attributeTypeMap;
    }
}

export class LibraryItem {
    'assets'?: Array<LibraryItemAsset>;
    'categories'?: Array<string>;
    'content'?: string;
    'contentType'?: string;
    'description'?: string;
    'industries'?: Array<string>;
    'libraryItemOid'?: number;
    'merchantId'?: string;
    /**
    * If this is a public item and the merchant has already purchased it, this is their version.  If not yet purchased, this will be zero.  This value will only be populated during a searchPublicItems() call.
    */
    'myPurchasedVersion'?: number;
    /**
    * This id points to the original object that was added to the library. For flows and campaigns, this is a uuid string.  For upsells, it is an oid integer.  For transactional_emails, it is an email name.
    */
    'originalObjectId'?: string;
    /**
    * The price of the published item.  Null for any private library items.
    */
    'price'?: number;
    /**
    * The formatted price of the published item.  Null for any private library items.
    */
    'priceFormatted'?: string;
    /**
    * True if this library item is a published item (not source)
    */
    'published'?: boolean;
    /**
    * The timestamp of the last published version
    */
    'publishedDts'?: any;
    /**
    * The source item used to publish this item.  This allows for comparisons between source and published
    */
    'publishedFromLibraryItemOid'?: number;
    /**
    * The source version when this item was published.  This allows for out-of-date alerts to be shown when there is a difference between source and published
    */
    'publishedVersion'?: number;
    /**
    * True if this library item has been purchased
    */
    'purchased'?: boolean;
    /**
    * The published item that was purchased to make this item.  This allows for comparisons between published and purchased
    */
    'purchasedFromLibraryItemOid'?: number;
    /**
    * The published version when this item was purchased.  This allows for out-of-date alerts to be shown when there is a difference between published and purchased
    */
    'purchasedVersion'?: number;
    /**
    * Any published library reviewed by UltraCart staff for malicious or inappropriate content will have this flag set to true.  This is always false for non-published items
    */
    'rejected'?: boolean;
    /**
    * Any rejected published item will have this field populated with the reason.
    */
    'rejectedReason'?: string;
    /**
    * Any published library items must be reviewed by UltraCart staff for malicious content.  This flag shows the status of that review.  This is always false for non-published items
    */
    'reviewed'?: boolean;
    /**
    * This is the timestamp for a published items formal review by UltraCart staff for malicious content.
    */
    'reviewedDts'?: any;
    'screenshots'?: Array<LibraryItemScreenshot>;
    'shareWithAccounts'?: Array<LibraryItemAccount>;
    'shareWithOtherEmails'?: Array<LibraryItemEmail>;
    /**
    * True if this item is shared from another merchant account
    */
    'shared'?: boolean;
    /**
    * True if this library item has been published
    */
    'source'?: boolean;
    /**
    * This oid points to the published library item, if there is one.
    */
    'sourceToLibraryItemOid'?: number;
    /**
    * The version of this item.  Increment every time the item is saved.
    */
    'sourceVersion'?: number;
    'style'?: string;
    'timesPurchased'?: number;
    'title'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assets",
            "baseName": "assets",
            "type": "Array<LibraryItemAsset>"
        },
        {
            "name": "categories",
            "baseName": "categories",
            "type": "Array<string>"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "industries",
            "baseName": "industries",
            "type": "Array<string>"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "myPurchasedVersion",
            "baseName": "my_purchased_version",
            "type": "number"
        },
        {
            "name": "originalObjectId",
            "baseName": "original_object_id",
            "type": "string"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "priceFormatted",
            "baseName": "price_formatted",
            "type": "string"
        },
        {
            "name": "published",
            "baseName": "published",
            "type": "boolean"
        },
        {
            "name": "publishedDts",
            "baseName": "published_dts",
            "type": "any"
        },
        {
            "name": "publishedFromLibraryItemOid",
            "baseName": "published_from_library_item_oid",
            "type": "number"
        },
        {
            "name": "publishedVersion",
            "baseName": "published_version",
            "type": "number"
        },
        {
            "name": "purchased",
            "baseName": "purchased",
            "type": "boolean"
        },
        {
            "name": "purchasedFromLibraryItemOid",
            "baseName": "purchased_from_library_item_oid",
            "type": "number"
        },
        {
            "name": "purchasedVersion",
            "baseName": "purchased_version",
            "type": "number"
        },
        {
            "name": "rejected",
            "baseName": "rejected",
            "type": "boolean"
        },
        {
            "name": "rejectedReason",
            "baseName": "rejected_reason",
            "type": "string"
        },
        {
            "name": "reviewed",
            "baseName": "reviewed",
            "type": "boolean"
        },
        {
            "name": "reviewedDts",
            "baseName": "reviewed_dts",
            "type": "any"
        },
        {
            "name": "screenshots",
            "baseName": "screenshots",
            "type": "Array<LibraryItemScreenshot>"
        },
        {
            "name": "shareWithAccounts",
            "baseName": "share_with_accounts",
            "type": "Array<LibraryItemAccount>"
        },
        {
            "name": "shareWithOtherEmails",
            "baseName": "share_with_other_emails",
            "type": "Array<LibraryItemEmail>"
        },
        {
            "name": "shared",
            "baseName": "shared",
            "type": "boolean"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "boolean"
        },
        {
            "name": "sourceToLibraryItemOid",
            "baseName": "source_to_library_item_oid",
            "type": "number"
        },
        {
            "name": "sourceVersion",
            "baseName": "source_version",
            "type": "number"
        },
        {
            "name": "style",
            "baseName": "style",
            "type": "string"
        },
        {
            "name": "timesPurchased",
            "baseName": "times_purchased",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItem.attributeTypeMap;
    }
}

export class LibraryItemAccount {
    'libraryItemAccountOid'?: number;
    'libraryItemOid'?: number;
    'otherMerchantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "libraryItemAccountOid",
            "baseName": "library_item_account_oid",
            "type": "number"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        },
        {
            "name": "otherMerchantId",
            "baseName": "other_merchant_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItemAccount.attributeTypeMap;
    }
}

export class LibraryItemAsset {
    'mimeType'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mimeType",
            "baseName": "mime_type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItemAsset.attributeTypeMap;
    }
}

export class LibraryItemEmail {
    'email'?: string;
    'libraryItemEmailOid'?: number;
    'libraryItemOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "libraryItemEmailOid",
            "baseName": "library_item_email_oid",
            "type": "number"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItemEmail.attributeTypeMap;
    }
}

export class LibraryItemQuery {
    /**
    * Category
    */
    'category'?: string;
    /**
    * Library item content type such as flow, campaign, cjson, email, or transactional_email
    */
    'contentType'?: string;
    /**
    * Description of library item
    */
    'description'?: string;
    /**
    * Industry
    */
    'industry'?: string;
    /**
    * Maximum price
    */
    'priceHigh'?: number;
    /**
    * Minimum price
    */
    'priceLow'?: number;
    /**
    * Minimum published date/time
    */
    'publishedDtsBegin'?: string;
    /**
    * Maximum published date/time
    */
    'publishedDtsEnd'?: string;
    /**
    * Boolean, true if this library item has been published and is the master copy of that published work
    */
    'sourceOfPublished'?: boolean;
    /**
    * Library item style
    */
    'style'?: string;
    /**
    * Title of the library item
    */
    'title'?: string;
    /**
    * Library item type such as header, footer, shipping block, etc
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "industry",
            "baseName": "industry",
            "type": "string"
        },
        {
            "name": "priceHigh",
            "baseName": "price_high",
            "type": "number"
        },
        {
            "name": "priceLow",
            "baseName": "price_low",
            "type": "number"
        },
        {
            "name": "publishedDtsBegin",
            "baseName": "published_dts_begin",
            "type": "string"
        },
        {
            "name": "publishedDtsEnd",
            "baseName": "published_dts_end",
            "type": "string"
        },
        {
            "name": "sourceOfPublished",
            "baseName": "source_of_published",
            "type": "boolean"
        },
        {
            "name": "style",
            "baseName": "style",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItemQuery.attributeTypeMap;
    }
}

export class LibraryItemResponse {
    'error'?: Error;
    'libraryItem'?: LibraryItem;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "libraryItem",
            "baseName": "library_item",
            "type": "LibraryItem"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItemResponse.attributeTypeMap;
    }
}

export class LibraryItemScreenshot {
    'defaultUrl'?: boolean;
    'screenshotUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultUrl",
            "baseName": "default_url",
            "type": "boolean"
        },
        {
            "name": "screenshotUrl",
            "baseName": "screenshot_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItemScreenshot.attributeTypeMap;
    }
}

export class LibraryItemsResponse {
    'error'?: Error;
    /**
    * Library items
    */
    'items'?: Array<LibraryItem>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<LibraryItem>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return LibraryItemsResponse.attributeTypeMap;
    }
}

export class LinkedAccount {
    /**
    * The company name of this linked account.
    */
    'company'?: string;
    /**
    * A merchant id that is linked to this account.
    */
    'merchantId'?: string;
    /**
    * If true, this user configuration (permissions, notifications, everything) is cascaded to this linked account.
    */
    'selected'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return LinkedAccount.attributeTypeMap;
    }
}

export class ListSegmentMembership {
    'name'?: string;
    'type'?: string;
    'uuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListSegmentMembership.attributeTypeMap;
    }
}

export class LookupRequest {
    'category'?: string;
    'matches'?: string;
    'maxHits'?: number;
    'storefrontOid'?: number;
    'subcategory'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "matches",
            "baseName": "matches",
            "type": "string"
        },
        {
            "name": "maxHits",
            "baseName": "max_hits",
            "type": "number"
        },
        {
            "name": "storefrontOid",
            "baseName": "storefront_oid",
            "type": "number"
        },
        {
            "name": "subcategory",
            "baseName": "subcategory",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LookupRequest.attributeTypeMap;
    }
}

export class LookupResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'values'?: Array<KeyValue>;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "values",
            "baseName": "values",
            "type": "Array<KeyValue>"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return LookupResponse.attributeTypeMap;
    }
}

export class Metric {
    'allTime'?: number;
    'allTimeFormatted'?: string;
    'last30'?: number;
    'last30Formatted'?: string;
    'name'?: string;
    'prior30'?: number;
    'prior30Formatted'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allTime",
            "baseName": "all_time",
            "type": "number"
        },
        {
            "name": "allTimeFormatted",
            "baseName": "all_time_formatted",
            "type": "string"
        },
        {
            "name": "last30",
            "baseName": "last_30",
            "type": "number"
        },
        {
            "name": "last30Formatted",
            "baseName": "last_30_formatted",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "prior30",
            "baseName": "prior_30",
            "type": "number"
        },
        {
            "name": "prior30Formatted",
            "baseName": "prior_30_formatted",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Metric.attributeTypeMap;
    }
}

export class ModelError {
    /**
    * A technical message meant to be read by a developer
    */
    'developerMessage'?: string;
    /**
    * HTTP status code
    */
    'errorCode'?: string;
    /**
    * Additional information often a link to additional documentation
    */
    'moreInfo'?: string;
    /**
    * An end-user friendly message suitable for display to the customer
    */
    'userMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "developerMessage",
            "baseName": "developer_message",
            "type": "string"
        },
        {
            "name": "errorCode",
            "baseName": "error_code",
            "type": "string"
        },
        {
            "name": "moreInfo",
            "baseName": "more_info",
            "type": "string"
        },
        {
            "name": "userMessage",
            "baseName": "user_message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}

export class Notification {
    /**
    * True if this notification can be filtered to only send for one or more distribution centers.
    */
    'canFilterByDistributionCenters'?: boolean;
    /**
    * True if this notification can include an affiliate information.
    */
    'canIncludeAffiliate'?: boolean;
    /**
    * True if this notification can include an order attachment.
    */
    'canIncludeOrder'?: boolean;
    /**
    * True if this notification can include a plain text rendering of an order directly within an email.  Some desire this over an attachment
    */
    'canIncludeOrderPlainText'?: boolean;
    /**
    * If this notification supports it, this list of distribution center CODES will filter the notification to just those distribution centers.
    */
    'distributionCenterFilters'?: Array<string>;
    /**
    * If true, and this notification supports it, affiliate information will be attached to all notifications of this type
    */
    'includeAffiliate'?: boolean;
    /**
    * If true, and this notification supports it, the order will be attached to all notifications of this type
    */
    'includeOrder'?: boolean;
    /**
    * If true, and this notification supports it, a plain text order will be directly inserted into all notifications of this type
    */
    'includeOrderPlainText'?: boolean;
    /**
    * The name of this notification.
    */
    'name'?: string;
    /**
    * A group for this notification.  This name is only used for visual grouping within interfaces.
    */
    'notificationGroup'?: string;
    /**
    * True if this user wishes to receive this email notification.
    */
    'selected'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canFilterByDistributionCenters",
            "baseName": "can_filter_by_distribution_centers",
            "type": "boolean"
        },
        {
            "name": "canIncludeAffiliate",
            "baseName": "can_include_affiliate",
            "type": "boolean"
        },
        {
            "name": "canIncludeOrder",
            "baseName": "can_include_order",
            "type": "boolean"
        },
        {
            "name": "canIncludeOrderPlainText",
            "baseName": "can_include_order_plain_text",
            "type": "boolean"
        },
        {
            "name": "distributionCenterFilters",
            "baseName": "distribution_center_filters",
            "type": "Array<string>"
        },
        {
            "name": "includeAffiliate",
            "baseName": "include_affiliate",
            "type": "boolean"
        },
        {
            "name": "includeOrder",
            "baseName": "include_order",
            "type": "boolean"
        },
        {
            "name": "includeOrderPlainText",
            "baseName": "include_order_plain_text",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "notificationGroup",
            "baseName": "notification_group",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Notification.attributeTypeMap;
    }
}

export class OauthRevokeSuccessResponse {
    /**
    * Message confirming revocation of credentials
    */
    'message'?: string;
    /**
    * True if revoke was successful
    */
    'successful'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "successful",
            "baseName": "successful",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OauthRevokeSuccessResponse.attributeTypeMap;
    }
}

export class OauthTokenResponse {
    /**
    * Access token to use in OAuth authenticated API call
    */
    'accessToken'?: string;
    'error'?: string;
    'errorDescription'?: string;
    'errorUri'?: string;
    /**
    * The number of seconds since issuance when the access token will expire and need to be refreshed using the refresh token
    */
    'expiresIn'?: string;
    /**
    * The refresh token that should be used to fetch a new access token when the expiration occurs
    */
    'refreshToken'?: string;
    /**
    * The scope of permissions associated with teh access token
    */
    'scope'?: string;
    /**
    * Type of token
    */
    'tokenType'?: OauthTokenResponse.TokenTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "errorDescription",
            "baseName": "error_description",
            "type": "string"
        },
        {
            "name": "errorUri",
            "baseName": "error_uri",
            "type": "string"
        },
        {
            "name": "expiresIn",
            "baseName": "expires_in",
            "type": "string"
        },
        {
            "name": "refreshToken",
            "baseName": "refresh_token",
            "type": "string"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        },
        {
            "name": "tokenType",
            "baseName": "token_type",
            "type": "OauthTokenResponse.TokenTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return OauthTokenResponse.attributeTypeMap;
    }
}

export namespace OauthTokenResponse {
    export enum TokenTypeEnum {
        Bearer = <any> 'bearer'
    }
}
export class Order {
    /**
    * Affiliates if any were associated with the order.  The first one in the array sent the order and each subsequent affiliate is the recruiter that earns a downline commission.
    */
    'affiliates'?: Array<OrderAffiliate>;
    'autoOrder'?: OrderAutoOrder;
    'billing'?: OrderBilling;
    'buysafe'?: OrderBuysafe;
    'channelPartner'?: OrderChannelPartner;
    'checkout'?: OrderCheckout;
    /**
    * Coupons
    */
    'coupons'?: Array<OrderCoupon>;
    /**
    * Date/time that the order was created
    */
    'creationDts'?: string;
    /**
    * Currency code that the customer used if different than the merchant's base currency code
    */
    'currencyCode'?: string;
    /**
    * Current stage that the order is in.
    */
    'currentStage'?: Order.CurrentStageEnum;
    'customerProfile'?: Customer;
    'digitalOrder'?: OrderDigitalOrder;
    'edi'?: OrderEdi;
    /**
    * Exchange rate at the time the order was placed if currency code is different than the base currency
    */
    'exchangeRate'?: number;
    'fraudScore'?: OrderFraudScore;
    'gift'?: OrderGift;
    'giftCertificate'?: OrderGiftCertificate;
    'internal'?: OrderInternal;
    /**
    * Items
    */
    'items'?: Array<OrderItem>;
    /**
    * Three letter ISO-639 language code used by the customer during the checkout if different than the default language
    */
    'languageIsoCode'?: string;
    'linkedShipment'?: OrderLinkedShipment;
    'marketing'?: OrderMarketing;
    /**
    * UltraCart merchant ID owning this order
    */
    'merchantId'?: string;
    /**
    * Order ID
    */
    'orderId'?: string;
    'payment'?: OrderPayment;
    /**
    * Properties, available only through update, not through insert due to the nature of how properties are handled internally
    */
    'properties'?: Array<OrderProperty>;
    'quote'?: OrderQuote;
    /**
    * If the order was refunded, the date/time that the last refund occurred
    */
    'refundDts'?: string;
    /**
    * If the order was rejected, the date/time that the rejection occurred
    */
    'rejectDts'?: string;
    'salesforce'?: OrderSalesforce;
    'shipping'?: OrderShipping;
    'summary'?: OrderSummary;
    /**
    * tags, available only through update, not through insert due to the nature of how tags are handled internally
    */
    'tags'?: Array<OrderTag>;
    'taxes'?: OrderTaxes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliates",
            "baseName": "affiliates",
            "type": "Array<OrderAffiliate>"
        },
        {
            "name": "autoOrder",
            "baseName": "auto_order",
            "type": "OrderAutoOrder"
        },
        {
            "name": "billing",
            "baseName": "billing",
            "type": "OrderBilling"
        },
        {
            "name": "buysafe",
            "baseName": "buysafe",
            "type": "OrderBuysafe"
        },
        {
            "name": "channelPartner",
            "baseName": "channel_partner",
            "type": "OrderChannelPartner"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "OrderCheckout"
        },
        {
            "name": "coupons",
            "baseName": "coupons",
            "type": "Array<OrderCoupon>"
        },
        {
            "name": "creationDts",
            "baseName": "creation_dts",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "currentStage",
            "baseName": "current_stage",
            "type": "Order.CurrentStageEnum"
        },
        {
            "name": "customerProfile",
            "baseName": "customer_profile",
            "type": "Customer"
        },
        {
            "name": "digitalOrder",
            "baseName": "digital_order",
            "type": "OrderDigitalOrder"
        },
        {
            "name": "edi",
            "baseName": "edi",
            "type": "OrderEdi"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchange_rate",
            "type": "number"
        },
        {
            "name": "fraudScore",
            "baseName": "fraud_score",
            "type": "OrderFraudScore"
        },
        {
            "name": "gift",
            "baseName": "gift",
            "type": "OrderGift"
        },
        {
            "name": "giftCertificate",
            "baseName": "gift_certificate",
            "type": "OrderGiftCertificate"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "OrderInternal"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<OrderItem>"
        },
        {
            "name": "languageIsoCode",
            "baseName": "language_iso_code",
            "type": "string"
        },
        {
            "name": "linkedShipment",
            "baseName": "linked_shipment",
            "type": "OrderLinkedShipment"
        },
        {
            "name": "marketing",
            "baseName": "marketing",
            "type": "OrderMarketing"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "payment",
            "baseName": "payment",
            "type": "OrderPayment"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<OrderProperty>"
        },
        {
            "name": "quote",
            "baseName": "quote",
            "type": "OrderQuote"
        },
        {
            "name": "refundDts",
            "baseName": "refund_dts",
            "type": "string"
        },
        {
            "name": "rejectDts",
            "baseName": "reject_dts",
            "type": "string"
        },
        {
            "name": "salesforce",
            "baseName": "salesforce",
            "type": "OrderSalesforce"
        },
        {
            "name": "shipping",
            "baseName": "shipping",
            "type": "OrderShipping"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "OrderSummary"
        },
        {
            "name": "tags",
            "baseName": "Tags",
            "type": "Array<OrderTag>"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "OrderTaxes"
        }    ];

    static getAttributeTypeMap() {
        return Order.attributeTypeMap;
    }
}

export namespace Order {
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown',
        PreOrdered = <any> 'Pre-ordered'
    }
}
export class OrderAffiliate {
    /**
    * Affiliate ID
    */
    'affiliateOid'?: number;
    /**
    * Ledger entries associated with all the commissions earned on this order
    */
    'ledgerEntries'?: Array<OrderAffiliateLedger>;
    /**
    * Sub identifier provided by the affiliate on the click that generated this order
    */
    'subId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affiliateOid",
            "baseName": "affiliate_oid",
            "type": "number"
        },
        {
            "name": "ledgerEntries",
            "baseName": "ledger_entries",
            "type": "Array<OrderAffiliateLedger>"
        },
        {
            "name": "subId",
            "baseName": "sub_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderAffiliate.attributeTypeMap;
    }
}

export class OrderAffiliateLedger {
    /**
    * UltraCart user name that assigned this commission if manually assigned
    */
    'assignedByUser'?: string;
    /**
    * Item ID that this ledger record is associated with
    */
    'itemId'?: string;
    /**
    * Tier number of this affiliate in the commission calculation
    */
    'tierNumber'?: number;
    /**
    * Amount of the transaction
    */
    'transactionAmount'?: number;
    /**
    * The amount that has been paid so far on the transaction
    */
    'transactionAmountPaid'?: number;
    /**
    * The date/time that the affiliate ledger was generated for the transaction
    */
    'transactionDts'?: string;
    /**
    * Details of the transaction suitable for display to the affiliate
    */
    'transactionMemo'?: string;
    /**
    * The percentage earned on the transaction
    */
    'transactionPercentage'?: number;
    /**
    * The state of the transaction
    */
    'transactionState'?: OrderAffiliateLedger.TransactionStateEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignedByUser",
            "baseName": "assigned_by_user",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "tierNumber",
            "baseName": "tier_number",
            "type": "number"
        },
        {
            "name": "transactionAmount",
            "baseName": "transaction_amount",
            "type": "number"
        },
        {
            "name": "transactionAmountPaid",
            "baseName": "transaction_amount_paid",
            "type": "number"
        },
        {
            "name": "transactionDts",
            "baseName": "transaction_dts",
            "type": "string"
        },
        {
            "name": "transactionMemo",
            "baseName": "transaction_memo",
            "type": "string"
        },
        {
            "name": "transactionPercentage",
            "baseName": "transaction_percentage",
            "type": "number"
        },
        {
            "name": "transactionState",
            "baseName": "transaction_state",
            "type": "OrderAffiliateLedger.TransactionStateEnum"
        }    ];

    static getAttributeTypeMap() {
        return OrderAffiliateLedger.attributeTypeMap;
    }
}

export namespace OrderAffiliateLedger {
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}
export class OrderAutoOrder {
    /**
    * Unique code assigned to this auto order
    */
    'autoOrderCode'?: string;
    /**
    * Auto order object identifier
    */
    'autoOrderOid'?: number;
    /**
    * Cancel this auto order after X additional rebills
    */
    'cancelAfterNextXOrders'?: number;
    /**
    * True if the auto order was canceled because the customer purchased a downgrade item
    */
    'cancelDowngrade'?: boolean;
    /**
    * True if the auto order was canceled because the customer purchased an upgrade item
    */
    'cancelUpgrade'?: boolean;
    /**
    * The user that canceled the auto order
    */
    'canceledByUser'?: string;
    /**
    * The date/time that the auto order was canceled
    */
    'canceledDts'?: string;
    /**
    * True if the auto order ran successfully to completion
    */
    'completed'?: boolean;
    /**
    * The number of credit card attempts that have taken place
    */
    'creditCardAttempt'?: number;
    /**
    * The date/time the auto order was disabled due to failed rebills
    */
    'disabledDts'?: string;
    /**
    * True if this auto order is enabled
    */
    'enabled'?: boolean;
    /**
    * The reason this auto order failed during the last rebill attempt
    */
    'failureReason'?: string;
    /**
    * The items that are setup to rebill
    */
    'items'?: Array<AutoOrderItem>;
    /**
    * The next time that the auto order will be attempted for processing
    */
    'nextAttempt'?: string;
    /**
    * The original order id that this auto order is associated with.
    */
    'originalOrderId'?: string;
    /**
    * Override the affiliate id given credit for rebills of this auto order
    */
    'overrideAffiliateId'?: number;
    /**
    * Rebill orders that have taken place on this auto order
    */
    'rebillOrders'?: Array<Order>;
    /**
    * The RTG code associated with this order for future rebills
    */
    'rotatingTransactionGatewayCode'?: string;
    /**
    * The status of the auto order
    */
    'status'?: OrderAutoOrder.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoOrderCode",
            "baseName": "auto_order_code",
            "type": "string"
        },
        {
            "name": "autoOrderOid",
            "baseName": "auto_order_oid",
            "type": "number"
        },
        {
            "name": "cancelAfterNextXOrders",
            "baseName": "cancel_after_next_x_orders",
            "type": "number"
        },
        {
            "name": "cancelDowngrade",
            "baseName": "cancel_downgrade",
            "type": "boolean"
        },
        {
            "name": "cancelUpgrade",
            "baseName": "cancel_upgrade",
            "type": "boolean"
        },
        {
            "name": "canceledByUser",
            "baseName": "canceled_by_user",
            "type": "string"
        },
        {
            "name": "canceledDts",
            "baseName": "canceled_dts",
            "type": "string"
        },
        {
            "name": "completed",
            "baseName": "completed",
            "type": "boolean"
        },
        {
            "name": "creditCardAttempt",
            "baseName": "credit_card_attempt",
            "type": "number"
        },
        {
            "name": "disabledDts",
            "baseName": "disabled_dts",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "failureReason",
            "baseName": "failure_reason",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<AutoOrderItem>"
        },
        {
            "name": "nextAttempt",
            "baseName": "next_attempt",
            "type": "string"
        },
        {
            "name": "originalOrderId",
            "baseName": "original_order_id",
            "type": "string"
        },
        {
            "name": "overrideAffiliateId",
            "baseName": "override_affiliate_id",
            "type": "number"
        },
        {
            "name": "rebillOrders",
            "baseName": "rebill_orders",
            "type": "Array<Order>"
        },
        {
            "name": "rotatingTransactionGatewayCode",
            "baseName": "rotating_transaction_gateway_code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "OrderAutoOrder.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return OrderAutoOrder.attributeTypeMap;
    }
}

export namespace OrderAutoOrder {
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}
export class OrderBilling {
    /**
    * Address line 1
    */
    'address1'?: string;
    /**
    * Address line 2
    */
    'address2'?: string;
    /**
    * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
    */
    'ccEmails'?: Array<string>;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Day time phone
    */
    'dayPhone'?: string;
    /**
    * Day time phone (E164 format)
    */
    'dayPhoneE164'?: string;
    /**
    * Email
    */
    'email'?: string;
    /**
    * Evening phone
    */
    'eveningPhone'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion'?: string;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "ccEmails",
            "baseName": "cc_emails",
            "type": "Array<string>"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "dayPhone",
            "baseName": "day_phone",
            "type": "string"
        },
        {
            "name": "dayPhoneE164",
            "baseName": "day_phone_e164",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "eveningPhone",
            "baseName": "evening_phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderBilling.attributeTypeMap;
    }
}

export class OrderBuysafe {
    /**
    * True if a buySAFE bond was available for purchase on this order
    */
    'buysafeBondAvailable'?: boolean;
    'buysafeBondCost'?: Currency;
    /**
    * True if the buySAFE bond was free for this order
    */
    'buysafeBondFree'?: boolean;
    'buysafeBondRefunded'?: Currency;
    /**
    * True if the buySAFE bond was wanted by the customer
    */
    'buysafeBondWanted'?: boolean;
    /**
    * Shopping cart ID associated with the buySAFE bond
    */
    'buysafeShoppingCartId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "buysafeBondAvailable",
            "baseName": "buysafe_bond_available",
            "type": "boolean"
        },
        {
            "name": "buysafeBondCost",
            "baseName": "buysafe_bond_cost",
            "type": "Currency"
        },
        {
            "name": "buysafeBondFree",
            "baseName": "buysafe_bond_free",
            "type": "boolean"
        },
        {
            "name": "buysafeBondRefunded",
            "baseName": "buysafe_bond_refunded",
            "type": "Currency"
        },
        {
            "name": "buysafeBondWanted",
            "baseName": "buysafe_bond_wanted",
            "type": "boolean"
        },
        {
            "name": "buysafeShoppingCartId",
            "baseName": "buysafe_shopping_cart_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderBuysafe.attributeTypeMap;
    }
}

export class OrderByTokenQuery {
    /**
    * Order Token
    */
    'orderToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderToken",
            "baseName": "order_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderByTokenQuery.attributeTypeMap;
    }
}

export class OrderChannelPartner {
    /**
    * If true, any purchase order submitted is automatically approved
    */
    'autoApprovePurchaseOrder'?: boolean;
    /**
    * The code of the channel partner
    */
    'channelPartnerCode'?: string;
    /**
    * Additional data provided by the channel partner, read-only
    */
    'channelPartnerData'?: string;
    /**
    * Channel partner object identifier, read-only and available on existing channel orders only.
    */
    'channelPartnerOid'?: number;
    /**
    * The order ID assigned by the channel partner for this order
    */
    'channelPartnerOrderId'?: string;
    /**
    * Indicates this order should be placed in Account Receivable for later payment processing
    */
    'noRealtimePaymentProcessing'?: boolean;
    /**
    * Indicates this order was already paid for via a channel purchase and no payment collection should be attempted
    */
    'skipPaymentProcessing'?: boolean;
    /**
    * Instructs UltraCart to skip shipping department and mark this order as fully complete.  Set this flag if you have already shipped product for this order.
    */
    'storeCompleted'?: boolean;
    /**
    * If true, any failed payment will place the order in Accounts Receivable rather than rejecting it.
    */
    'storeIfPaymentDeclines'?: boolean;
    /**
    * Any warnings are raised as errors and halt the import of the order
    */
    'treatWarningsAsErrors'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoApprovePurchaseOrder",
            "baseName": "auto_approve_purchase_order",
            "type": "boolean"
        },
        {
            "name": "channelPartnerCode",
            "baseName": "channel_partner_code",
            "type": "string"
        },
        {
            "name": "channelPartnerData",
            "baseName": "channel_partner_data",
            "type": "string"
        },
        {
            "name": "channelPartnerOid",
            "baseName": "channel_partner_oid",
            "type": "number"
        },
        {
            "name": "channelPartnerOrderId",
            "baseName": "channel_partner_order_id",
            "type": "string"
        },
        {
            "name": "noRealtimePaymentProcessing",
            "baseName": "no_realtime_payment_processing",
            "type": "boolean"
        },
        {
            "name": "skipPaymentProcessing",
            "baseName": "skip_payment_processing",
            "type": "boolean"
        },
        {
            "name": "storeCompleted",
            "baseName": "store_completed",
            "type": "boolean"
        },
        {
            "name": "storeIfPaymentDeclines",
            "baseName": "store_if_payment_declines",
            "type": "boolean"
        },
        {
            "name": "treatWarningsAsErrors",
            "baseName": "treat_warnings_as_errors",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderChannelPartner.attributeTypeMap;
    }
}

export class OrderCheckout {
    /**
    * Comments from the customer.  Rarely used on the single page checkout.
    */
    'comments'?: string;
    /**
    * Custom field 1
    */
    'customField1'?: string;
    /**
    * Custom field 2
    */
    'customField2'?: string;
    /**
    * Custom field 3
    */
    'customField3'?: string;
    /**
    * Custom field 4
    */
    'customField4'?: string;
    /**
    * Custom field 5
    */
    'customField5'?: string;
    /**
    * Custom field 6
    */
    'customField6'?: string;
    /**
    * Custom field 7
    */
    'customField7'?: string;
    /**
    * IP address of the customer when placing the order
    */
    'customerIpAddress'?: string;
    /**
    * Screen branding theme code associated with the order (legacy checkout)
    */
    'screenBrandingThemeCode'?: string;
    /**
    * StoreFront host name associated with the order
    */
    'storefrontHostName'?: string;
    /**
    * Upsell path code assigned during the checkout that the customer went through
    */
    'upsellPathCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "customField1",
            "baseName": "custom_field1",
            "type": "string"
        },
        {
            "name": "customField2",
            "baseName": "custom_field2",
            "type": "string"
        },
        {
            "name": "customField3",
            "baseName": "custom_field3",
            "type": "string"
        },
        {
            "name": "customField4",
            "baseName": "custom_field4",
            "type": "string"
        },
        {
            "name": "customField5",
            "baseName": "custom_field5",
            "type": "string"
        },
        {
            "name": "customField6",
            "baseName": "custom_field6",
            "type": "string"
        },
        {
            "name": "customField7",
            "baseName": "custom_field7",
            "type": "string"
        },
        {
            "name": "customerIpAddress",
            "baseName": "customer_ip_address",
            "type": "string"
        },
        {
            "name": "screenBrandingThemeCode",
            "baseName": "screen_branding_theme_code",
            "type": "string"
        },
        {
            "name": "storefrontHostName",
            "baseName": "storefront_host_name",
            "type": "string"
        },
        {
            "name": "upsellPathCode",
            "baseName": "upsell_path_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCheckout.attributeTypeMap;
    }
}

export class OrderCoupon {
    /**
    * QuickBooks accounting code for this coupon
    */
    'accountingCode'?: string;
    /**
    * Whether or not the coupon was automatically applied to the order
    */
    'automaticallyApplied'?: boolean;
    /**
    * Coupon code configured by the merchant.  Will differ if the customer used a one time coupon code generated off this base coupon
    */
    'baseCouponCode'?: string;
    /**
    * Coupon code entered by the customer
    */
    'couponCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "automaticallyApplied",
            "baseName": "automatically_applied",
            "type": "boolean"
        },
        {
            "name": "baseCouponCode",
            "baseName": "base_coupon_code",
            "type": "string"
        },
        {
            "name": "couponCode",
            "baseName": "coupon_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderCoupon.attributeTypeMap;
    }
}

export class OrderDigitalItem {
    /**
    * File size
    */
    'fileSize'?: number;
    /**
    * Last download
    */
    'lastDownload'?: string;
    /**
    * IP address that performed the last download
    */
    'lastDownloadIpAddress'?: string;
    /**
    * Original file name
    */
    'originalFilename'?: string;
    /**
    * Item id associated with this item
    */
    'productCode'?: string;
    /**
    * Item description associated with this item
    */
    'productDescription'?: string;
    /**
    * Remaining number of downloads
    */
    'remainingDownloads'?: number;
    /**
    * URL that the customer can click to download the specific digital item
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileSize",
            "baseName": "file_size",
            "type": "number"
        },
        {
            "name": "lastDownload",
            "baseName": "last_download",
            "type": "string"
        },
        {
            "name": "lastDownloadIpAddress",
            "baseName": "last_download_ip_address",
            "type": "string"
        },
        {
            "name": "originalFilename",
            "baseName": "original_filename",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "product_code",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "product_description",
            "type": "string"
        },
        {
            "name": "remainingDownloads",
            "baseName": "remaining_downloads",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDigitalItem.attributeTypeMap;
    }
}

export class OrderDigitalOrder {
    /**
    * Date/time that the digital order was created
    */
    'creationDts'?: string;
    /**
    * Expiration date/time of the digital order
    */
    'expirationDts'?: string;
    /**
    * Digital items associated with the digital order
    */
    'items'?: Array<OrderDigitalItem>;
    /**
    * URL where the customer can go to and download their digital order content
    */
    'url'?: string;
    /**
    * URL ID is a unique code that is part of the URLs
    */
    'urlId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creationDts",
            "baseName": "creation_dts",
            "type": "string"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<OrderDigitalItem>"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "urlId",
            "baseName": "url_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderDigitalOrder.attributeTypeMap;
    }
}

export class OrderEdi {
    /**
    * Billing address identification code from the EDI order.  Typically DUNS or DUNS+4
    */
    'billToEdiCode'?: string;
    /**
    * Department number associated with this EDI order
    */
    'ediDepartment'?: string;
    /**
    * Internal vendor number associated with this EDI order
    */
    'ediInternalVendorNumber'?: string;
    /**
    * Shipping address identification code from the EDI order.  Typically DUNS or DUNS+4
    */
    'shipToEdiCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billToEdiCode",
            "baseName": "bill_to_edi_code",
            "type": "string"
        },
        {
            "name": "ediDepartment",
            "baseName": "edi_department",
            "type": "string"
        },
        {
            "name": "ediInternalVendorNumber",
            "baseName": "edi_internal_vendor_number",
            "type": "string"
        },
        {
            "name": "shipToEdiCode",
            "baseName": "ship_to_edi_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderEdi.attributeTypeMap;
    }
}

export class OrderFormat {
    /**
    * The context to generate the order view for.
    */
    'context'?: string;
    /**
    * True to not link the email address to the order search
    */
    'dontLinkEmailToSearch'?: boolean;
    /**
    * True to make the email address a clickable mailto link
    */
    'emailAsLink'?: boolean;
    /**
    * Specify a distribution center oid to filter the items displayed to that particular distribution center.
    */
    'filterDistributionCenterOid'?: number;
    /**
    * The container oid to filter items to.
    */
    'filterToItemsInContactOid'?: number;
    /**
    * The desired format.
    */
    'format'?: OrderFormat.FormatEnum;
    /**
    * True to ide the bill to address
    */
    'hideBillToAddress'?: boolean;
    /**
    * True to hide price information
    */
    'hidePriceInformation'?: boolean;
    /**
    * True to link file attachments for download
    */
    'linkFileAttachments'?: boolean;
    /**
    * True to show contact information
    */
    'showContactInfo'?: boolean;
    /**
    * True to show the order in the merchant currency
    */
    'showInMerchantCurrency'?: boolean;
    /**
    * True to show internal information about the order
    */
    'showInternalInformation'?: boolean;
    /**
    * True to show merchant notes
    */
    'showMerchantNotes'?: boolean;
    /**
    * True to show non-sensitive payment information
    */
    'showNonSensitivePaymentInfo'?: boolean;
    /**
    * True to show payment information
    */
    'showPaymentInfo'?: boolean;
    /**
    * True to translate the order into the native language of the customer
    */
    'translate'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "dontLinkEmailToSearch",
            "baseName": "dont_link_email_to_search",
            "type": "boolean"
        },
        {
            "name": "emailAsLink",
            "baseName": "email_as_link",
            "type": "boolean"
        },
        {
            "name": "filterDistributionCenterOid",
            "baseName": "filter_distribution_center_oid",
            "type": "number"
        },
        {
            "name": "filterToItemsInContactOid",
            "baseName": "filter_to_items_in_contact_oid",
            "type": "number"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "OrderFormat.FormatEnum"
        },
        {
            "name": "hideBillToAddress",
            "baseName": "hide_bill_to_address",
            "type": "boolean"
        },
        {
            "name": "hidePriceInformation",
            "baseName": "hide_price_information",
            "type": "boolean"
        },
        {
            "name": "linkFileAttachments",
            "baseName": "link_file_attachments",
            "type": "boolean"
        },
        {
            "name": "showContactInfo",
            "baseName": "show_contact_info",
            "type": "boolean"
        },
        {
            "name": "showInMerchantCurrency",
            "baseName": "show_in_merchant_currency",
            "type": "boolean"
        },
        {
            "name": "showInternalInformation",
            "baseName": "show_internal_information",
            "type": "boolean"
        },
        {
            "name": "showMerchantNotes",
            "baseName": "show_merchant_notes",
            "type": "boolean"
        },
        {
            "name": "showNonSensitivePaymentInfo",
            "baseName": "show_non_sensitive_payment_info",
            "type": "boolean"
        },
        {
            "name": "showPaymentInfo",
            "baseName": "show_payment_info",
            "type": "boolean"
        },
        {
            "name": "translate",
            "baseName": "translate",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderFormat.attributeTypeMap;
    }
}

export namespace OrderFormat {
    export enum FormatEnum {
        Text = <any> 'text',
        Div = <any> 'div',
        Table = <any> 'table',
        Email = <any> 'email'
    }
}
export class OrderFormatResponse {
    /**
    * The URLs to any stylesheets that need to be included to properly view the markup.
    */
    'cssLinks'?: Array<string>;
    /**
    * The formatted result of the order.  This will be HTML or text depending upon the requested format.
    */
    'formattedResult'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cssLinks",
            "baseName": "css_links",
            "type": "Array<string>"
        },
        {
            "name": "formattedResult",
            "baseName": "formatted_result",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderFormatResponse.attributeTypeMap;
    }
}

export class OrderFraudScore {
    /**
    * True if the IP address is a known anonymous proxy server
    */
    'anonymousProxy'?: boolean;
    /**
    * Whether the BIN (first six digits) matched the country
    */
    'binMatch'?: OrderFraudScore.BinMatchEnum;
    /**
    * True if the email address belongs to a known credit card fraudster
    */
    'carderEmail'?: boolean;
    /**
    * Country code
    */
    'countryCode'?: string;
    /**
    * Country code matches BIN country
    */
    'countryMatch'?: boolean;
    /**
    * Whether the customer's phone number is located in the area of the billing address
    */
    'customerPhoneInBillingLocation'?: string;
    /**
    * Distance in kilometers between the IP address and the BIN
    */
    'distanceKm'?: number;
    /**
    * True if the email address is for a free service like gmail.com
    */
    'freeEmail'?: boolean;
    /**
    * True if the customer is in a high risk country known for internet fraud
    */
    'highRiskCountry'?: boolean;
    /**
    * City associated with the IP address
    */
    'ipCity'?: string;
    /**
    * ISP that owns the IP address
    */
    'ipIsp'?: string;
    /**
    * Approximate latitude associated with the IP address
    */
    'ipLatitude'?: string;
    /**
    * Approximate longitude associated with the IP address
    */
    'ipLongitude'?: string;
    /**
    * Organization that owns the IP address
    */
    'ipOrg'?: string;
    /**
    * State/region associated with the IP address
    */
    'ipRegion'?: string;
    /**
    * Likelihood of the IP address being a proxy server
    */
    'proxyScore'?: number;
    /**
    * Overall score.  This is the score that is compared to see if the order is rejected or held for review by the fraud filter rules.
    */
    'score'?: number;
    /**
    * True if the address is a known ship forwarding company
    */
    'shipForwarder'?: boolean;
    /**
    * Likelihood of the email address being associated with a spammer
    */
    'spamScore'?: number;
    /**
    * True if the IP address that placed the order is a transparent proxy server
    */
    'transparentProxy'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "anonymousProxy",
            "baseName": "anonymous_proxy",
            "type": "boolean"
        },
        {
            "name": "binMatch",
            "baseName": "bin_match",
            "type": "OrderFraudScore.BinMatchEnum"
        },
        {
            "name": "carderEmail",
            "baseName": "carder_email",
            "type": "boolean"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "countryMatch",
            "baseName": "country_match",
            "type": "boolean"
        },
        {
            "name": "customerPhoneInBillingLocation",
            "baseName": "customer_phone_in_billing_location",
            "type": "string"
        },
        {
            "name": "distanceKm",
            "baseName": "distance_km",
            "type": "number"
        },
        {
            "name": "freeEmail",
            "baseName": "free_email",
            "type": "boolean"
        },
        {
            "name": "highRiskCountry",
            "baseName": "high_risk_country",
            "type": "boolean"
        },
        {
            "name": "ipCity",
            "baseName": "ip_city",
            "type": "string"
        },
        {
            "name": "ipIsp",
            "baseName": "ip_isp",
            "type": "string"
        },
        {
            "name": "ipLatitude",
            "baseName": "ip_latitude",
            "type": "string"
        },
        {
            "name": "ipLongitude",
            "baseName": "ip_longitude",
            "type": "string"
        },
        {
            "name": "ipOrg",
            "baseName": "ip_org",
            "type": "string"
        },
        {
            "name": "ipRegion",
            "baseName": "ip_region",
            "type": "string"
        },
        {
            "name": "proxyScore",
            "baseName": "proxy_score",
            "type": "number"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "shipForwarder",
            "baseName": "ship_forwarder",
            "type": "boolean"
        },
        {
            "name": "spamScore",
            "baseName": "spam_score",
            "type": "number"
        },
        {
            "name": "transparentProxy",
            "baseName": "transparent_proxy",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderFraudScore.attributeTypeMap;
    }
}

export namespace OrderFraudScore {
    export enum BinMatchEnum {
        NA = <any> 'NA',
        No = <any> 'No',
        NotFound = <any> 'NotFound',
        Yes = <any> 'Yes'
    }
}
export class OrderGift {
    /**
    * True if the order is a gift
    */
    'gift'?: boolean;
    'giftCharge'?: Currency;
    /**
    * QuickBooks code for the gift charge
    */
    'giftChargeAccountingCode'?: string;
    'giftChargeRefunded'?: Currency;
    /**
    * Email address of the gift recipient
    */
    'giftEmail'?: string;
    /**
    * Message to the gift recipient
    */
    'giftMessage'?: string;
    /**
    * QuickBooks code for the gift wrap charge
    */
    'giftWrapAccountingCode'?: string;
    'giftWrapCost'?: Currency;
    'giftWrapRefunded'?: Currency;
    /**
    * Title of the gift wrap that the customer wants used
    */
    'giftWrapTitle'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gift",
            "baseName": "gift",
            "type": "boolean"
        },
        {
            "name": "giftCharge",
            "baseName": "gift_charge",
            "type": "Currency"
        },
        {
            "name": "giftChargeAccountingCode",
            "baseName": "gift_charge_accounting_code",
            "type": "string"
        },
        {
            "name": "giftChargeRefunded",
            "baseName": "gift_charge_refunded",
            "type": "Currency"
        },
        {
            "name": "giftEmail",
            "baseName": "gift_email",
            "type": "string"
        },
        {
            "name": "giftMessage",
            "baseName": "gift_message",
            "type": "string"
        },
        {
            "name": "giftWrapAccountingCode",
            "baseName": "gift_wrap_accounting_code",
            "type": "string"
        },
        {
            "name": "giftWrapCost",
            "baseName": "gift_wrap_cost",
            "type": "Currency"
        },
        {
            "name": "giftWrapRefunded",
            "baseName": "gift_wrap_refunded",
            "type": "Currency"
        },
        {
            "name": "giftWrapTitle",
            "baseName": "gift_wrap_title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderGift.attributeTypeMap;
    }
}

export class OrderGiftCertificate {
    'giftCertificateAmount'?: Currency;
    /**
    * Gift certificate code used on the order
    */
    'giftCertificateCode'?: string;
    /**
    * Gift certificate object identifier
    */
    'giftCertificateOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "giftCertificateAmount",
            "baseName": "gift_certificate_amount",
            "type": "Currency"
        },
        {
            "name": "giftCertificateCode",
            "baseName": "gift_certificate_code",
            "type": "string"
        },
        {
            "name": "giftCertificateOid",
            "baseName": "gift_certificate_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderGiftCertificate.attributeTypeMap;
    }
}

export class OrderInternal {
    /**
    * True if the order has been exported to QuickBooks. If QuickBooks is not configured, then this will already be true
    */
    'exportedToAccounting'?: boolean;
    /**
    * Merchant notes
    */
    'merchantNotes'?: string;
    /**
    * If placed via the BEOE, this is the user that placed the order
    */
    'placedByUser'?: string;
    /**
    * User that issued the refund
    */
    'refundByUser'?: string;
    /**
    * Sales rep code associated with the order
    */
    'salesRepCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exportedToAccounting",
            "baseName": "exported_to_accounting",
            "type": "boolean"
        },
        {
            "name": "merchantNotes",
            "baseName": "merchant_notes",
            "type": "string"
        },
        {
            "name": "placedByUser",
            "baseName": "placed_by_user",
            "type": "string"
        },
        {
            "name": "refundByUser",
            "baseName": "refund_by_user",
            "type": "string"
        },
        {
            "name": "salesRepCode",
            "baseName": "sales_rep_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderInternal.attributeTypeMap;
    }
}

export class OrderItem {
    /**
    * QuickBooks code
    */
    'accountingCode'?: string;
    /**
    * Activation codes assigned to this item
    */
    'activationCodes'?: Array<string>;
    'arbitraryUnitCost'?: Currency;
    /**
    * Date/time of the last rebill, used only during order insert to help project future rebills
    */
    'autoOrderLastRebillDts'?: string;
    /**
    * Auto order schedule, used only during inserts supplying the recurring schedule
    */
    'autoOrderSchedule'?: string;
    /**
    * Barcode
    */
    'barcode'?: string;
    /**
    * Channel partner item id if this order came through a channel partner and the channel partner item id was mapped to an internal item id
    */
    'channelPartnerItemId'?: string;
    /**
    * Cost of goods sold
    */
    'cogs'?: number;
    /**
    * Value of the kit component item
    */
    'componentUnitValue'?: number;
    'cost'?: Currency;
    /**
    * Country of origin (ISO-3166 two letter code)
    */
    'countryCodeOfOrigin'?: string;
    /**
    * Customs description
    */
    'customsDescription'?: string;
    /**
    * Description
    */
    'description'?: string;
    'discount'?: Currency;
    /**
    * Discount quantity
    */
    'discountQuantity'?: number;
    'discountShippingWeight'?: Weight;
    /**
    * Distribution center code responsible for shipping this item
    */
    'distributionCenterCode'?: string;
    'edi'?: OrderItemEdi;
    /**
    * True if this item is excluded from coupons
    */
    'excludeCoupon'?: boolean;
    /**
    * True if the item receives free shipping
    */
    'freeShipping'?: boolean;
    /**
    * Hazardous materials indicator
    */
    'hazmat'?: boolean;
    'height'?: Distance;
    /**
    * Item reference object identifier used to linked to auto order item record
    */
    'itemReferenceOid'?: number;
    /**
    * True if this item is a kit
    */
    'kit'?: boolean;
    /**
    * True if this item is a kit component
    */
    'kitComponent'?: boolean;
    'length'?: Distance;
    /**
    * Manufacturer SKU
    */
    'manufacturerSku'?: string;
    /**
    * Maximum days that the item can be in transit before spoilage (perishable products)
    */
    'maxDaysTimeInTransit'?: number;
    /**
    * Item ID
    */
    'merchantItemId'?: string;
    /**
    * Mix and match group name
    */
    'mixAndMatchGroupName'?: string;
    /**
    * Mix and match group object identifier
    */
    'mixAndMatchGroupOid'?: number;
    /**
    * True if this item is excluded from shipping discounts
    */
    'noShippingDiscount'?: boolean;
    /**
    * Options
    */
    'options'?: Array<OrderItemOption>;
    /**
    * Packed by user
    */
    'packedByUser'?: string;
    /**
    * Perishable class of the item
    */
    'perishableClass'?: string;
    /**
    * Pricing tier that granted the particular price for this item if the customer profile had pricing tiers assigned
    */
    'pricingTierName'?: string;
    /**
    * Properties
    */
    'properties'?: Array<OrderItemProperty>;
    /**
    * Quantity
    */
    'quantity'?: number;
    /**
    * Quantity refunded on this item (read only except refund operation)
    */
    'quantityRefunded'?: number;
    /**
    * QuickBooks class
    */
    'quickbooksClass'?: string;
    /**
    * True if this item ships in a separate box
    */
    'shipSeparately'?: boolean;
    /**
    * Shipped by user
    */
    'shippedByUser'?: string;
    /**
    * Date/time that this item was marked shipped
    */
    'shippedDts'?: string;
    /**
    * Special product type (USPS Media Mail)
    */
    'specialProductType'?: string;
    /**
    * Tags
    */
    'tags'?: Array<OrderItemTag>;
    /**
    * True if the item is tax free
    */
    'taxFree'?: boolean;
    'taxableCost'?: Currency;
    'totalCostWithDiscount'?: Currency;
    'totalRefunded'?: Currency;
    /**
    * Date/time that this item was transmitted to the distribution center
    */
    'transmittedToDistributionCenterDts'?: string;
    'unitCostWithDiscount'?: Currency;
    /**
    * True if this item was added to the order as part of an upsell
    */
    'upsell'?: boolean;
    'weight'?: Weight;
    'width'?: Distance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "activationCodes",
            "baseName": "activation_codes",
            "type": "Array<string>"
        },
        {
            "name": "arbitraryUnitCost",
            "baseName": "arbitrary_unit_cost",
            "type": "Currency"
        },
        {
            "name": "autoOrderLastRebillDts",
            "baseName": "auto_order_last_rebill_dts",
            "type": "string"
        },
        {
            "name": "autoOrderSchedule",
            "baseName": "auto_order_schedule",
            "type": "string"
        },
        {
            "name": "barcode",
            "baseName": "barcode",
            "type": "string"
        },
        {
            "name": "channelPartnerItemId",
            "baseName": "channel_partner_item_id",
            "type": "string"
        },
        {
            "name": "cogs",
            "baseName": "cogs",
            "type": "number"
        },
        {
            "name": "componentUnitValue",
            "baseName": "component_unit_value",
            "type": "number"
        },
        {
            "name": "cost",
            "baseName": "cost",
            "type": "Currency"
        },
        {
            "name": "countryCodeOfOrigin",
            "baseName": "country_code_of_origin",
            "type": "string"
        },
        {
            "name": "customsDescription",
            "baseName": "customs_description",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discount",
            "baseName": "discount",
            "type": "Currency"
        },
        {
            "name": "discountQuantity",
            "baseName": "discount_quantity",
            "type": "number"
        },
        {
            "name": "discountShippingWeight",
            "baseName": "discount_shipping_weight",
            "type": "Weight"
        },
        {
            "name": "distributionCenterCode",
            "baseName": "distribution_center_code",
            "type": "string"
        },
        {
            "name": "edi",
            "baseName": "edi",
            "type": "OrderItemEdi"
        },
        {
            "name": "excludeCoupon",
            "baseName": "exclude_coupon",
            "type": "boolean"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "boolean"
        },
        {
            "name": "hazmat",
            "baseName": "hazmat",
            "type": "boolean"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "Distance"
        },
        {
            "name": "itemReferenceOid",
            "baseName": "item_reference_oid",
            "type": "number"
        },
        {
            "name": "kit",
            "baseName": "kit",
            "type": "boolean"
        },
        {
            "name": "kitComponent",
            "baseName": "kit_component",
            "type": "boolean"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "Distance"
        },
        {
            "name": "manufacturerSku",
            "baseName": "manufacturer_sku",
            "type": "string"
        },
        {
            "name": "maxDaysTimeInTransit",
            "baseName": "max_days_time_in_transit",
            "type": "number"
        },
        {
            "name": "merchantItemId",
            "baseName": "merchant_item_id",
            "type": "string"
        },
        {
            "name": "mixAndMatchGroupName",
            "baseName": "mix_and_match_group_name",
            "type": "string"
        },
        {
            "name": "mixAndMatchGroupOid",
            "baseName": "mix_and_match_group_oid",
            "type": "number"
        },
        {
            "name": "noShippingDiscount",
            "baseName": "no_shipping_discount",
            "type": "boolean"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<OrderItemOption>"
        },
        {
            "name": "packedByUser",
            "baseName": "packed_by_user",
            "type": "string"
        },
        {
            "name": "perishableClass",
            "baseName": "perishable_class",
            "type": "string"
        },
        {
            "name": "pricingTierName",
            "baseName": "pricing_tier_name",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "Array<OrderItemProperty>"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "quantityRefunded",
            "baseName": "quantity_refunded",
            "type": "number"
        },
        {
            "name": "quickbooksClass",
            "baseName": "quickbooks_class",
            "type": "string"
        },
        {
            "name": "shipSeparately",
            "baseName": "ship_separately",
            "type": "boolean"
        },
        {
            "name": "shippedByUser",
            "baseName": "shipped_by_user",
            "type": "string"
        },
        {
            "name": "shippedDts",
            "baseName": "shipped_dts",
            "type": "string"
        },
        {
            "name": "specialProductType",
            "baseName": "special_product_type",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<OrderItemTag>"
        },
        {
            "name": "taxFree",
            "baseName": "tax_free",
            "type": "boolean"
        },
        {
            "name": "taxableCost",
            "baseName": "taxable_cost",
            "type": "Currency"
        },
        {
            "name": "totalCostWithDiscount",
            "baseName": "total_cost_with_discount",
            "type": "Currency"
        },
        {
            "name": "totalRefunded",
            "baseName": "total_refunded",
            "type": "Currency"
        },
        {
            "name": "transmittedToDistributionCenterDts",
            "baseName": "transmitted_to_distribution_center_dts",
            "type": "string"
        },
        {
            "name": "unitCostWithDiscount",
            "baseName": "unit_cost_with_discount",
            "type": "Currency"
        },
        {
            "name": "upsell",
            "baseName": "upsell",
            "type": "boolean"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "Weight"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "Distance"
        }    ];

    static getAttributeTypeMap() {
        return OrderItem.attributeTypeMap;
    }
}

export class OrderItemEdi {
    /**
    * Identification information receives on the EDI purchase order
    */
    'identifications'?: Array<OrderItemEdiIdentification>;
    /**
    * Lot information
    */
    'lots'?: Array<OrderItemEdiLot>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifications",
            "baseName": "identifications",
            "type": "Array<OrderItemEdiIdentification>"
        },
        {
            "name": "lots",
            "baseName": "lots",
            "type": "Array<OrderItemEdiLot>"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemEdi.attributeTypeMap;
    }
}

export class OrderItemEdiIdentification {
    /**
    * Identification value
    */
    'identification'?: string;
    /**
    * Quantity associated with this identifier
    */
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemEdiIdentification.attributeTypeMap;
    }
}

export class OrderItemEdiLot {
    /**
    * Log expiration
    */
    'lotExpiration'?: string;
    /**
    * Lot number
    */
    'lotNumber'?: string;
    /**
    * Lot quantity
    */
    'lotQuantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lotExpiration",
            "baseName": "lot_expiration",
            "type": "string"
        },
        {
            "name": "lotNumber",
            "baseName": "lot_number",
            "type": "string"
        },
        {
            "name": "lotQuantity",
            "baseName": "lot_quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemEdiLot.attributeTypeMap;
    }
}

export class OrderItemOption {
    /**
    * How the additional dimensions are applied to the item.
    */
    'additionalDimensionApplication'?: OrderItemOption.AdditionalDimensionApplicationEnum;
    'costChange'?: Currency;
    'fileAttachment'?: OrderItemOptionFileAttachment;
    'height'?: Distance;
    /**
    * True if this option is hidden from display on the order
    */
    'hidden'?: boolean;
    /**
    * Label
    */
    'label'?: string;
    'length'?: Distance;
    /**
    * True if the cost associated with this option is a one time fee or multiplied by the quantity of the item
    */
    'oneTimeFee'?: boolean;
    /**
    * Value
    */
    'value'?: string;
    'weightChange'?: Weight;
    'width'?: Distance;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalDimensionApplication",
            "baseName": "additional_dimension_application",
            "type": "OrderItemOption.AdditionalDimensionApplicationEnum"
        },
        {
            "name": "costChange",
            "baseName": "cost_change",
            "type": "Currency"
        },
        {
            "name": "fileAttachment",
            "baseName": "file_attachment",
            "type": "OrderItemOptionFileAttachment"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "Distance"
        },
        {
            "name": "hidden",
            "baseName": "hidden",
            "type": "boolean"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "Distance"
        },
        {
            "name": "oneTimeFee",
            "baseName": "one_time_fee",
            "type": "boolean"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "weightChange",
            "baseName": "weight_change",
            "type": "Weight"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "Distance"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemOption.attributeTypeMap;
    }
}

export namespace OrderItemOption {
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}
export class OrderItemOptionFileAttachment {
    /**
    * Expiration date/time
    */
    'expirationDts'?: string;
    /**
    * File name
    */
    'fileName'?: string;
    /**
    * Mime type
    */
    'mimeType'?: string;
    /**
    * Size
    */
    'size'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "fileName",
            "baseName": "file_name",
            "type": "string"
        },
        {
            "name": "mimeType",
            "baseName": "mime_type",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemOptionFileAttachment.attributeTypeMap;
    }
}

export class OrderItemProperty {
    /**
    * True if this property is displayed to the customer
    */
    'display'?: boolean;
    /**
    * The date/time that the property expires and is deleted
    */
    'expirationDts'?: string;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "display",
            "baseName": "display",
            "type": "boolean"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemProperty.attributeTypeMap;
    }
}

export class OrderItemTag {
    /**
    * Tag Value
    */
    'tagValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tagValue",
            "baseName": "tag_value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderItemTag.attributeTypeMap;
    }
}

export class OrderLinkedShipment {
    /**
    * True if this order has child linked shipments
    */
    'hasLinkedShipment'?: boolean;
    /**
    * True if this order is linked to another parent order
    */
    'linkedShipment'?: boolean;
    /**
    * The child linked shipment channel partner order ids
    */
    'linkedShipmentChannelPartnerOrderIds'?: Array<string>;
    /**
    * The child linked shipment order ids
    */
    'linkedShipmentOrderIds'?: Array<string>;
    /**
    * The parent order id that this one is linked to
    */
    'linkedShipmentToOrderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hasLinkedShipment",
            "baseName": "has_linked_shipment",
            "type": "boolean"
        },
        {
            "name": "linkedShipment",
            "baseName": "linked_shipment",
            "type": "boolean"
        },
        {
            "name": "linkedShipmentChannelPartnerOrderIds",
            "baseName": "linked_shipment_channel_partner_order_ids",
            "type": "Array<string>"
        },
        {
            "name": "linkedShipmentOrderIds",
            "baseName": "linked_shipment_order_ids",
            "type": "Array<string>"
        },
        {
            "name": "linkedShipmentToOrderId",
            "baseName": "linked_shipment_to_order_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderLinkedShipment.attributeTypeMap;
    }
}

export class OrderMarketing {
    /**
    * Advertising source
    */
    'advertisingSource'?: string;
    /**
    * True if the customer has opted into mailing list subscription
    */
    'mailingList'?: boolean;
    /**
    * Referral code
    */
    'referralCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "advertisingSource",
            "baseName": "advertising_source",
            "type": "string"
        },
        {
            "name": "mailingList",
            "baseName": "mailing_list",
            "type": "boolean"
        },
        {
            "name": "referralCode",
            "baseName": "referral_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderMarketing.attributeTypeMap;
    }
}

export class OrderPayment {
    'check'?: OrderPaymentCheck;
    'creditCard'?: OrderPaymentCreditCard;
    'echeck'?: OrderPaymentECheck;
    /**
    * True if order has been held for fraud review
    */
    'holdForFraudReview'?: boolean;
    /**
    * Date/time that the payment was successfully processed, for new orders, this field is only considered if channel_partner.skip_payment_processing is true
    */
    'paymentDts'?: string;
    /**
    * Payment method
    */
    'paymentMethod'?: OrderPayment.PaymentMethodEnum;
    /**
    * Payment method QuickBooks code
    */
    'paymentMethodAccountingCode'?: string;
    /**
    * Payment method QuickBooks deposit account
    */
    'paymentMethodDepositToAccount'?: string;
    /**
    * Payment status
    */
    'paymentStatus'?: OrderPayment.PaymentStatusEnum;
    'purchaseOrder'?: OrderPaymentPurchaseOrder;
    /**
    * Rotating transaction gateway code used to process this order
    */
    'rotatingTransactionGatewayCode'?: string;
    'surcharge'?: Currency;
    /**
    * Surcharge accounting code
    */
    'surchargeAccountingCode'?: string;
    /**
    * Surcharge transaction fee
    */
    'surchargeTransactionFee'?: number;
    /**
    * Surcharge transaction percentage
    */
    'surchargeTransactionPercentage'?: number;
    /**
    * True if this is a test order
    */
    'testOrder'?: boolean;
    /**
    * Transactions associated with processing this payment
    */
    'transactions'?: Array<OrderPaymentTransaction>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "check",
            "baseName": "check",
            "type": "OrderPaymentCheck"
        },
        {
            "name": "creditCard",
            "baseName": "credit_card",
            "type": "OrderPaymentCreditCard"
        },
        {
            "name": "echeck",
            "baseName": "echeck",
            "type": "OrderPaymentECheck"
        },
        {
            "name": "holdForFraudReview",
            "baseName": "hold_for_fraud_review",
            "type": "boolean"
        },
        {
            "name": "paymentDts",
            "baseName": "payment_dts",
            "type": "string"
        },
        {
            "name": "paymentMethod",
            "baseName": "payment_method",
            "type": "OrderPayment.PaymentMethodEnum"
        },
        {
            "name": "paymentMethodAccountingCode",
            "baseName": "payment_method_accounting_code",
            "type": "string"
        },
        {
            "name": "paymentMethodDepositToAccount",
            "baseName": "payment_method_deposit_to_account",
            "type": "string"
        },
        {
            "name": "paymentStatus",
            "baseName": "payment_status",
            "type": "OrderPayment.PaymentStatusEnum"
        },
        {
            "name": "purchaseOrder",
            "baseName": "purchase_order",
            "type": "OrderPaymentPurchaseOrder"
        },
        {
            "name": "rotatingTransactionGatewayCode",
            "baseName": "rotating_transaction_gateway_code",
            "type": "string"
        },
        {
            "name": "surcharge",
            "baseName": "surcharge",
            "type": "Currency"
        },
        {
            "name": "surchargeAccountingCode",
            "baseName": "surcharge_accounting_code",
            "type": "string"
        },
        {
            "name": "surchargeTransactionFee",
            "baseName": "surcharge_transaction_fee",
            "type": "number"
        },
        {
            "name": "surchargeTransactionPercentage",
            "baseName": "surcharge_transaction_percentage",
            "type": "number"
        },
        {
            "name": "testOrder",
            "baseName": "test_order",
            "type": "boolean"
        },
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<OrderPaymentTransaction>"
        }    ];

    static getAttributeTypeMap() {
        return OrderPayment.attributeTypeMap;
    }
}

export namespace OrderPayment {
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        EBay = <any> 'eBay',
        ECheck = <any> 'eCheck',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer',
        Walmart = <any> 'Walmart'
    }
    export enum PaymentStatusEnum {
        Unprocessed = <any> 'Unprocessed',
        Authorized = <any> 'Authorized',
        CaptureFailed = <any> 'Capture Failed',
        Processed = <any> 'Processed',
        Declined = <any> 'Declined',
        Voided = <any> 'Voided',
        Refunded = <any> 'Refunded',
        Skipped = <any> 'Skipped'
    }
}
export class OrderPaymentCheck {
    /**
    * Check number
    */
    'checkNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "checkNumber",
            "baseName": "check_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentCheck.attributeTypeMap;
    }
}

export class OrderPaymentCreditCard {
    /**
    * Card authorization ticket
    */
    'cardAuthTicket'?: string;
    /**
    * Card authorization amount
    */
    'cardAuthorizationAmount'?: number;
    /**
    * Card authorization date/time
    */
    'cardAuthorizationDts'?: string;
    /**
    * Card authorization reference number
    */
    'cardAuthorizationReferenceNumber'?: string;
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth'?: number;
    /**
    * Card expiration year (Four digit year)
    */
    'cardExpirationYear'?: number;
    /**
    * Card number (masked to last 4)
    */
    'cardNumber'?: string;
    /**
    * Card number token from hosted fields used to update the cart number
    */
    'cardNumberToken'?: string;
    /**
    * True if the card has been truncated
    */
    'cardNumberTruncated'?: boolean;
    /**
    * Card type
    */
    'cardType'?: OrderPaymentCreditCard.CardTypeEnum;
    /**
    * Card verification number token from hosted fields, only for import/insert of new orders, completely ignored for updates, and always null/empty for queries
    */
    'cardVerificationNumberToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardAuthTicket",
            "baseName": "card_auth_ticket",
            "type": "string"
        },
        {
            "name": "cardAuthorizationAmount",
            "baseName": "card_authorization_amount",
            "type": "number"
        },
        {
            "name": "cardAuthorizationDts",
            "baseName": "card_authorization_dts",
            "type": "string"
        },
        {
            "name": "cardAuthorizationReferenceNumber",
            "baseName": "card_authorization_reference_number",
            "type": "string"
        },
        {
            "name": "cardExpirationMonth",
            "baseName": "card_expiration_month",
            "type": "number"
        },
        {
            "name": "cardExpirationYear",
            "baseName": "card_expiration_year",
            "type": "number"
        },
        {
            "name": "cardNumber",
            "baseName": "card_number",
            "type": "string"
        },
        {
            "name": "cardNumberToken",
            "baseName": "card_number_token",
            "type": "string"
        },
        {
            "name": "cardNumberTruncated",
            "baseName": "card_number_truncated",
            "type": "boolean"
        },
        {
            "name": "cardType",
            "baseName": "card_type",
            "type": "OrderPaymentCreditCard.CardTypeEnum"
        },
        {
            "name": "cardVerificationNumberToken",
            "baseName": "card_verification_number_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentCreditCard.attributeTypeMap;
    }
}

export namespace OrderPaymentCreditCard {
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        JCB = <any> 'JCB',
        MasterCard = <any> 'MasterCard',
        VISA = <any> 'VISA'
    }
}
export class OrderPaymentECheck {
    /**
    * Bank routing code
    */
    'bankAbaCode'?: string;
    /**
    * Bank account name
    */
    'bankAccountName'?: string;
    /**
    * Bank account number (masked to last 4)
    */
    'bankAccountNumber'?: string;
    /**
    * Bank account type
    */
    'bankAccountType'?: OrderPaymentECheck.BankAccountTypeEnum;
    /**
    * Bank name
    */
    'bankName'?: string;
    /**
    * Bank owner type
    */
    'bankOwnerType'?: OrderPaymentECheck.BankOwnerTypeEnum;
    /**
    * Customer tax id (masked to last 4)
    */
    'customerTaxId'?: string;
    /**
    * Driver license date of birth
    */
    'driversLicenseDob'?: string;
    /**
    * Driver license number (masked to last 4)
    */
    'driversLicenseNumber'?: string;
    /**
    * Driver license state
    */
    'driversLicenseState'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bankAbaCode",
            "baseName": "bank_aba_code",
            "type": "string"
        },
        {
            "name": "bankAccountName",
            "baseName": "bank_account_name",
            "type": "string"
        },
        {
            "name": "bankAccountNumber",
            "baseName": "bank_account_number",
            "type": "string"
        },
        {
            "name": "bankAccountType",
            "baseName": "bank_account_type",
            "type": "OrderPaymentECheck.BankAccountTypeEnum"
        },
        {
            "name": "bankName",
            "baseName": "bank_name",
            "type": "string"
        },
        {
            "name": "bankOwnerType",
            "baseName": "bank_owner_type",
            "type": "OrderPaymentECheck.BankOwnerTypeEnum"
        },
        {
            "name": "customerTaxId",
            "baseName": "customer_tax_id",
            "type": "string"
        },
        {
            "name": "driversLicenseDob",
            "baseName": "drivers_license_dob",
            "type": "string"
        },
        {
            "name": "driversLicenseNumber",
            "baseName": "drivers_license_number",
            "type": "string"
        },
        {
            "name": "driversLicenseState",
            "baseName": "drivers_license_state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentECheck.attributeTypeMap;
    }
}

export namespace OrderPaymentECheck {
    export enum BankAccountTypeEnum {
        Checking = <any> 'Checking',
        Savings = <any> 'Savings'
    }
    export enum BankOwnerTypeEnum {
        Personal = <any> 'Personal',
        Business = <any> 'Business'
    }
}
export class OrderPaymentPurchaseOrder {
    /**
    * Purchase order number
    */
    'purchaseOrderNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseOrderNumber",
            "baseName": "purchase_order_number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentPurchaseOrder.attributeTypeMap;
    }
}

export class OrderPaymentTransaction {
    /**
    * Details
    */
    'details'?: Array<OrderPaymentTransactionDetail>;
    /**
    * True if the transaction was successful
    */
    'successful'?: boolean;
    /**
    * Transaction gateway
    */
    'transactionGateway'?: string;
    /**
    * Transaction date/time
    */
    'transactionTimestamp'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<OrderPaymentTransactionDetail>"
        },
        {
            "name": "successful",
            "baseName": "successful",
            "type": "boolean"
        },
        {
            "name": "transactionGateway",
            "baseName": "transaction_gateway",
            "type": "string"
        },
        {
            "name": "transactionTimestamp",
            "baseName": "transaction_timestamp",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentTransaction.attributeTypeMap;
    }
}

export class OrderPaymentTransactionDetail {
    /**
    * Name
    */
    'name'?: string;
    /**
    * Type
    */
    'type'?: string;
    /**
    * Value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentTransactionDetail.attributeTypeMap;
    }
}

export class OrderProcessPaymentRequest {
    /**
    * Card verification number token from hosted fields used during credit card transaction processing (optional)
    */
    'cardVerificationNumberToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardVerificationNumberToken",
            "baseName": "card_verification_number_token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderProcessPaymentRequest.attributeTypeMap;
    }
}

export class OrderProcessPaymentResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'paymentTransaction'?: OrderPaymentTransaction;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "paymentTransaction",
            "baseName": "payment_transaction",
            "type": "OrderPaymentTransaction"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return OrderProcessPaymentResponse.attributeTypeMap;
    }
}

export class OrderProperty {
    /**
    * True if this property is displayed to the customer
    */
    'display'?: boolean;
    /**
    * The date/time that the property expires and is deleted
    */
    'expirationDts'?: string;
    /**
    * Name
    */
    'name'?: string;
    /**
    * Value
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "display",
            "baseName": "display",
            "type": "boolean"
        },
        {
            "name": "expirationDts",
            "baseName": "expiration_dts",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderProperty.attributeTypeMap;
    }
}

export class OrderQuery {
    /**
    * CC Email
    */
    'ccEmail'?: string;
    /**
    * The code of the channel partner
    */
    'channelPartnerCode'?: string;
    /**
    * The order ID assigned by the channel partner for this order
    */
    'channelPartnerOrderId'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Date/time that the order was created
    */
    'creationDateBegin'?: string;
    /**
    * Date/time that the order was created
    */
    'creationDateEnd'?: string;
    /**
    * Current stage that the order is in.
    */
    'currentStage'?: OrderQuery.CurrentStageEnum;
    /**
    * The customer profile to find associated orders for
    */
    'customerProfileOid'?: number;
    /**
    * Email
    */
    'email'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Item ID
    */
    'itemId'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * Order ID
    */
    'orderId'?: string;
    /**
    * Date/time that the order was successfully processed
    */
    'paymentDateBegin'?: string;
    /**
    * Date/time that the order was successfully processed
    */
    'paymentDateEnd'?: string;
    /**
    * Payment method
    */
    'paymentMethod'?: OrderQuery.PaymentMethodEnum;
    /**
    * Phone
    */
    'phone'?: string;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * Purchase order number
    */
    'purchaseOrderNumber'?: string;
    /**
    * Date/time that the order was refunded
    */
    'refundDateBegin'?: string;
    /**
    * Date/time that the order was refunded
    */
    'refundDateEnd'?: string;
    /**
    * RMA number
    */
    'rma'?: string;
    /**
    * Screen branding theme code associated with the order (legacy checkout)
    */
    'screenBrandingThemeCode'?: string;
    /**
    * Date/time that the order was shipping
    */
    'shipmentDateBegin'?: string;
    /**
    * Date/time that the order was shipped
    */
    'shipmentDateEnd'?: string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion'?: string;
    /**
    * StoreFront host name associated with the order
    */
    'storefrontHostName'?: string;
    /**
    * Total
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ccEmail",
            "baseName": "cc_email",
            "type": "string"
        },
        {
            "name": "channelPartnerCode",
            "baseName": "channel_partner_code",
            "type": "string"
        },
        {
            "name": "channelPartnerOrderId",
            "baseName": "channel_partner_order_id",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "creationDateBegin",
            "baseName": "creation_date_begin",
            "type": "string"
        },
        {
            "name": "creationDateEnd",
            "baseName": "creation_date_end",
            "type": "string"
        },
        {
            "name": "currentStage",
            "baseName": "current_stage",
            "type": "OrderQuery.CurrentStageEnum"
        },
        {
            "name": "customerProfileOid",
            "baseName": "customer_profile_oid",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "item_id",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "order_id",
            "type": "string"
        },
        {
            "name": "paymentDateBegin",
            "baseName": "payment_date_begin",
            "type": "string"
        },
        {
            "name": "paymentDateEnd",
            "baseName": "payment_date_end",
            "type": "string"
        },
        {
            "name": "paymentMethod",
            "baseName": "payment_method",
            "type": "OrderQuery.PaymentMethodEnum"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "purchaseOrderNumber",
            "baseName": "purchase_order_number",
            "type": "string"
        },
        {
            "name": "refundDateBegin",
            "baseName": "refund_date_begin",
            "type": "string"
        },
        {
            "name": "refundDateEnd",
            "baseName": "refund_date_end",
            "type": "string"
        },
        {
            "name": "rma",
            "baseName": "rma",
            "type": "string"
        },
        {
            "name": "screenBrandingThemeCode",
            "baseName": "screen_branding_theme_code",
            "type": "string"
        },
        {
            "name": "shipmentDateBegin",
            "baseName": "shipment_date_begin",
            "type": "string"
        },
        {
            "name": "shipmentDateEnd",
            "baseName": "shipment_date_end",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "storefrontHostName",
            "baseName": "storefront_host_name",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderQuery.attributeTypeMap;
    }
}

export namespace OrderQuery {
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown'
    }
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        ECheck = <any> 'eCheck',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer'
    }
}
export class OrderQueryBatch {
    /**
    * Order IDs
    */
    'orderIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderIds",
            "baseName": "order_ids",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return OrderQueryBatch.attributeTypeMap;
    }
}

export class OrderQuote {
    /**
    * Expiration of quote at date/time
    */
    'quoteExpirationDts'?: string;
    /**
    * Quoted by user
    */
    'quotedBy'?: string;
    /**
    * Quoted on date/time
    */
    'quotedDts'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "quoteExpirationDts",
            "baseName": "quote_expiration_dts",
            "type": "string"
        },
        {
            "name": "quotedBy",
            "baseName": "quoted_by",
            "type": "string"
        },
        {
            "name": "quotedDts",
            "baseName": "quoted_dts",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderQuote.attributeTypeMap;
    }
}

export class OrderReplacement {
    /**
    * Additional merchant notes to append to the new order
    */
    'additionalMerchantNotesNewOrder'?: string;
    /**
    * Additional merchant notes to append to the original order
    */
    'additionalMerchantNotesOriginalOrder'?: string;
    /**
    * Custom field 1
    */
    'customField1'?: string;
    /**
    * Custom field 2
    */
    'customField2'?: string;
    /**
    * Custom field 3
    */
    'customField3'?: string;
    /**
    * Custom field 4
    */
    'customField4'?: string;
    /**
    * Custom field 5
    */
    'customField5'?: string;
    /**
    * Custom field 6
    */
    'customField6'?: string;
    /**
    * Custom field 7
    */
    'customField7'?: string;
    /**
    * Set to true if this replacement shipment should be free for the customer.
    */
    'free'?: boolean;
    /**
    * Set to true if you want to immediately charge the payment on this order, otherwise it will go to Accounts Receivable.
    */
    'immediateCharge'?: boolean;
    /**
    * Items to include in the replacement order
    */
    'items'?: Array<OrderReplacementItem>;
    /**
    * Original order id
    */
    'originalOrderId'?: string;
    /**
    * Shipping method to use.  If not specified or invalid then least cost shipping will take place.
    */
    'shippingMethod'?: string;
    /**
    * Set to true if you want to skip the payment as if it was successful.
    */
    'skipPayment'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalMerchantNotesNewOrder",
            "baseName": "additional_merchant_notes_new_order",
            "type": "string"
        },
        {
            "name": "additionalMerchantNotesOriginalOrder",
            "baseName": "additional_merchant_notes_original_order",
            "type": "string"
        },
        {
            "name": "customField1",
            "baseName": "custom_field1",
            "type": "string"
        },
        {
            "name": "customField2",
            "baseName": "custom_field2",
            "type": "string"
        },
        {
            "name": "customField3",
            "baseName": "custom_field3",
            "type": "string"
        },
        {
            "name": "customField4",
            "baseName": "custom_field4",
            "type": "string"
        },
        {
            "name": "customField5",
            "baseName": "custom_field5",
            "type": "string"
        },
        {
            "name": "customField6",
            "baseName": "custom_field6",
            "type": "string"
        },
        {
            "name": "customField7",
            "baseName": "custom_field7",
            "type": "string"
        },
        {
            "name": "free",
            "baseName": "free",
            "type": "boolean"
        },
        {
            "name": "immediateCharge",
            "baseName": "immediate_charge",
            "type": "boolean"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<OrderReplacementItem>"
        },
        {
            "name": "originalOrderId",
            "baseName": "original_order_id",
            "type": "string"
        },
        {
            "name": "shippingMethod",
            "baseName": "shipping_method",
            "type": "string"
        },
        {
            "name": "skipPayment",
            "baseName": "skip_payment",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderReplacement.attributeTypeMap;
    }
}

export class OrderReplacementItem {
    /**
    * Cost to charge the customer if specified.  If not specified then the default item cost is used.
    */
    'arbitraryUnitCost'?: number;
    /**
    * Item ID
    */
    'merchantItemId'?: string;
    /**
    * Quantity
    */
    'quantity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "arbitraryUnitCost",
            "baseName": "arbitrary_unit_cost",
            "type": "number"
        },
        {
            "name": "merchantItemId",
            "baseName": "merchant_item_id",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OrderReplacementItem.attributeTypeMap;
    }
}

export class OrderReplacementResponse {
    'chargeSuccessful'?: boolean;
    'errorMessage'?: string;
    'feedback'?: string;
    'free'?: boolean;
    'orderId'?: string;
    'successful'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "chargeSuccessful",
            "baseName": "chargeSuccessful",
            "type": "boolean"
        },
        {
            "name": "errorMessage",
            "baseName": "errorMessage",
            "type": "string"
        },
        {
            "name": "feedback",
            "baseName": "feedback",
            "type": "string"
        },
        {
            "name": "free",
            "baseName": "free",
            "type": "boolean"
        },
        {
            "name": "orderId",
            "baseName": "orderId",
            "type": "string"
        },
        {
            "name": "successful",
            "baseName": "successful",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrderReplacementResponse.attributeTypeMap;
    }
}

export class OrderResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'order'?: Order;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Order"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return OrderResponse.attributeTypeMap;
    }
}

export class OrderSalesforce {
    /**
    * Salesforce.com opportunity id
    */
    'salesforceOpportunityId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "salesforceOpportunityId",
            "baseName": "salesforce_opportunity_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderSalesforce.attributeTypeMap;
    }
}

export class OrderShipping {
    /**
    * Address line 1
    */
    'address1'?: string;
    /**
    * Address line 2
    */
    'address2'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Company
    */
    'company'?: string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode'?: string;
    /**
    * Day time phone
    */
    'dayPhone'?: string;
    /**
    * Day time phone (E164 format)
    */
    'dayPhoneE164'?: string;
    /**
    * Date the customer is requesting delivery on.  Typically used for perishable product delivery.
    */
    'deliveryDate'?: string;
    /**
    * Evening phone
    */
    'eveningPhone'?: string;
    /**
    * First name
    */
    'firstName'?: string;
    /**
    * Last name
    */
    'lastName'?: string;
    /**
    * If true, instructs UltraCart to apply the cheapest shipping method to this order.  Used only for channel partner order inserts.
    */
    'leastCostRoute'?: boolean;
    /**
    * List of shipping methods to consider if least_code_route is true. Used only for channel parter order inserts.
    */
    'leastCostRouteShippingMethods'?: Array<string>;
    /**
    * Lift gate requested (LTL shipping methods only)
    */
    'liftGate'?: boolean;
    /**
    * Postal code
    */
    'postalCode'?: string;
    /**
    * RMA number
    */
    'rma'?: string;
    /**
    * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
    */
    'shipOnDate'?: string;
    /**
    * True if the shipping address is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
    */
    'shipToResidential'?: boolean;
    /**
    * Shipping 3rd party account number
    */
    'shipping3rdPartyAccountNumber'?: string;
    /**
    * Date/time the order shipped on.  This date is set once the first shipment is sent to the customer.
    */
    'shippingDate'?: string;
    /**
    * Shipping department status
    */
    'shippingDepartmentStatus'?: string;
    /**
    * Shipping method
    */
    'shippingMethod'?: string;
    /**
    * Shipping method accounting code
    */
    'shippingMethodAccountingCode'?: string;
    /**
    * Special instructions from the customer regarding shipping
    */
    'specialInstructions'?: string;
    /**
    * State
    */
    'stateRegion'?: string;
    /**
    * Title
    */
    'title'?: string;
    /**
    * Tracking number details
    */
    'trackingNumberDetails'?: Array<OrderTrackingNumberDetails>;
    /**
    * Tracking numbers
    */
    'trackingNumbers'?: Array<string>;
    'weight'?: Weight;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "dayPhone",
            "baseName": "day_phone",
            "type": "string"
        },
        {
            "name": "dayPhoneE164",
            "baseName": "day_phone_e164",
            "type": "string"
        },
        {
            "name": "deliveryDate",
            "baseName": "delivery_date",
            "type": "string"
        },
        {
            "name": "eveningPhone",
            "baseName": "evening_phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "first_name",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "last_name",
            "type": "string"
        },
        {
            "name": "leastCostRoute",
            "baseName": "least_cost_route",
            "type": "boolean"
        },
        {
            "name": "leastCostRouteShippingMethods",
            "baseName": "least_cost_route_shipping_methods",
            "type": "Array<string>"
        },
        {
            "name": "liftGate",
            "baseName": "lift_gate",
            "type": "boolean"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "rma",
            "baseName": "rma",
            "type": "string"
        },
        {
            "name": "shipOnDate",
            "baseName": "ship_on_date",
            "type": "string"
        },
        {
            "name": "shipToResidential",
            "baseName": "ship_to_residential",
            "type": "boolean"
        },
        {
            "name": "shipping3rdPartyAccountNumber",
            "baseName": "shipping_3rd_party_account_number",
            "type": "string"
        },
        {
            "name": "shippingDate",
            "baseName": "shipping_date",
            "type": "string"
        },
        {
            "name": "shippingDepartmentStatus",
            "baseName": "shipping_department_status",
            "type": "string"
        },
        {
            "name": "shippingMethod",
            "baseName": "shipping_method",
            "type": "string"
        },
        {
            "name": "shippingMethodAccountingCode",
            "baseName": "shipping_method_accounting_code",
            "type": "string"
        },
        {
            "name": "specialInstructions",
            "baseName": "special_instructions",
            "type": "string"
        },
        {
            "name": "stateRegion",
            "baseName": "state_region",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "trackingNumberDetails",
            "baseName": "tracking_number_details",
            "type": "Array<OrderTrackingNumberDetails>"
        },
        {
            "name": "trackingNumbers",
            "baseName": "tracking_numbers",
            "type": "Array<string>"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "Weight"
        }    ];

    static getAttributeTypeMap() {
        return OrderShipping.attributeTypeMap;
    }
}

export class OrderSummary {
    'actualFulfillment'?: Currency;
    'actualShipping'?: Currency;
    'arbitraryShippingHandlingTotal'?: Currency;
    'otherRefunded'?: Currency;
    'shippingHandlingRefunded'?: Currency;
    'shippingHandlingTotal'?: Currency;
    'shippingHandlingTotalDiscount'?: Currency;
    'subtotal'?: Currency;
    'subtotalDiscount'?: Currency;
    'subtotalDiscountRefunded'?: Currency;
    'subtotalRefunded'?: Currency;
    'tax'?: Currency;
    'taxRefunded'?: Currency;
    'taxableSubtotal'?: Currency;
    'taxableSubtotalDiscount'?: Currency;
    'total'?: Currency;
    'totalRefunded'?: Currency;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actualFulfillment",
            "baseName": "actual_fulfillment",
            "type": "Currency"
        },
        {
            "name": "actualShipping",
            "baseName": "actual_shipping",
            "type": "Currency"
        },
        {
            "name": "arbitraryShippingHandlingTotal",
            "baseName": "arbitrary_shipping_handling_total",
            "type": "Currency"
        },
        {
            "name": "otherRefunded",
            "baseName": "other_refunded",
            "type": "Currency"
        },
        {
            "name": "shippingHandlingRefunded",
            "baseName": "shipping_handling_refunded",
            "type": "Currency"
        },
        {
            "name": "shippingHandlingTotal",
            "baseName": "shipping_handling_total",
            "type": "Currency"
        },
        {
            "name": "shippingHandlingTotalDiscount",
            "baseName": "shipping_handling_total_discount",
            "type": "Currency"
        },
        {
            "name": "subtotal",
            "baseName": "subtotal",
            "type": "Currency"
        },
        {
            "name": "subtotalDiscount",
            "baseName": "subtotal_discount",
            "type": "Currency"
        },
        {
            "name": "subtotalDiscountRefunded",
            "baseName": "subtotal_discount_refunded",
            "type": "Currency"
        },
        {
            "name": "subtotalRefunded",
            "baseName": "subtotal_refunded",
            "type": "Currency"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "Currency"
        },
        {
            "name": "taxRefunded",
            "baseName": "tax_refunded",
            "type": "Currency"
        },
        {
            "name": "taxableSubtotal",
            "baseName": "taxable_subtotal",
            "type": "Currency"
        },
        {
            "name": "taxableSubtotalDiscount",
            "baseName": "taxable_subtotal_discount",
            "type": "Currency"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "Currency"
        },
        {
            "name": "totalRefunded",
            "baseName": "total_refunded",
            "type": "Currency"
        }    ];

    static getAttributeTypeMap() {
        return OrderSummary.attributeTypeMap;
    }
}

export class OrderTag {
    /**
    * Tag Value
    */
    'tagValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tagValue",
            "baseName": "tag_value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTag.attributeTypeMap;
    }
}

export class OrderTaxes {
    /**
    * Arbitrary Tax, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
    */
    'arbitraryTax'?: number;
    /**
    * Arbitrary tax rate, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
    */
    'arbitraryTaxRate'?: number;
    /**
    * Arbitrary taxable subtotal, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
    */
    'arbitraryTaxableSubtotal'?: number;
    /**
    * QuickBooks tax city code
    */
    'taxCityAccountingCode'?: string;
    /**
    * QuickBooks tax country code
    */
    'taxCountryAccountingCode'?: string;
    /**
    * County used for tax calculation purposes (only in the United States)
    */
    'taxCounty'?: string;
    /**
    * QuickBooks tax county code
    */
    'taxCountyAccountingCode'?: string;
    /**
    * True if gift charge is taxed
    */
    'taxGiftCharge'?: boolean;
    /**
    * QuickBooks tax postal code code
    */
    'taxPostalCodeAccountingCode'?: string;
    /**
    * Tax rate, this is meaningless for updating an order.  For inserting a new order, if you need to override internal tax calculations, use the arbitrary fields.
    */
    'taxRate'?: number;
    /**
    * Tax rate at the city level
    */
    'taxRateCity'?: number;
    /**
    * Tax rate at the country level
    */
    'taxRateCountry'?: number;
    /**
    * Tax rate at the county level
    */
    'taxRateCounty'?: number;
    /**
    * Tax rate at the postal code level
    */
    'taxRatePostalCode'?: number;
    /**
    * Tax rate at the state level
    */
    'taxRateState'?: number;
    /**
    * True if shipping is taxed
    */
    'taxShipping'?: boolean;
    /**
    * QuickBooks tax state code
    */
    'taxStateAccountingCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "arbitraryTax",
            "baseName": "arbitrary_tax",
            "type": "number"
        },
        {
            "name": "arbitraryTaxRate",
            "baseName": "arbitrary_tax_rate",
            "type": "number"
        },
        {
            "name": "arbitraryTaxableSubtotal",
            "baseName": "arbitrary_taxable_subtotal",
            "type": "number"
        },
        {
            "name": "taxCityAccountingCode",
            "baseName": "tax_city_accounting_code",
            "type": "string"
        },
        {
            "name": "taxCountryAccountingCode",
            "baseName": "tax_country_accounting_code",
            "type": "string"
        },
        {
            "name": "taxCounty",
            "baseName": "tax_county",
            "type": "string"
        },
        {
            "name": "taxCountyAccountingCode",
            "baseName": "tax_county_accounting_code",
            "type": "string"
        },
        {
            "name": "taxGiftCharge",
            "baseName": "tax_gift_charge",
            "type": "boolean"
        },
        {
            "name": "taxPostalCodeAccountingCode",
            "baseName": "tax_postal_code_accounting_code",
            "type": "string"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateCity",
            "baseName": "tax_rate_city",
            "type": "number"
        },
        {
            "name": "taxRateCountry",
            "baseName": "tax_rate_country",
            "type": "number"
        },
        {
            "name": "taxRateCounty",
            "baseName": "tax_rate_county",
            "type": "number"
        },
        {
            "name": "taxRatePostalCode",
            "baseName": "tax_rate_postal_code",
            "type": "number"
        },
        {
            "name": "taxRateState",
            "baseName": "tax_rate_state",
            "type": "number"
        },
        {
            "name": "taxShipping",
            "baseName": "tax_shipping",
            "type": "boolean"
        },
        {
            "name": "taxStateAccountingCode",
            "baseName": "tax_state_accounting_code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTaxes.attributeTypeMap;
    }
}

export class OrderTokenResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * An order token that securely represents an order id
    */
    'orderToken'?: string;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "orderToken",
            "baseName": "order_token",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return OrderTokenResponse.attributeTypeMap;
    }
}

export class OrderTrackingNumberDetail {
    'city'?: string;
    'eventLocalDate'?: string;
    'eventLocalTime'?: string;
    'state'?: string;
    'subtag'?: string;
    'subtagMessage'?: string;
    'tag'?: string;
    'tagDescription'?: string;
    'tagIcon'?: string;
    'zip'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "eventLocalDate",
            "baseName": "event_local_date",
            "type": "string"
        },
        {
            "name": "eventLocalTime",
            "baseName": "event_local_time",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "subtag",
            "baseName": "subtag",
            "type": "string"
        },
        {
            "name": "subtagMessage",
            "baseName": "subtag_message",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "tagDescription",
            "baseName": "tag_description",
            "type": "string"
        },
        {
            "name": "tagIcon",
            "baseName": "tag_icon",
            "type": "string"
        },
        {
            "name": "zip",
            "baseName": "zip",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTrackingNumberDetail.attributeTypeMap;
    }
}

export class OrderTrackingNumberDetails {
    'actualDeliveryDate'?: string;
    'actualDeliveryDateFormatted'?: string;
    'details'?: Array<OrderTrackingNumberDetail>;
    'expectedDeliveryDate'?: string;
    'expectedDeliveryDateFormatted'?: string;
    'mapUrl'?: string;
    'orderPlacedDate'?: string;
    'orderPlacedDateFormatted'?: string;
    'paymentProcessedDate'?: string;
    'paymentProcessedDateFormatted'?: string;
    'shippedDate'?: string;
    'shippedDateFormatted'?: string;
    'shippingMethod'?: string;
    'status'?: string;
    'statusDescription'?: string;
    'trackingNumber'?: string;
    'trackingUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actualDeliveryDate",
            "baseName": "actual_delivery_date",
            "type": "string"
        },
        {
            "name": "actualDeliveryDateFormatted",
            "baseName": "actual_delivery_date_formatted",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<OrderTrackingNumberDetail>"
        },
        {
            "name": "expectedDeliveryDate",
            "baseName": "expected_delivery_date",
            "type": "string"
        },
        {
            "name": "expectedDeliveryDateFormatted",
            "baseName": "expected_delivery_date_formatted",
            "type": "string"
        },
        {
            "name": "mapUrl",
            "baseName": "map_url",
            "type": "string"
        },
        {
            "name": "orderPlacedDate",
            "baseName": "order_placed_date",
            "type": "string"
        },
        {
            "name": "orderPlacedDateFormatted",
            "baseName": "order_placed_date_formatted",
            "type": "string"
        },
        {
            "name": "paymentProcessedDate",
            "baseName": "payment_processed_date",
            "type": "string"
        },
        {
            "name": "paymentProcessedDateFormatted",
            "baseName": "payment_processed_date_formatted",
            "type": "string"
        },
        {
            "name": "shippedDate",
            "baseName": "shipped_date",
            "type": "string"
        },
        {
            "name": "shippedDateFormatted",
            "baseName": "shipped_date_formatted",
            "type": "string"
        },
        {
            "name": "shippingMethod",
            "baseName": "shipping_method",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "statusDescription",
            "baseName": "status_description",
            "type": "string"
        },
        {
            "name": "trackingNumber",
            "baseName": "tracking_number",
            "type": "string"
        },
        {
            "name": "trackingUrl",
            "baseName": "tracking_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrderTrackingNumberDetails.attributeTypeMap;
    }
}

export class OrdersResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * orders
    */
    'orders'?: Array<Order>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "orders",
            "baseName": "orders",
            "type": "Array<Order>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return OrdersResponse.attributeTypeMap;
    }
}

export class Permission {
    /**
    * A group for this permission.  This name is only used for visual grouping within interfaces.
    */
    'permissionGroup'?: string;
    /**
    * The name of this permission.
    */
    'permissionName'?: string;
    /**
    * True if this user has this permission.
    */
    'selected'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "permissionGroup",
            "baseName": "permission_group",
            "type": "string"
        },
        {
            "name": "permissionName",
            "baseName": "permission_Name",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Permission.attributeTypeMap;
    }
}

export class PricingTier {
    /**
    * Allow 3rd party billing
    */
    'allow3rdPartyBilling'?: boolean;
    /**
    * Allow COD
    */
    'allowCod'?: boolean;
    /**
    * Allow purchase order
    */
    'allowPurchaseOrder'?: boolean;
    /**
    * Allow quote request
    */
    'allowQuoteRequest'?: boolean;
    'approvalNotification'?: PricingTierNotification;
    /**
    * Auto approve COD
    */
    'autoApproveCod'?: boolean;
    /**
    * Auto approve purchase order
    */
    'autoApprovePurchaseOrder'?: boolean;
    /**
    * Default on wholesale signup
    */
    'defaultOnWholesaleSignup'?: boolean;
    /**
    * Default percentage discount
    */
    'defaultPercentageDiscount'?: number;
    /**
    * Default shipping method oid
    */
    'defaultShippingMethodOid'?: number;
    /**
    * Default tier
    */
    'defaultTier'?: boolean;
    /**
    * Display on wholesale signup
    */
    'displayOnWholesaleSignup'?: boolean;
    /**
    * Exclude from free promotion
    */
    'excludeFromFreePromotion'?: boolean;
    /**
    * Exempt shipping handling charge
    */
    'exemptShippingHandlingCharge'?: boolean;
    /**
    * Free shipping
    */
    'freeShipping'?: boolean;
    /**
    * Free shipping minimum
    */
    'freeShippingMinimum'?: number;
    /**
    * Maximum item count
    */
    'maximumItemCount'?: number;
    /**
    * Minimum item count
    */
    'minimumItemCount'?: number;
    /**
    * Minimum subtotal
    */
    'minimumSubtotal'?: number;
    /**
    * Name
    */
    'name'?: string;
    /**
    * No coupons
    */
    'noCoupons'?: boolean;
    /**
    * No free shipping
    */
    'noFreeShipping'?: boolean;
    /**
    * No realtime charge
    */
    'noRealtimeCharge'?: boolean;
    /**
    * Not valid when coupon present
    */
    'notValidWhenCouponPresent'?: boolean;
    /**
    * Pricing Tier Oid
    */
    'pricingTierOid'?: number;
    /**
    * Realtime percentage discount
    */
    'realtimePercentageDiscount'?: number;
    'signupNotification'?: PricingTierNotification;
    /**
    * Suppress buySAFE (deprecated)
    */
    'suppressBuysafe'?: boolean;
    /**
    * Suppress mailing list
    */
    'suppressMailingList'?: boolean;
    /**
    * Tax Exempt
    */
    'taxExempt'?: boolean;
    /**
    * Track separately
    */
    'trackSeparately'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allow3rdPartyBilling",
            "baseName": "allow_3rd_party_billing",
            "type": "boolean"
        },
        {
            "name": "allowCod",
            "baseName": "allow_cod",
            "type": "boolean"
        },
        {
            "name": "allowPurchaseOrder",
            "baseName": "allow_purchase_order",
            "type": "boolean"
        },
        {
            "name": "allowQuoteRequest",
            "baseName": "allow_quote_request",
            "type": "boolean"
        },
        {
            "name": "approvalNotification",
            "baseName": "approval_notification",
            "type": "PricingTierNotification"
        },
        {
            "name": "autoApproveCod",
            "baseName": "auto_approve_cod",
            "type": "boolean"
        },
        {
            "name": "autoApprovePurchaseOrder",
            "baseName": "auto_approve_purchase_order",
            "type": "boolean"
        },
        {
            "name": "defaultOnWholesaleSignup",
            "baseName": "default_on_wholesale_signup",
            "type": "boolean"
        },
        {
            "name": "defaultPercentageDiscount",
            "baseName": "default_percentage_discount",
            "type": "number"
        },
        {
            "name": "defaultShippingMethodOid",
            "baseName": "default_shipping_method_oid",
            "type": "number"
        },
        {
            "name": "defaultTier",
            "baseName": "default_tier",
            "type": "boolean"
        },
        {
            "name": "displayOnWholesaleSignup",
            "baseName": "display_on_wholesale_signup",
            "type": "boolean"
        },
        {
            "name": "excludeFromFreePromotion",
            "baseName": "exclude_from_free_promotion",
            "type": "boolean"
        },
        {
            "name": "exemptShippingHandlingCharge",
            "baseName": "exempt_shipping_handling_charge",
            "type": "boolean"
        },
        {
            "name": "freeShipping",
            "baseName": "free_shipping",
            "type": "boolean"
        },
        {
            "name": "freeShippingMinimum",
            "baseName": "free_shipping_minimum",
            "type": "number"
        },
        {
            "name": "maximumItemCount",
            "baseName": "maximum_item_count",
            "type": "number"
        },
        {
            "name": "minimumItemCount",
            "baseName": "minimum_item_count",
            "type": "number"
        },
        {
            "name": "minimumSubtotal",
            "baseName": "minimum_subtotal",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "noCoupons",
            "baseName": "no_coupons",
            "type": "boolean"
        },
        {
            "name": "noFreeShipping",
            "baseName": "no_free_shipping",
            "type": "boolean"
        },
        {
            "name": "noRealtimeCharge",
            "baseName": "no_realtime_charge",
            "type": "boolean"
        },
        {
            "name": "notValidWhenCouponPresent",
            "baseName": "not_valid_when_coupon_present",
            "type": "boolean"
        },
        {
            "name": "pricingTierOid",
            "baseName": "pricing_tier_oid",
            "type": "number"
        },
        {
            "name": "realtimePercentageDiscount",
            "baseName": "realtime_percentage_discount",
            "type": "number"
        },
        {
            "name": "signupNotification",
            "baseName": "signup_notification",
            "type": "PricingTierNotification"
        },
        {
            "name": "suppressBuysafe",
            "baseName": "suppress_buysafe",
            "type": "boolean"
        },
        {
            "name": "suppressMailingList",
            "baseName": "suppress_mailing_list",
            "type": "boolean"
        },
        {
            "name": "taxExempt",
            "baseName": "tax_exempt",
            "type": "boolean"
        },
        {
            "name": "trackSeparately",
            "baseName": "track_separately",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PricingTier.attributeTypeMap;
    }
}

export class PricingTierNotification {
    /**
    * Notification format
    */
    'format'?: string;
    /**
    * Notification subject
    */
    'subject'?: string;
    /**
    * Notification text
    */
    'text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PricingTierNotification.attributeTypeMap;
    }
}

export class PricingTiersResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * pricing_tiers
    */
    'pricingTiers'?: Array<PricingTier>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "pricingTiers",
            "baseName": "pricingTiers",
            "type": "Array<PricingTier>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return PricingTiersResponse.attributeTypeMap;
    }
}

export class Property {
    'name'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Property.attributeTypeMap;
    }
}

export class RegisterAffiliateClickRequest {
    /**
    * Affiliate Id (must be specified if landing_page_url is not)
    */
    'affid'?: number;
    /**
    * IP Address (must be specified for non-browser key authenticated)
    */
    'ipAddress'?: string;
    /**
    * Landing Page URL
    */
    'landingPageUrl'?: string;
    /**
    * Referrer URL (used for detecting invisible linking)
    */
    'referrerUrl'?: string;
    /**
    * Sub Id (optional value if affid is specified.
    */
    'subid'?: string;
    /**
    * User agent of the browser (must be specified for non-browser key authenticated)
    */
    'userAgent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "affid",
            "baseName": "affid",
            "type": "number"
        },
        {
            "name": "ipAddress",
            "baseName": "ip_address",
            "type": "string"
        },
        {
            "name": "landingPageUrl",
            "baseName": "landing_page_url",
            "type": "string"
        },
        {
            "name": "referrerUrl",
            "baseName": "referrer_url",
            "type": "string"
        },
        {
            "name": "subid",
            "baseName": "subid",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "user_agent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RegisterAffiliateClickRequest.attributeTypeMap;
    }
}

export class RegisterAffiliateClickResponse {
    /**
    * The cookie max age to use
    */
    'cookieMaxAge'?: number;
    /**
    * The names of all the cookies to set on the browser
    */
    'cookieNames'?: Array<string>;
    /**
    * The values of all the cookies to set on the browser
    */
    'cookieValues'?: Array<string>;
    /**
    * True if a click was registered
    */
    'registered'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cookieMaxAge",
            "baseName": "cookie_max_age",
            "type": "number"
        },
        {
            "name": "cookieNames",
            "baseName": "cookie_names",
            "type": "Array<string>"
        },
        {
            "name": "cookieValues",
            "baseName": "cookie_values",
            "type": "Array<string>"
        },
        {
            "name": "registered",
            "baseName": "registered",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RegisterAffiliateClickResponse.attributeTypeMap;
    }
}

export class ResponseMetadata {
    /**
    * Payload name
    */
    'payloadName'?: string;
    'resultSet'?: ResultSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payloadName",
            "baseName": "payload_name",
            "type": "string"
        },
        {
            "name": "resultSet",
            "baseName": "result_set",
            "type": "ResultSet"
        }    ];

    static getAttributeTypeMap() {
        return ResponseMetadata.attributeTypeMap;
    }
}

export class ResultSet {
    /**
    * Number of results in this set
    */
    'count'?: number;
    /**
    * Maximum number of results that can be returned in a set
    */
    'limit'?: number;
    /**
    * True if there are more results to query
    */
    'more'?: boolean;
    /**
    * The next offset that you should query to retrieve more results
    */
    'nextOffset'?: number;
    /**
    * Offset of this result set (zero based)
    */
    'offset'?: number;
    /**
    * The total number of records in the result set.  May be null if the number is not known and the client should continue iterating as long as more is true.
    */
    'totalRecords'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "more",
            "baseName": "more",
            "type": "boolean"
        },
        {
            "name": "nextOffset",
            "baseName": "next_offset",
            "type": "number"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "totalRecords",
            "baseName": "total_records",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResultSet.attributeTypeMap;
    }
}

export class ScreenshotsResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * List of screenshot urls related to the object (depends on which method was called).
    */
    'screenshots'?: Array<string>;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "screenshots",
            "baseName": "screenshots",
            "type": "Array<string>"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ScreenshotsResponse.attributeTypeMap;
    }
}

export class SelfConfig {
    /**
    * True if sales tax should be collected based on billing address instead of shipping address
    */
    'taxBilling'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taxBilling",
            "baseName": "tax_billing",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SelfConfig.attributeTypeMap;
    }
}

export class SovosConfig {
    /**
    * Sovos access key
    */
    'accessKey'?: string;
    /**
    * True if this Sovos configuration is to estimate taxes only and not report placed orders to Sovos
    */
    'estimateOnly'?: boolean;
    /**
    * Date/time of the connection test to Sovos
    */
    'lastTestDts'?: string;
    /**
    * Sovos secret key
    */
    'secretKey'?: string;
    /**
    * Send test orders through to Sovos.  The default is to not transmit test orders to Sovos.
    */
    'sendTestOrders'?: boolean;
    /**
    * Test results of the last connection test to Sovos
    */
    'testResults'?: string;
    /**
    * True if this Sovos configuration is currently undergoing user acceptance testing
    */
    'uat'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessKey",
            "baseName": "access_key",
            "type": "string"
        },
        {
            "name": "estimateOnly",
            "baseName": "estimate_only",
            "type": "boolean"
        },
        {
            "name": "lastTestDts",
            "baseName": "last_test_dts",
            "type": "string"
        },
        {
            "name": "secretKey",
            "baseName": "secret_key",
            "type": "string"
        },
        {
            "name": "sendTestOrders",
            "baseName": "send_test_orders",
            "type": "boolean"
        },
        {
            "name": "testResults",
            "baseName": "test_results",
            "type": "string"
        },
        {
            "name": "uat",
            "baseName": "uat",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SovosConfig.attributeTypeMap;
    }
}

export class StateProvince {
    /**
    * abbreviation
    */
    'abbreviation'?: string;
    /**
    * name
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "abbreviation",
            "baseName": "abbreviation",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StateProvince.attributeTypeMap;
    }
}

export class StepWaiting {
    'commseqStepUuid'?: string;
    'numberWaiting'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commseqStepUuid",
            "baseName": "commseq_step_uuid",
            "type": "string"
        },
        {
            "name": "numberWaiting",
            "baseName": "number_waiting",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StepWaiting.attributeTypeMap;
    }
}

export class TaxCity {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode'?: string;
    /**
    * City
    */
    'city'?: string;
    /**
    * Tax record object identifier used internally by database
    */
    'cityOid'?: number;
    /**
    * Tax record object identifier used internally by database
    */
    'countyOid'?: number;
    /**
    * Flag instructing engine to not collect city tax for this city
    */
    'dontCollectCity'?: boolean;
    /**
    * Flag instructing engine to not collect postal code tax for this city
    */
    'dontCollectPostalCode'?: boolean;
    /**
    * Postal Codes within this city
    */
    'postalCodes'?: Array<TaxPostalCode>;
    /**
    * Tax Rate
    */
    'taxRate'?: number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "cityOid",
            "baseName": "city_oid",
            "type": "number"
        },
        {
            "name": "countyOid",
            "baseName": "county_oid",
            "type": "number"
        },
        {
            "name": "dontCollectCity",
            "baseName": "dont_collect_city",
            "type": "boolean"
        },
        {
            "name": "dontCollectPostalCode",
            "baseName": "dont_collect_postal_code",
            "type": "boolean"
        },
        {
            "name": "postalCodes",
            "baseName": "postal_codes",
            "type": "Array<TaxPostalCode>"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxCity.attributeTypeMap;
    }
}

export class TaxCountry {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode'?: string;
    /**
    * Country code (2 characters
    */
    'countryCode'?: string;
    /**
    * Tax record object identifier used internally by database
    */
    'countryOid'?: number;
    /**
    * States (or regions or territories) within this country
    */
    'states'?: Array<TaxState>;
    /**
    * True if taxation within this jurisdiction should charge tax on gift charge
    */
    'taxGiftCharge'?: boolean;
    /**
    * True if taxation within this jurisdiction should charge tax on gift wrap
    */
    'taxGiftWrap'?: boolean;
    /**
    * Tax Rate
    */
    'taxRate'?: number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted'?: string;
    /**
    * True if taxation within this jurisdiction should charge tax on shipping
    */
    'taxShipping'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "countryOid",
            "baseName": "country_oid",
            "type": "number"
        },
        {
            "name": "states",
            "baseName": "states",
            "type": "Array<TaxState>"
        },
        {
            "name": "taxGiftCharge",
            "baseName": "tax_gift_charge",
            "type": "boolean"
        },
        {
            "name": "taxGiftWrap",
            "baseName": "tax_gift_wrap",
            "type": "boolean"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        },
        {
            "name": "taxShipping",
            "baseName": "tax_shipping",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TaxCountry.attributeTypeMap;
    }
}

export class TaxCountryCode {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode'?: string;
    /**
    * Country code (2 characters
    */
    'countryCode'?: string;
    /**
    * Country name
    */
    'countryName'?: string;
    /**
    * Tax Rate
    */
    'taxRate'?: number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "country_code",
            "type": "string"
        },
        {
            "name": "countryName",
            "baseName": "country_name",
            "type": "string"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxCountryCode.attributeTypeMap;
    }
}

export class TaxCounty {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode'?: string;
    /**
    * Cities within this city
    */
    'cities'?: Array<TaxCity>;
    /**
    * County
    */
    'county'?: string;
    /**
    * Tax record object identifier used internally by database
    */
    'countyOid'?: number;
    /**
    * Flag instructing engine to not collect city tax for this county
    */
    'dontCollectCity'?: boolean;
    /**
    * Flag instructing engine to not collect county tax for this county
    */
    'dontCollectCounty'?: boolean;
    /**
    * Flag instructing engine to not collect postal code tax for this county
    */
    'dontCollectPostalCode'?: boolean;
    /**
    * Tax record object identifier used internally by database
    */
    'stateOid'?: number;
    /**
    * Tax Rate
    */
    'taxRate'?: number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "cities",
            "baseName": "cities",
            "type": "Array<TaxCity>"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "countyOid",
            "baseName": "county_oid",
            "type": "number"
        },
        {
            "name": "dontCollectCity",
            "baseName": "dont_collect_city",
            "type": "boolean"
        },
        {
            "name": "dontCollectCounty",
            "baseName": "dont_collect_county",
            "type": "boolean"
        },
        {
            "name": "dontCollectPostalCode",
            "baseName": "dont_collect_postal_code",
            "type": "boolean"
        },
        {
            "name": "stateOid",
            "baseName": "state_oid",
            "type": "number"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxCounty.attributeTypeMap;
    }
}

export class TaxJarConfig {
    /**
    * True if TaxJar is active for this merchant
    */
    'active'?: boolean;
    /**
    * TaxJar API key
    */
    'apiKey'?: string;
    /**
    * True if this TaxJar configuration is to estimate taxes only and not report placed orders to TaxJar
    */
    'estimateOnly'?: boolean;
    /**
    * Send orders outside your nexus TaxJar.  The default is to not transmit outside orders to TaxJar to reduce API calls.  However, this will prevent TaxJar from dynamically creating new Nexus when thresholds are exceeded for a state.
    */
    'sendOutsideNexus'?: boolean;
    /**
    * Send test orders through to TaxJar.  The default is to not transmit test orders to TaxJar.
    */
    'sendTestOrders'?: boolean;
    /**
    * Use distribution center from address
    */
    'useDistributionCenterFrom'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "apiKey",
            "baseName": "api_key",
            "type": "string"
        },
        {
            "name": "estimateOnly",
            "baseName": "estimate_only",
            "type": "boolean"
        },
        {
            "name": "sendOutsideNexus",
            "baseName": "send_outside_nexus",
            "type": "boolean"
        },
        {
            "name": "sendTestOrders",
            "baseName": "send_test_orders",
            "type": "boolean"
        },
        {
            "name": "useDistributionCenterFrom",
            "baseName": "use_distribution_center_from",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TaxJarConfig.attributeTypeMap;
    }
}

export class TaxPostalCode {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode'?: string;
    /**
    * Tax record object identifier used internally by database
    */
    'cityOid'?: number;
    /**
    * Flag instructing engine to not collect postal code tax for this postal code
    */
    'dontCollectPostalCode'?: boolean;
    /**
    * Postal Code (5 digits)
    */
    'postalCode'?: string;
    /**
    * Tax record object identifier used internally by database
    */
    'postalCodeOid'?: number;
    /**
    * Tax Rate
    */
    'taxRate'?: number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "cityOid",
            "baseName": "city_oid",
            "type": "number"
        },
        {
            "name": "dontCollectPostalCode",
            "baseName": "dont_collect_postal_code",
            "type": "boolean"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "postalCodeOid",
            "baseName": "postal_code_oid",
            "type": "number"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxPostalCode.attributeTypeMap;
    }
}

export class TaxProviderActivateResult {
    'details'?: string;
    /**
    * True if the connection was successful
    */
    'success'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "details",
            "baseName": "details",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderActivateResult.attributeTypeMap;
    }
}

export class TaxProviderAvalara {
    'configuration'?: AvalaraConfig;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Selected
    */
    'selected'?: boolean;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "AvalaraConfig"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderAvalara.attributeTypeMap;
    }
}

export class TaxProviderAvalaraCompaniesResult {
    /**
    * Tax companies configured by the merchant
    */
    'companies'?: Array<TaxProviderAvalaraCompany>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "companies",
            "baseName": "companies",
            "type": "Array<TaxProviderAvalaraCompany>"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderAvalaraCompaniesResult.attributeTypeMap;
    }
}

export class TaxProviderAvalaraCompany {
    /**
    * Company code
    */
    'companyCode'?: string;
    /**
    * Company name
    */
    'companyName'?: string;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Selected
    */
    'selected'?: boolean;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "companyCode",
            "baseName": "company_code",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "company_name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderAvalaraCompany.attributeTypeMap;
    }
}

export class TaxProviderSelf {
    'configuration'?: SelfConfig;
    /**
    * Countries that collect sales tax
    */
    'countries'?: Array<TaxCountry>;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Selected
    */
    'selected'?: boolean;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "SelfConfig"
        },
        {
            "name": "countries",
            "baseName": "countries",
            "type": "Array<TaxCountry>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderSelf.attributeTypeMap;
    }
}

export class TaxProviderSelfCountriesResponse {
    /**
    * countries
    */
    'countries'?: Array<TaxCountryCode>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "countries",
            "baseName": "countries",
            "type": "Array<TaxCountryCode>"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderSelfCountriesResponse.attributeTypeMap;
    }
}

export class TaxProviderSelfRegionsResponse {
    /**
    * regions
    */
    'regions'?: Array<TaxStateCode>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "regions",
            "baseName": "regions",
            "type": "Array<TaxStateCode>"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderSelfRegionsResponse.attributeTypeMap;
    }
}

export class TaxProviderSovos {
    'configuration'?: SovosConfig;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Selected
    */
    'selected'?: boolean;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "SovosConfig"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderSovos.attributeTypeMap;
    }
}

export class TaxProviderTaxJar {
    'configuration'?: TaxJarConfig;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Selected
    */
    'selected'?: boolean;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "TaxJarConfig"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderTaxJar.attributeTypeMap;
    }
}

export class TaxProviderTestResult {
    'details'?: string;
    /**
    * True if the connection was successful
    */
    'success'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "details",
            "baseName": "details",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderTestResult.attributeTypeMap;
    }
}

export class TaxProviderUltraCart {
    'configuration'?: UltraCartConfig;
    /**
    * Description
    */
    'description'?: string;
    /**
    * Selected
    */
    'selected'?: boolean;
    /**
    * States in the union showing their management status
    */
    'states'?: Array<TaxProviderUltraCartState>;
    /**
    * Title
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "UltraCartConfig"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "states",
            "baseName": "states",
            "type": "Array<TaxProviderUltraCartState>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderUltraCart.attributeTypeMap;
    }
}

export class TaxProviderUltraCartState {
    /**
    * True if this state taxes are managed by UltraCart
    */
    'enabled'?: boolean;
    /**
    * State Code (2 digits)
    */
    'stateCode'?: string;
    /**
    * Fully spelled out state name
    */
    'stateName'?: string;
    /**
    * True if gift charges should be taxed in this state.
    */
    'taxGiftCharge'?: boolean;
    /**
    * True if gift wrap should be taxed in this state.
    */
    'taxGiftWrap'?: boolean;
    /**
    * State tax rate formatted for display
    */
    'taxRateFormatted'?: string;
    /**
    * True if shipping should be taxed in this state.
    */
    'taxShipping'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "stateCode",
            "baseName": "state_code",
            "type": "string"
        },
        {
            "name": "stateName",
            "baseName": "state_name",
            "type": "string"
        },
        {
            "name": "taxGiftCharge",
            "baseName": "tax_gift_charge",
            "type": "boolean"
        },
        {
            "name": "taxGiftWrap",
            "baseName": "tax_gift_wrap",
            "type": "boolean"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        },
        {
            "name": "taxShipping",
            "baseName": "tax_shipping",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TaxProviderUltraCartState.attributeTypeMap;
    }
}

export class TaxProvidersResponse {
    'avalara'?: TaxProviderAvalara;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    'self'?: TaxProviderSelf;
    'sovos'?: TaxProviderSovos;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'taxjar'?: TaxProviderTaxJar;
    'ultracart'?: TaxProviderUltraCart;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avalara",
            "baseName": "avalara",
            "type": "TaxProviderAvalara"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "TaxProviderSelf"
        },
        {
            "name": "sovos",
            "baseName": "sovos",
            "type": "TaxProviderSovos"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "taxjar",
            "baseName": "taxjar",
            "type": "TaxProviderTaxJar"
        },
        {
            "name": "ultracart",
            "baseName": "ultracart",
            "type": "TaxProviderUltraCart"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return TaxProvidersResponse.attributeTypeMap;
    }
}

export class TaxState {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode'?: string;
    /**
    * Counties within this state
    */
    'counties'?: Array<TaxCounty>;
    /**
    * Tax record object identifier used internally by database
    */
    'countryOid'?: number;
    /**
    * Flag instructing engine to not collect city tax for this state
    */
    'dontCollectCity'?: boolean;
    /**
    * Flag instructing engine to not collect county tax for this state
    */
    'dontCollectCounty'?: boolean;
    /**
    * Flag instructing engine to not collect postal code tax for this state
    */
    'dontCollectPostalCode'?: boolean;
    /**
    * Flag instructing engine to not collect state tax for this state
    */
    'dontCollectState'?: boolean;
    /**
    * State code
    */
    'stateCode'?: string;
    /**
    * Tax record object identifier used internally by database
    */
    'stateOid'?: number;
    /**
    * True if taxation within this jurisdiction should charge tax on gift charge
    */
    'taxGiftCharge'?: boolean;
    /**
    * True if taxation within this jurisdiction should charge tax on gift wrap
    */
    'taxGiftWrap'?: boolean;
    /**
    * Tax Rate
    */
    'taxRate'?: number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted'?: string;
    /**
    * True if taxation within this jurisdiction should charge tax on shipping
    */
    'taxShipping'?: boolean;
    /**
    * If true, use UltraCart managed rates for this state
    */
    'useUltracartManagedRates'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "counties",
            "baseName": "counties",
            "type": "Array<TaxCounty>"
        },
        {
            "name": "countryOid",
            "baseName": "country_oid",
            "type": "number"
        },
        {
            "name": "dontCollectCity",
            "baseName": "dont_collect_city",
            "type": "boolean"
        },
        {
            "name": "dontCollectCounty",
            "baseName": "dont_collect_county",
            "type": "boolean"
        },
        {
            "name": "dontCollectPostalCode",
            "baseName": "dont_collect_postal_code",
            "type": "boolean"
        },
        {
            "name": "dontCollectState",
            "baseName": "dont_collect_state",
            "type": "boolean"
        },
        {
            "name": "stateCode",
            "baseName": "state_code",
            "type": "string"
        },
        {
            "name": "stateOid",
            "baseName": "state_oid",
            "type": "number"
        },
        {
            "name": "taxGiftCharge",
            "baseName": "tax_gift_charge",
            "type": "boolean"
        },
        {
            "name": "taxGiftWrap",
            "baseName": "tax_gift_wrap",
            "type": "boolean"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        },
        {
            "name": "taxShipping",
            "baseName": "tax_shipping",
            "type": "boolean"
        },
        {
            "name": "useUltracartManagedRates",
            "baseName": "use_ultracart_managed_rates",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TaxState.attributeTypeMap;
    }
}

export class TaxStateCode {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode'?: string;
    /**
    * State code (2 characters
    */
    'stateCode'?: string;
    /**
    * State name
    */
    'stateName'?: string;
    /**
    * Tax Rate
    */
    'taxRate'?: number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountingCode",
            "baseName": "accounting_code",
            "type": "string"
        },
        {
            "name": "stateCode",
            "baseName": "state_code",
            "type": "string"
        },
        {
            "name": "stateName",
            "baseName": "state_name",
            "type": "string"
        },
        {
            "name": "taxRate",
            "baseName": "tax_rate",
            "type": "number"
        },
        {
            "name": "taxRateFormatted",
            "baseName": "tax_rate_formatted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TaxStateCode.attributeTypeMap;
    }
}

export class TempMultimedia {
    /**
    * Filename
    */
    'filename'?: string;
    /**
    * Height
    */
    'height'?: number;
    /**
    * Multimedia type
    */
    'multimediaType'?: TempMultimedia.MultimediaTypeEnum;
    /**
    * Size
    */
    'size'?: number;
    /**
    * Temporary multimedia object identifier
    */
    'tempMultimediaOid'?: number;
    /**
    * URL
    */
    'url'?: string;
    /**
    * Width
    */
    'width'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "multimediaType",
            "baseName": "multimedia_type",
            "type": "TempMultimedia.MultimediaTypeEnum"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "tempMultimediaOid",
            "baseName": "temp_multimedia_oid",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TempMultimedia.attributeTypeMap;
    }
}

export namespace TempMultimedia {
    export enum MultimediaTypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Video = <any> 'Video'
    }
}
export class TempMultimediaResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'tempMultimedia'?: TempMultimedia;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "tempMultimedia",
            "baseName": "temp_multimedia",
            "type": "TempMultimedia"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return TempMultimediaResponse.attributeTypeMap;
    }
}

export class ThumbnailParametersRequest {
    'height'?: number;
    'pngFormat'?: boolean;
    'squareThumbnail'?: boolean;
    'webp'?: boolean;
    'width'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "pngFormat",
            "baseName": "pngFormat",
            "type": "boolean"
        },
        {
            "name": "squareThumbnail",
            "baseName": "squareThumbnail",
            "type": "boolean"
        },
        {
            "name": "webp",
            "baseName": "webp",
            "type": "boolean"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ThumbnailParametersRequest.attributeTypeMap;
    }
}

export class ThumbnailParametersResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    /**
    * Suffix to append to the larger image URL to obtain the thumbnail
    */
    'thumbnailUrlSuffix'?: string;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "thumbnailUrlSuffix",
            "baseName": "thumbnail_url_suffix",
            "type": "string"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return ThumbnailParametersResponse.attributeTypeMap;
    }
}

export class TransactionEmail {
    /**
    * Actual template contents
    */
    'content'?: string;
    /**
    * The uuid of the sending domain
    */
    'espDomainUuid'?: string;
    /**
    * Friendly from that will appear in customer email clients.
    */
    'espFriendlyName'?: string;
    /**
    * The username of the sending email.  This is not the full email.  Only the username which is everything before the @ sign.
    */
    'espUser'?: string;
    /**
    * An internal identifier used to aid in retrieving templates from the filesystem.
    */
    'fileExists'?: boolean;
    /**
    * File name
    */
    'fileName'?: string;
    /**
    * Group
    */
    'group'?: string;
    /**
    * Handlebar Variables available for email template
    */
    'handlebarVariables'?: Array<string>;
    /**
    * Invalid will be true if the template cannot compile
    */
    'invalid'?: boolean;
    /**
    * Last modified timestamp
    */
    'lastModified'?: string;
    /**
    * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
    */
    'libraryItemOid'?: number;
    /**
    * Options that help govern how and when this template is used
    */
    'options'?: Array<TransactionEmailOption>;
    /**
    * directory path where template is stored in file system
    */
    'path'?: string;
    /**
    * Size of file in friendly description
    */
    'size'?: string;
    /**
    * Internal identifier used to store and retrieve template from filesystem
    */
    'storeFrontFsDirectoryOid'?: number;
    /**
    * Internal identifier used to store and retrieve template from filesystem
    */
    'storeFrontFsFileOid'?: number;
    /**
    * Subject
    */
    'subject'?: string;
    /**
    * Any syntax errors contained within the tempalate
    */
    'syntaxErrors'?: string;
    /**
    * Internal value used to locate the template in the filesystem
    */
    'templatePathRelativePath'?: string;
    /**
    * Theme relative path in the filesystem.
    */
    'themeRelativePath'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "espDomainUuid",
            "baseName": "esp_domain_uuid",
            "type": "string"
        },
        {
            "name": "espFriendlyName",
            "baseName": "esp_friendly_name",
            "type": "string"
        },
        {
            "name": "espUser",
            "baseName": "esp_user",
            "type": "string"
        },
        {
            "name": "fileExists",
            "baseName": "file_exists",
            "type": "boolean"
        },
        {
            "name": "fileName",
            "baseName": "file_name",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "string"
        },
        {
            "name": "handlebarVariables",
            "baseName": "handlebar_variables",
            "type": "Array<string>"
        },
        {
            "name": "invalid",
            "baseName": "invalid",
            "type": "boolean"
        },
        {
            "name": "lastModified",
            "baseName": "last_modified",
            "type": "string"
        },
        {
            "name": "libraryItemOid",
            "baseName": "library_item_oid",
            "type": "number"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<TransactionEmailOption>"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "string"
        },
        {
            "name": "storeFrontFsDirectoryOid",
            "baseName": "store_front_fs_directory_oid",
            "type": "number"
        },
        {
            "name": "storeFrontFsFileOid",
            "baseName": "store_front_fs_file_oid",
            "type": "number"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "syntaxErrors",
            "baseName": "syntax_errors",
            "type": "string"
        },
        {
            "name": "templatePathRelativePath",
            "baseName": "template_path_relative_path",
            "type": "string"
        },
        {
            "name": "themeRelativePath",
            "baseName": "theme_relative_path",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TransactionEmail.attributeTypeMap;
    }
}

export class TransactionEmailListResponse {
    'emailNames'?: Array<string>;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailNames",
            "baseName": "email_names",
            "type": "Array<string>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return TransactionEmailListResponse.attributeTypeMap;
    }
}

export class TransactionEmailOption {
    'description'?: string;
    'merchantEmailDeliveryOptionOid'?: number;
    'merchantId'?: string;
    'name'?: string;
    'selected'?: boolean;
    'storeFrontOid'?: number;
    'templateDisplay'?: string;
    'templateType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "merchantEmailDeliveryOptionOid",
            "baseName": "merchantEmailDeliveryOptionOid",
            "type": "number"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "storeFrontOid",
            "baseName": "storeFrontOid",
            "type": "number"
        },
        {
            "name": "templateDisplay",
            "baseName": "templateDisplay",
            "type": "string"
        },
        {
            "name": "templateType",
            "baseName": "templateType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TransactionEmailOption.attributeTypeMap;
    }
}

export class TransactionEmailResponse {
    'email'?: TransactionEmail;
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "TransactionEmail"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return TransactionEmailResponse.attributeTypeMap;
    }
}

export class UltraCartConfig {
    /**
    * True if sales tax should be collected based on billing address instead of shipping address
    */
    'taxBilling'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taxBilling",
            "baseName": "tax_billing",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UltraCartConfig.attributeTypeMap;
    }
}

export class User {
    /**
    * A list of IP addresses whitelisted for any user with API Access permission.  Without this list, each ip address must be authenticated by a user, which can be a pain for some servers.
    */
    'apiIpAddressMasks'?: Array<string>;
    /**
    * Supply a new FTP password using this field.  Password are stored using one-way encryption, so they are never available anywhere in the system.  The FTP password cannot be the same as the normal password.
    */
    'changeFtpPasswordTo'?: string;
    /**
    * Supply a new password using this field.  Password are stored using one-way encryption, so they are never available anywhere in the system.
    */
    'changePasswordTo'?: string;
    /**
    * Email address of user
    */
    'email'?: string;
    /**
    * Full name of user.  This is used solely for human assistance and so the UltraCart staff knows who they are calling when there is a problem.
    */
    'fullName'?: string;
    /**
    * A list of groups for this merchant and whether or not this user is a member of those groups.
    */
    'groups'?: Array<UserGroupMembership>;
    /**
    * A list of linked accounts and whether or not this user is mirrored to any of those accounts.
    */
    'linkedAccounts'?: Array<LinkedAccount>;
    /**
    * User name of user.  Must be unique across a merchant account.
    */
    'login'?: string;
    /**
    * A list of user logins over the past 90 days
    */
    'loginHistories'?: Array<UserLogin>;
    /**
    * A list of notifications the user receives.
    */
    'notifications'?: Array<Notification>;
    /**
    * OTP Serial Number such as Google Authenticator or Crypto Card.
    */
    'otpSerialNumber'?: string;
    /**
    * A list of permissions the user enjoys for accessing the backend of UltraCart.
    */
    'permissions'?: Array<Permission>;
    /**
    * Phone number of user.  Please supply a valid phone number.  When something breaks on your account, we need to be able to reach you.
    */
    'phone'?: string;
    /**
    * User id is a unique identifier for this user
    */
    'userId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiIpAddressMasks",
            "baseName": "api_ip_address_masks",
            "type": "Array<string>"
        },
        {
            "name": "changeFtpPasswordTo",
            "baseName": "change_ftp_password_to",
            "type": "string"
        },
        {
            "name": "changePasswordTo",
            "baseName": "change_password_to",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<UserGroupMembership>"
        },
        {
            "name": "linkedAccounts",
            "baseName": "linked_accounts",
            "type": "Array<LinkedAccount>"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "loginHistories",
            "baseName": "login_histories",
            "type": "Array<UserLogin>"
        },
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "Array<Notification>"
        },
        {
            "name": "otpSerialNumber",
            "baseName": "otp_serial_number",
            "type": "string"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Array<Permission>"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserGroupMembership {
    'groupOid'?: number;
    'member'?: boolean;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "groupOid",
            "baseName": "groupOid",
            "type": "number"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserGroupMembership.attributeTypeMap;
    }
}

export class UserLogin {
    /**
    * IP Address
    */
    'ipAddress'?: string;
    /**
    * login
    */
    'login'?: string;
    /**
    * Login date/time
    */
    'loginDts'?: string;
    /**
    * User Agent
    */
    'userAgent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipAddress",
            "baseName": "ip_address",
            "type": "string"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "loginDts",
            "baseName": "login_dts",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "user_agent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserLogin.attributeTypeMap;
    }
}

export class UserLoginsResponse {
    'error'?: Error;
    /**
    * Logins
    */
    'logins'?: Array<UserLogin>;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "logins",
            "baseName": "logins",
            "type": "Array<UserLogin>"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return UserLoginsResponse.attributeTypeMap;
    }
}

export class UserResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'user'?: User;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return UserResponse.attributeTypeMap;
    }
}

export class UsersResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'users'?: Array<User>;
    'warning'?: Warning;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<User>"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        }    ];

    static getAttributeTypeMap() {
        return UsersResponse.attributeTypeMap;
    }
}

export class VerificationRecord {
    'name'?: string;
    'type'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VerificationRecord.attributeTypeMap;
    }
}

export class Warning {
    /**
    * Additional information often a link to additional documentation
    */
    'moreInfo'?: string;
    /**
    * A technical message meant to be read by a developer
    */
    'warningMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "moreInfo",
            "baseName": "more_info",
            "type": "string"
        },
        {
            "name": "warningMessage",
            "baseName": "warning_message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Warning.attributeTypeMap;
    }
}

export class Webhook {
    /**
    * Populated if webhook associated with an API user
    */
    'apiUserOid'?: number;
    /**
    * Version of the API objects that are sent in notifications
    */
    'apiVersion'?: Webhook.ApiVersionEnum;
    'applicationProfile'?: ApiUserApplicationProfile;
    /**
    * The type of authentication this webhook will use when communicating with your server
    */
    'authenticationType'?: Webhook.AuthenticationTypeEnum;
    /**
    * Basic authentication password
    */
    'basicPassword'?: string;
    /**
    * Basic authentication user name
    */
    'basicUsername'?: string;
    /**
    * The number of consecutive failures that have occurred trying to deliver notifications to the target server
    */
    'consecutiveFailures'?: number;
    /**
    * True if the webhook has been disabled
    */
    'disabled'?: boolean;
    /**
    * The categories of events.  Individual events and subscriptions are handled in the child objects.  _placeholders parameter effects the population of this on a retrieval.
    */
    'eventCategories'?: Array<WebhookEventCategory>;
    /**
    * IAM Access Key for AWS SQS Delivery
    */
    'iamAccessKey'?: string;
    /**
    * IAM Secret Key for AWS SQS Delivery
    */
    'iamSecretKey'?: string;
    /**
    * The maximum number of events in the payload that UltraCart will deliver
    */
    'maximumEvents'?: number;
    /**
    * The maximum size of the payload that UltraCart will deliver
    */
    'maximumSize'?: number;
    /**
    * The UltraCart merchant ID that owns this webhook
    */
    'merchantId'?: string;
    /**
    * The next time UltraCart will attempt delivery if failures have been occurring
    */
    'nextRetryAfter'?: string;
    /**
    * The number of pending events for this webhook
    */
    'pending'?: number;
    /**
    * The object identifier for this webhook
    */
    'webhookOid'?: number;
    /**
    * The URL to deliver events to.  Must be HTTPS for customer related information.
    */
    'webhookUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiUserOid",
            "baseName": "api_user_oid",
            "type": "number"
        },
        {
            "name": "apiVersion",
            "baseName": "api_version",
            "type": "Webhook.ApiVersionEnum"
        },
        {
            "name": "applicationProfile",
            "baseName": "application_profile",
            "type": "ApiUserApplicationProfile"
        },
        {
            "name": "authenticationType",
            "baseName": "authentication_type",
            "type": "Webhook.AuthenticationTypeEnum"
        },
        {
            "name": "basicPassword",
            "baseName": "basic_password",
            "type": "string"
        },
        {
            "name": "basicUsername",
            "baseName": "basic_username",
            "type": "string"
        },
        {
            "name": "consecutiveFailures",
            "baseName": "consecutive_failures",
            "type": "number"
        },
        {
            "name": "disabled",
            "baseName": "disabled",
            "type": "boolean"
        },
        {
            "name": "eventCategories",
            "baseName": "event_categories",
            "type": "Array<WebhookEventCategory>"
        },
        {
            "name": "iamAccessKey",
            "baseName": "iam_access_key",
            "type": "string"
        },
        {
            "name": "iamSecretKey",
            "baseName": "iam_secret_key",
            "type": "string"
        },
        {
            "name": "maximumEvents",
            "baseName": "maximum_events",
            "type": "number"
        },
        {
            "name": "maximumSize",
            "baseName": "maximum_size",
            "type": "number"
        },
        {
            "name": "merchantId",
            "baseName": "merchant_id",
            "type": "string"
        },
        {
            "name": "nextRetryAfter",
            "baseName": "next_retry_after",
            "type": "string"
        },
        {
            "name": "pending",
            "baseName": "pending",
            "type": "number"
        },
        {
            "name": "webhookOid",
            "baseName": "webhook_oid",
            "type": "number"
        },
        {
            "name": "webhookUrl",
            "baseName": "webhook_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Webhook.attributeTypeMap;
    }
}

export namespace Webhook {
    export enum ApiVersionEnum {
        _20170301 = <any> '2017-03-01'
    }
    export enum AuthenticationTypeEnum {
        None = <any> 'none',
        Basic = <any> 'basic'
    }
}
export class WebhookEventCategory {
    /**
    * True if any events are subscribed to.
    */
    'anySubscribed'?: boolean;
    /**
    * Array of available expansion constants
    */
    'availableExpansions'?: Array<string>;
    /**
    * Name of the event category
    */
    'eventCategory'?: string;
    /**
    * The events within the category.  Individual subscription flags contained within the child object.
    */
    'events'?: Array<WebhookEventSubscription>;
    /**
    * True if all the events within this category are subscribed.  This is a convenience flag to make user interfaces easier.
    */
    'subscribed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "anySubscribed",
            "baseName": "any_subscribed",
            "type": "boolean"
        },
        {
            "name": "availableExpansions",
            "baseName": "available_expansions",
            "type": "Array<string>"
        },
        {
            "name": "eventCategory",
            "baseName": "event_category",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<WebhookEventSubscription>"
        },
        {
            "name": "subscribed",
            "baseName": "subscribed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return WebhookEventCategory.attributeTypeMap;
    }
}

export class WebhookEventSubscription {
    /**
    * Comment about the event to provide further clarification to the end user
    */
    'comments'?: string;
    /**
    * True if the event is deprecated.  See the API change log for details on when it will be discontinued.
    */
    'deprecatedFlag'?: boolean;
    /**
    * True if the event is discontinued.  See the API change log for details on migration details.
    */
    'discontinuedFlag'?: boolean;
    /**
    * Description of the event
    */
    'eventDescription'?: string;
    /**
    * Event name
    */
    'eventName'?: string;
    /**
    * The expand string for the notification object.  See the individual resource _expand documentation for valid values.
    */
    'expansion'?: string;
    /**
    * True if this is event is subscribed to
    */
    'subscribed'?: boolean;
    /**
    * True if the event can be triggered to reflow existing records
    */
    'supportsReflow'?: boolean;
    /**
    * The webhook event object identifier
    */
    'webhookEventOid'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "deprecatedFlag",
            "baseName": "deprecated_flag",
            "type": "boolean"
        },
        {
            "name": "discontinuedFlag",
            "baseName": "discontinued_flag",
            "type": "boolean"
        },
        {
            "name": "eventDescription",
            "baseName": "event_description",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "event_name",
            "type": "string"
        },
        {
            "name": "expansion",
            "baseName": "expansion",
            "type": "string"
        },
        {
            "name": "subscribed",
            "baseName": "subscribed",
            "type": "boolean"
        },
        {
            "name": "supportsReflow",
            "baseName": "supports_reflow",
            "type": "boolean"
        },
        {
            "name": "webhookEventOid",
            "baseName": "webhook_event_oid",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WebhookEventSubscription.attributeTypeMap;
    }
}

export class WebhookLog {
    /**
    * Date/time of delivery
    */
    'deliveryDts'?: string;
    /**
    * Number of milliseconds to process the notification
    */
    'duration'?: number;
    /**
    * Request payload (first 100,000 characters)
    */
    'request'?: string;
    /**
    * Request headers sent to the server
    */
    'requestHeaders'?: Array<HTTPHeader>;
    /**
    * Request id is a unique string that you can look up in the logs
    */
    'requestId'?: string;
    /**
    * Response payload (first 100,000 characters)
    */
    'response'?: string;
    /**
    * Response headers received from the server
    */
    'responseHeaders'?: Array<HTTPHeader>;
    /**
    * HTTP status code received from the server
    */
    'statusCode'?: number;
    /**
    * True if the delivery was successful
    */
    'success'?: boolean;
    /**
    * URI of the webhook delivered to
    */
    'uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deliveryDts",
            "baseName": "delivery_dts",
            "type": "string"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "request",
            "baseName": "request",
            "type": "string"
        },
        {
            "name": "requestHeaders",
            "baseName": "request_headers",
            "type": "Array<HTTPHeader>"
        },
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "responseHeaders",
            "baseName": "response_headers",
            "type": "Array<HTTPHeader>"
        },
        {
            "name": "statusCode",
            "baseName": "status_code",
            "type": "number"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLog.attributeTypeMap;
    }
}

export class WebhookLogResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;
    'webhookLog'?: WebhookLog;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        },
        {
            "name": "webhookLog",
            "baseName": "webhook_log",
            "type": "WebhookLog"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLogResponse.attributeTypeMap;
    }
}

export class WebhookLogSummariesResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;
    /**
    * Webhook log summaries
    */
    'webhookLogSummaries'?: Array<WebhookLogSummary>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        },
        {
            "name": "webhookLogSummaries",
            "baseName": "webhook_log_summaries",
            "type": "Array<WebhookLogSummary>"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLogSummariesResponse.attributeTypeMap;
    }
}

export class WebhookLogSummary {
    /**
    * Date/time of the delivery
    */
    'deliveryDts'?: string;
    /**
    * Request id
    */
    'requestId'?: string;
    /**
    * True if the notification was successful
    */
    'success'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deliveryDts",
            "baseName": "delivery_dts",
            "type": "string"
        },
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return WebhookLogSummary.attributeTypeMap;
    }
}

export class WebhookResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;
    'webhook'?: Webhook;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "Webhook"
        }    ];

    static getAttributeTypeMap() {
        return WebhookResponse.attributeTypeMap;
    }
}

export class WebhookSampleRequest {
    /**
    * Request
    */
    'request'?: string;
    /**
    * Request headers
    */
    'requestHeaders'?: Array<HTTPHeader>;
    /**
    * Request id
    */
    'requestId'?: string;
    /**
    * URI to send request to
    */
    'uri'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "request",
            "baseName": "request",
            "type": "string"
        },
        {
            "name": "requestHeaders",
            "baseName": "request_headers",
            "type": "Array<HTTPHeader>"
        },
        {
            "name": "requestId",
            "baseName": "request_id",
            "type": "string"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSampleRequest.attributeTypeMap;
    }
}

export class WebhookSampleRequestResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;
    'webhookSampleRequest'?: WebhookSampleRequest;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        },
        {
            "name": "webhookSampleRequest",
            "baseName": "webhook_sample_request",
            "type": "WebhookSampleRequest"
        }    ];

    static getAttributeTypeMap() {
        return WebhookSampleRequestResponse.attributeTypeMap;
    }
}

export class WebhooksResponse {
    'error'?: Error;
    'metadata'?: ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success'?: boolean;
    'warning'?: Warning;
    'webhooks'?: Array<Webhook>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "Error"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "ResponseMetadata"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "warning",
            "baseName": "warning",
            "type": "Warning"
        },
        {
            "name": "webhooks",
            "baseName": "webhooks",
            "type": "Array<Webhook>"
        }    ];

    static getAttributeTypeMap() {
        return WebhooksResponse.attributeTypeMap;
    }
}

export class Weight {
    /**
    * Unit of measure
    */
    'uom'?: Weight.UomEnum;
    /**
    * Weight
    */
    'value'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uom",
            "baseName": "uom",
            "type": "Weight.UomEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Weight.attributeTypeMap;
    }
}

export namespace Weight {
    export enum UomEnum {
        KG = <any> 'KG',
        LB = <any> 'LB',
        OZ = <any> 'OZ'
    }
}

let enumsMap: {[index: string]: any} = {
        "AffiliateLedger.TransactionStateEnum": AffiliateLedger.TransactionStateEnum,
        "AffiliateLink.CustomHtmlApprovalStatusEnum": AffiliateLink.CustomHtmlApprovalStatusEnum,
        "AffiliateLink.InvisibleLinkApprovalStatusEnum": AffiliateLink.InvisibleLinkApprovalStatusEnum,
        "AffiliateLink.TypeEnum": AffiliateLink.TypeEnum,
        "AutoOrder.StatusEnum": AutoOrder.StatusEnum,
        "AutoOrderItem.FrequencyEnum": AutoOrderItem.FrequencyEnum,
        "AutoOrderItemSimpleSchedule.FrequencyEnum": AutoOrderItemSimpleSchedule.FrequencyEnum,
        "CartCustomerProfileCreditCard.CardTypeEnum": CartCustomerProfileCreditCard.CardTypeEnum,
        "CartItemMultimedia.TypeEnum": CartItemMultimedia.TypeEnum,
        "CartItemOption.TypeEnum": CartItemOption.TypeEnum,
        "CartKitComponentOption.TypeEnum": CartKitComponentOption.TypeEnum,
        "CheckoutHandoffRequest.OperationEnum": CheckoutHandoffRequest.OperationEnum,
        "Distance.UomEnum": Distance.UomEnum,
        "EmailCommseqStep.TypeEnum": EmailCommseqStep.TypeEnum,
        "Experiment.StatusEnum": Experiment.StatusEnum,
        "ItemAutoOrderStep.TypeEnum": ItemAutoOrderStep.TypeEnum,
        "ItemContentMultimedia.TypeEnum": ItemContentMultimedia.TypeEnum,
        "ItemOption.TypeEnum": ItemOption.TypeEnum,
        "ItemOptionValue.AdditionalDimensionApplicationEnum": ItemOptionValue.AdditionalDimensionApplicationEnum,
        "ItemRelatedItem.TypeEnum": ItemRelatedItem.TypeEnum,
        "ItemRestrictionItem.TypeEnum": ItemRestrictionItem.TypeEnum,
        "ItemShippingDestinationRestriction.ValidityEnum": ItemShippingDestinationRestriction.ValidityEnum,
        "ItemShippingMethod.ShippingMethodValidityEnum": ItemShippingMethod.ShippingMethodValidityEnum,
        "ItemTag.TagTypeEnum": ItemTag.TagTypeEnum,
        "ItemThirdPartyEmailMarketing.ProviderNameEnum": ItemThirdPartyEmailMarketing.ProviderNameEnum,
        "OauthTokenResponse.TokenTypeEnum": OauthTokenResponse.TokenTypeEnum,
        "Order.CurrentStageEnum": Order.CurrentStageEnum,
        "OrderAffiliateLedger.TransactionStateEnum": OrderAffiliateLedger.TransactionStateEnum,
        "OrderAutoOrder.StatusEnum": OrderAutoOrder.StatusEnum,
        "OrderFormat.FormatEnum": OrderFormat.FormatEnum,
        "OrderFraudScore.BinMatchEnum": OrderFraudScore.BinMatchEnum,
        "OrderItemOption.AdditionalDimensionApplicationEnum": OrderItemOption.AdditionalDimensionApplicationEnum,
        "OrderPayment.PaymentMethodEnum": OrderPayment.PaymentMethodEnum,
        "OrderPayment.PaymentStatusEnum": OrderPayment.PaymentStatusEnum,
        "OrderPaymentCreditCard.CardTypeEnum": OrderPaymentCreditCard.CardTypeEnum,
        "OrderPaymentECheck.BankAccountTypeEnum": OrderPaymentECheck.BankAccountTypeEnum,
        "OrderPaymentECheck.BankOwnerTypeEnum": OrderPaymentECheck.BankOwnerTypeEnum,
        "OrderQuery.CurrentStageEnum": OrderQuery.CurrentStageEnum,
        "OrderQuery.PaymentMethodEnum": OrderQuery.PaymentMethodEnum,
        "TempMultimedia.MultimediaTypeEnum": TempMultimedia.MultimediaTypeEnum,
        "Webhook.ApiVersionEnum": Webhook.ApiVersionEnum,
        "Webhook.AuthenticationTypeEnum": Webhook.AuthenticationTypeEnum,
        "Weight.UomEnum": Weight.UomEnum,
}

let typeMap: {[index: string]: any} = {
    "AccountsReceivableRetryConfig": AccountsReceivableRetryConfig,
    "AccountsReceivableRetryConfigResponse": AccountsReceivableRetryConfigResponse,
    "AccountsReceivableRetryDayActivity": AccountsReceivableRetryDayActivity,
    "AccountsReceivableRetryStatAccount": AccountsReceivableRetryStatAccount,
    "AccountsReceivableRetryStatMetrics": AccountsReceivableRetryStatMetrics,
    "AccountsReceivableRetryStatRevenue": AccountsReceivableRetryStatRevenue,
    "AccountsReceivableRetryStatsResponse": AccountsReceivableRetryStatsResponse,
    "Activity": Activity,
    "AddLibraryItemRequest": AddLibraryItemRequest,
    "AffiliateClick": AffiliateClick,
    "AffiliateClickQuery": AffiliateClickQuery,
    "AffiliateClicksResponse": AffiliateClicksResponse,
    "AffiliateLedger": AffiliateLedger,
    "AffiliateLedgerQuery": AffiliateLedgerQuery,
    "AffiliateLedgersResponse": AffiliateLedgersResponse,
    "AffiliateLink": AffiliateLink,
    "ApiUserApplicationProfile": ApiUserApplicationProfile,
    "ApplyLibraryItemRequest": ApplyLibraryItemRequest,
    "ApplyLibraryItemResponse": ApplyLibraryItemResponse,
    "AutoOrder": AutoOrder,
    "AutoOrderItem": AutoOrderItem,
    "AutoOrderItemFutureSchedule": AutoOrderItemFutureSchedule,
    "AutoOrderItemOption": AutoOrderItemOption,
    "AutoOrderItemSimpleSchedule": AutoOrderItemSimpleSchedule,
    "AutoOrderQuery": AutoOrderQuery,
    "AutoOrderQueryBatch": AutoOrderQueryBatch,
    "AutoOrderResponse": AutoOrderResponse,
    "AutoOrdersRequest": AutoOrdersRequest,
    "AutoOrdersResponse": AutoOrdersResponse,
    "AvalaraConfig": AvalaraConfig,
    "BaseResponse": BaseResponse,
    "Cart": Cart,
    "CartAffiliate": CartAffiliate,
    "CartAffirmCheckoutResponse": CartAffirmCheckoutResponse,
    "CartBilling": CartBilling,
    "CartBuysafe": CartBuysafe,
    "CartCheckout": CartCheckout,
    "CartCoupon": CartCoupon,
    "CartCurrencyConversion": CartCurrencyConversion,
    "CartCustomerProfile": CartCustomerProfile,
    "CartCustomerProfileAddress": CartCustomerProfileAddress,
    "CartCustomerProfileCreditCard": CartCustomerProfileCreditCard,
    "CartFinalizeOrderRequest": CartFinalizeOrderRequest,
    "CartFinalizeOrderRequestOptions": CartFinalizeOrderRequestOptions,
    "CartFinalizeOrderResponse": CartFinalizeOrderResponse,
    "CartGift": CartGift,
    "CartGiftCertificate": CartGiftCertificate,
    "CartItem": CartItem,
    "CartItemAttribute": CartItemAttribute,
    "CartItemMultimedia": CartItemMultimedia,
    "CartItemMultimediaThumbnail": CartItemMultimediaThumbnail,
    "CartItemOption": CartItemOption,
    "CartItemOptionValue": CartItemOptionValue,
    "CartItemPhysical": CartItemPhysical,
    "CartItemVariationSelection": CartItemVariationSelection,
    "CartKitComponentOption": CartKitComponentOption,
    "CartMarketing": CartMarketing,
    "CartPayment": CartPayment,
    "CartPaymentAffirm": CartPaymentAffirm,
    "CartPaymentAmazon": CartPaymentAmazon,
    "CartPaymentCheck": CartPaymentCheck,
    "CartPaymentCreditCard": CartPaymentCreditCard,
    "CartPaymentPurchaseOrder": CartPaymentPurchaseOrder,
    "CartProfileLoginRequest": CartProfileLoginRequest,
    "CartProfileLoginResponse": CartProfileLoginResponse,
    "CartProfileRegisterRequest": CartProfileRegisterRequest,
    "CartProfileRegisterResponse": CartProfileRegisterResponse,
    "CartProperty": CartProperty,
    "CartResponse": CartResponse,
    "CartSettings": CartSettings,
    "CartSettingsBilling": CartSettingsBilling,
    "CartSettingsGift": CartSettingsGift,
    "CartSettingsGiftWrap": CartSettingsGiftWrap,
    "CartSettingsPayment": CartSettingsPayment,
    "CartSettingsPaymentAmazon": CartSettingsPaymentAmazon,
    "CartSettingsPaymentCreditCard": CartSettingsPaymentCreditCard,
    "CartSettingsPaymentPayPal": CartSettingsPaymentPayPal,
    "CartSettingsProvince": CartSettingsProvince,
    "CartSettingsShipping": CartSettingsShipping,
    "CartSettingsShippingCalendar": CartSettingsShippingCalendar,
    "CartSettingsShippingEstimate": CartSettingsShippingEstimate,
    "CartSettingsTaxes": CartSettingsTaxes,
    "CartSettingsTerms": CartSettingsTerms,
    "CartShipping": CartShipping,
    "CartSummary": CartSummary,
    "CartTaxes": CartTaxes,
    "CartUpsellAfter": CartUpsellAfter,
    "CartValidationRequest": CartValidationRequest,
    "CartValidationResponse": CartValidationResponse,
    "ChargebackDispute": ChargebackDispute,
    "ChargebackDisputeResponse": ChargebackDisputeResponse,
    "ChargebackDisputesResponse": ChargebackDisputesResponse,
    "CheckoutAllowedCountriesResponse": CheckoutAllowedCountriesResponse,
    "CheckoutHandoffRequest": CheckoutHandoffRequest,
    "CheckoutHandoffResponse": CheckoutHandoffResponse,
    "CheckoutSetupBrowserKeyRequest": CheckoutSetupBrowserKeyRequest,
    "CheckoutSetupBrowserKeyResponse": CheckoutSetupBrowserKeyResponse,
    "CheckoutStateProvinceResponse": CheckoutStateProvinceResponse,
    "CityStateZip": CityStateZip,
    "CountriesResponse": CountriesResponse,
    "Country": Country,
    "Coupon": Coupon,
    "CouponAmountOffItems": CouponAmountOffItems,
    "CouponAmountOffShipping": CouponAmountOffShipping,
    "CouponAmountOffShippingWithItemsPurchase": CouponAmountOffShippingWithItemsPurchase,
    "CouponAmountOffSubtotal": CouponAmountOffSubtotal,
    "CouponAmountOffSubtotalAndShipping": CouponAmountOffSubtotalAndShipping,
    "CouponAmountOffSubtotalFreeShippingWithPurchase": CouponAmountOffSubtotalFreeShippingWithPurchase,
    "CouponAmountOffSubtotalWithBlockPurchase": CouponAmountOffSubtotalWithBlockPurchase,
    "CouponAmountOffSubtotalWithItemsPurchase": CouponAmountOffSubtotalWithItemsPurchase,
    "CouponAutomaticallyApplyCouponCodes": CouponAutomaticallyApplyCouponCodes,
    "CouponCodesRequest": CouponCodesRequest,
    "CouponCodesResponse": CouponCodesResponse,
    "CouponDiscountItemWithItemPurchase": CouponDiscountItemWithItemPurchase,
    "CouponDiscountItems": CouponDiscountItems,
    "CouponEditorValues": CouponEditorValues,
    "CouponFreeItemAndShippingWithSubtotal": CouponFreeItemAndShippingWithSubtotal,
    "CouponFreeItemWithItemPurchase": CouponFreeItemWithItemPurchase,
    "CouponFreeItemWithSubtotal": CouponFreeItemWithSubtotal,
    "CouponFreeItemsWithItemPurchase": CouponFreeItemsWithItemPurchase,
    "CouponFreeItemsWithMixMatchPurchase": CouponFreeItemsWithMixMatchPurchase,
    "CouponFreeShipping": CouponFreeShipping,
    "CouponFreeShippingSpecificItems": CouponFreeShippingSpecificItems,
    "CouponFreeShippingWithItemsPurchase": CouponFreeShippingWithItemsPurchase,
    "CouponFreeShippingWithSubtotal": CouponFreeShippingWithSubtotal,
    "CouponMultipleAmountsOffItems": CouponMultipleAmountsOffItems,
    "CouponNoDiscount": CouponNoDiscount,
    "CouponPercentOffItemWithItemsQuantityPurchase": CouponPercentOffItemWithItemsQuantityPurchase,
    "CouponPercentOffItems": CouponPercentOffItems,
    "CouponPercentOffItemsAndFreeShipping": CouponPercentOffItemsAndFreeShipping,
    "CouponPercentOffItemsWithItemsPurchase": CouponPercentOffItemsWithItemsPurchase,
    "CouponPercentOffRetailPriceItems": CouponPercentOffRetailPriceItems,
    "CouponPercentOffShipping": CouponPercentOffShipping,
    "CouponPercentOffSubtotal": CouponPercentOffSubtotal,
    "CouponPercentOffSubtotalAndFreeShipping": CouponPercentOffSubtotalAndFreeShipping,
    "CouponPercentOffSubtotalLimit": CouponPercentOffSubtotalLimit,
    "CouponPercentOffSubtotalWithItemsPurchase": CouponPercentOffSubtotalWithItemsPurchase,
    "CouponPercentOffSubtotalWithSubtotal": CouponPercentOffSubtotalWithSubtotal,
    "CouponQuery": CouponQuery,
    "CouponResponse": CouponResponse,
    "CouponRestriction": CouponRestriction,
    "CouponTierAmount": CouponTierAmount,
    "CouponTierItemDiscount": CouponTierItemDiscount,
    "CouponTierPercent": CouponTierPercent,
    "CouponTierQuantityAmount": CouponTierQuantityAmount,
    "CouponTierQuantityPercent": CouponTierQuantityPercent,
    "CouponTieredAmountOffItem": CouponTieredAmountOffItem,
    "CouponTieredAmountOffSubtotal": CouponTieredAmountOffSubtotal,
    "CouponTieredPercentOffItems": CouponTieredPercentOffItems,
    "CouponTieredPercentOffShipping": CouponTieredPercentOffShipping,
    "CouponTieredPercentOffSubtotal": CouponTieredPercentOffSubtotal,
    "CouponsResponse": CouponsResponse,
    "Currency": Currency,
    "Customer": Customer,
    "CustomerActivity": CustomerActivity,
    "CustomerAffiliate": CustomerAffiliate,
    "CustomerAttachment": CustomerAttachment,
    "CustomerBilling": CustomerBilling,
    "CustomerCard": CustomerCard,
    "CustomerEditorValues": CustomerEditorValues,
    "CustomerEmail": CustomerEmail,
    "CustomerEmailListChanges": CustomerEmailListChanges,
    "CustomerLoyalty": CustomerLoyalty,
    "CustomerLoyaltyLedger": CustomerLoyaltyLedger,
    "CustomerLoyaltyRedemption": CustomerLoyaltyRedemption,
    "CustomerOrdersSummary": CustomerOrdersSummary,
    "CustomerPricingTier": CustomerPricingTier,
    "CustomerPrivacy": CustomerPrivacy,
    "CustomerQuery": CustomerQuery,
    "CustomerQuotesSummary": CustomerQuotesSummary,
    "CustomerResponse": CustomerResponse,
    "CustomerReviewer": CustomerReviewer,
    "CustomerShipping": CustomerShipping,
    "CustomerSoftwareEntitlement": CustomerSoftwareEntitlement,
    "CustomerTag": CustomerTag,
    "CustomerTaxCodes": CustomerTaxCodes,
    "CustomersResponse": CustomersResponse,
    "DataTablesServerSideResponse": DataTablesServerSideResponse,
    "Distance": Distance,
    "DistributionCenter": DistributionCenter,
    "DistributionCentersResponse": DistributionCentersResponse,
    "EmailBaseTemplateListResponse": EmailBaseTemplateListResponse,
    "EmailCampaign": EmailCampaign,
    "EmailCampaignResponse": EmailCampaignResponse,
    "EmailCampaignsResponse": EmailCampaignsResponse,
    "EmailClick": EmailClick,
    "EmailClicksResponse": EmailClicksResponse,
    "EmailCommseq": EmailCommseq,
    "EmailCommseqEmail": EmailCommseqEmail,
    "EmailCommseqEmailResponse": EmailCommseqEmailResponse,
    "EmailCommseqEmailSendTestRequest": EmailCommseqEmailSendTestRequest,
    "EmailCommseqEmailSendTestResponse": EmailCommseqEmailSendTestResponse,
    "EmailCommseqEmailsRequest": EmailCommseqEmailsRequest,
    "EmailCommseqEmailsResponse": EmailCommseqEmailsResponse,
    "EmailCommseqPostcard": EmailCommseqPostcard,
    "EmailCommseqPostcardResponse": EmailCommseqPostcardResponse,
    "EmailCommseqPostcardSendTestRequest": EmailCommseqPostcardSendTestRequest,
    "EmailCommseqPostcardSendTestResponse": EmailCommseqPostcardSendTestResponse,
    "EmailCommseqPostcardsRequest": EmailCommseqPostcardsRequest,
    "EmailCommseqPostcardsResponse": EmailCommseqPostcardsResponse,
    "EmailCommseqResponse": EmailCommseqResponse,
    "EmailCommseqStat": EmailCommseqStat,
    "EmailCommseqStatResponse": EmailCommseqStatResponse,
    "EmailCommseqStep": EmailCommseqStep,
    "EmailCommseqsResponse": EmailCommseqsResponse,
    "EmailCustomer": EmailCustomer,
    "EmailCustomerEditorUrlResponse": EmailCustomerEditorUrlResponse,
    "EmailCustomersResponse": EmailCustomersResponse,
    "EmailDashboardActivity": EmailDashboardActivity,
    "EmailDashboardActivityResponse": EmailDashboardActivityResponse,
    "EmailDashboardStatsResponse": EmailDashboardStatsResponse,
    "EmailDomain": EmailDomain,
    "EmailEditorTokenResponse": EmailEditorTokenResponse,
    "EmailFlow": EmailFlow,
    "EmailFlowBackPopulateRequest": EmailFlowBackPopulateRequest,
    "EmailFlowBackPopulateResponse": EmailFlowBackPopulateResponse,
    "EmailFlowResponse": EmailFlowResponse,
    "EmailFlowsResponse": EmailFlowsResponse,
    "EmailGlobalSettings": EmailGlobalSettings,
    "EmailGlobalSettingsResponse": EmailGlobalSettingsResponse,
    "EmailGlobalUnsubscribeRequest": EmailGlobalUnsubscribeRequest,
    "EmailGlobalUnsubscribeResponse": EmailGlobalUnsubscribeResponse,
    "EmailHistogramPropertyNamesResponse": EmailHistogramPropertyNamesResponse,
    "EmailHistogramPropertyValuesResponse": EmailHistogramPropertyValuesResponse,
    "EmailList": EmailList,
    "EmailListArchiveResponse": EmailListArchiveResponse,
    "EmailListCustomer": EmailListCustomer,
    "EmailListCustomersResponse": EmailListCustomersResponse,
    "EmailListResponse": EmailListResponse,
    "EmailListSegmentMembership": EmailListSegmentMembership,
    "EmailListSegmentUsedBy": EmailListSegmentUsedBy,
    "EmailListSubscribeResponse": EmailListSubscribeResponse,
    "EmailListsResponse": EmailListsResponse,
    "EmailOrder": EmailOrder,
    "EmailOrdersResponse": EmailOrdersResponse,
    "EmailPerformance": EmailPerformance,
    "EmailPerformanceCustomerHistogram": EmailPerformanceCustomerHistogram,
    "EmailPerformanceCustomerHistogramPeriod": EmailPerformanceCustomerHistogramPeriod,
    "EmailPerformanceDaily": EmailPerformanceDaily,
    "EmailPerformanceResponse": EmailPerformanceResponse,
    "EmailPlan": EmailPlan,
    "EmailPlanAdditional": EmailPlanAdditional,
    "EmailPlanResponse": EmailPlanResponse,
    "EmailPostcardStat": EmailPostcardStat,
    "EmailSegment": EmailSegment,
    "EmailSegmentArchiveResponse": EmailSegmentArchiveResponse,
    "EmailSegmentCustomer": EmailSegmentCustomer,
    "EmailSegmentCustomersResponse": EmailSegmentCustomersResponse,
    "EmailSegmentDownloadPrepareResponse": EmailSegmentDownloadPrepareResponse,
    "EmailSegmentResponse": EmailSegmentResponse,
    "EmailSegmentsResponse": EmailSegmentsResponse,
    "EmailSendingDomainResponse": EmailSendingDomainResponse,
    "EmailSendingDomainsResponse": EmailSendingDomainsResponse,
    "EmailSettings": EmailSettings,
    "EmailSettingsResponse": EmailSettingsResponse,
    "EmailStat": EmailStat,
    "EmailStatPostcardSummaryRequest": EmailStatPostcardSummaryRequest,
    "EmailStatPostcardSummaryResponse": EmailStatPostcardSummaryResponse,
    "EmailStatSummaryRequest": EmailStatSummaryRequest,
    "EmailStatSummaryResponse": EmailStatSummaryResponse,
    "EmailStepStat": EmailStepStat,
    "EmailStepStatRequest": EmailStepStatRequest,
    "EmailStepStatResponse": EmailStepStatResponse,
    "EmailStepWaitingRequest": EmailStepWaitingRequest,
    "EmailStepWaitingResponse": EmailStepWaitingResponse,
    "EmailTemplate": EmailTemplate,
    "EmailTemplatesResponse": EmailTemplatesResponse,
    "EmailThirdPartyList": EmailThirdPartyList,
    "EmailThirdPartyListImportRequest": EmailThirdPartyListImportRequest,
    "EmailThirdPartyProvider": EmailThirdPartyProvider,
    "EmailThirdPartyProvidersResponse": EmailThirdPartyProvidersResponse,
    "ErrorResponse": ErrorResponse,
    "Experiment": Experiment,
    "ExperimentResponse": ExperimentResponse,
    "ExperimentVariation": ExperimentVariation,
    "ExperimentsResponse": ExperimentsResponse,
    "FulfillmentInventory": FulfillmentInventory,
    "FulfillmentShipment": FulfillmentShipment,
    "GeocodeRequest": GeocodeRequest,
    "GeocodeResponse": GeocodeResponse,
    "Group": Group,
    "GroupResponse": GroupResponse,
    "GroupUserMembership": GroupUserMembership,
    "GroupsResponse": GroupsResponse,
    "HTTPHeader": HTTPHeader,
    "Item": Item,
    "ItemAccounting": ItemAccounting,
    "ItemAmember": ItemAmember,
    "ItemAutoOrder": ItemAutoOrder,
    "ItemAutoOrderStep": ItemAutoOrderStep,
    "ItemAutoOrderStepArbitraryUnitCostSchedule": ItemAutoOrderStepArbitraryUnitCostSchedule,
    "ItemAutoOrderStepGrandfatherPricing": ItemAutoOrderStepGrandfatherPricing,
    "ItemCCBill": ItemCCBill,
    "ItemChannelPartnerMapping": ItemChannelPartnerMapping,
    "ItemChargeback": ItemChargeback,
    "ItemChargebackAddendum": ItemChargebackAddendum,
    "ItemChargebackAdjustmentRequest": ItemChargebackAdjustmentRequest,
    "ItemCheckout": ItemCheckout,
    "ItemContent": ItemContent,
    "ItemContentAssignment": ItemContentAssignment,
    "ItemContentAttribute": ItemContentAttribute,
    "ItemContentMultimedia": ItemContentMultimedia,
    "ItemContentMultimediaThumbnail": ItemContentMultimediaThumbnail,
    "ItemDigitalDelivery": ItemDigitalDelivery,
    "ItemDigitalItem": ItemDigitalItem,
    "ItemEbay": ItemEbay,
    "ItemEbayCategorySpecific": ItemEbayCategorySpecific,
    "ItemEbayMarketListing": ItemEbayMarketListing,
    "ItemEbayMarketPlaceAnalysis": ItemEbayMarketPlaceAnalysis,
    "ItemEmailNotifications": ItemEmailNotifications,
    "ItemEnrollment123": ItemEnrollment123,
    "ItemGiftCertificate": ItemGiftCertificate,
    "ItemGoogleProductSearch": ItemGoogleProductSearch,
    "ItemIdentifiers": ItemIdentifiers,
    "ItemInstantPaymentNotification": ItemInstantPaymentNotification,
    "ItemInstantPaymentNotifications": ItemInstantPaymentNotifications,
    "ItemInternal": ItemInternal,
    "ItemKitComponent": ItemKitComponent,
    "ItemKitDefinition": ItemKitDefinition,
    "ItemOption": ItemOption,
    "ItemOptionValue": ItemOptionValue,
    "ItemOptionValueAdditionalItem": ItemOptionValueAdditionalItem,
    "ItemOptionValueDigitalItem": ItemOptionValueDigitalItem,
    "ItemPaymentProcessing": ItemPaymentProcessing,
    "ItemPhysical": ItemPhysical,
    "ItemPricing": ItemPricing,
    "ItemPricingTier": ItemPricingTier,
    "ItemPricingTierDiscount": ItemPricingTierDiscount,
    "ItemPricingTierLimit": ItemPricingTierLimit,
    "ItemProperty": ItemProperty,
    "ItemRealtimePricing": ItemRealtimePricing,
    "ItemRelated": ItemRelated,
    "ItemRelatedItem": ItemRelatedItem,
    "ItemReporting": ItemReporting,
    "ItemResponse": ItemResponse,
    "ItemRestriction": ItemRestriction,
    "ItemRestrictionItem": ItemRestrictionItem,
    "ItemRevguard": ItemRevguard,
    "ItemReviews": ItemReviews,
    "ItemSalesforce": ItemSalesforce,
    "ItemShipping": ItemShipping,
    "ItemShippingCase": ItemShippingCase,
    "ItemShippingDestinationMarkup": ItemShippingDestinationMarkup,
    "ItemShippingDestinationRestriction": ItemShippingDestinationRestriction,
    "ItemShippingDistributionCenter": ItemShippingDistributionCenter,
    "ItemShippingMethod": ItemShippingMethod,
    "ItemShippingPackageRequirement": ItemShippingPackageRequirement,
    "ItemTag": ItemTag,
    "ItemTags": ItemTags,
    "ItemTax": ItemTax,
    "ItemTaxExemption": ItemTaxExemption,
    "ItemThirdPartyEmailMarketing": ItemThirdPartyEmailMarketing,
    "ItemVariantItem": ItemVariantItem,
    "ItemVariation": ItemVariation,
    "ItemVariationOption": ItemVariationOption,
    "ItemWishlistMember": ItemWishlistMember,
    "ItemsRequest": ItemsRequest,
    "ItemsResponse": ItemsResponse,
    "KeyValue": KeyValue,
    "LibraryFilterValues": LibraryFilterValues,
    "LibraryFilterValuesResponse": LibraryFilterValuesResponse,
    "LibraryItem": LibraryItem,
    "LibraryItemAccount": LibraryItemAccount,
    "LibraryItemAsset": LibraryItemAsset,
    "LibraryItemEmail": LibraryItemEmail,
    "LibraryItemQuery": LibraryItemQuery,
    "LibraryItemResponse": LibraryItemResponse,
    "LibraryItemScreenshot": LibraryItemScreenshot,
    "LibraryItemsResponse": LibraryItemsResponse,
    "LinkedAccount": LinkedAccount,
    "ListSegmentMembership": ListSegmentMembership,
    "LookupRequest": LookupRequest,
    "LookupResponse": LookupResponse,
    "Metric": Metric,
    "ModelError": ModelError,
    "Notification": Notification,
    "OauthRevokeSuccessResponse": OauthRevokeSuccessResponse,
    "OauthTokenResponse": OauthTokenResponse,
    "Order": Order,
    "OrderAffiliate": OrderAffiliate,
    "OrderAffiliateLedger": OrderAffiliateLedger,
    "OrderAutoOrder": OrderAutoOrder,
    "OrderBilling": OrderBilling,
    "OrderBuysafe": OrderBuysafe,
    "OrderByTokenQuery": OrderByTokenQuery,
    "OrderChannelPartner": OrderChannelPartner,
    "OrderCheckout": OrderCheckout,
    "OrderCoupon": OrderCoupon,
    "OrderDigitalItem": OrderDigitalItem,
    "OrderDigitalOrder": OrderDigitalOrder,
    "OrderEdi": OrderEdi,
    "OrderFormat": OrderFormat,
    "OrderFormatResponse": OrderFormatResponse,
    "OrderFraudScore": OrderFraudScore,
    "OrderGift": OrderGift,
    "OrderGiftCertificate": OrderGiftCertificate,
    "OrderInternal": OrderInternal,
    "OrderItem": OrderItem,
    "OrderItemEdi": OrderItemEdi,
    "OrderItemEdiIdentification": OrderItemEdiIdentification,
    "OrderItemEdiLot": OrderItemEdiLot,
    "OrderItemOption": OrderItemOption,
    "OrderItemOptionFileAttachment": OrderItemOptionFileAttachment,
    "OrderItemProperty": OrderItemProperty,
    "OrderItemTag": OrderItemTag,
    "OrderLinkedShipment": OrderLinkedShipment,
    "OrderMarketing": OrderMarketing,
    "OrderPayment": OrderPayment,
    "OrderPaymentCheck": OrderPaymentCheck,
    "OrderPaymentCreditCard": OrderPaymentCreditCard,
    "OrderPaymentECheck": OrderPaymentECheck,
    "OrderPaymentPurchaseOrder": OrderPaymentPurchaseOrder,
    "OrderPaymentTransaction": OrderPaymentTransaction,
    "OrderPaymentTransactionDetail": OrderPaymentTransactionDetail,
    "OrderProcessPaymentRequest": OrderProcessPaymentRequest,
    "OrderProcessPaymentResponse": OrderProcessPaymentResponse,
    "OrderProperty": OrderProperty,
    "OrderQuery": OrderQuery,
    "OrderQueryBatch": OrderQueryBatch,
    "OrderQuote": OrderQuote,
    "OrderReplacement": OrderReplacement,
    "OrderReplacementItem": OrderReplacementItem,
    "OrderReplacementResponse": OrderReplacementResponse,
    "OrderResponse": OrderResponse,
    "OrderSalesforce": OrderSalesforce,
    "OrderShipping": OrderShipping,
    "OrderSummary": OrderSummary,
    "OrderTag": OrderTag,
    "OrderTaxes": OrderTaxes,
    "OrderTokenResponse": OrderTokenResponse,
    "OrderTrackingNumberDetail": OrderTrackingNumberDetail,
    "OrderTrackingNumberDetails": OrderTrackingNumberDetails,
    "OrdersResponse": OrdersResponse,
    "Permission": Permission,
    "PricingTier": PricingTier,
    "PricingTierNotification": PricingTierNotification,
    "PricingTiersResponse": PricingTiersResponse,
    "Property": Property,
    "RegisterAffiliateClickRequest": RegisterAffiliateClickRequest,
    "RegisterAffiliateClickResponse": RegisterAffiliateClickResponse,
    "ResponseMetadata": ResponseMetadata,
    "ResultSet": ResultSet,
    "ScreenshotsResponse": ScreenshotsResponse,
    "SelfConfig": SelfConfig,
    "SovosConfig": SovosConfig,
    "StateProvince": StateProvince,
    "StepWaiting": StepWaiting,
    "TaxCity": TaxCity,
    "TaxCountry": TaxCountry,
    "TaxCountryCode": TaxCountryCode,
    "TaxCounty": TaxCounty,
    "TaxJarConfig": TaxJarConfig,
    "TaxPostalCode": TaxPostalCode,
    "TaxProviderActivateResult": TaxProviderActivateResult,
    "TaxProviderAvalara": TaxProviderAvalara,
    "TaxProviderAvalaraCompaniesResult": TaxProviderAvalaraCompaniesResult,
    "TaxProviderAvalaraCompany": TaxProviderAvalaraCompany,
    "TaxProviderSelf": TaxProviderSelf,
    "TaxProviderSelfCountriesResponse": TaxProviderSelfCountriesResponse,
    "TaxProviderSelfRegionsResponse": TaxProviderSelfRegionsResponse,
    "TaxProviderSovos": TaxProviderSovos,
    "TaxProviderTaxJar": TaxProviderTaxJar,
    "TaxProviderTestResult": TaxProviderTestResult,
    "TaxProviderUltraCart": TaxProviderUltraCart,
    "TaxProviderUltraCartState": TaxProviderUltraCartState,
    "TaxProvidersResponse": TaxProvidersResponse,
    "TaxState": TaxState,
    "TaxStateCode": TaxStateCode,
    "TempMultimedia": TempMultimedia,
    "TempMultimediaResponse": TempMultimediaResponse,
    "ThumbnailParametersRequest": ThumbnailParametersRequest,
    "ThumbnailParametersResponse": ThumbnailParametersResponse,
    "TransactionEmail": TransactionEmail,
    "TransactionEmailListResponse": TransactionEmailListResponse,
    "TransactionEmailOption": TransactionEmailOption,
    "TransactionEmailResponse": TransactionEmailResponse,
    "UltraCartConfig": UltraCartConfig,
    "User": User,
    "UserGroupMembership": UserGroupMembership,
    "UserLogin": UserLogin,
    "UserLoginsResponse": UserLoginsResponse,
    "UserResponse": UserResponse,
    "UsersResponse": UsersResponse,
    "VerificationRecord": VerificationRecord,
    "Warning": Warning,
    "Webhook": Webhook,
    "WebhookEventCategory": WebhookEventCategory,
    "WebhookEventSubscription": WebhookEventSubscription,
    "WebhookLog": WebhookLog,
    "WebhookLogResponse": WebhookLogResponse,
    "WebhookLogSummariesResponse": WebhookLogSummariesResponse,
    "WebhookLogSummary": WebhookLogSummary,
    "WebhookResponse": WebhookResponse,
    "WebhookSampleRequest": WebhookSampleRequest,
    "WebhookSampleRequestResponse": WebhookSampleRequestResponse,
    "WebhooksResponse": WebhooksResponse,
    "Weight": Weight,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AffiliateApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class AffiliateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AffiliateApiApiKeys, value: string) {
        (this.authentications as any)[AffiliateApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve clicks
     * @param clickQuery Click query
     * @param limit The maximum number of records to return on this one API call. (Maximum 10000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param expand The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request options.
     */
    public getClicksByQuery (clickQuery: AffiliateClickQuery, limit?: number, offset?: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AffiliateClicksResponse;  }> {
        const localVarPath = this.basePath + '/affiliate/clicks/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clickQuery' is not null or undefined
        if (clickQuery === null || clickQuery === undefined) {
            throw new Error('Required parameter clickQuery was null or undefined when calling getClicksByQuery.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(clickQuery, "AffiliateClickQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AffiliateClicksResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AffiliateClicksResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve ledger entries
     * @param ledgerQuery Ledger query
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param expand The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request options.
     */
    public getLedgersByQuery (ledgerQuery: AffiliateLedgerQuery, limit?: number, offset?: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AffiliateLedgersResponse;  }> {
        const localVarPath = this.basePath + '/affiliate/ledgers/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ledgerQuery' is not null or undefined
        if (ledgerQuery === null || ledgerQuery === undefined) {
            throw new Error('Required parameter ledgerQuery was null or undefined when calling getLedgersByQuery.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(ledgerQuery, "AffiliateLedgerQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AffiliateLedgersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AffiliateLedgersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AutoOrderApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class AutoOrderApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AutoOrderApiApiKeys, value: string) {
        (this.authentications as any)[AutoOrderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Retrieves a single auto order using the specified auto order oid. 
     * @summary Retrieve an auto order
     * @param autoOrderOid The auto order oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getAutoOrder (autoOrderOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/{auto_order_oid}'
            .replace('{' + 'auto_order_oid' + '}', encodeURIComponent(String(autoOrderOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'autoOrderOid' is not null or undefined
        if (autoOrderOid === null || autoOrderOid === undefined) {
            throw new Error('Required parameter autoOrderOid was null or undefined when calling getAutoOrder.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order
     * @param autoOrderCode The auto order oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getAutoOrderByCode (autoOrderCode: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/code/{auto_order_code}'
            .replace('{' + 'auto_order_code' + '}', encodeURIComponent(String(autoOrderCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'autoOrderCode' is not null or undefined
        if (autoOrderCode === null || autoOrderCode === undefined) {
            throw new Error('Required parameter autoOrderCode was null or undefined when calling getAutoOrderByCode.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order
     * @param referenceOrderId The auto order oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getAutoOrderByReferenceOrderId (referenceOrderId: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/reference_order_id/{reference_order_id}'
            .replace('{' + 'reference_order_id' + '}', encodeURIComponent(String(referenceOrderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'referenceOrderId' is not null or undefined
        if (referenceOrderId === null || referenceOrderId === undefined) {
            throw new Error('Required parameter referenceOrderId was null or undefined when calling getAutoOrderByReferenceOrderId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param autoOrderCode Auto order code
     * @param originalOrderId Original order id
     * @param firstName First name
     * @param lastName Last name
     * @param company Company
     * @param city City
     * @param state State
     * @param postalCode Postal code
     * @param countryCode Country code (ISO-3166 two letter)
     * @param phone Phone
     * @param email Email
     * @param originalOrderDateBegin Original order date begin
     * @param originalOrderDateEnd Original order date end
     * @param nextShipmentDateBegin Next shipment date begin
     * @param nextShipmentDateEnd Next shipment date end
     * @param cardType Card type
     * @param itemId Item ID
     * @param status Status
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch auto orders that have been created/modified since this date/time.
     * @param sort The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getAutoOrders (autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (autoOrderCode !== undefined) {
            localVarQueryParameters['auto_order_code'] = ObjectSerializer.serialize(autoOrderCode, "string");
        }

        if (originalOrderId !== undefined) {
            localVarQueryParameters['original_order_id'] = ObjectSerializer.serialize(originalOrderId, "string");
        }

        if (firstName !== undefined) {
            localVarQueryParameters['first_name'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (lastName !== undefined) {
            localVarQueryParameters['last_name'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (company !== undefined) {
            localVarQueryParameters['company'] = ObjectSerializer.serialize(company, "string");
        }

        if (city !== undefined) {
            localVarQueryParameters['city'] = ObjectSerializer.serialize(city, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (postalCode !== undefined) {
            localVarQueryParameters['postal_code'] = ObjectSerializer.serialize(postalCode, "string");
        }

        if (countryCode !== undefined) {
            localVarQueryParameters['country_code'] = ObjectSerializer.serialize(countryCode, "string");
        }

        if (phone !== undefined) {
            localVarQueryParameters['phone'] = ObjectSerializer.serialize(phone, "string");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (originalOrderDateBegin !== undefined) {
            localVarQueryParameters['original_order_date_begin'] = ObjectSerializer.serialize(originalOrderDateBegin, "string");
        }

        if (originalOrderDateEnd !== undefined) {
            localVarQueryParameters['original_order_date_end'] = ObjectSerializer.serialize(originalOrderDateEnd, "string");
        }

        if (nextShipmentDateBegin !== undefined) {
            localVarQueryParameters['next_shipment_date_begin'] = ObjectSerializer.serialize(nextShipmentDateBegin, "string");
        }

        if (nextShipmentDateEnd !== undefined) {
            localVarQueryParameters['next_shipment_date_end'] = ObjectSerializer.serialize(nextShipmentDateEnd, "string");
        }

        if (cardType !== undefined) {
            localVarQueryParameters['card_type'] = ObjectSerializer.serialize(cardType, "string");
        }

        if (itemId !== undefined) {
            localVarQueryParameters['item_id'] = ObjectSerializer.serialize(itemId, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (since !== undefined) {
            localVarQueryParameters['_since'] = ObjectSerializer.serialize(since, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve auto order batch
     * @param autoOrderBatch Auto order batch
     * @param expand The object expansion to perform on the result.
     * @param {*} [options] Override http request options.
     */
    public getAutoOrdersBatch (autoOrderBatch: AutoOrderQueryBatch, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/batch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'autoOrderBatch' is not null or undefined
        if (autoOrderBatch === null || autoOrderBatch === undefined) {
            throw new Error('Required parameter autoOrderBatch was null or undefined when calling getAutoOrdersBatch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(autoOrderBatch, "AutoOrderQueryBatch")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param autoOrderQuery Auto order query
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.
     * @param {*} [options] Override http request options.
     */
    public getAutoOrdersByQuery (autoOrderQuery: AutoOrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'autoOrderQuery' is not null or undefined
        if (autoOrderQuery === null || autoOrderQuery === undefined) {
            throw new Error('Required parameter autoOrderQuery was null or undefined when calling getAutoOrdersByQuery.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(autoOrderQuery, "AutoOrderQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an auto order on the UltraCart account. 
     * @summary Update an auto order
     * @param autoOrder Auto order to update
     * @param autoOrderOid The auto order oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public updateAutoOrder (autoOrder: AutoOrder, autoOrderOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/{auto_order_oid}'
            .replace('{' + 'auto_order_oid' + '}', encodeURIComponent(String(autoOrderOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'autoOrder' is not null or undefined
        if (autoOrder === null || autoOrder === undefined) {
            throw new Error('Required parameter autoOrder was null or undefined when calling updateAutoOrder.');
        }

        // verify required parameter 'autoOrderOid' is not null or undefined
        if (autoOrderOid === null || autoOrderOid === undefined) {
            throw new Error('Required parameter autoOrderOid was null or undefined when calling updateAutoOrder.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(autoOrder, "AutoOrder")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update multiple auto orders on the UltraCart account. 
     * @summary Update multiple auto orders
     * @param autoOrdersRequest Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param async True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request options.
     */
    public updateAutoOrdersBatch (autoOrdersRequest: AutoOrdersRequest, expand?: string, placeholders?: boolean, async?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/batch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'autoOrdersRequest' is not null or undefined
        if (autoOrdersRequest === null || autoOrdersRequest === undefined) {
            throw new Error('Required parameter autoOrdersRequest was null or undefined when calling updateAutoOrdersBatch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        if (async !== undefined) {
            localVarQueryParameters['_async'] = ObjectSerializer.serialize(async, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(autoOrdersRequest, "AutoOrdersRequest")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AutoOrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChargebackApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class ChargebackApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChargebackApiApiKeys, value: string) {
        (this.authentications as any)[ChargebackApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Delete a chargeback on the UltraCart account. 
     * @summary Delete a chargeback
     * @param chargebackDisputeOid The chargeback_dispute_oid to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteChargeback (chargebackDisputeOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', encodeURIComponent(String(chargebackDisputeOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling deleteChargeback.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChargebackDisputeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single chargeback using the specified chargeback dispute oid. 
     * @summary Retrieve a chargeback
     * @param chargebackDisputeOid The chargeback dispute oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getChargebackDispute (chargebackDisputeOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', encodeURIComponent(String(chargebackDisputeOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling getChargebackDispute.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChargebackDisputeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve chargebacks
     * @param orderId Order Id
     * @param caseNumber Case number
     * @param status Status
     * @param expirationDtsStart Expiration dts start
     * @param expirationDtsEnd Expiration dts end
     * @param chargebackDtsStart Chargeback dts start
     * @param chargebackDtsEnd Chargeback dts end
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch chargebacks that have been created/modified since this date/time.
     * @param sort The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getChargebackDisputes (orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ChargebackDisputesResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (orderId !== undefined) {
            localVarQueryParameters['order_id'] = ObjectSerializer.serialize(orderId, "string");
        }

        if (caseNumber !== undefined) {
            localVarQueryParameters['case_number'] = ObjectSerializer.serialize(caseNumber, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (expirationDtsStart !== undefined) {
            localVarQueryParameters['expiration_dts_start'] = ObjectSerializer.serialize(expirationDtsStart, "string");
        }

        if (expirationDtsEnd !== undefined) {
            localVarQueryParameters['expiration_dts_end'] = ObjectSerializer.serialize(expirationDtsEnd, "string");
        }

        if (chargebackDtsStart !== undefined) {
            localVarQueryParameters['chargeback_dts_start'] = ObjectSerializer.serialize(chargebackDtsStart, "string");
        }

        if (chargebackDtsEnd !== undefined) {
            localVarQueryParameters['chargeback_dts_end'] = ObjectSerializer.serialize(chargebackDtsEnd, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (since !== undefined) {
            localVarQueryParameters['_since'] = ObjectSerializer.serialize(since, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChargebackDisputesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a chargeback on the UltraCart account. 
     * @summary Insert a chargeback
     * @param chargeback Chargeback to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public insertChargeback (chargeback: ChargebackDispute, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chargeback' is not null or undefined
        if (chargeback === null || chargeback === undefined) {
            throw new Error('Required parameter chargeback was null or undefined when calling insertChargeback.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(chargeback, "ChargebackDispute")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChargebackDisputeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a chargeback on the UltraCart account. 
     * @summary Update a chargeback
     * @param chargeback Chargeback to update
     * @param chargebackDisputeOid The chargeback_dispute_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public updateChargeback (chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', encodeURIComponent(String(chargebackDisputeOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'chargeback' is not null or undefined
        if (chargeback === null || chargeback === undefined) {
            throw new Error('Required parameter chargeback was null or undefined when calling updateChargeback.');
        }

        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling updateChargeback.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(chargeback, "ChargebackDispute")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChargebackDisputeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CheckoutApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CheckoutApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CheckoutApiApiKeys, value: string) {
        (this.authentications as any)[CheckoutApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @summary City/State for Zip
     * @param cart Cart
     * @param {*} [options] Override http request options.
     */
    public cityState (cart: Cart, options: any = {}) : Promise<{ response: http.ClientResponse; body: CityStateZip;  }> {
        const localVarPath = this.basePath + '/checkout/city_state';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling cityState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cart, "Cart")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CityStateZip;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CityStateZip");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @summary Finalize Order
     * @param finalizeRequest Finalize request
     * @param {*} [options] Override http request options.
     */
    public finalizeOrder (finalizeRequest: CartFinalizeOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartFinalizeOrderResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/finalizeOrder';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'finalizeRequest' is not null or undefined
        if (finalizeRequest === null || finalizeRequest === undefined) {
            throw new Error('Required parameter finalizeRequest was null or undefined when calling finalizeOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(finalizeRequest, "CartFinalizeOrderRequest")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartFinalizeOrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartFinalizeOrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * @summary Get affirm checkout (by cart id)
     * @param cartId Cart ID to retrieve
     * @param {*} [options] Override http request options.
     */
    public getAffirmCheckout (cartId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartAffirmCheckoutResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/{cart_id}/affirmCheckout'
            .replace('{' + 'cart_id' + '}', encodeURIComponent(String(cartId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cartId' is not null or undefined
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getAffirmCheckout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartAffirmCheckoutResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartAffirmCheckoutResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lookup the allowed countries for this merchant id 
     * @summary Allowed countries
     * @param {*} [options] Override http request options.
     */
    public getAllowedCountries (options: any = {}) : Promise<{ response: http.ClientResponse; body: CheckoutAllowedCountriesResponse;  }> {
        const localVarPath = this.basePath + '/checkout/allowedCountries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutAllowedCountriesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CheckoutAllowedCountriesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @summary Get cart
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCart (expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a cart specified by the cart_id parameter. 
     * @summary Get cart (by cart id)
     * @param cartId Cart ID to retrieve
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCartByCartId (cartId: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/{cart_id}'
            .replace('{' + 'cart_id' + '}', encodeURIComponent(String(cartId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cartId' is not null or undefined
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getCartByCartId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a cart specified by the return code parameter. 
     * @summary Get cart (by return code)
     * @param returnCode Return code to lookup cart ID by
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCartByReturnCode (returnCode: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/return/{return_code}'
            .replace('{' + 'return_code' + '}', encodeURIComponent(String(returnCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'returnCode' is not null or undefined
        if (returnCode === null || returnCode === undefined) {
            throw new Error('Required parameter returnCode was null or undefined when calling getCartByReturnCode.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Lookup a state/province list for a given country code 
     * @summary Get state/province list for a country code
     * @param countryCode Two letter ISO country code
     * @param {*} [options] Override http request options.
     */
    public getStateProvincesForCountry (countryCode: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CheckoutStateProvinceResponse;  }> {
        const localVarPath = this.basePath + '/checkout/stateProvincesForCountry/{country_code}'
            .replace('{' + 'country_code' + '}', encodeURIComponent(String(countryCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling getStateProvincesForCountry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutStateProvinceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CheckoutStateProvinceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm or finalization of the order (including upsell processing). 
     * @summary Handoff cart
     * @param handoffRequest Handoff request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public handoffCart (handoffRequest: CheckoutHandoffRequest, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CheckoutHandoffResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/handoff';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'handoffRequest' is not null or undefined
        if (handoffRequest === null || handoffRequest === undefined) {
            throw new Error('Required parameter handoffRequest was null or undefined when calling handoffCart.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(handoffRequest, "CheckoutHandoffRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutHandoffResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CheckoutHandoffResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * @summary Profile login
     * @param loginRequest Login request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public login (loginRequest: CartProfileLoginRequest, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartProfileLoginResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'loginRequest' is not null or undefined
        if (loginRequest === null || loginRequest === undefined) {
            throw new Error('Required parameter loginRequest was null or undefined when calling login.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(loginRequest, "CartProfileLoginRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartProfileLoginResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartProfileLoginResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @summary Profile logout
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public logout (cart: Cart, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling logout.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cart, "Cart")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @summary Profile registration
     * @param registerRequest Register request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public register (registerRequest: CartProfileRegisterRequest, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartProfileRegisterResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/register';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'registerRequest' is not null or undefined
        if (registerRequest === null || registerRequest === undefined) {
            throw new Error('Required parameter registerRequest was null or undefined when calling register.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registerRequest, "CartProfileRegisterRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartProfileRegisterResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartProfileRegisterResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * @summary Register affiliate click
     * @param registerAffiliateClickRequest Register affiliate click request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public registerAffiliateClick (registerAffiliateClickRequest: RegisterAffiliateClickRequest, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: RegisterAffiliateClickResponse;  }> {
        const localVarPath = this.basePath + '/checkout/affiliateClick/register';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'registerAffiliateClickRequest' is not null or undefined
        if (registerAffiliateClickRequest === null || registerAffiliateClickRequest === undefined) {
            throw new Error('Required parameter registerAffiliateClickRequest was null or undefined when calling registerAffiliateClick.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registerAffiliateClickRequest, "RegisterAffiliateClickRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RegisterAffiliateClickResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RegisterAffiliateClickResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request options.
     */
    public relatedItemsForCart (cart: Cart, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/checkout/related_items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling relatedItemsForCart.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cart, "Cart")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items (specific item)
     * @param itemId Item ID to retrieve related items for
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request options.
     */
    public relatedItemsForItem (itemId: string, cart: Cart, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/checkout/relatedItems/{item_id}'
            .replace('{' + 'item_id' + '}', encodeURIComponent(String(itemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling relatedItemsForItem.');
        }

        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling relatedItemsForItem.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cart, "Cart")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @summary Setup Browser Application
     * @param browserKeyRequest Setup browser key request
     * @param {*} [options] Override http request options.
     */
    public setupBrowserKey (browserKeyRequest: CheckoutSetupBrowserKeyRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CheckoutSetupBrowserKeyResponse;  }> {
        const localVarPath = this.basePath + '/checkout/browser_key';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'browserKeyRequest' is not null or undefined
        if (browserKeyRequest === null || browserKeyRequest === undefined) {
            throw new Error('Required parameter browserKeyRequest was null or undefined when calling setupBrowserKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(browserKeyRequest, "CheckoutSetupBrowserKeyRequest")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutSetupBrowserKeyResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CheckoutSetupBrowserKeyResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the cart. 
     * @summary Update cart
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public updateCart (cart: Cart, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling updateCart.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cart, "Cart")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @summary Validate
     * @param validationRequest Validation request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public validateCart (validationRequest: CartValidationRequest, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CartValidationResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/validate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'validationRequest' is not null or undefined
        if (validationRequest === null || validationRequest === undefined) {
            throw new Error('Required parameter validationRequest was null or undefined when calling validateCart.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(validationRequest, "CartValidationRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartValidationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CartValidationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CouponApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CouponApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CouponApiApiKeys, value: string) {
        (this.authentications as any)[CouponApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Delete a coupon on the UltraCart account. 
     * @summary Delete a coupon
     * @param couponOid The coupon_oid to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteCoupon (couponOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}'
            .replace('{' + 'coupon_oid' + '}', encodeURIComponent(String(couponOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling deleteCoupon.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Generate one time codes for a coupon 
     * @summary Generates one time codes for a coupon
     * @param couponOid The coupon oid to generate codes.
     * @param couponCodesRequest Coupon code generation parameters
     * @param {*} [options] Override http request options.
     */
    public generateCouponCodes (couponOid: number, couponCodesRequest: CouponCodesRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}/generate_codes'
            .replace('{' + 'coupon_oid' + '}', encodeURIComponent(String(couponOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling generateCouponCodes.');
        }

        // verify required parameter 'couponCodesRequest' is not null or undefined
        if (couponCodesRequest === null || couponCodesRequest === undefined) {
            throw new Error('Required parameter couponCodesRequest was null or undefined when calling generateCouponCodes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(couponCodesRequest, "CouponCodesRequest")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponCodesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Generate one time codes by merchant code 
     * @summary Generates one time codes by merchant code
     * @param merchantCode The merchant code to generate one time codes.
     * @param couponCodesRequest Coupon code generation parameters
     * @param {*} [options] Override http request options.
     */
    public generateOneTimeCodesByMerchantCode (merchantCode: string, couponCodesRequest: CouponCodesRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/merchant_code/{merchant_code}/generate_codes'
            .replace('{' + 'merchant_code' + '}', encodeURIComponent(String(merchantCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantCode' is not null or undefined
        if (merchantCode === null || merchantCode === undefined) {
            throw new Error('Required parameter merchantCode was null or undefined when calling generateOneTimeCodesByMerchantCode.');
        }

        // verify required parameter 'couponCodesRequest' is not null or undefined
        if (couponCodesRequest === null || couponCodesRequest === undefined) {
            throw new Error('Required parameter couponCodesRequest was null or undefined when calling generateOneTimeCodesByMerchantCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(couponCodesRequest, "CouponCodesRequest")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponCodesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single coupon using the specified coupon profile oid. 
     * @summary Retrieve a coupon
     * @param couponOid The coupon oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCoupon (couponOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}'
            .replace('{' + 'coupon_oid' + '}', encodeURIComponent(String(couponOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling getCoupon.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single coupon using the specified merchant code. 
     * @summary Retrieve a coupon by merchant code
     * @param merchantCode The coupon merchant code to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCouponByMerchantCode (merchantCode: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/merchant_code/{merchant_code}'
            .replace('{' + 'merchant_code' + '}', encodeURIComponent(String(merchantCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantCode' is not null or undefined
        if (merchantCode === null || merchantCode === undefined) {
            throw new Error('Required parameter merchantCode was null or undefined when calling getCouponByMerchantCode.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons
     * @param merchantCode Merchant code
     * @param description Description
     * @param couponType Coupon type
     * @param startDateBegin Start date begin
     * @param startDateEnd Start date end
     * @param expirationDateBegin Expiration date begin
     * @param expirationDateEnd Expiration date end
     * @param affiliateOid Affiliate oid
     * @param excludeExpired Exclude expired
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCoupons (merchantCode?: string, description?: string, couponType?: string, startDateBegin?: string, startDateEnd?: string, expirationDateBegin?: string, expirationDateEnd?: string, affiliateOid?: number, excludeExpired?: boolean, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponsResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (merchantCode !== undefined) {
            localVarQueryParameters['merchant_code'] = ObjectSerializer.serialize(merchantCode, "string");
        }

        if (description !== undefined) {
            localVarQueryParameters['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (couponType !== undefined) {
            localVarQueryParameters['coupon_type'] = ObjectSerializer.serialize(couponType, "string");
        }

        if (startDateBegin !== undefined) {
            localVarQueryParameters['start_date_begin'] = ObjectSerializer.serialize(startDateBegin, "string");
        }

        if (startDateEnd !== undefined) {
            localVarQueryParameters['start_date_end'] = ObjectSerializer.serialize(startDateEnd, "string");
        }

        if (expirationDateBegin !== undefined) {
            localVarQueryParameters['expiration_date_begin'] = ObjectSerializer.serialize(expirationDateBegin, "string");
        }

        if (expirationDateEnd !== undefined) {
            localVarQueryParameters['expiration_date_end'] = ObjectSerializer.serialize(expirationDateEnd, "string");
        }

        if (affiliateOid !== undefined) {
            localVarQueryParameters['affiliate_oid'] = ObjectSerializer.serialize(affiliateOid, "number");
        }

        if (excludeExpired !== undefined) {
            localVarQueryParameters['exclude_expired'] = ObjectSerializer.serialize(excludeExpired, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons by query
     * @param couponQuery Coupon query
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCouponsByQuery (couponQuery: CouponQuery, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponsResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'couponQuery' is not null or undefined
        if (couponQuery === null || couponQuery === undefined) {
            throw new Error('Required parameter couponQuery was null or undefined when calling getCouponsByQuery.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(couponQuery, "CouponQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve values needed for a coupon editor 
     * @summary Retrieve values needed for a coupon editor
     * @param {*} [options] Override http request options.
     */
    public getEditorValues (options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponEditorValues;  }> {
        const localVarPath = this.basePath + '/coupon/editor_values';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponEditorValues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponEditorValues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a coupon on the UltraCart account. 
     * @summary Insert a coupon
     * @param coupon Coupon to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public insertCoupon (coupon: Coupon, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling insertCoupon.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coupon, "Coupon")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a coupon on the UltraCart account. 
     * @summary Update a coupon
     * @param coupon Coupon to update
     * @param couponOid The coupon_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public updateCoupon (coupon: Coupon, couponOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}'
            .replace('{' + 'coupon_oid' + '}', encodeURIComponent(String(couponOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling updateCoupon.');
        }

        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling updateCoupon.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(coupon, "Coupon")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CouponResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerApiApiKeys, value: string) {
        (this.authentications as any)[CustomerApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Delete a customer on the UltraCart account. 
     * @summary Delete a customer
     * @param customerProfileOid The customer_profile_oid to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomer (customerProfileOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', encodeURIComponent(String(customerProfileOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling deleteCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single customer using the specified customer profile oid. 
     * @summary Retrieve a customer
     * @param customerProfileOid The customer oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCustomer (customerProfileOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', encodeURIComponent(String(customerProfileOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling getCustomer.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers
     * @param email Email
     * @param qbClass Quickbooks class
     * @param quickbooksCode Quickbooks code
     * @param lastModifiedDtsStart Last modified date start
     * @param lastModifiedDtsEnd Last modified date end
     * @param signupDtsStart Signup date start
     * @param signupDtsEnd Signup date end
     * @param billingFirstName Billing first name
     * @param billingLastName Billing last name
     * @param billingCompany Billing company
     * @param billingCity Billing city
     * @param billingState Billing state
     * @param billingPostalCode Billing postal code
     * @param billingCountryCode Billing country code
     * @param billingDayPhone Billing day phone
     * @param billingEveningPhone Billing evening phone
     * @param shippingFirstName Shipping first name
     * @param shippingLastName Shipping last name
     * @param shippingCompany Shipping company
     * @param shippingCity Shipping city
     * @param shippingState Shipping state
     * @param shippingPostalCode Shipping postal code
     * @param shippingCountryCode Shipping country code
     * @param shippingDayPhone Shipping day phone
     * @param shippingEveningPhone Shipping evening phone
     * @param pricingTierOid Pricing tier oid
     * @param pricingTierName Pricing tier name
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch customers that have been created/modified since this date/time.
     * @param sort The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCustomers (email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomersResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (qbClass !== undefined) {
            localVarQueryParameters['qb_class'] = ObjectSerializer.serialize(qbClass, "string");
        }

        if (quickbooksCode !== undefined) {
            localVarQueryParameters['quickbooks_code'] = ObjectSerializer.serialize(quickbooksCode, "string");
        }

        if (lastModifiedDtsStart !== undefined) {
            localVarQueryParameters['last_modified_dts_start'] = ObjectSerializer.serialize(lastModifiedDtsStart, "string");
        }

        if (lastModifiedDtsEnd !== undefined) {
            localVarQueryParameters['last_modified_dts_end'] = ObjectSerializer.serialize(lastModifiedDtsEnd, "string");
        }

        if (signupDtsStart !== undefined) {
            localVarQueryParameters['signup_dts_start'] = ObjectSerializer.serialize(signupDtsStart, "string");
        }

        if (signupDtsEnd !== undefined) {
            localVarQueryParameters['signup_dts_end'] = ObjectSerializer.serialize(signupDtsEnd, "string");
        }

        if (billingFirstName !== undefined) {
            localVarQueryParameters['billing_first_name'] = ObjectSerializer.serialize(billingFirstName, "string");
        }

        if (billingLastName !== undefined) {
            localVarQueryParameters['billing_last_name'] = ObjectSerializer.serialize(billingLastName, "string");
        }

        if (billingCompany !== undefined) {
            localVarQueryParameters['billing_company'] = ObjectSerializer.serialize(billingCompany, "string");
        }

        if (billingCity !== undefined) {
            localVarQueryParameters['billing_city'] = ObjectSerializer.serialize(billingCity, "string");
        }

        if (billingState !== undefined) {
            localVarQueryParameters['billing_state'] = ObjectSerializer.serialize(billingState, "string");
        }

        if (billingPostalCode !== undefined) {
            localVarQueryParameters['billing_postal_code'] = ObjectSerializer.serialize(billingPostalCode, "string");
        }

        if (billingCountryCode !== undefined) {
            localVarQueryParameters['billing_country_code'] = ObjectSerializer.serialize(billingCountryCode, "string");
        }

        if (billingDayPhone !== undefined) {
            localVarQueryParameters['billing_day_phone'] = ObjectSerializer.serialize(billingDayPhone, "string");
        }

        if (billingEveningPhone !== undefined) {
            localVarQueryParameters['billing_evening_phone'] = ObjectSerializer.serialize(billingEveningPhone, "string");
        }

        if (shippingFirstName !== undefined) {
            localVarQueryParameters['shipping_first_name'] = ObjectSerializer.serialize(shippingFirstName, "string");
        }

        if (shippingLastName !== undefined) {
            localVarQueryParameters['shipping_last_name'] = ObjectSerializer.serialize(shippingLastName, "string");
        }

        if (shippingCompany !== undefined) {
            localVarQueryParameters['shipping_company'] = ObjectSerializer.serialize(shippingCompany, "string");
        }

        if (shippingCity !== undefined) {
            localVarQueryParameters['shipping_city'] = ObjectSerializer.serialize(shippingCity, "string");
        }

        if (shippingState !== undefined) {
            localVarQueryParameters['shipping_state'] = ObjectSerializer.serialize(shippingState, "string");
        }

        if (shippingPostalCode !== undefined) {
            localVarQueryParameters['shipping_postal_code'] = ObjectSerializer.serialize(shippingPostalCode, "string");
        }

        if (shippingCountryCode !== undefined) {
            localVarQueryParameters['shipping_country_code'] = ObjectSerializer.serialize(shippingCountryCode, "string");
        }

        if (shippingDayPhone !== undefined) {
            localVarQueryParameters['shipping_day_phone'] = ObjectSerializer.serialize(shippingDayPhone, "string");
        }

        if (shippingEveningPhone !== undefined) {
            localVarQueryParameters['shipping_evening_phone'] = ObjectSerializer.serialize(shippingEveningPhone, "string");
        }

        if (pricingTierOid !== undefined) {
            localVarQueryParameters['pricing_tier_oid'] = ObjectSerializer.serialize(pricingTierOid, "number");
        }

        if (pricingTierName !== undefined) {
            localVarQueryParameters['pricing_tier_name'] = ObjectSerializer.serialize(pricingTierName, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (since !== undefined) {
            localVarQueryParameters['_since'] = ObjectSerializer.serialize(since, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers by query
     * @param customerQuery Customer query
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch customers that have been created/modified since this date/time.
     * @param sort The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCustomersByQuery (customerQuery: CustomerQuery, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomersResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerQuery' is not null or undefined
        if (customerQuery === null || customerQuery === undefined) {
            throw new Error('Required parameter customerQuery was null or undefined when calling getCustomersByQuery.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (since !== undefined) {
            localVarQueryParameters['_since'] = ObjectSerializer.serialize(since, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customerQuery, "CustomerQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
     * @summary Retrieve customers for DataTables plugin
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getCustomersForDataTables (expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DataTablesServerSideResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/dataTables';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataTablesServerSideResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataTablesServerSideResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve values needed for a customer profile editor. 
     * @summary Retrieve values needed for a customer profile editor
     * @param {*} [options] Override http request options.
     */
    public getEditorValues (options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerEditorValues;  }> {
        const localVarPath = this.basePath + '/customer/editor_values';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerEditorValues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerEditorValues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all email lists across all storefronts 
     * @summary Retrieve all email lists across all storefronts
     * @param {*} [options] Override http request options.
     */
    public getEmailLists (options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }> {
        const localVarPath = this.basePath + '/customer/email_lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a customer on the UltraCart account. 
     * @summary Insert a customer
     * @param customer Customer to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public insertCustomer (customer: Customer, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling insertCustomer.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customer, "Customer")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a customer on the UltraCart account. 
     * @summary Update a customer
     * @param customer Customer to update
     * @param customerProfileOid The customer_profile_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public updateCustomer (customer: Customer, customerProfileOid: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', encodeURIComponent(String(customerProfileOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling updateCustomer.');
        }

        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling updateCustomer.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customer, "Customer")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email list subscriptions for a customer 
     * @summary Update email list subscriptions for a customer
     * @param customerProfileOid The customer profile oid
     * @param listChanges List changes
     * @param {*} [options] Override http request options.
     */
    public updateCustomerEmailLists (customerProfileOid: number, listChanges: CustomerEmailListChanges, options: any = {}) : Promise<{ response: http.ClientResponse; body: CustomerEmailListChanges;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}/email_lists'
            .replace('{' + 'customer_profile_oid' + '}', encodeURIComponent(String(customerProfileOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling updateCustomerEmailLists.');
        }

        // verify required parameter 'listChanges' is not null or undefined
        if (listChanges === null || listChanges === undefined) {
            throw new Error('Required parameter listChanges was null or undefined when calling updateCustomerEmailLists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(listChanges, "CustomerEmailListChanges")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerEmailListChanges;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomerEmailListChanges");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FulfillmentApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class FulfillmentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FulfillmentApiApiKeys, value: string) {
        (this.authentications as any)[FulfillmentApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
     * @summary Acknowledge receipt of orders.
     * @param distributionCenterCode Distribution center code
     * @param orderIds Orders to acknowledge receipt of (limit 100)
     * @param {*} [options] Override http request options.
     */
    public acknowledgeOrders (distributionCenterCode: string, orderIds: Array<string>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/acknowledgements'
            .replace('{' + 'distribution_center_code' + '}', encodeURIComponent(String(distributionCenterCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling acknowledgeOrders.');
        }

        // verify required parameter 'orderIds' is not null or undefined
        if (orderIds === null || orderIds === undefined) {
            throw new Error('Required parameter orderIds was null or undefined when calling acknowledgeOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderIds, "Array<string>")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
     * @summary Retrieve orders queued up for this distribution center.
     * @param distributionCenterCode Distribution center code
     * @param {*} [options] Override http request options.
     */
    public getDistributionCenterOrders (distributionCenterCode: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/orders'
            .replace('{' + 'distribution_center_code' + '}', encodeURIComponent(String(distributionCenterCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling getDistributionCenterOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the distribution centers that this user has access to. 
     * @summary Retrieve distribution centers
     * @param {*} [options] Override http request options.
     */
    public getDistributionCenters (options: any = {}) : Promise<{ response: http.ClientResponse; body: DistributionCentersResponse;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DistributionCentersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DistributionCentersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store the tracking information and mark the order shipped for this distribution center. 
     * @summary Mark orders as shipped
     * @param distributionCenterCode Distribution center code
     * @param shipments Orders to mark shipped
     * @param {*} [options] Override http request options.
     */
    public shipOrders (distributionCenterCode: string, shipments: Array<FulfillmentShipment>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/shipments'
            .replace('{' + 'distribution_center_code' + '}', encodeURIComponent(String(distributionCenterCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling shipOrders.');
        }

        // verify required parameter 'shipments' is not null or undefined
        if (shipments === null || shipments === undefined) {
            throw new Error('Required parameter shipments was null or undefined when calling shipOrders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(shipments, "Array<FulfillmentShipment>")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the inventory for items associated with this distribution center 
     * @summary Update inventory
     * @param distributionCenterCode Distribution center code
     * @param inventories Inventory updates (limit 500)
     * @param {*} [options] Override http request options.
     */
    public updateInventory (distributionCenterCode: string, inventories: Array<FulfillmentInventory>, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/inventory'
            .replace('{' + 'distribution_center_code' + '}', encodeURIComponent(String(distributionCenterCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling updateInventory.');
        }

        // verify required parameter 'inventories' is not null or undefined
        if (inventories === null || inventories === undefined) {
            throw new Error('Required parameter inventories was null or undefined when calling updateInventory.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inventories, "Array<FulfillmentInventory>")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ItemApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class ItemApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ItemApiApiKeys, value: string) {
        (this.authentications as any)[ItemApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Delete an item on the UltraCart account. 
     * @summary Delete an item
     * @param merchantItemOid The item oid to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteItem (merchantItemOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', encodeURIComponent(String(merchantItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling deleteItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single item using the specified item oid. 
     * @summary Retrieve an item
     * @param merchantItemOid The item oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public getItem (merchantItemOid: number, expand?: string, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', encodeURIComponent(String(merchantItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling getItem.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single item using the specified item id. 
     * @summary Retrieve an item by item id
     * @param merchantItemId The item id to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public getItemByMerchantItemId (merchantItemId: string, expand?: string, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/merchant_item_id/{merchant_item_id}'
            .replace('{' + 'merchant_item_id' + '}', encodeURIComponent(String(merchantItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantItemId' is not null or undefined
        if (merchantItemId === null || merchantItemId === undefined) {
            throw new Error('Required parameter merchantItemId was null or undefined when calling getItemByMerchantItemId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve items
     * @param parentCategoryId The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
     * @param parentCategoryPath The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
     * @param limit The maximum number of records to return on this one API call. (Default 100, Max 2000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch items that have been created/modified since this date/time.
     * @param sort The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public getItems (parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/item/items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (parentCategoryId !== undefined) {
            localVarQueryParameters['parent_category_id'] = ObjectSerializer.serialize(parentCategoryId, "number");
        }

        if (parentCategoryPath !== undefined) {
            localVarQueryParameters['parent_category_path'] = ObjectSerializer.serialize(parentCategoryPath, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (since !== undefined) {
            localVarQueryParameters['_since'] = ObjectSerializer.serialize(since, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the pricing tiers 
     * @summary Retrieve pricing tiers
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getPricingTiers (expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PricingTiersResponse;  }> {
        const localVarPath = this.basePath + '/item/pricing_tiers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PricingTiersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PricingTiersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new item on the UltraCart account. 
     * @summary Create an item
     * @param item Item to create
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public insertItem (item: Item, expand?: string, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling insertItem.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(item, "Item")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a new item on the UltraCart account. 
     * @summary Update an item
     * @param item Item to update
     * @param merchantItemOid The item oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public updateItem (item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', encodeURIComponent(String(merchantItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling updateItem.');
        }

        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling updateItem.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(item, "Item")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update multiple item on the UltraCart account. 
     * @summary Update multiple items
     * @param itemsRequest Items to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param async True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request options.
     */
    public updateItems (itemsRequest: ItemsRequest, expand?: string, placeholders?: boolean, async?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/item/items/batch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemsRequest' is not null or undefined
        if (itemsRequest === null || itemsRequest === undefined) {
            throw new Error('Required parameter itemsRequest was null or undefined when calling updateItems.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        if (async !== undefined) {
            localVarQueryParameters['_async'] = ObjectSerializer.serialize(async, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemsRequest, "ItemsRequest")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
     * @summary Upload an image to the temporary multimedia.
     * @param file File to upload
     * @param {*} [options] Override http request options.
     */
    public uploadTemporaryMultimedia (file: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: TempMultimediaResponse;  }> {
        const localVarPath = this.basePath + '/item/temp_multimedia';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling uploadTemporaryMultimedia.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TempMultimediaResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TempMultimediaResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OauthApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class OauthApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OauthApiApiKeys, value: string) {
        (this.authentications as any)[OauthApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
     * @summary Exchange authorization code for access token.
     * @param clientId The OAuth application client_id.
     * @param grantType Type of grant
     * @param code Authorization code received back from the browser redirect
     * @param redirectUri The URI that you redirect the browser to to start the authorization process
     * @param refreshToken The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
     * @param {*} [options] Override http request options.
     */
    public oauthAccessToken (clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OauthTokenResponse;  }> {
        const localVarPath = this.basePath + '/oauth/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling oauthAccessToken.');
        }

        // verify required parameter 'grantType' is not null or undefined
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling oauthAccessToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (clientId !== undefined) {
            localVarFormParams['client_id'] = ObjectSerializer.serialize(clientId, "string");
        }

        if (grantType !== undefined) {
            localVarFormParams['grant_type'] = ObjectSerializer.serialize(grantType, "string");
        }

        if (code !== undefined) {
            localVarFormParams['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (redirectUri !== undefined) {
            localVarFormParams['redirect_uri'] = ObjectSerializer.serialize(redirectUri, "string");
        }

        if (refreshToken !== undefined) {
            localVarFormParams['refresh_token'] = ObjectSerializer.serialize(refreshToken, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthTokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OauthTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revokes the OAuth application associated with the specified client_id and token. 
     * @summary Revoke this OAuth application.
     * @param clientId The OAuth application client_id.
     * @param token The OAuth access token that is to be revoked..
     * @param {*} [options] Override http request options.
     */
    public oauthRevoke (clientId: string, token: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OauthRevokeSuccessResponse;  }> {
        const localVarPath = this.basePath + '/oauth/revoke';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling oauthRevoke.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling oauthRevoke.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (clientId !== undefined) {
            localVarFormParams['client_id'] = ObjectSerializer.serialize(clientId, "string");
        }

        if (token !== undefined) {
            localVarFormParams['token'] = ObjectSerializer.serialize(token, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthRevokeSuccessResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OauthRevokeSuccessResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class OrderApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrderApiApiKeys, value: string) {
        (this.authentications as any)[OrderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order.  Returns true if successful. 
     * @summary Adjusts an order total
     * @param orderId The order id to cancel.
     * @param desiredTotal The desired total with no formatting. example 123.45
     * @param {*} [options] Override http request options.
     */
    public adjustOrderTotal (orderId: string, desiredTotal: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/adjust_order_total/{desired_total}'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'desired_total' + '}', encodeURIComponent(String(desiredTotal)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling adjustOrderTotal.');
        }

        // verify required parameter 'desiredTotal' is not null or undefined
        if (desiredTotal === null || desiredTotal === undefined) {
            throw new Error('Required parameter desiredTotal was null or undefined when calling adjustOrderTotal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
     * @summary Cancel an order
     * @param orderId The order id to cancel.
     * @param {*} [options] Override http request options.
     */
    public cancelOrder (orderId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/cancel'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an order on the UltraCart account. 
     * @summary Delete an order
     * @param orderId The order id to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteOrder (orderId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling deleteOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Format the order for display at text or html 
     * @summary Format order
     * @param orderId The order id to format
     * @param formatOptions Format options
     * @param {*} [options] Override http request options.
     */
    public format (orderId: string, formatOptions: OrderFormat, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderFormatResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/format'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling format.');
        }

        // verify required parameter 'formatOptions' is not null or undefined
        if (formatOptions === null || formatOptions === undefined) {
            throw new Error('Required parameter formatOptions was null or undefined when calling format.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(formatOptions, "OrderFormat")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderFormatResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderFormatResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
     * @summary Generate an order token for a given order id
     * @param orderId The order id to generate a token for.
     * @param {*} [options] Override http request options.
     */
    public generateOrderToken (orderId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderTokenResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/token/{order_id}'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling generateOrderToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderTokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Configuration
     * @param {*} [options] Override http request options.
     */
    public getAccountsReceivableRetryConfig (options: any = {}) : Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryConfigResponse;  }> {
        const localVarPath = this.basePath + '/order/accountsReceivableRetryConfig';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryConfigResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountsReceivableRetryConfigResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Statistics
     * @param from 
     * @param to 
     * @param {*} [options] Override http request options.
     */
    public getAccountsReceivableRetryStats (from?: string, to?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryStatsResponse;  }> {
        const localVarPath = this.basePath + '/order/accountsReceivableRetryConfig/stats';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "string");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryStatsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountsReceivableRetryStatsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single order using the specified order id. 
     * @summary Retrieve an order
     * @param orderId The order id to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getOrder (orderId: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrder.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single order using the specified order token. 
     * @summary Retrieve an order using a token
     * @param orderByTokenQuery Order by token query
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getOrderByToken (orderByTokenQuery: OrderByTokenQuery, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderByTokenQuery' is not null or undefined
        if (orderByTokenQuery === null || orderByTokenQuery === undefined) {
            throw new Error('Required parameter orderByTokenQuery was null or undefined when calling getOrderByToken.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderByTokenQuery, "OrderByTokenQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param orderId Order Id
     * @param paymentMethod Payment Method
     * @param company Company
     * @param firstName First Name
     * @param lastName Last Name
     * @param city City
     * @param stateRegion State/Region
     * @param postalCode Postal Code
     * @param countryCode Country Code (ISO-3166 two letter)
     * @param phone Phone
     * @param email Email
     * @param ccEmail CC Email
     * @param total Total
     * @param screenBrandingThemeCode Screen Branding Theme Code
     * @param storefrontHostName StoreFront Host Name
     * @param creationDateBegin Creation Date Begin
     * @param creationDateEnd Creation Date End
     * @param paymentDateBegin Payment Date Begin
     * @param paymentDateEnd Payment Date End
     * @param shipmentDateBegin Shipment Date Begin
     * @param shipmentDateEnd Shipment Date End
     * @param rma RMA
     * @param purchaseOrderNumber Purchase Order Number
     * @param itemId Item Id
     * @param currentStage Current Stage
     * @param channelPartnerCode Channel Partner Code
     * @param channelPartnerOrderId Channel Partner Order ID
     * @param customerProfileOid 
     * @param refundDateBegin 
     * @param refundDateEnd 
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.
     * @param {*} [options] Override http request options.
     */
    public getOrders (orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, customerProfileOid?: number, refundDateBegin?: string, refundDateEnd?: string, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/order/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (orderId !== undefined) {
            localVarQueryParameters['order_id'] = ObjectSerializer.serialize(orderId, "string");
        }

        if (paymentMethod !== undefined) {
            localVarQueryParameters['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (company !== undefined) {
            localVarQueryParameters['company'] = ObjectSerializer.serialize(company, "string");
        }

        if (firstName !== undefined) {
            localVarQueryParameters['first_name'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (lastName !== undefined) {
            localVarQueryParameters['last_name'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (city !== undefined) {
            localVarQueryParameters['city'] = ObjectSerializer.serialize(city, "string");
        }

        if (stateRegion !== undefined) {
            localVarQueryParameters['state_region'] = ObjectSerializer.serialize(stateRegion, "string");
        }

        if (postalCode !== undefined) {
            localVarQueryParameters['postal_code'] = ObjectSerializer.serialize(postalCode, "string");
        }

        if (countryCode !== undefined) {
            localVarQueryParameters['country_code'] = ObjectSerializer.serialize(countryCode, "string");
        }

        if (phone !== undefined) {
            localVarQueryParameters['phone'] = ObjectSerializer.serialize(phone, "string");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (ccEmail !== undefined) {
            localVarQueryParameters['cc_email'] = ObjectSerializer.serialize(ccEmail, "string");
        }

        if (total !== undefined) {
            localVarQueryParameters['total'] = ObjectSerializer.serialize(total, "number");
        }

        if (screenBrandingThemeCode !== undefined) {
            localVarQueryParameters['screen_branding_theme_code'] = ObjectSerializer.serialize(screenBrandingThemeCode, "string");
        }

        if (storefrontHostName !== undefined) {
            localVarQueryParameters['storefront_host_name'] = ObjectSerializer.serialize(storefrontHostName, "string");
        }

        if (creationDateBegin !== undefined) {
            localVarQueryParameters['creation_date_begin'] = ObjectSerializer.serialize(creationDateBegin, "string");
        }

        if (creationDateEnd !== undefined) {
            localVarQueryParameters['creation_date_end'] = ObjectSerializer.serialize(creationDateEnd, "string");
        }

        if (paymentDateBegin !== undefined) {
            localVarQueryParameters['payment_date_begin'] = ObjectSerializer.serialize(paymentDateBegin, "string");
        }

        if (paymentDateEnd !== undefined) {
            localVarQueryParameters['payment_date_end'] = ObjectSerializer.serialize(paymentDateEnd, "string");
        }

        if (shipmentDateBegin !== undefined) {
            localVarQueryParameters['shipment_date_begin'] = ObjectSerializer.serialize(shipmentDateBegin, "string");
        }

        if (shipmentDateEnd !== undefined) {
            localVarQueryParameters['shipment_date_end'] = ObjectSerializer.serialize(shipmentDateEnd, "string");
        }

        if (rma !== undefined) {
            localVarQueryParameters['rma'] = ObjectSerializer.serialize(rma, "string");
        }

        if (purchaseOrderNumber !== undefined) {
            localVarQueryParameters['purchase_order_number'] = ObjectSerializer.serialize(purchaseOrderNumber, "string");
        }

        if (itemId !== undefined) {
            localVarQueryParameters['item_id'] = ObjectSerializer.serialize(itemId, "string");
        }

        if (currentStage !== undefined) {
            localVarQueryParameters['current_stage'] = ObjectSerializer.serialize(currentStage, "string");
        }

        if (channelPartnerCode !== undefined) {
            localVarQueryParameters['channel_partner_code'] = ObjectSerializer.serialize(channelPartnerCode, "string");
        }

        if (channelPartnerOrderId !== undefined) {
            localVarQueryParameters['channel_partner_order_id'] = ObjectSerializer.serialize(channelPartnerOrderId, "string");
        }

        if (customerProfileOid !== undefined) {
            localVarQueryParameters['customer_profile_oid'] = ObjectSerializer.serialize(customerProfileOid, "number");
        }

        if (refundDateBegin !== undefined) {
            localVarQueryParameters['Refund Date Begin'] = ObjectSerializer.serialize(refundDateBegin, "string");
        }

        if (refundDateEnd !== undefined) {
            localVarQueryParameters['Refund Date End'] = ObjectSerializer.serialize(refundDateEnd, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve order batch
     * @param orderBatch Order batch
     * @param expand The object expansion to perform on the result.
     * @param {*} [options] Override http request options.
     */
    public getOrdersBatch (orderBatch: OrderQueryBatch, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/batch';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderBatch' is not null or undefined
        if (orderBatch === null || orderBatch === undefined) {
            throw new Error('Required parameter orderBatch was null or undefined when calling getOrdersBatch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderBatch, "OrderQueryBatch")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param orderQuery Order query
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.
     * @param {*} [options] Override http request options.
     */
    public getOrdersByQuery (orderQuery: OrderQuery, limit?: number, offset?: number, sort?: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/query';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderQuery' is not null or undefined
        if (orderQuery === null || orderQuery === undefined) {
            throw new Error('Required parameter orderQuery was null or undefined when calling getOrdersByQuery.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderQuery, "OrderQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
     * @summary Insert an order
     * @param order Order to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public insertOrder (order: Order, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling insertOrder.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "Order")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Process payment on order 
     * @summary Process payment
     * @param orderId The order id to process payment on
     * @param processPaymentRequest Process payment parameters
     * @param {*} [options] Override http request options.
     */
    public processPayment (orderId: string, processPaymentRequest: OrderProcessPaymentRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderProcessPaymentResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/process_payment'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling processPayment.');
        }

        // verify required parameter 'processPaymentRequest' is not null or undefined
        if (processPaymentRequest === null || processPaymentRequest === undefined) {
            throw new Error('Required parameter processPaymentRequest was null or undefined when calling processPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(processPaymentRequest, "OrderProcessPaymentRequest")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderProcessPaymentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderProcessPaymentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Perform a refund operation on an order and then update the order if successful 
     * @summary Refund an order
     * @param order Order to refund
     * @param orderId The order id to refund.
     * @param rejectAfterRefund Reject order after refund
     * @param skipCustomerNotification Skip customer email notification
     * @param autoOrderCancel Cancel associated auto orders
     * @param manualRefund Consider a manual refund done externally
     * @param reverseAffiliateTransactions Reverse affiliate transactions
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public refundOrder (order: Order, orderId: string, rejectAfterRefund?: boolean, skipCustomerNotification?: boolean, autoOrderCancel?: boolean, manualRefund?: boolean, reverseAffiliateTransactions?: boolean, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/refund'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling refundOrder.');
        }

        if (rejectAfterRefund !== undefined) {
            localVarQueryParameters['reject_after_refund'] = ObjectSerializer.serialize(rejectAfterRefund, "boolean");
        }

        if (skipCustomerNotification !== undefined) {
            localVarQueryParameters['skip_customer_notification'] = ObjectSerializer.serialize(skipCustomerNotification, "boolean");
        }

        if (autoOrderCancel !== undefined) {
            localVarQueryParameters['auto_order_cancel'] = ObjectSerializer.serialize(autoOrderCancel, "boolean");
        }

        if (manualRefund !== undefined) {
            localVarQueryParameters['manual_refund'] = ObjectSerializer.serialize(manualRefund, "boolean");
        }

        if (reverseAffiliateTransactions !== undefined) {
            localVarQueryParameters['reverse_affiliate_transactions'] = ObjectSerializer.serialize(reverseAffiliateTransactions, "boolean");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "Order")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a replacement order based upon a previous order 
     * @summary Replacement order
     * @param orderId The order id to generate a replacement for.
     * @param replacement Replacement order details
     * @param {*} [options] Override http request options.
     */
    public replacement (orderId: string, replacement: OrderReplacement, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderReplacementResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/replacement'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling replacement.');
        }

        // verify required parameter 'replacement' is not null or undefined
        if (replacement === null || replacement === undefined) {
            throw new Error('Required parameter replacement was null or undefined when calling replacement.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(replacement, "OrderReplacement")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderReplacementResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderReplacementResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend the receipt for an order on the UltraCart account. 
     * @summary Resend receipt
     * @param orderId The order id to resend the receipt for.
     * @param {*} [options] Override http request options.
     */
    public resendReceipt (orderId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/resend_receipt'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling resendReceipt.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend shipment confirmation for an order on the UltraCart account. 
     * @summary Resend shipment confirmation
     * @param orderId The order id to resend the shipment notification for.
     * @param {*} [options] Override http request options.
     */
    public resendShipmentConfirmation (orderId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/resend_shipment_confirmation'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling resendShipmentConfirmation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Update A/R Retry Configuration
     * @param retryConfig AccountsReceivableRetryConfig object
     * @param {*} [options] Override http request options.
     */
    public updateAccountsReceivableRetryConfig (retryConfig: AccountsReceivableRetryConfig, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/accountsReceivableRetryConfig';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'retryConfig' is not null or undefined
        if (retryConfig === null || retryConfig === undefined) {
            throw new Error('Required parameter retryConfig was null or undefined when calling updateAccountsReceivableRetryConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(retryConfig, "AccountsReceivableRetryConfig")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
     * @summary Update an order
     * @param order Order to update
     * @param orderId The order id to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public updateOrder (order: Order, orderId: string, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling updateOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateOrder.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(order, "Order")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrderResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StorefrontApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class StorefrontApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StorefrontApiApiKeys, value: string) {
        (this.authentications as any)[StorefrontApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * 
     * @summary Add to library
     * @param addLibraryRequest New library item request
     * @param {*} [options] Override http request options.
     */
    public addToLibrary (addLibraryRequest: AddLibraryItemRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'addLibraryRequest' is not null or undefined
        if (addLibraryRequest === null || addLibraryRequest === undefined) {
            throw new Error('Required parameter addLibraryRequest was null or undefined when calling addToLibrary.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addLibraryRequest, "AddLibraryItemRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Apply library item to storefront.
     * @param applyLibraryRequest New library item
     * @param {*} [options] Override http request options.
     */
    public applyToStoreFront (applyLibraryRequest: ApplyLibraryItemRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ApplyLibraryItemResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/apply';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applyLibraryRequest' is not null or undefined
        if (applyLibraryRequest === null || applyLibraryRequest === undefined) {
            throw new Error('Required parameter applyLibraryRequest was null or undefined when calling applyToStoreFront.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(applyLibraryRequest, "ApplyLibraryItemRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApplyLibraryItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplyLibraryItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Archive email list
     * @param storefrontOid 
     * @param emailListUuid 
     * @param {*} [options] Override http request options.
     */
    public archiveEmailList (storefrontOid: number, emailListUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListArchiveResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/archive'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling archiveEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling archiveEmailList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListArchiveResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListArchiveResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Archive email segment
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param {*} [options] Override http request options.
     */
    public archiveEmailSegment (storefrontOid: number, emailSegmentUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentArchiveResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/archive'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling archiveEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling archiveEmailSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentArchiveResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentArchiveResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Back populate email flow
     * @param storefrontOid 
     * @param emailFlowUuid 
     * @param backPopulateRequest The request to back populate
     * @param {*} [options] Override http request options.
     */
    public backPopulateEmailFlow (storefrontOid: number, emailFlowUuid: string, backPopulateRequest: EmailFlowBackPopulateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailFlowBackPopulateResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/backfill'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_flow_uuid' + '}', encodeURIComponent(String(emailFlowUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling backPopulateEmailFlow.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling backPopulateEmailFlow.');
        }

        // verify required parameter 'backPopulateRequest' is not null or undefined
        if (backPopulateRequest === null || backPopulateRequest === undefined) {
            throw new Error('Required parameter backPopulateRequest was null or undefined when calling backPopulateEmailFlow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(backPopulateRequest, "EmailFlowBackPopulateRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowBackPopulateResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailFlowBackPopulateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check download of email segment
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param emailSegmentRebuildUuid 
     * @param {*} [options] Override http request options.
     */
    public checkDownloadEmailSegment (storefrontOid: number, emailSegmentUuid: string, emailSegmentRebuildUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentDownloadPrepareResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/downloadPrepare/{email_segment_rebuild_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)))
            .replace('{' + 'email_segment_rebuild_uuid' + '}', encodeURIComponent(String(emailSegmentRebuildUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling checkDownloadEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling checkDownloadEmailSegment.');
        }

        // verify required parameter 'emailSegmentRebuildUuid' is not null or undefined
        if (emailSegmentRebuildUuid === null || emailSegmentRebuildUuid === undefined) {
            throw new Error('Required parameter emailSegmentRebuildUuid was null or undefined when calling checkDownloadEmailSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentDownloadPrepareResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentDownloadPrepareResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clone email campaign
     * @param storefrontOid 
     * @param emailCampaignUuid 
     * @param targetStorefrontOid 
     * @param {*} [options] Override http request options.
     */
    public cloneEmailCampaign (storefrontOid: number, emailCampaignUuid: string, targetStorefrontOid?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/clone'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_campaign_uuid' + '}', encodeURIComponent(String(emailCampaignUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling cloneEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling cloneEmailCampaign.');
        }

        if (targetStorefrontOid !== undefined) {
            localVarQueryParameters['target_storefront_oid'] = ObjectSerializer.serialize(targetStorefrontOid, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCampaignResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clone email flow
     * @param storefrontOid 
     * @param emailFlowUuid 
     * @param targetStorefrontOid 
     * @param {*} [options] Override http request options.
     */
    public cloneEmailFlow (storefrontOid: number, emailFlowUuid: string, targetStorefrontOid?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/clone'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_flow_uuid' + '}', encodeURIComponent(String(emailFlowUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling cloneEmailFlow.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling cloneEmailFlow.');
        }

        if (targetStorefrontOid !== undefined) {
            localVarQueryParameters['target_storefront_oid'] = ObjectSerializer.serialize(targetStorefrontOid, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailFlowResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create email campaign
     * @param domain 
     * @param {*} [options] Override http request options.
     */
    public createEmailSendingDomain (domain: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains/{domain}/create'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling createEmailSendingDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSendingDomainResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete communication sequence stats
     * @param storefrontOid 
     * @param commseqUuid 
     * @param {*} [options] Override http request options.
     */
    public deleteEmailCommseqStat (storefrontOid: number, commseqUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stat'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteEmailCommseqStat.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling deleteEmailCommseqStat.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete email email
     * @param storefrontOid 
     * @param commseqEmailUuid 
     * @param {*} [options] Override http request options.
     */
    public deleteEmailEmail (storefrontOid: number, commseqEmailUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteEmailEmail.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling deleteEmailEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete email list customer
     * @param storefrontOid 
     * @param emailListUuid 
     * @param emailCustomerUuid 
     * @param {*} [options] Override http request options.
     */
    public deleteEmailListCustomer (storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)))
            .replace('{' + 'email_customer_uuid' + '}', encodeURIComponent(String(emailCustomerUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteEmailListCustomer.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling deleteEmailListCustomer.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling deleteEmailListCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete email postcard
     * @param storefrontOid 
     * @param commseqPostcardUuid 
     * @param {*} [options] Override http request options.
     */
    public deleteEmailPostcard (storefrontOid: number, commseqPostcardUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_postcard_uuid' + '}', encodeURIComponent(String(commseqPostcardUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteEmailPostcard.');
        }

        // verify required parameter 'commseqPostcardUuid' is not null or undefined
        if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
            throw new Error('Required parameter commseqPostcardUuid was null or undefined when calling deleteEmailPostcard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary delete email campaign
     * @param domain 
     * @param {*} [options] Override http request options.
     */
    public deleteEmailSendingDomain (domain: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains/{domain}'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling deleteEmailSendingDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete experiment
     * @param storefrontOid 
     * @param storefrontExperimentOid 
     * @param {*} [options] Override http request options.
     */
    public deleteExperiment (storefrontOid: number, storefrontExperimentOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'storefront_experiment_oid' + '}', encodeURIComponent(String(storefrontExperimentOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteExperiment.');
        }

        // verify required parameter 'storefrontExperimentOid' is not null or undefined
        if (storefrontExperimentOid === null || storefrontExperimentOid === undefined) {
            throw new Error('Required parameter storefrontExperimentOid was null or undefined when calling deleteExperiment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete library item
     * @param libraryItemOid 
     * @param {*} [options] Override http request options.
     */
    public deleteLibraryItem (libraryItemOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/{library_item_oid}'
            .replace('{' + 'library_item_oid' + '}', encodeURIComponent(String(libraryItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'libraryItemOid' is not null or undefined
        if (libraryItemOid === null || libraryItemOid === undefined) {
            throw new Error('Required parameter libraryItemOid was null or undefined when calling deleteLibraryItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Duplicate library item.
     * @param libraryItemOid 
     * @param {*} [options] Override http request options.
     */
    public duplicateLibraryItem (libraryItemOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/{library_item_oid}/duplicate'
            .replace('{' + 'library_item_oid' + '}', encodeURIComponent(String(libraryItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'libraryItemOid' is not null or undefined
        if (libraryItemOid === null || libraryItemOid === undefined) {
            throw new Error('Required parameter libraryItemOid was null or undefined when calling duplicateLibraryItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Obtain lat/long for an address
     * @param storefrontOid 
     * @param geocodeRequest geocode request
     * @param {*} [options] Override http request options.
     */
    public geocodeAddress (storefrontOid: number, geocodeRequest: GeocodeRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: GeocodeResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/geocode'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling geocodeAddress.');
        }

        // verify required parameter 'geocodeRequest' is not null or undefined
        if (geocodeRequest === null || geocodeRequest === undefined) {
            throw new Error('Required parameter geocodeRequest was null or undefined when calling geocodeAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(geocodeRequest, "GeocodeRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GeocodeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GeocodeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtain a list of all the countries 
     * @summary Get countries
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getCountries (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: CountriesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/countries'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getCountries.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CountriesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CountriesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Fetches a temporary authentication token for the editor 
     * @summary Gets editor token
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEditorToken (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailEditorTokenResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/editor_token'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEditorToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailEditorTokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailEditorTokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email communication base templates
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailBaseTemplates (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailBaseTemplateListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/baseTemplates'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailBaseTemplates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailBaseTemplateListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailBaseTemplateListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email campaign
     * @param storefrontOid 
     * @param emailCampaignUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailCampaign (storefrontOid: number, emailCampaignUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_campaign_uuid' + '}', encodeURIComponent(String(emailCampaignUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling getEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCampaignResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email campaign screenshots
     * @param storefrontOid 
     * @param emailCampaignUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailCampaignScreenshots (storefrontOid: number, emailCampaignUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ScreenshotsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/screenshots'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_campaign_uuid' + '}', encodeURIComponent(String(emailCampaignUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCampaignScreenshots.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling getEmailCampaignScreenshots.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ScreenshotsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ScreenshotsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email campaigns
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailCampaigns (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCampaigns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCampaignsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email campaigns with stats
     * @param storefrontOid 
     * @param statDays 
     * @param {*} [options] Override http request options.
     */
    public getEmailCampaignsWithStats (storefrontOid: number, statDays: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaignsWithStats/{stat_days}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'stat_days' + '}', encodeURIComponent(String(statDays)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCampaignsWithStats.');
        }

        // verify required parameter 'statDays' is not null or undefined
        if (statDays === null || statDays === undefined) {
            throw new Error('Required parameter statDays was null or undefined when calling getEmailCampaignsWithStats.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCampaignsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email commseq
     * @param storefrontOid 
     * @param commseqUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailCommseq (storefrontOid: number, commseqUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseq.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseq.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email communication sequence emails stats
     * @param storefrontOid 
     * @param commseqUuid 
     * @param statsRequest StatsRequest
     * @param {*} [options] Override http request options.
     */
    public getEmailCommseqEmailStats (storefrontOid: number, commseqUuid: string, statsRequest: EmailStatSummaryRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailStatSummaryResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/emailStats'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqEmailStats.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqEmailStats.');
        }

        // verify required parameter 'statsRequest' is not null or undefined
        if (statsRequest === null || statsRequest === undefined) {
            throw new Error('Required parameter statsRequest was null or undefined when calling getEmailCommseqEmailStats.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(statsRequest, "EmailStatSummaryRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailStatSummaryResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailStatSummaryResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email communication sequence postcard stats
     * @param storefrontOid 
     * @param commseqUuid 
     * @param statsRequest StatsRequest
     * @param {*} [options] Override http request options.
     */
    public getEmailCommseqPostcardStats (storefrontOid: number, commseqUuid: string, statsRequest: EmailStatPostcardSummaryRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailStatPostcardSummaryResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/postcardStats'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqPostcardStats.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqPostcardStats.');
        }

        // verify required parameter 'statsRequest' is not null or undefined
        if (statsRequest === null || statsRequest === undefined) {
            throw new Error('Required parameter statsRequest was null or undefined when calling getEmailCommseqPostcardStats.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(statsRequest, "EmailStatPostcardSummaryRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailStatPostcardSummaryResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailStatPostcardSummaryResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get communication sequence stats overall
     * @param storefrontOid 
     * @param commseqUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailCommseqStatOverall (storefrontOid: number, commseqUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqStatResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stat'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqStatOverall.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqStatOverall.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqStatResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqStatResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email communication sequence step stats
     * @param storefrontOid 
     * @param commseqUuid 
     * @param statsRequest StatsRequest
     * @param {*} [options] Override http request options.
     */
    public getEmailCommseqStepStats (storefrontOid: number, commseqUuid: string, statsRequest: EmailStepStatRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailStepStatResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stepStats'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqStepStats.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqStepStats.');
        }

        // verify required parameter 'statsRequest' is not null or undefined
        if (statsRequest === null || statsRequest === undefined) {
            throw new Error('Required parameter statsRequest was null or undefined when calling getEmailCommseqStepStats.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(statsRequest, "EmailStepStatRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailStepStatResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailStepStatResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email communication sequence customers waiting at each requested step
     * @param storefrontOid 
     * @param commseqUuid 
     * @param waitingRequest WaitingRequest
     * @param {*} [options] Override http request options.
     */
    public getEmailCommseqStepWaiting (storefrontOid: number, commseqUuid: string, waitingRequest: EmailStepWaitingRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailStepWaitingResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/waiting'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqStepWaiting.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqStepWaiting.');
        }

        // verify required parameter 'waitingRequest' is not null or undefined
        if (waitingRequest === null || waitingRequest === undefined) {
            throw new Error('Required parameter waitingRequest was null or undefined when calling getEmailCommseqStepWaiting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(waitingRequest, "EmailStepWaitingRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailStepWaitingResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailStepWaitingResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email commseqs
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailCommseqs (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqs.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get customers editor URL
     * @param storefrontOid 
     * @param emailCustomerUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailCustomerEditorUrl (storefrontOid: number, emailCustomerUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/customers/{email_customer_uuid}/editor_url'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_customer_uuid' + '}', encodeURIComponent(String(emailCustomerUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCustomerEditorUrl.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling getEmailCustomerEditorUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCustomerEditorUrlResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email customers
     * @param storefrontOid 
     * @param pageNumber 
     * @param pageSize 
     * @param searchEmailPrefix 
     * @param {*} [options] Override http request options.
     */
    public getEmailCustomers (storefrontOid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/customers'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCustomers.');
        }

        if (pageNumber !== undefined) {
            localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (searchEmailPrefix !== undefined) {
            localVarQueryParameters['searchEmailPrefix'] = ObjectSerializer.serialize(searchEmailPrefix, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email dashboard activity
     * @param storefrontOid 
     * @param lastRecords 
     * @param {*} [options] Override http request options.
     */
    public getEmailDashboardActivity (storefrontOid: number, lastRecords?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailDashboardActivityResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/dashboard_activity'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailDashboardActivity.');
        }

        if (lastRecords !== undefined) {
            localVarQueryParameters['last_records'] = ObjectSerializer.serialize(lastRecords, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailDashboardActivityResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailDashboardActivityResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get dashboard stats
     * @param storefrontOid 
     * @param days 
     * @param {*} [options] Override http request options.
     */
    public getEmailDashboardStats (storefrontOid: number, days?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailDashboardStatsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/dashboard_stats'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailDashboardStats.');
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailDashboardStatsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailDashboardStatsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email email
     * @param storefrontOid 
     * @param commseqEmailUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailEmail (storefrontOid: number, commseqEmailUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmail.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling getEmailEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqEmailResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email email clicks
     * @param storefrontOid 
     * @param commseqUuid 
     * @param commseqStepUuid 
     * @param commseqEmailUuid 
     * @param days 
     * @param {*} [options] Override http request options.
     */
    public getEmailEmailClicks (storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailClicksResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/steps/{commseq_step_uuid}/emails/{commseq_email_uuid}/clicks'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)))
            .replace('{' + 'commseq_step_uuid' + '}', encodeURIComponent(String(commseqStepUuid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmailClicks.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailEmailClicks.');
        }

        // verify required parameter 'commseqStepUuid' is not null or undefined
        if (commseqStepUuid === null || commseqStepUuid === undefined) {
            throw new Error('Required parameter commseqStepUuid was null or undefined when calling getEmailEmailClicks.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling getEmailEmailClicks.');
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailClicksResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailClicksResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email order customer editor url
     * @param storefrontOid 
     * @param commseqEmailUuid 
     * @param orderId 
     * @param {*} [options] Override http request options.
     */
    public getEmailEmailCustomerEditorUrl (storefrontOid: number, commseqEmailUuid: string, orderId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/orders/{order_id}/editor_url'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)))
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmailCustomerEditorUrl.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling getEmailEmailCustomerEditorUrl.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getEmailEmailCustomerEditorUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCustomerEditorUrlResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email email orders
     * @param storefrontOid 
     * @param commseqUuid 
     * @param commseqStepUuid 
     * @param commseqEmailUuid 
     * @param days 
     * @param {*} [options] Override http request options.
     */
    public getEmailEmailOrders (storefrontOid: number, commseqUuid: string, commseqStepUuid: string, commseqEmailUuid: string, days?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailOrdersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/steps/{commseq_step_uuid}/emails/{commseq_email_uuid}/orders'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)))
            .replace('{' + 'commseq_step_uuid' + '}', encodeURIComponent(String(commseqStepUuid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmailOrders.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailEmailOrders.');
        }

        // verify required parameter 'commseqStepUuid' is not null or undefined
        if (commseqStepUuid === null || commseqStepUuid === undefined) {
            throw new Error('Required parameter commseqStepUuid was null or undefined when calling getEmailEmailOrders.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling getEmailEmailOrders.');
        }

        if (days !== undefined) {
            localVarQueryParameters['days'] = ObjectSerializer.serialize(days, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailOrdersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailOrdersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email emails
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailEmails (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqEmailsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email emails multiple
     * @param storefrontOid 
     * @param emailCommseqEmailsRequest Request of email uuids
     * @param {*} [options] Override http request options.
     */
    public getEmailEmailsMultiple (storefrontOid: number, emailCommseqEmailsRequest: EmailCommseqEmailsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/multiple'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmailsMultiple.');
        }

        // verify required parameter 'emailCommseqEmailsRequest' is not null or undefined
        if (emailCommseqEmailsRequest === null || emailCommseqEmailsRequest === undefined) {
            throw new Error('Required parameter emailCommseqEmailsRequest was null or undefined when calling getEmailEmailsMultiple.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqEmailsRequest, "EmailCommseqEmailsRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqEmailsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email flow
     * @param storefrontOid 
     * @param emailFlowUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailFlow (storefrontOid: number, emailFlowUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_flow_uuid' + '}', encodeURIComponent(String(emailFlowUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailFlow.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling getEmailFlow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailFlowResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email flow screenshots
     * @param storefrontOid 
     * @param emailFlowUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailFlowScreenshots (storefrontOid: number, emailFlowUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ScreenshotsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/screenshots'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_flow_uuid' + '}', encodeURIComponent(String(emailFlowUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailFlowScreenshots.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling getEmailFlowScreenshots.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ScreenshotsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ScreenshotsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email flows
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailFlows (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailFlowsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailFlows.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailFlowsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email globalsettings
     * @param {*} [options] Override http request options.
     */
    public getEmailGlobalSettings (options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailGlobalSettingsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/global_settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailGlobalSettingsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailGlobalSettingsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email list
     * @param storefrontOid 
     * @param emailListUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailList (storefrontOid: number, emailListUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling getEmailList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email list customer editor url
     * @param storefrontOid 
     * @param emailListUuid 
     * @param emailCustomerUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailListCustomerEditorUrl (storefrontOid: number, emailListUuid: string, emailCustomerUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}/editor_url'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)))
            .replace('{' + 'email_customer_uuid' + '}', encodeURIComponent(String(emailCustomerUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailListCustomerEditorUrl.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling getEmailListCustomerEditorUrl.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling getEmailListCustomerEditorUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCustomerEditorUrlResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email list customers
     * @param storefrontOid 
     * @param emailListUuid 
     * @param pageNumber 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public getEmailListCustomers (storefrontOid: number, emailListUuid: string, pageNumber?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailListCustomers.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling getEmailListCustomers.');
        }

        if (pageNumber !== undefined) {
            localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email lists
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailLists (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailLists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email performance
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailPerformance (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailPerformanceResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/performance'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailPerformance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailPerformanceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailPerformanceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email plan
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailPlan (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailPlanResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/plan'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailPlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailPlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email postcard
     * @param storefrontOid 
     * @param commseqPostcardUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailPostcard (storefrontOid: number, commseqPostcardUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_postcard_uuid' + '}', encodeURIComponent(String(commseqPostcardUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailPostcard.');
        }

        // verify required parameter 'commseqPostcardUuid' is not null or undefined
        if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
            throw new Error('Required parameter commseqPostcardUuid was null or undefined when calling getEmailPostcard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqPostcardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email postcards
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailPostcards (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/postcards'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailPostcards.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqPostcardsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email postcards multiple
     * @param storefrontOid 
     * @param emailCommseqPostcardsRequest Request of postcard uuids
     * @param {*} [options] Override http request options.
     */
    public getEmailPostcardsMultiple (storefrontOid: number, emailCommseqPostcardsRequest: EmailCommseqPostcardsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/postcards/multiple'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailPostcardsMultiple.');
        }

        // verify required parameter 'emailCommseqPostcardsRequest' is not null or undefined
        if (emailCommseqPostcardsRequest === null || emailCommseqPostcardsRequest === undefined) {
            throw new Error('Required parameter emailCommseqPostcardsRequest was null or undefined when calling getEmailPostcardsMultiple.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqPostcardsRequest, "EmailCommseqPostcardsRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqPostcardsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email segment
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailSegment (storefrontOid: number, emailSegmentUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling getEmailSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email segment customers editor URL
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param emailCustomerUuid 
     * @param {*} [options] Override http request options.
     */
    public getEmailSegmentCustomerEditorUrl (storefrontOid: number, emailSegmentUuid: string, emailCustomerUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers/{email_customer_uuid}/editor_url'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)))
            .replace('{' + 'email_customer_uuid' + '}', encodeURIComponent(String(emailCustomerUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCustomerEditorUrlResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email segment customers
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param pageNumber 
     * @param pageSize 
     * @param {*} [options] Override http request options.
     */
    public getEmailSegmentCustomers (storefrontOid: number, emailSegmentUuid: string, pageNumber?: number, pageSize?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegmentCustomers.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling getEmailSegmentCustomers.');
        }

        if (pageNumber !== undefined) {
            localVarQueryParameters['pageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email segments
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailSegments (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email sending domain
     * @param domain 
     * @param {*} [options] Override http request options.
     */
    public getEmailSendingDomain (domain: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domain/{domain}'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getEmailSendingDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSendingDomainResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email sending domain status
     * @param domain 
     * @param {*} [options] Override http request options.
     */
    public getEmailSendingDomainStatus (domain: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains/{domain}/status'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getEmailSendingDomainStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSendingDomainResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email sending domains
     * @param {*} [options] Override http request options.
     */
    public getEmailSendingDomains (options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSendingDomainsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSendingDomainsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email settings
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailSettings (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSettingsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/settings'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSettingsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSettingsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email template
     * @param storefrontOid 
     * @param emailTemplateOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailTemplate (storefrontOid: number, emailTemplateOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailTemplate;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/templates/{email_template_oid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_template_oid' + '}', encodeURIComponent(String(emailTemplateOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailTemplate.');
        }

        // verify required parameter 'emailTemplateOid' is not null or undefined
        if (emailTemplateOid === null || emailTemplateOid === undefined) {
            throw new Error('Required parameter emailTemplateOid was null or undefined when calling getEmailTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailTemplate;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailTemplate");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get email templates
     * @param storefrontOid 
     * @param triggerType 
     * @param {*} [options] Override http request options.
     */
    public getEmailTemplates (storefrontOid: number, triggerType?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailTemplatesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/templates'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailTemplates.');
        }

        if (triggerType !== undefined) {
            localVarQueryParameters['trigger_type'] = ObjectSerializer.serialize(triggerType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailTemplatesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailTemplatesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of third party email providers
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getEmailThirdPartyProviders (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailThirdPartyProvidersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/third_party_providers'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailThirdPartyProviders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailThirdPartyProvidersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailThirdPartyProvidersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get experiments
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getExperiments (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ExperimentsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/experiments'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getExperiments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExperimentsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExperimentsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtain a list of property names for a given property type 
     * @summary Get histogram property names
     * @param storefrontOid 
     * @param propertyType 
     * @param {*} [options] Override http request options.
     */
    public getHistogramPropertyNames (storefrontOid: number, propertyType?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyNamesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/histogram/property_names'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getHistogramPropertyNames.');
        }

        if (propertyType !== undefined) {
            localVarQueryParameters['property_type'] = ObjectSerializer.serialize(propertyType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyNamesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailHistogramPropertyNamesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtain a list of property values for a given property name and type 
     * @summary Get histogram property values
     * @param storefrontOid 
     * @param propertyName 
     * @param propertyType 
     * @param limit 
     * @param {*} [options] Override http request options.
     */
    public getHistogramPropertyValues (storefrontOid: number, propertyName?: string, propertyType?: string, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyValuesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/histogram/property_values'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getHistogramPropertyValues.');
        }

        if (propertyName !== undefined) {
            localVarQueryParameters['property_name'] = ObjectSerializer.serialize(propertyName, "string");
        }

        if (propertyType !== undefined) {
            localVarQueryParameters['property_type'] = ObjectSerializer.serialize(propertyType, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyValuesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailHistogramPropertyValuesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get library values used to populate drop down boxes for filtering.
     * @param {*} [options] Override http request options.
     */
    public getLibraryFilterValues (options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryFilterValuesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/filter_values';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryFilterValuesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryFilterValuesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get library item.
     * @param libraryItemOid 
     * @param {*} [options] Override http request options.
     */
    public getLibraryItem (libraryItemOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/{library_item_oid}'
            .replace('{' + 'library_item_oid' + '}', encodeURIComponent(String(libraryItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'libraryItemOid' is not null or undefined
        if (libraryItemOid === null || libraryItemOid === undefined) {
            throw new Error('Required parameter libraryItemOid was null or undefined when calling getLibraryItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get thumbnail parameters
     * @param thumbnailParameters Thumbnail Parameters
     * @param {*} [options] Override http request options.
     */
    public getThumbnailParameters (thumbnailParameters: ThumbnailParametersRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: ThumbnailParametersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/thumbnailParameters';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thumbnailParameters' is not null or undefined
        if (thumbnailParameters === null || thumbnailParameters === undefined) {
            throw new Error('Required parameter thumbnailParameters was null or undefined when calling getThumbnailParameters.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(thumbnailParameters, "ThumbnailParametersRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ThumbnailParametersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ThumbnailParametersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Fetch a transactional email 
     * @summary Gets a transaction email object
     * @param storefrontOid 
     * @param emailId 
     * @param {*} [options] Override http request options.
     */
    public getTransactionEmail (storefrontOid: number, emailId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TransactionEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/transaction_email/list/{email_id}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_id' + '}', encodeURIComponent(String(emailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getTransactionEmail.');
        }

        // verify required parameter 'emailId' is not null or undefined
        if (emailId === null || emailId === undefined) {
            throw new Error('Required parameter emailId was null or undefined when calling getTransactionEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionEmailResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionEmailResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtain a list of all transactional emails and return back just their names 
     * @summary Gets a list of transaction email names
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public getTransactionEmailList (storefrontOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: TransactionEmailListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/transaction_email/list'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getTransactionEmailList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionEmailListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionEmailListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get transactional email screenshots
     * @param storefrontOid 
     * @param emailId 
     * @param {*} [options] Override http request options.
     */
    public getTransactionEmailScreenshots (storefrontOid: number, emailId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ScreenshotsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/transaction_email/list/{email_id}/screenshots'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_id' + '}', encodeURIComponent(String(emailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getTransactionEmailScreenshots.');
        }

        // verify required parameter 'emailId' is not null or undefined
        if (emailId === null || emailId === undefined) {
            throw new Error('Required parameter emailId was null or undefined when calling getTransactionEmailScreenshots.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ScreenshotsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ScreenshotsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Globally unsubscribe a customer
     * @param storefrontOid 
     * @param unsubscribe Unsubscribe
     * @param {*} [options] Override http request options.
     */
    public globalUnsubscribe (storefrontOid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailGlobalUnsubscribeResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/globalUnsubscribe'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling globalUnsubscribe.');
        }

        // verify required parameter 'unsubscribe' is not null or undefined
        if (unsubscribe === null || unsubscribe === undefined) {
            throw new Error('Required parameter unsubscribe was null or undefined when calling globalUnsubscribe.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(unsubscribe, "EmailGlobalUnsubscribeRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailGlobalUnsubscribeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailGlobalUnsubscribeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Import a third party provider list
     * @param storefrontOid 
     * @param importRequest lists to import
     * @param {*} [options] Override http request options.
     */
    public importEmailThirdPartyProviderList (storefrontOid: number, importRequest: EmailThirdPartyListImportRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/third_party_providers/import'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling importEmailThirdPartyProviderList.');
        }

        // verify required parameter 'importRequest' is not null or undefined
        if (importRequest === null || importRequest === undefined) {
            throw new Error('Required parameter importRequest was null or undefined when calling importEmailThirdPartyProviderList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(importRequest, "EmailThirdPartyListImportRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Insert email campaign
     * @param storefrontOid 
     * @param emailCampaign Email campaign
     * @param {*} [options] Override http request options.
     */
    public insertEmailCampaign (storefrontOid: number, emailCampaign: EmailCampaign, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailCampaign.');
        }

        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling insertEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaign, "EmailCampaign")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCampaignResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Insert email commseq
     * @param storefrontOid 
     * @param emailCommseq Email commseq
     * @param {*} [options] Override http request options.
     */
    public insertEmailCommseq (storefrontOid: number, emailCommseq: EmailCommseq, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailCommseq.');
        }

        // verify required parameter 'emailCommseq' is not null or undefined
        if (emailCommseq === null || emailCommseq === undefined) {
            throw new Error('Required parameter emailCommseq was null or undefined when calling insertEmailCommseq.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseq, "EmailCommseq")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Insert email email
     * @param storefrontOid 
     * @param emailCommseqEmail Email email
     * @param {*} [options] Override http request options.
     */
    public insertEmailEmail (storefrontOid: number, emailCommseqEmail: EmailCommseqEmail, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailEmail.');
        }

        // verify required parameter 'emailCommseqEmail' is not null or undefined
        if (emailCommseqEmail === null || emailCommseqEmail === undefined) {
            throw new Error('Required parameter emailCommseqEmail was null or undefined when calling insertEmailEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqEmail, "EmailCommseqEmail")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqEmailResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Insert email flow
     * @param storefrontOid 
     * @param emailFlow Email flow
     * @param {*} [options] Override http request options.
     */
    public insertEmailFlow (storefrontOid: number, emailFlow: EmailFlow, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailFlow.');
        }

        // verify required parameter 'emailFlow' is not null or undefined
        if (emailFlow === null || emailFlow === undefined) {
            throw new Error('Required parameter emailFlow was null or undefined when calling insertEmailFlow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailFlow, "EmailFlow")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailFlowResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Insert email list
     * @param storefrontOid 
     * @param emailList Email list
     * @param {*} [options] Override http request options.
     */
    public insertEmailList (storefrontOid: number, emailList: EmailList, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailList.');
        }

        // verify required parameter 'emailList' is not null or undefined
        if (emailList === null || emailList === undefined) {
            throw new Error('Required parameter emailList was null or undefined when calling insertEmailList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailList, "EmailList")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Insert email postcard
     * @param storefrontOid 
     * @param emailCommseqPostcard Email postcard
     * @param {*} [options] Override http request options.
     */
    public insertEmailPostcard (storefrontOid: number, emailCommseqPostcard: EmailCommseqPostcard, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/postcards'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailPostcard.');
        }

        // verify required parameter 'emailCommseqPostcard' is not null or undefined
        if (emailCommseqPostcard === null || emailCommseqPostcard === undefined) {
            throw new Error('Required parameter emailCommseqPostcard was null or undefined when calling insertEmailPostcard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqPostcard, "EmailCommseqPostcard")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqPostcardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Insert email segment
     * @param storefrontOid 
     * @param emailSegment Email segment
     * @param {*} [options] Override http request options.
     */
    public insertEmailSegment (storefrontOid: number, emailSegment: EmailSegment, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailSegment.');
        }

        // verify required parameter 'emailSegment' is not null or undefined
        if (emailSegment === null || emailSegment === undefined) {
            throw new Error('Required parameter emailSegment was null or undefined when calling insertEmailSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailSegment, "EmailSegment")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Prepare download of email segment
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param {*} [options] Override http request options.
     */
    public prepareDownloadEmailSegment (storefrontOid: number, emailSegmentUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentDownloadPrepareResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/downloadPrepare'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling prepareDownloadEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling prepareDownloadEmailSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentDownloadPrepareResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentDownloadPrepareResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publish library item.
     * @param libraryItemOid 
     * @param {*} [options] Override http request options.
     */
    public publishLibraryItem (libraryItemOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/{library_item_oid}/publish'
            .replace('{' + 'library_item_oid' + '}', encodeURIComponent(String(libraryItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'libraryItemOid' is not null or undefined
        if (libraryItemOid === null || libraryItemOid === undefined) {
            throw new Error('Required parameter libraryItemOid was null or undefined when calling publishLibraryItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Purchase public library item, which creates a copy of the item in your personal code library
     * @param libraryItemOid 
     * @param storefrontOid 
     * @param {*} [options] Override http request options.
     */
    public purchaseLibraryItem (libraryItemOid: number, storefrontOid?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/{library_item_oid}/purchase'
            .replace('{' + 'library_item_oid' + '}', encodeURIComponent(String(libraryItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'libraryItemOid' is not null or undefined
        if (libraryItemOid === null || libraryItemOid === undefined) {
            throw new Error('Required parameter libraryItemOid was null or undefined when calling purchaseLibraryItem.');
        }

        if (storefrontOid !== undefined) {
            localVarQueryParameters['storefront_oid'] = ObjectSerializer.serialize(storefrontOid, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Release email communication sequence customers waiting at the specified step
     * @param storefrontOid 
     * @param commseqUuid 
     * @param commseqStepUuid 
     * @param {*} [options] Override http request options.
     */
    public releaseEmailCommseqStepWaiting (storefrontOid: number, commseqUuid: string, commseqStepUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/waiting/{commseq_step_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)))
            .replace('{' + 'commseq_step_uuid' + '}', encodeURIComponent(String(commseqStepUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling releaseEmailCommseqStepWaiting.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling releaseEmailCommseqStepWaiting.');
        }

        // verify required parameter 'commseqStepUuid' is not null or undefined
        if (commseqStepUuid === null || commseqStepUuid === undefined) {
            throw new Error('Required parameter commseqStepUuid was null or undefined when calling releaseEmailCommseqStepWaiting.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request a review of an email
     * @param storefrontOid 
     * @param commseqEmailUuid 
     * @param emailCommseqEmailReviewRequest Email commseq email review request
     * @param {*} [options] Override http request options.
     */
    public review (storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailReviewRequest: EmailCommseqEmailSendTestRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailSendTestResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/review'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling review.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling review.');
        }

        // verify required parameter 'emailCommseqEmailReviewRequest' is not null or undefined
        if (emailCommseqEmailReviewRequest === null || emailCommseqEmailReviewRequest === undefined) {
            throw new Error('Required parameter emailCommseqEmailReviewRequest was null or undefined when calling review.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqEmailReviewRequest, "EmailCommseqEmailSendTestRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailSendTestResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqEmailSendTestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Searches for all matching values
     * @param category 
     * @param matches 
     * @param storefrontOid 
     * @param maxHits 
     * @param subcategory 
     * @param {*} [options] Override http request options.
     */
    public search (category?: string, matches?: string, storefrontOid?: string, maxHits?: number, subcategory?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: LookupResponse;  }> {
        const localVarPath = this.basePath + '/storefront/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (category !== undefined) {
            localVarQueryParameters['category'] = ObjectSerializer.serialize(category, "string");
        }

        if (matches !== undefined) {
            localVarQueryParameters['matches'] = ObjectSerializer.serialize(matches, "string");
        }

        if (storefrontOid !== undefined) {
            localVarQueryParameters['storefront_oid'] = ObjectSerializer.serialize(storefrontOid, "string");
        }

        if (maxHits !== undefined) {
            localVarQueryParameters['max_hits'] = ObjectSerializer.serialize(maxHits, "number");
        }

        if (subcategory !== undefined) {
            localVarQueryParameters['subcategory'] = ObjectSerializer.serialize(subcategory, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LookupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LookupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Searches for all matching values (using POST)
     * @param lookupRequest LookupRequest
     * @param {*} [options] Override http request options.
     */
    public search2 (lookupRequest: LookupRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: LookupResponse;  }> {
        const localVarPath = this.basePath + '/storefront/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'lookupRequest' is not null or undefined
        if (lookupRequest === null || lookupRequest === undefined) {
            throw new Error('Required parameter lookupRequest was null or undefined when calling search2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(lookupRequest, "LookupRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LookupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LookupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search email list customers
     * @param storefrontOid 
     * @param emailListUuid 
     * @param startsWith 
     * @param {*} [options] Override http request options.
     */
    public searchEmailListCustomers (storefrontOid: number, emailListUuid: string, startsWith?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/search'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling searchEmailListCustomers.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling searchEmailListCustomers.');
        }

        if (startsWith !== undefined) {
            localVarQueryParameters['startsWith'] = ObjectSerializer.serialize(startsWith, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search email segment customers
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param startsWith 
     * @param {*} [options] Override http request options.
     */
    public searchEmailSegmentCustomers (storefrontOid: number, emailSegmentUuid: string, startsWith?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/search'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling searchEmailSegmentCustomers.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling searchEmailSegmentCustomers.');
        }

        if (startsWith !== undefined) {
            localVarQueryParameters['startsWith'] = ObjectSerializer.serialize(startsWith, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentCustomersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param itemQuery Item query
     * @param limit The maximum number of records to return on this one API call. (Maximum 10000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request options.
     */
    public searchLibraryItems (itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemQuery' is not null or undefined
        if (itemQuery === null || itemQuery === undefined) {
            throw new Error('Required parameter itemQuery was null or undefined when calling searchLibraryItems.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemQuery, "LibraryItemQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param itemQuery Item query
     * @param limit The maximum number of records to return on this one API call. (Maximum 10000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request options.
     */
    public searchPublishedItems (itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/search_published';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemQuery' is not null or undefined
        if (itemQuery === null || itemQuery === undefined) {
            throw new Error('Required parameter itemQuery was null or undefined when calling searchPublishedItems.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemQuery, "LibraryItemQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items needing review or rejected
     * @param itemQuery Item query
     * @param limit The maximum number of records to return on this one API call. (Maximum 10000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request options.
     */
    public searchReviewItems (itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/search_review';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemQuery' is not null or undefined
        if (itemQuery === null || itemQuery === undefined) {
            throw new Error('Required parameter itemQuery was null or undefined when calling searchReviewItems.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemQuery, "LibraryItemQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param itemQuery Item query
     * @param limit The maximum number of records to return on this one API call. (Maximum 10000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request options.
     */
    public searchSharedItems (itemQuery: LibraryItemQuery, limit?: number, offset?: number, sort?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/search_shared';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemQuery' is not null or undefined
        if (itemQuery === null || itemQuery === undefined) {
            throw new Error('Required parameter itemQuery was null or undefined when calling searchSharedItems.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(itemQuery, "LibraryItemQuery")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send email test
     * @param storefrontOid 
     * @param commseqEmailUuid 
     * @param emailCommseqEmailTestRequest Email commseq email test request
     * @param {*} [options] Override http request options.
     */
    public sendEmailTest (storefrontOid: number, commseqEmailUuid: string, emailCommseqEmailTestRequest: EmailCommseqEmailSendTestRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailSendTestResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/test'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling sendEmailTest.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling sendEmailTest.');
        }

        // verify required parameter 'emailCommseqEmailTestRequest' is not null or undefined
        if (emailCommseqEmailTestRequest === null || emailCommseqEmailTestRequest === undefined) {
            throw new Error('Required parameter emailCommseqEmailTestRequest was null or undefined when calling sendEmailTest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqEmailTestRequest, "EmailCommseqEmailSendTestRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailSendTestResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqEmailSendTestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send postcard test
     * @param storefrontOid 
     * @param commseqPostcardUuid 
     * @param emailCommseqPostcardTestRequest Email commseq email test request
     * @param {*} [options] Override http request options.
     */
    public sendPostcardTest (storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcardTestRequest: EmailCommseqPostcardSendTestRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardSendTestResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}/test'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_postcard_uuid' + '}', encodeURIComponent(String(commseqPostcardUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling sendPostcardTest.');
        }

        // verify required parameter 'commseqPostcardUuid' is not null or undefined
        if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
            throw new Error('Required parameter commseqPostcardUuid was null or undefined when calling sendPostcardTest.');
        }

        // verify required parameter 'emailCommseqPostcardTestRequest' is not null or undefined
        if (emailCommseqPostcardTestRequest === null || emailCommseqPostcardTestRequest === undefined) {
            throw new Error('Required parameter emailCommseqPostcardTestRequest was null or undefined when calling sendPostcardTest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqPostcardTestRequest, "EmailCommseqPostcardSendTestRequest")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardSendTestResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqPostcardSendTestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Start email campaign
     * @param storefrontOid 
     * @param emailCampaignUuid 
     * @param {*} [options] Override http request options.
     */
    public startEmailCampaign (storefrontOid: number, emailCampaignUuid: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/start'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_campaign_uuid' + '}', encodeURIComponent(String(emailCampaignUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling startEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling startEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BaseResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Subscribe customers to email list
     * @param storefrontOid 
     * @param emailListUuid 
     * @param customers Customers
     * @param {*} [options] Override http request options.
     */
    public subscribeToEmailList (storefrontOid: number, emailListUuid: string, customers: Array<EmailCustomer>, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListSubscribeResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/subscribe'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling subscribeToEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling subscribeToEmailList.');
        }

        // verify required parameter 'customers' is not null or undefined
        if (customers === null || customers === undefined) {
            throw new Error('Required parameter customers was null or undefined when calling subscribeToEmailList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(customers, "Array<EmailCustomer>")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListSubscribeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListSubscribeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email campaign
     * @param storefrontOid 
     * @param emailCampaignUuid 
     * @param emailCampaign Email campaign
     * @param {*} [options] Override http request options.
     */
    public updateEmailCampaign (storefrontOid: number, emailCampaignUuid: string, emailCampaign: EmailCampaign, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_campaign_uuid' + '}', encodeURIComponent(String(emailCampaignUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling updateEmailCampaign.');
        }

        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling updateEmailCampaign.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCampaign, "EmailCampaign")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCampaignResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email commseq
     * @param storefrontOid 
     * @param commseqUuid 
     * @param emailCommseq Email commseq
     * @param {*} [options] Override http request options.
     */
    public updateEmailCommseq (storefrontOid: number, commseqUuid: string, emailCommseq: EmailCommseq, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_uuid' + '}', encodeURIComponent(String(commseqUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailCommseq.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling updateEmailCommseq.');
        }

        // verify required parameter 'emailCommseq' is not null or undefined
        if (emailCommseq === null || emailCommseq === undefined) {
            throw new Error('Required parameter emailCommseq was null or undefined when calling updateEmailCommseq.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseq, "EmailCommseq")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email customer
     * @param storefrontOid 
     * @param emailCustomerUuid 
     * @param emailCustomer Email customer
     * @param {*} [options] Override http request options.
     */
    public updateEmailCustomer (storefrontOid: number, emailCustomerUuid: string, emailCustomer: EmailCustomer, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/customers/{email_customer_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_customer_uuid' + '}', encodeURIComponent(String(emailCustomerUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailCustomer.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling updateEmailCustomer.');
        }

        // verify required parameter 'emailCustomer' is not null or undefined
        if (emailCustomer === null || emailCustomer === undefined) {
            throw new Error('Required parameter emailCustomer was null or undefined when calling updateEmailCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCustomer, "EmailCustomer")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email email
     * @param storefrontOid 
     * @param commseqEmailUuid 
     * @param emailCommseqEmail Email commseq email
     * @param {*} [options] Override http request options.
     */
    public updateEmailEmail (storefrontOid: number, commseqEmailUuid: string, emailCommseqEmail: EmailCommseqEmail, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_email_uuid' + '}', encodeURIComponent(String(commseqEmailUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailEmail.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling updateEmailEmail.');
        }

        // verify required parameter 'emailCommseqEmail' is not null or undefined
        if (emailCommseqEmail === null || emailCommseqEmail === undefined) {
            throw new Error('Required parameter emailCommseqEmail was null or undefined when calling updateEmailEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqEmail, "EmailCommseqEmail")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqEmailResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email flow
     * @param storefrontOid 
     * @param emailFlowUuid 
     * @param emailFlow Email flow
     * @param {*} [options] Override http request options.
     */
    public updateEmailFlow (storefrontOid: number, emailFlowUuid: string, emailFlow: EmailFlow, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_flow_uuid' + '}', encodeURIComponent(String(emailFlowUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailFlow.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling updateEmailFlow.');
        }

        // verify required parameter 'emailFlow' is not null or undefined
        if (emailFlow === null || emailFlow === undefined) {
            throw new Error('Required parameter emailFlow was null or undefined when calling updateEmailFlow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailFlow, "EmailFlow")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailFlowResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email global settings
     * @param globalSettings global settings request
     * @param {*} [options] Override http request options.
     */
    public updateEmailGlobalSettings (globalSettings: EmailGlobalSettings, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailGlobalSettingsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/global_settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'globalSettings' is not null or undefined
        if (globalSettings === null || globalSettings === undefined) {
            throw new Error('Required parameter globalSettings was null or undefined when calling updateEmailGlobalSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(globalSettings, "EmailGlobalSettings")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailGlobalSettingsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailGlobalSettingsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email list
     * @param storefrontOid 
     * @param emailListUuid 
     * @param emailList Email list
     * @param {*} [options] Override http request options.
     */
    public updateEmailList (storefrontOid: number, emailListUuid: string, emailList: EmailList, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_list_uuid' + '}', encodeURIComponent(String(emailListUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling updateEmailList.');
        }

        // verify required parameter 'emailList' is not null or undefined
        if (emailList === null || emailList === undefined) {
            throw new Error('Required parameter emailList was null or undefined when calling updateEmailList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailList, "EmailList")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailListResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email plan
     * @param storefrontOid 
     * @param settings plan request
     * @param {*} [options] Override http request options.
     */
    public updateEmailPlan (storefrontOid: number, settings: EmailPlan, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailPlanResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/plan'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailPlan.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling updateEmailPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "EmailPlan")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailPlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailPlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email postcard
     * @param storefrontOid 
     * @param commseqPostcardUuid 
     * @param emailCommseqPostcard Email commseq postcard
     * @param {*} [options] Override http request options.
     */
    public updateEmailPostcard (storefrontOid: number, commseqPostcardUuid: string, emailCommseqPostcard: EmailCommseqPostcard, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'commseq_postcard_uuid' + '}', encodeURIComponent(String(commseqPostcardUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailPostcard.');
        }

        // verify required parameter 'commseqPostcardUuid' is not null or undefined
        if (commseqPostcardUuid === null || commseqPostcardUuid === undefined) {
            throw new Error('Required parameter commseqPostcardUuid was null or undefined when calling updateEmailPostcard.');
        }

        // verify required parameter 'emailCommseqPostcard' is not null or undefined
        if (emailCommseqPostcard === null || emailCommseqPostcard === undefined) {
            throw new Error('Required parameter emailCommseqPostcard was null or undefined when calling updateEmailPostcard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailCommseqPostcard, "EmailCommseqPostcard")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqPostcardResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailCommseqPostcardResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email segment
     * @param storefrontOid 
     * @param emailSegmentUuid 
     * @param emailSegment Email segment
     * @param {*} [options] Override http request options.
     */
    public updateEmailSegment (storefrontOid: number, emailSegmentUuid: string, emailSegment: EmailSegment, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_segment_uuid' + '}', encodeURIComponent(String(emailSegmentUuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling updateEmailSegment.');
        }

        // verify required parameter 'emailSegment' is not null or undefined
        if (emailSegment === null || emailSegment === undefined) {
            throw new Error('Required parameter emailSegment was null or undefined when calling updateEmailSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(emailSegment, "EmailSegment")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSegmentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update email settings
     * @param storefrontOid 
     * @param settings settings request
     * @param {*} [options] Override http request options.
     */
    public updateEmailSettings (storefrontOid: number, settings: EmailSettings, options: any = {}) : Promise<{ response: http.ClientResponse; body: EmailSettingsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/settings'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailSettings.');
        }

        // verify required parameter 'settings' is not null or undefined
        if (settings === null || settings === undefined) {
            throw new Error('Required parameter settings was null or undefined when calling updateEmailSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(settings, "EmailSettings")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSettingsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EmailSettingsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update experiment
     * @param storefrontOid 
     * @param storefrontExperimentOid 
     * @param experiment Experiment
     * @param {*} [options] Override http request options.
     */
    public updateExperiment (storefrontOid: number, storefrontExperimentOid: number, experiment: Experiment, options: any = {}) : Promise<{ response: http.ClientResponse; body: ExperimentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'storefront_experiment_oid' + '}', encodeURIComponent(String(storefrontExperimentOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateExperiment.');
        }

        // verify required parameter 'storefrontExperimentOid' is not null or undefined
        if (storefrontExperimentOid === null || storefrontExperimentOid === undefined) {
            throw new Error('Required parameter storefrontExperimentOid was null or undefined when calling updateExperiment.');
        }

        // verify required parameter 'experiment' is not null or undefined
        if (experiment === null || experiment === undefined) {
            throw new Error('Required parameter experiment was null or undefined when calling updateExperiment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(experiment, "Experiment")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExperimentResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExperimentResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update library item. Note that only certain fields may be updated via this method.
     * @param libraryItemOid 
     * @param libraryItem Library item
     * @param {*} [options] Override http request options.
     */
    public updateLibraryItem (libraryItemOid: number, libraryItem: LibraryItem, options: any = {}) : Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }> {
        const localVarPath = this.basePath + '/storefront/code_library/{library_item_oid}'
            .replace('{' + 'library_item_oid' + '}', encodeURIComponent(String(libraryItemOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'libraryItemOid' is not null or undefined
        if (libraryItemOid === null || libraryItemOid === undefined) {
            throw new Error('Required parameter libraryItemOid was null or undefined when calling updateLibraryItem.');
        }

        // verify required parameter 'libraryItem' is not null or undefined
        if (libraryItem === null || libraryItem === undefined) {
            throw new Error('Required parameter libraryItem was null or undefined when calling updateLibraryItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(libraryItem, "LibraryItem")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LibraryItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LibraryItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a transactional email 
     * @summary Updates a transaction email object
     * @param storefrontOid 
     * @param emailId 
     * @param transactionEmail TransactionEmail
     * @param {*} [options] Override http request options.
     */
    public updateTransactionEmail (storefrontOid: number, emailId: string, transactionEmail: TransactionEmail, options: any = {}) : Promise<{ response: http.ClientResponse; body: TransactionEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/transaction_email/list/{email_id}'
            .replace('{' + 'storefront_oid' + '}', encodeURIComponent(String(storefrontOid)))
            .replace('{' + 'email_id' + '}', encodeURIComponent(String(emailId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateTransactionEmail.');
        }

        // verify required parameter 'emailId' is not null or undefined
        if (emailId === null || emailId === undefined) {
            throw new Error('Required parameter emailId was null or undefined when calling updateTransactionEmail.');
        }

        // verify required parameter 'transactionEmail' is not null or undefined
        if (transactionEmail === null || transactionEmail === undefined) {
            throw new Error('Required parameter transactionEmail was null or undefined when calling updateTransactionEmail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(transactionEmail, "TransactionEmail")
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionEmailResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionEmailResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class TaxApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TaxApiApiKeys, value: string) {
        (this.authentications as any)[TaxApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Deletes a Self tax provider city. 
     * @summary Deletes a Self tax provider city
     * @param city The city being deleted.
     * @param taxCity tax city to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteTaxProviderSelfCity (city: string, taxCity: TaxCity, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/city/{city}'
            .replace('{' + 'city' + '}', encodeURIComponent(String(city)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'city' is not null or undefined
        if (city === null || city === undefined) {
            throw new Error('Required parameter city was null or undefined when calling deleteTaxProviderSelfCity.');
        }

        // verify required parameter 'taxCity' is not null or undefined
        if (taxCity === null || taxCity === undefined) {
            throw new Error('Required parameter taxCity was null or undefined when calling deleteTaxProviderSelfCity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxCity, "TaxCity")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider country. 
     * @summary Deletes a Self tax provider country
     * @param countryCode The country code being deleted.
     * @param taxCountry tax country to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteTaxProviderSelfCountry (countryCode: string, taxCountry: TaxCountry, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/country/{countryCode}'
            .replace('{' + 'countryCode' + '}', encodeURIComponent(String(countryCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling deleteTaxProviderSelfCountry.');
        }

        // verify required parameter 'taxCountry' is not null or undefined
        if (taxCountry === null || taxCountry === undefined) {
            throw new Error('Required parameter taxCountry was null or undefined when calling deleteTaxProviderSelfCountry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxCountry, "TaxCountry")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider county. 
     * @summary Deletes a Self tax provider county
     * @param county The county being deleted.
     * @param taxCounty tax county to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteTaxProviderSelfCounty (county: string, taxCounty: TaxCounty, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/county/{county}'
            .replace('{' + 'county' + '}', encodeURIComponent(String(county)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'county' is not null or undefined
        if (county === null || county === undefined) {
            throw new Error('Required parameter county was null or undefined when calling deleteTaxProviderSelfCounty.');
        }

        // verify required parameter 'taxCounty' is not null or undefined
        if (taxCounty === null || taxCounty === undefined) {
            throw new Error('Required parameter taxCounty was null or undefined when calling deleteTaxProviderSelfCounty.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxCounty, "TaxCounty")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider postalCode. 
     * @summary Deletes a Self tax provider postalCode
     * @param postalCode The postal code being deleted.
     * @param taxPostalCode tax postal code to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteTaxProviderSelfPostalCode (postalCode: string, taxPostalCode: TaxPostalCode, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/postalCode/{postal_code}'
            .replace('{' + 'postal_code' + '}', encodeURIComponent(String(postalCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'postalCode' is not null or undefined
        if (postalCode === null || postalCode === undefined) {
            throw new Error('Required parameter postalCode was null or undefined when calling deleteTaxProviderSelfPostalCode.');
        }

        // verify required parameter 'taxPostalCode' is not null or undefined
        if (taxPostalCode === null || taxPostalCode === undefined) {
            throw new Error('Required parameter taxPostalCode was null or undefined when calling deleteTaxProviderSelfPostalCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxPostalCode, "TaxPostalCode")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider state. 
     * @summary Deletes a Self tax provider state
     * @param stateCode The state code being deleted.
     * @param taxState tax state to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteTaxProviderSelfState (stateCode: string, taxState: TaxState, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/state/{stateCode}'
            .replace('{' + 'stateCode' + '}', encodeURIComponent(String(stateCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling deleteTaxProviderSelfState.');
        }

        // verify required parameter 'taxState' is not null or undefined
        if (taxState === null || taxState === undefined) {
            throw new Error('Required parameter taxState was null or undefined when calling deleteTaxProviderSelfState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxState, "TaxState")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the Avalara tax provider. 
     * @summary Retrieve the Avalara tax provider
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderAvalara (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderAvalara");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns Avalara Tax companies configured by the merchant 
     * @summary Returns Avalara Tax companies configured by the merchant
     * @param taxProviderAvalara TaxProviderAvalara object
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderAvalaraCompanies (taxProviderAvalara: TaxProviderAvalara, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderAvalaraCompaniesResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara/companies';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taxProviderAvalara' is not null or undefined
        if (taxProviderAvalara === null || taxProviderAvalara === undefined) {
            throw new Error('Required parameter taxProviderAvalara was null or undefined when calling getTaxProviderAvalaraCompanies.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxProviderAvalara, "TaxProviderAvalara")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderAvalaraCompaniesResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderAvalaraCompaniesResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Attempts to connect to Avalara and returns back the response. 
     * @summary Attempts to connect to Avalara and returns back the response
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderAvalaraTest (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara/test';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderTestResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the Self tax provider. 
     * @summary Retrieve the Self tax provider
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderSelf (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }> {
        const localVarPath = this.basePath + '/tax/providers/self';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderSelf");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the Self tax provider countries. 
     * @summary Retrieve the Self tax provider countries
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderSelfCountries (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderSelfCountriesResponse;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/countries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelfCountriesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderSelfCountriesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the Self tax provider regions for a given country code. 
     * @summary Retrieve the Self tax provider regions for a given country code
     * @param countryCode The country code regions desired.
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderSelfRegionsByCountryCode (countryCode: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderSelfRegionsResponse;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/regions/{countryCode}'
            .replace('{' + 'countryCode' + '}', encodeURIComponent(String(countryCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling getTaxProviderSelfRegionsByCountryCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelfRegionsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderSelfRegionsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the Sovos tax provider. 
     * @summary Retrieve the Sovos tax provider
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderSovos (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderSovos;  }> {
        const localVarPath = this.basePath + '/tax/providers/sovos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSovos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderSovos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Attempts to connect to Sovos and returns back the response. 
     * @summary Attempts to connect to Sovos and returns back the response
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderSovosTest (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/sovos/test';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderTestResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the TaxJar tax provider. 
     * @summary Retrieve the TaxJar tax provider
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderTaxJar (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }> {
        const localVarPath = this.basePath + '/tax/providers/taxjar';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderTaxJar");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Attempts to connect to TaxJar and returns back the response. 
     * @summary Attempts to connect to TaxJar and returns back the response
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderTaxJarTest (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/taxjar/test';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderTestResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the UltraCart tax provider. 
     * @summary Retrieve the UltraCart tax provider
     * @param {*} [options] Override http request options.
     */
    public getTaxProviderUltraCart (options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }> {
        const localVarPath = this.basePath + '/tax/providers/ultracart';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderUltraCart");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves tax methods for this account. 
     * @summary Retrieve tax methods
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request options.
     */
    public getTaxProviders (limit?: number, offset?: number, expand?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProvidersResponse;  }> {
        const localVarPath = this.basePath + '/tax/providers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (expand !== undefined) {
            localVarQueryParameters['_expand'] = ObjectSerializer.serialize(expand, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProvidersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProvidersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Toggle a tax provider to active. 
     * @summary Toggle a tax provider to active
     * @param providerName The tax provider to set active.
     * @param {*} [options] Override http request options.
     */
    public setActiveTaxProvider (providerName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderActivateResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/setActive/{providerName}'
            .replace('{' + 'providerName' + '}', encodeURIComponent(String(providerName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'providerName' is not null or undefined
        if (providerName === null || providerName === undefined) {
            throw new Error('Required parameter providerName was null or undefined when calling setActiveTaxProvider.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderActivateResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderActivateResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the Avalara tax provider. 
     * @summary Update the Avalara tax provider
     * @param taxProviderAvalara TaxProviderAvalara object
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderAvalara (taxProviderAvalara: TaxProviderAvalara, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taxProviderAvalara' is not null or undefined
        if (taxProviderAvalara === null || taxProviderAvalara === undefined) {
            throw new Error('Required parameter taxProviderAvalara was null or undefined when calling updateTaxProviderAvalara.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxProviderAvalara, "TaxProviderAvalara")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderAvalara");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the Self tax provider. 
     * @summary Update the Self tax provider
     * @param taxProviderSelf TaxProviderSelf object
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderSelf (taxProviderSelf: TaxProviderSelf, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }> {
        const localVarPath = this.basePath + '/tax/providers/self';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taxProviderSelf' is not null or undefined
        if (taxProviderSelf === null || taxProviderSelf === undefined) {
            throw new Error('Required parameter taxProviderSelf was null or undefined when calling updateTaxProviderSelf.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxProviderSelf, "TaxProviderSelf")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderSelf");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider city. 
     * @summary Updates a Self tax provider city
     * @param city The city being updated.
     * @param taxCity tax city to be updated
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderSelfCity (city: string, taxCity: TaxCity, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxCity;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/city/{city}'
            .replace('{' + 'city' + '}', encodeURIComponent(String(city)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'city' is not null or undefined
        if (city === null || city === undefined) {
            throw new Error('Required parameter city was null or undefined when calling updateTaxProviderSelfCity.');
        }

        // verify required parameter 'taxCity' is not null or undefined
        if (taxCity === null || taxCity === undefined) {
            throw new Error('Required parameter taxCity was null or undefined when calling updateTaxProviderSelfCity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxCity, "TaxCity")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxCity;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxCity");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider country. 
     * @summary Updates a Self tax provider country
     * @param countryCode The country code being updated.
     * @param taxCountry tax country to be updated
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderSelfCountry (countryCode: string, taxCountry: TaxCountry, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxCountry;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/country/{countryCode}'
            .replace('{' + 'countryCode' + '}', encodeURIComponent(String(countryCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling updateTaxProviderSelfCountry.');
        }

        // verify required parameter 'taxCountry' is not null or undefined
        if (taxCountry === null || taxCountry === undefined) {
            throw new Error('Required parameter taxCountry was null or undefined when calling updateTaxProviderSelfCountry.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxCountry, "TaxCountry")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxCountry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxCountry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider county. 
     * @summary Updates a Self tax provider county
     * @param county The county being updated.
     * @param taxCounty tax county to be updated
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderSelfCounty (county: string, taxCounty: TaxCounty, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxCounty;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/county/{county}'
            .replace('{' + 'county' + '}', encodeURIComponent(String(county)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'county' is not null or undefined
        if (county === null || county === undefined) {
            throw new Error('Required parameter county was null or undefined when calling updateTaxProviderSelfCounty.');
        }

        // verify required parameter 'taxCounty' is not null or undefined
        if (taxCounty === null || taxCounty === undefined) {
            throw new Error('Required parameter taxCounty was null or undefined when calling updateTaxProviderSelfCounty.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxCounty, "TaxCounty")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxCounty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxCounty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider postalCode. 
     * @summary Updates a Self tax provider postalCode
     * @param postalCode The postal code being updated.
     * @param taxPostalCode tax postal code to be updated
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderSelfPostalCode (postalCode: string, taxPostalCode: TaxPostalCode, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxPostalCode;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/postalCode/{postal_code}'
            .replace('{' + 'postal_code' + '}', encodeURIComponent(String(postalCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'postalCode' is not null or undefined
        if (postalCode === null || postalCode === undefined) {
            throw new Error('Required parameter postalCode was null or undefined when calling updateTaxProviderSelfPostalCode.');
        }

        // verify required parameter 'taxPostalCode' is not null or undefined
        if (taxPostalCode === null || taxPostalCode === undefined) {
            throw new Error('Required parameter taxPostalCode was null or undefined when calling updateTaxProviderSelfPostalCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxPostalCode, "TaxPostalCode")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxPostalCode;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxPostalCode");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider state. 
     * @summary Updates a Self tax provider state
     * @param stateCode The state code being updated.
     * @param taxState tax state to be updated
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderSelfState (stateCode: string, taxState: TaxState, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxState;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/state/{stateCode}'
            .replace('{' + 'stateCode' + '}', encodeURIComponent(String(stateCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling updateTaxProviderSelfState.');
        }

        // verify required parameter 'taxState' is not null or undefined
        if (taxState === null || taxState === undefined) {
            throw new Error('Required parameter taxState was null or undefined when calling updateTaxProviderSelfState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxState, "TaxState")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxState;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxState");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the Sovos tax provider. 
     * @summary Update the Sovos tax provider
     * @param taxProviderSovos TaxProviderSovos object
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderSovos (taxProviderSovos: TaxProviderSovos, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderSovos;  }> {
        const localVarPath = this.basePath + '/tax/providers/sovos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taxProviderSovos' is not null or undefined
        if (taxProviderSovos === null || taxProviderSovos === undefined) {
            throw new Error('Required parameter taxProviderSovos was null or undefined when calling updateTaxProviderSovos.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxProviderSovos, "TaxProviderSovos")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSovos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderSovos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the TaxJar tax provider. 
     * @summary Update the TaxJar tax provider
     * @param taxProviderTaxJar TaxProviderTaxJar object
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderTaxJar (taxProviderTaxJar: TaxProviderTaxJar, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }> {
        const localVarPath = this.basePath + '/tax/providers/taxjar';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taxProviderTaxJar' is not null or undefined
        if (taxProviderTaxJar === null || taxProviderTaxJar === undefined) {
            throw new Error('Required parameter taxProviderTaxJar was null or undefined when calling updateTaxProviderTaxJar.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxProviderTaxJar, "TaxProviderTaxJar")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderTaxJar");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the UltraCart tax provider. 
     * @summary Update the UltraCart tax provider
     * @param taxProviderUltracart TaxProviderUltraCart object
     * @param {*} [options] Override http request options.
     */
    public updateTaxProviderUltraCart (taxProviderUltracart: TaxProviderUltraCart, options: any = {}) : Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }> {
        const localVarPath = this.basePath + '/tax/providers/ultracart';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taxProviderUltracart' is not null or undefined
        if (taxProviderUltracart === null || taxProviderUltracart === undefined) {
            throw new Error('Required parameter taxProviderUltracart was null or undefined when calling updateTaxProviderUltraCart.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxProviderUltracart, "TaxProviderUltraCart")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TaxProviderUltraCart");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Delete a group on the UltraCart account. 
     * @summary Delete a group
     * @param groupOid The group_oid to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteGroup (groupOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/user/groups/{group_oid}'
            .replace('{' + 'group_oid' + '}', encodeURIComponent(String(groupOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupOid' is not null or undefined
        if (groupOid === null || groupOid === undefined) {
            throw new Error('Required parameter groupOid was null or undefined when calling deleteGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a user on the UltraCart account. 
     * @summary Delete a user
     * @param userId The user_id to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteUser (userId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/user/users/{user_id}'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single group using the specified group id. 
     * @summary Retrieve a group
     * @param groupOid The group id to retrieve.
     * @param {*} [options] Override http request options.
     */
    public getGroup (groupOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/user/groups/{group_oid}'
            .replace('{' + 'group_oid' + '}', encodeURIComponent(String(groupOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupOid' is not null or undefined
        if (groupOid === null || groupOid === undefined) {
            throw new Error('Required parameter groupOid was null or undefined when calling getGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get groups
     * @param {*} [options] Override http request options.
     */
    public getGroups (options: any = {}) : Promise<{ response: http.ClientResponse; body: GroupsResponse;  }> {
        const localVarPath = this.basePath + '/user/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a single user using the specified user id. 
     * @summary Retrieve a user
     * @param userId The user id to retrieve.
     * @param {*} [options] Override http request options.
     */
    public getUser (userId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserResponse;  }> {
        const localVarPath = this.basePath + '/user/users/{user_id}'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves logins for a single user using the specified user id. 
     * @summary Retrieve a user's login history
     * @param userId The user id to retrieve.
     * @param {*} [options] Override http request options.
     */
    public getUserLogins (userId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserLoginsResponse;  }> {
        const localVarPath = this.basePath + '/user/users/{user_id}/logins'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserLogins.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserLoginsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserLoginsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get users
     * @param {*} [options] Override http request options.
     */
    public getUsers (options: any = {}) : Promise<{ response: http.ClientResponse; body: UsersResponse;  }> {
        const localVarPath = this.basePath + '/user/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UsersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UsersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a group on the UltraCart account. 
     * @summary Insert a group
     * @param group Group to insert
     * @param {*} [options] Override http request options.
     */
    public insertGroup (group: Group, options: any = {}) : Promise<{ response: http.ClientResponse; body: GroupResponse;  }> {
        const localVarPath = this.basePath + '/user/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling insertGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "Group")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a user on the UltraCart account. 
     * @summary Insert a user
     * @param user User to insert
     * @param {*} [options] Override http request options.
     */
    public insertUser (user: User, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserResponse;  }> {
        const localVarPath = this.basePath + '/user/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling insertUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a group on the UltraCart account. 
     * @summary Update a group
     * @param group Group to update
     * @param groupOid The group_oid to update.
     * @param {*} [options] Override http request options.
     */
    public updateGroup (group: Group, groupOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: GroupResponse;  }> {
        const localVarPath = this.basePath + '/user/groups/{group_oid}'
            .replace('{' + 'group_oid' + '}', encodeURIComponent(String(groupOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling updateGroup.');
        }

        // verify required parameter 'groupOid' is not null or undefined
        if (groupOid === null || groupOid === undefined) {
            throw new Error('Required parameter groupOid was null or undefined when calling updateGroup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "Group")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a user on the UltraCart account. 
     * @summary Update a user
     * @param user User to update
     * @param userId The user_id to update.
     * @param {*} [options] Override http request options.
     */
    public updateUser (user: User, userId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserResponse;  }> {
        const localVarPath = this.basePath + '/user/users/{user_id}'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateUser.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhookApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class WebhookApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhookApiApiKeys, value: string) {
        (this.authentications as any)[WebhookApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    /**
     * Delete a webhook on the UltraCart account. 
     * @summary Delete a webhook
     * @param webhookOid The webhook oid to delete.
     * @param {*} [options] Override http request options.
     */
    public deleteWebhook (webhookOid: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}'
            .replace('{' + 'webhookOid' + '}', encodeURIComponent(String(webhookOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling deleteWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
     * @summary Delete a webhook by URL
     * @param webhook Webhook to delete
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookByUrl (webhook: Webhook, options: any = {}) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling deleteWebhookByUrl.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhook, "Webhook")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves an individual log for a webhook given the webhook oid the request id. 
     * @summary Retrieve an individual log
     * @param webhookOid The webhook oid that owns the log.
     * @param requestId The request id associated with the log to view.
     * @param {*} [options] Override http request options.
     */
    public getWebhookLog (webhookOid: number, requestId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: WebhookLogResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/logs/{requestId}'
            .replace('{' + 'webhookOid' + '}', encodeURIComponent(String(webhookOid)))
            .replace('{' + 'requestId' + '}', encodeURIComponent(String(requestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling getWebhookLog.');
        }

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getWebhookLog.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookLogResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookLogResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
     * @summary Retrieve the log summaries
     * @param webhookOid The webhook oid to retrieve log summaries for.
     * @param limit The maximum number of records to return on this one API call.
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch log summaries that have been delivered since this date/time.
     * @param {*} [options] Override http request options.
     */
    public getWebhookLogSummaries (webhookOid: number, limit?: number, offset?: number, since?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: WebhookLogSummariesResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/logs'
            .replace('{' + 'webhookOid' + '}', encodeURIComponent(String(webhookOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling getWebhookLogSummaries.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (since !== undefined) {
            localVarQueryParameters['_since'] = ObjectSerializer.serialize(since, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookLogSummariesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookLogSummariesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves the webhooks associated with this application. 
     * @summary Retrieve webhooks
     * @param limit The maximum number of records to return on this one API call.
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the webhooks.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (limit?: number, offset?: number, sort?: string, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: WebhooksResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['_limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['_offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['_sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhooksResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhooksResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
     * @summary Add a webhook
     * @param webhook Webhook to create
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public insertWebhook (webhook: Webhook, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling insertWebhook.');
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhook, "Webhook")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
     * @summary Resend events to the webhook endpoint.
     * @param webhookOid The webhook oid that is receiving the reflowed events.
     * @param eventName The event to reflow.
     * @param {*} [options] Override http request options.
     */
    public resendEvent (webhookOid: number, eventName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: WebhookSampleRequestResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/reflow/{eventName}'
            .replace('{' + 'webhookOid' + '}', encodeURIComponent(String(webhookOid)))
            .replace('{' + 'eventName' + '}', encodeURIComponent(String(eventName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling resendEvent.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling resendEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookSampleRequestResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookSampleRequestResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a webhook on the account 
     * @summary Update a webhook
     * @param webhook Webhook to update
     * @param webhookOid The webhook oid to update.
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request options.
     */
    public updateWebhook (webhook: Webhook, webhookOid: number, placeholders?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}'
            .replace('{' + 'webhookOid' + '}', encodeURIComponent(String(webhookOid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling updateWebhook.');
        }

        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling updateWebhook.');
        }

        if (placeholders !== undefined) {
            localVarQueryParameters['_placeholders'] = ObjectSerializer.serialize(placeholders, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(webhook, "Webhook")
        };

        this.authentications.ultraCartOauth.applyToRequest(localVarRequestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
