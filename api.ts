/**
 * UltraCart Rest API V2
 * This is the next generation UltraCart REST API...
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://secure.ultracart.com/rest/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class ApiUserApplicationProfile {
    /**
    * Application logo URL
    */
    'apiApplicationLogoUrl': string;
    /**
    * Application description
    */
    'applicationDescription': string;
    /**
    * Application name
    */
    'applicationName': string;
    /**
    * Developer name
    */
    'developerName': string;
    /**
    * Developer website
    */
    'developerWebsite': string;
}

export class AutoOrder {
    /**
    * Unique code assigned to this auto order
    */
    'autoOrderCode': string;
    /**
    * Auto order object identifier
    */
    'autoOrderOid': number;
    /**
    * Cancel this auto order after X additional rebills
    */
    'cancelAfterNextXOrders': number;
    /**
    * True if the auto order was canceled because the customer purchased a downgrade item
    */
    'cancelDowngrade': boolean;
    /**
    * True if the auto order was canceled because the customer purchased an upgrade item
    */
    'cancelUpgrade': boolean;
    /**
    * The user that canceled the auto order
    */
    'canceledByUser': string;
    /**
    * The date/time that the auto order was canceled
    */
    'canceledDts': string;
    /**
    * The number of credit card attempts that have taken place
    */
    'creditCardAttempt': number;
    /**
    * The date/time the auto order was disabled due to failed rebills
    */
    'disabledDts': string;
    /**
    * True if this auto order is enabled
    */
    'enabled': boolean;
    /**
    * The reason this auto order failed during the last rebill attempt
    */
    'failureReason': string;
    /**
    * The items that are setup to rebill
    */
    'items': Array<AutoOrderItem>;
    /**
    * The next time that the auto order will be attempted for processing
    */
    'nextAttempt': string;
    'originalOrder': Order;
    /**
    * The original order id that this auto order is associated with.
    */
    'originalOrderId': string;
    /**
    * Override the affiliate id given credit for rebills of this auto order
    */
    'overrideAffiliateId': number;
    /**
    * Rebill orders that have taken place on this auto order
    */
    'rebillOrders': Array<Order>;
    /**
    * The RTG code associated with this order for future rebills
    */
    'rotatingTransactionGatewayCode': string;
}

export class AutoOrderItem {
    /**
    * Arbitrary item id that should be rebilled instead of the normal schedule
    */
    'arbitraryItemId': string;
    /**
    * An arbitrary percentage discount to provide on future rebills
    */
    'arbitraryPercentageDiscount': number;
    /**
    * Arbitrary quantity to rebill
    */
    'arbitraryQuantity': number;
    /**
    * The number of days to rebill if the frequency is set to an arbitrary number of days
    */
    'arbitraryScheduleDays': number;
    /**
    * Arbitrary unit cost that rebills of this item should occur at
    */
    'arbitraryUnitCost': number;
    /**
    * The number of rebills to give the arbitrary unit cost on before reverting to normal pricing.
    */
    'arbitraryUnitCostRemainingOrders': number;
    /**
    * Primary key of AutoOrderItem
    */
    'autoOrderItemOid': number;
    /**
    * Frequency of the rebill if not a fixed schedule
    */
    'frequency': AutoOrderItem.FrequencyEnum;
    /**
    * Date/time of the last order of this item
    */
    'lastOrderDts': string;
    /**
    * The life time value of this item including the original purchase
    */
    'lifeTimeValue': number;
    /**
    * The date/time of when the next pre-shipment notice should be sent
    */
    'nextPreshipmentNoticeDts': string;
    /**
    * Date/time that this item is scheduled to rebill
    */
    'nextShipmentDts': string;
    /**
    * Date/time after which no additional rebills of this item should occur
    */
    'noOrderAfterDts': string;
    /**
    * The number of times this item has rebilled
    */
    'numberOfRebills': number;
    /**
    * Options associated with this item
    */
    'options': Array<AutoOrderItemOption>;
    /**
    * The original item id purchased
    */
    'originalItemId': string;
    /**
    * The original quantity purchased
    */
    'originalQuantity': number;
    /**
    * The PayPal Payer ID tied to this item
    */
    'paypalPayerId': string;
    /**
    * The PayPal Profile ID tied to this item
    */
    'paypalRecurringPaymentProfileId': string;
    /**
    * True if the preshipment notice associated with the next rebill has been sent
    */
    'preshipmentNoticeSent': boolean;
    /**
    * The value of the rebills of this item
    */
    'rebillValue': number;
    /**
    * The number of rebills remaining before this item is complete
    */
    'remainingRepeatCount': number;
}

export namespace AutoOrderItem {
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}
export class AutoOrderItemOption {
    /**
    * Label
    */
    'label': string;
    /**
    * Value
    */
    'value': string;
}

export class AutoOrderResponse {
    'autoOrder': AutoOrder;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class AutoOrdersResponse {
    'autoOrders': Array<AutoOrder>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class BaseResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Cart {
    'affiliate': CartAffiliate;
    /**
    * The ISO-4217 three letter base currency code of the account
    */
    'baseCurrencyCode': string;
    'billing': CartBilling;
    'buysafe': CartBuysafe;
    /**
    * Unique identifier for this cart
    */
    'cartId': string;
    'checkout': CartCheckout;
    /**
    * Coupons
    */
    'coupons': Array<CartCoupon>;
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    'customerProfile': CartCustomerProfile;
    /**
    * The exchange rate if the customer is viewing a different currency than the base
    */
    'exchangeRate': number;
    'gift': CartGift;
    'giftCertificate': CartGiftCertificate;
    /**
    * Items
    */
    'items': Array<CartItem>;
    /**
    * The ISO-631 three letter code the customer would like to checkout with
    */
    'languageIsoCode': string;
    /**
    * True if the customer is logged into their profile
    */
    'loggedIn': boolean;
    'marketing': CartMarketing;
    /**
    * Merchant ID this cart is associated with
    */
    'merchantId': string;
    'payment': CartPayment;
    'settings': CartSettings;
    'shipping': CartShipping;
    'summary': CartSummary;
    'taxes': CartTaxes;
    'upsellAfter': CartUpsellAfter;
}

export class CartAffiliate {
    /**
    * Affiliate id associated with the cart
    */
    'affiliateId': number;
    /**
    * Affiliate sub id associated with the cart
    */
    'affiliateSubId': string;
}

export class CartBilling {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
    */
    'ccEmails': Array<string>;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Email
    */
    'email': string;
    /**
    * Email entered for confirmation
    */
    'emailConfirm': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
}

export class CartBuysafe {
    /**
    * True if buySAFE is willing to bond the order
    */
    'bondAvailable': boolean;
    'bondCost': Currency;
    /**
    * True if the bond is free (merchant paying for it)
    */
    'bondFree': boolean;
    /**
    * True if the customer wants the bond
    */
    'bondWanted': boolean;
    /**
    * Recommend text to display to the customer
    */
    'cartDisplayText': string;
    /**
    * URL associated with the recommended text
    */
    'cartDisplayUrl': string;
}

export class CartCheckout {
    /**
    * Comments from the customer.  Rarely used on the single page checkout.
    */
    'comments': string;
    /**
    * Custom field 1
    */
    'customField1': string;
    /**
    * Custom field 2
    */
    'customField2': string;
    /**
    * Custom field 3
    */
    'customField3': string;
    /**
    * Custom field 4
    */
    'customField4': string;
    /**
    * Custom field 5
    */
    'customField5': string;
    /**
    * Custom field 6
    */
    'customField6': string;
    /**
    * Custom field 7
    */
    'customField7': string;
    /**
    * IP Address
    */
    'ipAddress': string;
    /**
    * Screen branding theme code
    */
    'screenBrandingThemeCode': string;
}

export class CartCoupon {
    /**
    * Coupon code
    */
    'couponCode': string;
}

export class CartCustomerProfile {
    /**
    * True if profile is allowed to bill to their 3rd party shipping account
    */
    'allow3rdPartyBilling': boolean;
    /**
    * True if this profile is allowed to use a COD
    */
    'allowCod': boolean;
    /**
    * True if this profile is allowed to use a purchase order
    */
    'allowPurchaseOrder': boolean;
    /**
    * Billing addresses on file for this profile
    */
    'billingAddresses': Array<CartCustomerProfileAddress>;
    /**
    * Credit cards on file for this profile (masked)
    */
    'creditCards': Array<CartCustomerProfileCreditCard>;
    /**
    * Unique identifier
    */
    'customerProfileOid': number;
    /**
    * DHL account number on file
    */
    'dhlAccountNumber': string;
    /**
    * Email
    */
    'email': string;
    /**
    * FedEx account number on file
    */
    'fedexAccountNumber': string;
    /**
    * True if this profile always qualifies for free shipping
    */
    'freeShipping': boolean;
    /**
    * The minimum aount that this profile has to purchase to qualify for free shipping
    */
    'freeShippingMinimum': number;
    /**
    * Maximum item count this profile can purchase
    */
    'maximumItemCount': number;
    /**
    * Minimum item count this profile must purchase
    */
    'minimumItemCount': number;
    /**
    * Minimum subtotal this profile must purchase
    */
    'minimumSubtotal': number;
    /**
    * True if this profile is prevented from using coupons
    */
    'noCoupons': boolean;
    /**
    * True if this profile is never given free shipping
    */
    'noFreeShipping': boolean;
    /**
    * True if this customers orders are not charged in real-time
    */
    'noRealtimeCharge': boolean;
    /**
    * Pricing tier names this profile qualifies for
    */
    'pricingTiers': Array<string>;
    /**
    * Shipping addresses on file for this profile
    */
    'shippingAddresses': Array<CartCustomerProfileAddress>;
    /**
    * True if this profile is exempt from sales tax
    */
    'taxExempt': boolean;
    /**
    * UPS account number on file
    */
    'upsAccountNumber': string;
}

export class CartCustomerProfileAddress {
    /**
    * Address 1
    */
    'address1': string;
    /**
    * Address 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 Country code
    */
    'countryCode': string;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Unique identifier for this address
    */
    'oid': number;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Tax county if a billing address
    */
    'taxCounty': string;
    /**
    * Title
    */
    'title': string;
}

export class CartCustomerProfileCreditCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (four digit)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked last 4 digits)
    */
    'cardNumber': string;
    /**
    * Card type
    */
    'cardType': CartCustomerProfileCreditCard.CardTypeEnum;
    /**
    * Unique identifier for this stored card
    */
    'customerProfileCreditCardId': number;
    /**
    * Last used
    */
    'lastUsedDate': string;
}

export namespace CartCustomerProfileCreditCard {
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        MasterCard = <any> 'MasterCard',
        JCB = <any> 'JCB',
        VISA = <any> 'VISA'
    }
}
export class CartFinalizeOrderRequest {
    'cart': Cart;
    'options': CartFinalizeOrderRequestOptions;
}

export class CartFinalizeOrderRequestOptions {
    /**
    * Automatically approve the purchase order
    */
    'autoApprovePurchaseOrder': boolean;
    /**
    * Channel partner code to associate this order with
    */
    'channelPartnerCode': string;
    /**
    * Channel partner oid to associate this order with
    */
    'channelPartnerOid': number;
    /**
    * Channel partner order id for reference
    */
    'channelPartnerOrderId': string;
    /**
    * Consider this order a recurring order for the purposes of payment gateway recurring flag
    */
    'considerRecurring': boolean;
    /**
    * If the order was authorized outside of UltraCart, this is the amount of the authorization
    */
    'creditCardAuthorizationAmount': number;
    /**
    * If the order was authorized outside of UltraCart, this is the date/time of the authorization
    */
    'creditCardAuthorizationDate': string;
    /**
    * If the order was authorized outside of UltraCart, this is the authorization reference number
    */
    'creditCardAuthorizationReferenceNumber': string;
    /**
    * Prevents normal real-time processing of the payment and sends the order to Accounts Receivable
    */
    'noRealtimePaymentProcessing': boolean;
    /**
    * True if the system should create another cart automatically if the current cart was logged into a profile
    */
    'setupNextCart': boolean;
    /**
    * Skip payment processing and move the order on to shipping (or completed if no shipping required)
    */
    'skipPaymentProcessing': boolean;
    /**
    * True the order in the completed stage
    */
    'storeCompleted': boolean;
    /**
    * Store the order in accounts receivable if the payment declines
    */
    'storeIfPaymentDeclines': boolean;
}

export class CartFinalizeOrderResponse {
    /**
    * Error messages if the order could not be completed
    */
    'errors': Array<string>;
    'nextCart': Cart;
    'order': Order;
    /**
    * Order ID assigned to the order
    */
    'orderId': string;
    /**
    * True if the cart was converted successfully to an order
    */
    'successful': boolean;
}

export class CartGift {
    /**
    * True if this order is a gift
    */
    'gift': boolean;
    'giftCharge': Currency;
    /**
    * Email address of the gift recipient
    */
    'giftEmail': string;
    /**
    * Message to the gift recipient
    */
    'giftMessage': string;
    'giftWrapCost': Currency;
    /**
    * Title of the selected gift wrap
    */
    'giftWrapTitle': string;
}

export class CartGiftCertificate {
    'giftCertificateAmount': Currency;
    /**
    * Gift certificate code
    */
    'giftCertificateCode': string;
    'giftCertificateRemainingBalanceAfterOrder': Currency;
}

export class CartItem {
    'arbitraryUnitCost': Currency;
    /**
    * Attributes
    */
    'attributes': Array<CartItemAttribute>;
    /**
    * Auto order schedule the customer selected
    */
    'autoOrderSchedule': string;
    /**
    * URL to the default multimedia image
    */
    'defaultImageUrl': string;
    /**
    * URL to the default multimedia thumbnail
    */
    'defaultThumbnailUrl': string;
    /**
    * Description of the item
    */
    'description': string;
    'discount': Currency;
    /**
    * Extended description of the item
    */
    'extendedDescription': string;
    /**
    * Item ID
    */
    'itemId': string;
    /**
    * Item object identifier
    */
    'itemOid': number;
    /**
    * True if this item is a kit
    */
    'kit': boolean;
    /**
    * Options associated with the kit components
    */
    'kitComponentOptions': Array<CartKitComponentOption>;
    'manufacturerSuggestedRetailPrice': Currency;
    /**
    * Maximum quantity the customer can purchase
    */
    'maximumQuantity': number;
    /**
    * Minimum quantity the customer can purchase
    */
    'minimumQuantity': number;
    /**
    * Multimedia
    */
    'multimedia': Array<CartItemMultimedia>;
    /**
    * Options
    */
    'options': Array<CartItemOption>;
    'phsyical': CartItemPhysical;
    /**
    * Position of the item in the cart
    */
    'position': number;
    /**
    * True if this item is on pre-order
    */
    'preorder': boolean;
    /**
    * quantity
    */
    'quantity': number;
    /**
    * Customer selectable auto order schedules
    */
    'schedules': Array<string>;
    'totalCost': Currency;
    'totalCostWithDiscount': Currency;
    'unitCost': Currency;
    'unitCostWithDiscount': Currency;
    /**
    * True if this item was added to the cart as part of an upsell
    */
    'upsell': boolean;
    /**
    * Variations
    */
    'variations': Array<CartItemVariationSelection>;
    /**
    * URL to view the product on the site
    */
    'viewUrl': string;
}

export class CartItemAttribute {
    /**
    * Name of the attribute
    */
    'name': string;
    /**
    * Type of attribute
    */
    'type': string;
    /**
    * Value of the attribute
    */
    'value': string;
}

export class CartItemMultimedia {
    /**
    * Code assigned to the multimedia
    */
    'code': string;
    /**
    * Description
    */
    'description': string;
    /**
    * True if the image should be excluded from galleries
    */
    'excludeFromGallery': boolean;
    /**
    * Image height
    */
    'imageHeight': number;
    /**
    * Image width
    */
    'imageWidth': number;
    /**
    * True if the multimedia is the default for this type
    */
    'isDefault': boolean;
    /**
    * Thumbnails of the images
    */
    'thumbnails': Array<CartItemMultimediaThumbnail>;
    /**
    * Type of multimedia
    */
    'type': CartItemMultimedia.TypeEnum;
    /**
    * URL to view multimedia at
    */
    'url': string;
}

export namespace CartItemMultimedia {
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}
export class CartItemMultimediaThumbnail {
    /**
    * Height in pixels
    */
    'height': number;
    /**
    * True if thumbnail is a PNG, otherwise its a JPEG
    */
    'png': boolean;
    /**
    * True if the thumbnail is square
    */
    'square': boolean;
    /**
    * URL for the thumbnail
    */
    'url': string;
    /**
    * Width in pixels
    */
    'width': number;
}

export class CartItemOption {
    'costIfSpecified': Currency;
    'costPerLetter': Currency;
    'costPerLine': Currency;
    /**
    * True if the default answer is ignored
    */
    'ignoreIfDefault': boolean;
    /**
    * Display label for the option
    */
    'label': string;
    /**
    * Name of the option
    */
    'name': string;
    /**
    * Charge the fee a single time instead of multiplying by the quantity
    */
    'oneTimeFee': boolean;
    /**
    * Unique identifier for the option
    */
    'optionOid': number;
    /**
    * True if the customer is required to select a value
    */
    'required': boolean;
    /**
    * The value of the option specified by the customer
    */
    'selectedValue': string;
    /**
    * Type of option
    */
    'type': CartItemOption.TypeEnum;
    /**
    * Values that the customer can select from for radio or select type options
    */
    'values': Array<CartItemOptionValue>;
}

export namespace CartItemOption {
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}
export class CartItemOptionValue {
    'additionalCost': Currency;
    'additionalWeight': Weight;
    /**
    * True if this is the default value
    */
    'defaultValue': boolean;
    /**
    * Display order of the option value
    */
    'displayOrder': number;
    /**
    * Value of the option the customer can select
    */
    'value': string;
}

export class CartItemPhysical {
    'height': Distance;
    'length': Distance;
    'weight': Weight;
    'width': Distance;
}

export class CartItemVariationSelection {
    /**
    * Variation name
    */
    'variationName': string;
    /**
    * Variation value
    */
    'variationValue': string;
}

export class CartKitComponentOption {
    'costIfSpecified': Currency;
    'costPerLetter': Currency;
    'costPerLine': Currency;
    /**
    * True if the default answer is ignored
    */
    'ignoreIfDefault': boolean;
    /**
    * Kit component item id
    */
    'itemId': string;
    /**
    * Unique identifier for the kit component item
    */
    'itemOid': number;
    /**
    * Display label for the option
    */
    'label': string;
    /**
    * Name of the option
    */
    'name': string;
    /**
    * Charge the fee a single time instead of multiplying by the quantity
    */
    'oneTimeFee': boolean;
    /**
    * Unique identifier for the option
    */
    'optionOid': number;
    /**
    * True if the customer is required to select a value
    */
    'required': boolean;
    /**
    * The value of the option specified by the customer
    */
    'selectedValue': string;
    /**
    * Type of option
    */
    'type': CartKitComponentOption.TypeEnum;
    /**
    * Values that the customer can select from for radio or select type options
    */
    'values': Array<CartItemOptionValue>;
}

export namespace CartKitComponentOption {
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}
export class CartMarketing {
    /**
    * The advertising source the customer indicated
    */
    'advertisingSource': string;
    /**
    * True if the customer agrees to receiving marketing emails
    */
    'mailingListOptIn': boolean;
}

export class CartPayment {
    'amazon': CartPaymentAmazon;
    'check': CartPaymentCheck;
    'creditCard': CartPaymentCreditCard;
    /**
    * Payment method
    */
    'paymentMethod': string;
    'purchaseOrder': CartPaymentPurchaseOrder;
    /**
    * Rotating transaction gateway code
    */
    'rtgCode': string;
}

export class CartPaymentAmazon {
    /**
    * Amazon order reference id
    */
    'amazonOrderReferenceId': string;
}

export class CartPaymentCheck {
    /**
    * Check number they are paying with
    */
    'checkNumber': number;
}

export class CartPaymentCreditCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (four digit year)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked to the last 4)
    */
    'cardNumber': string;
    /**
    * Hosted field token for the card number
    */
    'cardNumberToken': string;
    /**
    * Card type
    */
    'cardType': string;
    /**
    * Card verification number (masked)
    */
    'cardVerificationNumber': string;
    /**
    * Hosted field token for the card verification number
    */
    'cardVerificationNumberToken': string;
    /**
    * ID of the stored credit card to use
    */
    'customerProfileCreditCardId': number;
    /**
    * True if the customer wants to store the card on their profile for future re-use
    */
    'storeCreditCard': boolean;
}

export class CartPaymentPurchaseOrder {
    /**
    * Purchase order number
    */
    'purchaseOrderNumber': string;
}

export class CartProfileLoginRequest {
    'cart': Cart;
    /**
    * Password for the profile
    */
    'password': string;
}

export class CartProfileLoginResponse {
    'cart': Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors': Array<string>;
}

export class CartProfileRegisterRequest {
    'cart': Cart;
    /**
    * Password for the profile
    */
    'password': string;
}

export class CartProfileRegisterResponse {
    'cart': Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors': Array<string>;
}

export class CartResponse {
    'cart': Cart;
    /**
    * Errors that should be displayed to the customer
    */
    'errors': Array<string>;
}

export class CartSettings {
    'billing': CartSettingsBilling;
    'gift': CartSettingsGift;
    'payment': CartSettingsPayment;
    'shipping': CartSettingsShipping;
    'taxes': CartSettingsTaxes;
    'terms': CartSettingsTerms;
}

export class CartSettingsBilling {
    /**
    * Provinces
    */
    'provinces': Array<CartSettingsProvince>;
}

export class CartSettingsGift {
    /**
    * True if this checkout supports gift giving
    */
    'allowGifts': boolean;
    'giftCharge': Currency;
    /**
    * The gift wraps available for the customer to select from
    */
    'giftWraps': Array<CartSettingsGiftWrap>;
    /**
    * The maximum length of the gift message the giver can enter
    */
    'maxMessageLength': number;
}

export class CartSettingsGiftWrap {
    'cost': Currency;
    /**
    * Title of the gift wrap
    */
    'title': string;
    /**
    * URL for the sample of the gift wrap
    */
    'url': string;
}

export class CartSettingsPayment {
    'amazon': CartSettingsPaymentAmazon;
    'creditCard': CartSettingsPaymentCreditCard;
    /**
    * True if this card requires a payment from the customer
    */
    'needPayment': boolean;
    'paypal': CartSettingsPaymentPayPal;
    /**
    * True if Amazon payments are available on this order
    */
    'supportsAmazon': boolean;
    /**
    * True if check payments are available on this order
    */
    'supportsCheck': boolean;
    /**
    * True if COD payments are available on this order
    */
    'supportsCod': boolean;
    /**
    * True if credit card payments are available on this order
    */
    'supportsCreditCard': boolean;
    /**
    * True if money order payments are available on this order
    */
    'supportsMoneyOrder': boolean;
    /**
    * True if PayPal payments are available on this order
    */
    'supportsPaypal': boolean;
    /**
    * True if purchase order payments are available on this order
    */
    'supportsPurchaseOrder': boolean;
    /**
    * True if quote requests payments are available on this order
    */
    'supportsQuoteRequest': boolean;
    /**
    * True if wire transfer payments are available on this order
    */
    'supportsWireTransfer': boolean;
}

export class CartSettingsPaymentAmazon {
    /**
    * Amazon button URL
    */
    'amazonButtonUrl': string;
    /**
    * Amazon merchant ID
    */
    'amazonMerchantId': string;
    /**
    * Amazon widget URL
    */
    'amazonWidgetUrl': string;
}

export class CartSettingsPaymentCreditCard {
    /**
    * True if the credit card verification number should be collected
    */
    'collectCreditCardVerificationNumber': boolean;
    /**
    * Available credit card types
    */
    'creditCardTypes': Array<string>;
    /**
    * The shoppingCartToken needed for proper initialization of hosted fields collection
    */
    'hostedFieldsShoppingCartToken': string;
}

export class CartSettingsPaymentPayPal {
    /**
    * PayPal button alt text
    */
    'paypalButtonAltText': string;
    /**
    * PayPal button URL
    */
    'paypalButtonUrl': string;
    /**
    * PayPal Credit button URL
    */
    'paypalCreditButtonUrl': string;
    /**
    * PayPal Credit legal image URL
    */
    'paypalCreditLegalImageUrl': string;
    /**
    * PayPal Credit legal URL
    */
    'paypalCreditLegalUrl': string;
}

export class CartSettingsProvince {
    'code': string;
    'province': string;
}

export class CartSettingsShipping {
    'deliverOnDate': CartSettingsShippingCalendar;
    /**
    * Estimates for this cart
    */
    'estimates': Array<CartSettingsShippingEstimate>;
    /**
    * True if this order needs shipping
    */
    'needShipping': boolean;
    /**
    * Provinces
    */
    'provinces': Array<CartSettingsProvince>;
    'shipOnDate': CartSettingsShippingCalendar;
}

export class CartSettingsShippingCalendar {
    /**
    * Specified dates that are blacked out on the calendar
    */
    'blackouts': string;
    /**
    * Days of week that should be enabled on the calendar (0 - Sunday through 6 - Saturday)
    */
    'daysOfWeek': Array<boolean>;
    /**
    * The earliest date that can be selected on the calendar
    */
    'earliest': string;
    /**
    * True if the customer is required to select a date
    */
    'require': boolean;
    /**
    * True if this calendar should be shown to the customer
    */
    'show': boolean;
}

export class CartSettingsShippingEstimate {
    /**
    * True if this method allows the customer to use their own shipper account number
    */
    'allow3rdPartyBilling': boolean;
    /**
    * Comment to display to the customer about this method
    */
    'comment': string;
    'cost': Currency;
    'costBeforeDiscount': Currency;
    /**
    * True if this is the default method
    */
    'defaultMethod': boolean;
    'discount': Currency;
    /**
    * True if this method is discounted because of a coupon
    */
    'discounted': boolean;
    /**
    * The name to display to the customer
    */
    'displayName': string;
    /**
    * Date of the estimated delivery (or range)
    */
    'estimatedDelivery': string;
    /**
    * True if a lift gate option for this method should be offered to the customer
    */
    'liftGateOption': boolean;
    /**
    * Shipping method name
    */
    'name': string;
    'tax': Currency;
    'totalTax': Currency;
}

export class CartSettingsTaxes {
    'counties': Array<string>;
}

export class CartSettingsTerms {
    /**
    * HTML version of the terms
    */
    'html': string;
    /**
    * Text version of the terms.
    */
    'text': string;
}

export class CartShipping {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day time phone
    */
    'dayPhone': string;
    /**
    * Date the customer is requesting delivery on. Typically used for perishable product delivery.
    */
    'deliveryDate': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Lift gate requested (LTL shipping methods only)
    */
    'liftGate': boolean;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
    */
    'shipOnDate': string;
    /**
    * True if the shipping adress is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
    */
    'shipToResidential': boolean;
    /**
    * 3rd party account number to ship against for UPS or FedEx
    */
    'shipping3rdPartyAccountNumber': string;
    /**
    * Shipping method
    */
    'shippingMethod': string;
    /**
    * Special instructions from the customer regarding shipping
    */
    'specialInstructions': string;
    /**
    * State/Region
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
}

export class CartSummary {
    'arbitraryShippingHandlingTotal': Currency;
    'arbitraryTax': Currency;
    'arbitraryTaxRate': Currency;
    'arbitraryTaxableSubtotal': Currency;
    'shippingHandling': Currency;
    'shippingHandlingDiscount': Currency;
    'shippingHandlingWithDiscount': Currency;
    'subtotal': Currency;
    'subtotalDiscount': Currency;
    'subtotalWithDiscount': Currency;
    'surcharge': Currency;
    'tax': Currency;
    'taxableSubtotal': Currency;
    'taxableSubtotalDiscount': Currency;
    'taxableSubtotalWithDiscount': Currency;
    'total': Currency;
}

export class CartTaxes {
    /**
    * Tax county if the state requires it.
    */
    'county': string;
    /**
    * True if tax exempt
    */
    'exempt': boolean;
    /**
    * Tax rate
    */
    'rate': number;
}

export class CartUpsellAfter {
    /**
    * The date/time after which the cart will finalize into an order.
    */
    'finalizeAfterDts': string;
    /**
    * The amount of inactivity in minutes after which the cart should be finalized into an order.  This will calculate the finalize_after_dts field.
    */
    'finalizeAfterMinutes': number;
    /**
    * Upsell path code
    */
    'upsellPathCode': string;
}

export class CartValidationRequest {
    'cart': Cart;
    /**
    * Checks to perform
    */
    'checks': Array<string>;
}

export class CartValidationResponse {
    'cart': Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors': Array<string>;
}

export class ChargebackDispute {
    /**
    * Account number
    */
    'accountNumber': string;
    /**
    * Adjustment request text
    */
    'adjustmentRequestText': string;
    /**
    * Amount
    */
    'amount': number;
    /**
    * Auth code
    */
    'authCode': string;
    /**
    * Case number
    */
    'caseNumber': string;
    /**
    * Chargeback Dispute Oid
    */
    'chargebackDisputeOid': number;
    /**
    * Chargeback dts
    */
    'chargebackDts': string;
    /**
    * Currency
    */
    'currency': string;
    /**
    * Customer care notes
    */
    'customerCareNotes': string;
    /**
    * Encryption key
    */
    'encryptionKey': string;
    /**
    * Expiration Dts
    */
    'expirationDts': string;
    /**
    * Fax failure reason
    */
    'faxFailureReason': string;
    /**
    * Fax number
    */
    'faxNumber': string;
    /**
    * Fax transaction id
    */
    'faxTransactionId': number;
    /**
    * icsid
    */
    'icsid': string;
    /**
    * Merchant account profile oid
    */
    'merchantAccountProfileOid': number;
    'order': Order;
    /**
    * Order Id
    */
    'orderId': string;
    /**
    * Partial card number
    */
    'partialCardNumber': string;
    /**
    * PDF file oid
    */
    'pdfFileOid': string;
    /**
    * Reason code
    */
    'reasonCode': string;
    /**
    * Status
    */
    'status': string;
    /**
    * Website URL
    */
    'websiteUrl': string;
}

export class ChargebackDisputeResponse {
    'chargeback': ChargebackDispute;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class ChargebackDisputesResponse {
    'chargebacks': Array<ChargebackDispute>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class CheckoutHandoffRequest {
    'cart': Cart;
    /**
    * If any error happen during the processing on the UltraCart side, the browser will be redirected to your error_return_url with the error passed in this parameter name.
    */
    'errorParameterName': string;
    /**
    * The URL to return the browser to if there are processing errors on the UltraCart side.
    */
    'errorReturnUrl': string;
    /**
    * The type of handoff operation to perform
    */
    'operation': CheckoutHandoffRequest.OperationEnum;
    /**
    * The maximum amount of revenue that you think the customer could add during a custom upsell after sequence on your checkout.
    */
    'paypalMaximumUpsellRevenue': number;
    /**
    * The URl to return the customers browser to after they have completed the PayPal process.
    */
    'paypalReturnUrl': string;
    /**
    * The desired secure host name to perform the handoff on.  This should match the desired StoreFront.
    */
    'secureHostName': string;
}

export namespace CheckoutHandoffRequest {
    export enum OperationEnum {
        Checkout = <any> 'checkout',
        PayPal = <any> 'payPal',
        PayPalCredit = <any> 'payPalCredit',
        View = <any> 'view'
    }
}
export class CheckoutHandoffResponse {
    'cart': Cart;
    /**
    * Errors that occurred which are preventing the handoff operation.  Display these to the customer.
    */
    'errors': Array<string>;
    /**
    * The URL that you should redirect the customers browser to
    */
    'redirectToUrl': string;
}

export class CheckoutSetupBrowserKeyRequest {
    /**
    * Allowed referrers.  If URLs are specified, automatic translation will convert them to proper allowed referrer maskes.
    */
    'allowedReferrers': Array<string>;
}

export class CheckoutSetupBrowserKeyResponse {
    /**
    * Browser key that is used to authenticate against the new linked application.
    */
    'browserKey': string;
}

export class CityStateZip {
    'city': string;
    'error': string;
    'state': string;
    'validZip': boolean;
    'zip': string;
}

export class Currency {
    /**
    * Value localized to the customer
    */
    'localized': number;
    /**
    * Value localized and formatted for the customer
    */
    'localizedFormatted': string;
    /**
    * Value in base currency
    */
    'value': number;
}

export class Customer {
    /**
    * Affiliate oid
    */
    'affiliateOid': number;
    /**
    * Allow 3rd party billing
    */
    'allow3rdPartyBilling': boolean;
    /**
    * Allow COD
    */
    'allowCod': boolean;
    /**
    * Allow purchase orders by this customer
    */
    'allowPurchaseOrder': boolean;
    /**
    * Allow quote request
    */
    'allowQuoteRequest': boolean;
    /**
    * Allow selection of residential or business address type
    */
    'allowSelectionOfAddressType': boolean;
    /**
    * Auto approve COD
    */
    'autoApproveCod': boolean;
    /**
    * Auto approve purchase orders by this customer
    */
    'autoApprovePurchaseOrder': boolean;
    /**
    * Automatic merchant notes are added to every order placed
    */
    'automaticMerchantNotes': string;
    /**
    * Billing addresses for this customer
    */
    'billing': Array<CustomerBilling>;
    /**
    * Business notes (internally visible only)
    */
    'businessNotes': string;
    /**
    * Credit Cards for this customer
    */
    'cards': Array<CustomerCard>;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * DHL account number
    */
    'dhlAccountNumber': string;
    /**
    * Email address of this customer profile
    */
    'email': string;
    /**
    * Exempt shipping handling charge
    */
    'exemptShippingHandlingCharge': boolean;
    /**
    * FedEx account number
    */
    'fedexAccountNumber': string;
    /**
    * This customer always receives free shipping
    */
    'freeShipping': boolean;
    /**
    * If free_shipping is true, this is the minimum subtotal required for free shipping
    */
    'freeShippingMinimum': number;
    /**
    * Last modified by
    */
    'lastModifiedBy': string;
    /**
    * Last modified date
    */
    'lastModifiedDts': string;
    /**
    * Maximum item count
    */
    'maximumItemCount': number;
    /**
    * Minimum item count
    */
    'minimumItemCount': number;
    /**
    * Minimum subtotal
    */
    'minimumSubtotal': number;
    /**
    * No coupons
    */
    'noCoupons': boolean;
    /**
    * No free shipping regardless of coupons or item level settings
    */
    'noFreeShipping': boolean;
    /**
    * No realtime charge
    */
    'noRealtimeCharge': boolean;
    /**
    * Password (may only be set, never read)
    */
    'password': string;
    /**
    * Pricing tiers for this customer
    */
    'pricingTiers': Array<CustomerPricingTier>;
    /**
    * QuickBooks class to import this customer as
    */
    'qbClass': string;
    /**
    * QuickBooks name to import this customer as
    */
    'qbCode': string;
    /**
    * Referral Source
    */
    'referralSource': string;
    /**
    * Sales rep code
    */
    'salesRepCode': string;
    /**
    * Send signup notification, if true during customer creation, will send a notification.
    */
    'sendSignupNotification': boolean;
    /**
    * Shipping addresses for this customer
    */
    'shipping': Array<CustomerShipping>;
    /**
    * Signup date
    */
    'signupDts': string;
    /**
    * Suppress buySAFE
    */
    'suppressBuysafe': boolean;
    /**
    * True if the customer is tax exempt
    */
    'taxExempt': boolean;
    /**
    * Tax ID
    */
    'taxId': string;
    /**
    * Terms for this customer
    */
    'terms': string;
    /**
    * True if the customer should be tracked separately in QuickBooks
    */
    'trackSeparately': boolean;
    /**
    * Unapproved
    */
    'unapproved': boolean;
    /**
    * UPS account number
    */
    'upsAccountNumber': string;
    /**
    * Website url
    */
    'websiteUrl': string;
}

export class CustomerBilling {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Customer profile billing object identifier
    */
    'customerBillingOid': number;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Default billing
    */
    'defaultBilling': boolean;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Last used date
    */
    'lastUsedDts': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Tax County
    */
    'taxCounty': string;
    /**
    * Title
    */
    'title': string;
}

export class CustomerCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (four digit year)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked to the last 4)
    */
    'cardNumber': string;
    /**
    * Hosted field token for the card number
    */
    'cardNumberToken': string;
    /**
    * Card type
    */
    'cardType': string;
    /**
    * ID of the stored credit card to use
    */
    'customerProfileCreditCardId': number;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * Last used date
    */
    'lastUsedDts': string;
}

export class CustomerPricingTier {
    /**
    * Name
    */
    'name': string;
    /**
    * Pricing Tier Oid
    */
    'pricingTierOid': number;
}

export class CustomerResponse {
    'customer': Customer;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class CustomerShipping {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * Customer profile shipping object identifier
    */
    'customerShippingOid': number;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Default shipping
    */
    'defaultShipping': boolean;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Last used date
    */
    'lastUsedDts': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Tax County
    */
    'taxCounty': string;
    /**
    * Title
    */
    'title': string;
}

export class CustomersResponse {
    'customers': Array<Customer>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Distance {
    /**
    * Unit of measure
    */
    'uom': Distance.UomEnum;
    /**
    * The distance measured in UOM
    */
    'value': number;
}

export namespace Distance {
    export enum UomEnum {
        IN = <any> 'IN',
        CM = <any> 'CM'
    }
}
export class DistributionCenter {
    /**
    * Address line 1 of the distribution center
    */
    'address1': string;
    /**
    * Address line 2 of the distribution center
    */
    'address2': string;
    /**
    * City of the distribution center
    */
    'city': string;
    /**
    * Unique code for this distribution center
    */
    'code': string;
    /**
    * Country code of the distribution center
    */
    'countryCode': string;
    /**
    * True if this is the default distribution center on the account
    */
    'defaultCenter': boolean;
    /**
    * True if this distribution center handles all new items by default
    */
    'defaultHandlesAllItems': boolean;
    /**
    * Distribution center object identifier
    */
    'distributionCenterOid': number;
    /**
    * DUNS number assigned to this distribution center (EDI)
    */
    'duns': string;
    /**
    * Estimate shipments for this distribution center as if they came from the other distribution center
    */
    'estimateFromDistributionCenterOid': number;
    /**
    * Password associated with the virtual FTP
    */
    'ftpPassword': string;
    /**
    * The number of minutes to hold a shipment
    */
    'holdBeforeShipmentMinutes': number;
    /**
    * True if the shipment should be held before transmission and require a manual release
    */
    'holdBeforeTransmission': boolean;
    /**
    * Latitude where the distribution center is located
    */
    'latitude': number;
    /**
    * Longitude where the distribution center is located
    */
    'longitude': number;
    /**
    * Name of this distribution center
    */
    'name': string;
    /**
    * True if this distribution center does not handle customer direct shipments
    */
    'noCustomerDirectShipments': boolean;
    /**
    * True if this distribution center is not allowed to participate in a split shipment.
    */
    'noSplitShipment': boolean;
    /**
    * Postal code of the distribution center
    */
    'postalCode': string;
    /**
    * The number of processing days required before an order ships
    */
    'processDays': number;
    /**
    * The time (EST) after which inventory updates will be processed
    */
    'processInventoryStartTime': string;
    /**
    * The time (EST) before which inventory updates will be processed
    */
    'processInventoryStopTime': string;
    /**
    * True if ASNs are required for this distribution center (EDI)
    */
    'requireAsn': boolean;
    /**
    * True if we should send the kit instead of the components
    */
    'sendKitInsteadOfComponents': boolean;
    /**
    * The time (EST) after which shipments will not be processed on Friday
    */
    'shipmentCutoffTimeFriday': string;
    /**
    * The time (EST) after which shipments will not be processed on Monday
    */
    'shipmentCutoffTimeMonday': string;
    /**
    * The time (EST) after which shipments will not be processed on Saturday
    */
    'shipmentCutoffTimeSaturday': string;
    /**
    * The time (EST) after which shipments will not be processed on Sunday
    */
    'shipmentCutoffTimeSunday': string;
    /**
    * The time (EST) after which shipments will not be processed on Thursday
    */
    'shipmentCutoffTimeThursday': string;
    /**
    * The time (EST) after which shipments will not be processed on Tuesday
    */
    'shipmentCutoffTimeTuesday': string;
    /**
    * The time (EST) after which shipments will not be processed on Wednesday
    */
    'shipmentCutoffTimeWednesday': string;
    /**
    * State of the distribution center
    */
    'state': string;
    /**
    * Transport mechanism for this distribution center
    */
    'transport': string;
}

export class DistributionCentersResponse {
    'distributionCenters': Array<DistributionCenter>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Error {
    /**
    * A technical message meant to be read by a developer
    */
    'developerMessage': string;
    /**
    * HTTP status code
    */
    'errorCode': string;
    /**
    * Additional information often a link to additional documentation
    */
    'moreInfo': string;
    /**
    * An end-user friendly message suitable for display to the customer
    */
    'userMessage': string;
}

export class ErrorResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class FulfillmentInventory {
    'itemId': string;
    'quantity': number;
}

export class FulfillmentShipment {
    /**
    * Order ID that was shipped
    */
    'orderId': string;
    /**
    * Tracking numbers associated with the shipment
    */
    'trackingNumbers': Array<string>;
}

export class HTTPHeader {
    /**
    * Name of the HTTP header
    */
    'name': string;
    /**
    * Value of the HTTP header
    */
    'value': string;
}

export class Item {
    'accounting': ItemAccounting;
    'amember': ItemAmember;
    'autoOrder': ItemAutoOrder;
    'ccbill': ItemCCBill;
    /**
    * Channel Partner Item Mapping
    */
    'channelPartnerMappings': Array<ItemChannelPartnerMapping>;
    'chargeback': ItemChargeback;
    'checkout': ItemCheckout;
    'content': ItemContent;
    /**
    * Date/time of creation
    */
    'creationDts': string;
    /**
    * Description of the item up to 500 characters.
    */
    'description': string;
    /**
    * Description translated text instance id
    */
    'descriptionTranslatedTextInstanceOid': number;
    'digitalDelivery': ItemDigitalDelivery;
    'ebay': ItemEbay;
    'emailNotifications': ItemEmailNotifications;
    'enrollment123': ItemEnrollment123;
    'giftCertificate': ItemGiftCertificate;
    'googleProductSearch': ItemGoogleProductSearch;
    'identifiers': ItemIdentifiers;
    /**
    * True if this item is inactive and can not be purchased
    */
    'inactive': boolean;
    'instantPaymentNotifications': ItemInstantPaymentNotifications;
    'internal': ItemInternal;
    /**
    * True if this item is a kit
    */
    'kit': boolean;
    'kitDefinition': ItemKitDefinition;
    /**
    * Date/time of last modification
    */
    'lastModifiedDts': string;
    /**
    * UltraCart merchant ID owning item
    */
    'merchantId': string;
    /**
    * Unique item id assigned to this item
    */
    'merchantItemId': string;
    /**
    * Unique object identifier for this item
    */
    'merchantItemOid': number;
    /**
    * Options
    */
    'options': Array<ItemOption>;
    /**
    * Parent category of the item.  Zero indicates the root folder.
    */
    'parentCategoryId': number;
    'paymentProcessing': ItemPaymentProcessing;
    'physical': ItemPhysical;
    'pricing': ItemPricing;
    'realtimePricing': ItemRealtimePricing;
    'related': ItemRelated;
    'reporting': ItemReporting;
    'restriction': ItemRestriction;
    'revguard': ItemRevguard;
    'reviews': ItemReviews;
    'salesforce': ItemSalesforce;
    'shipping': ItemShipping;
    'tax': ItemTax;
    /**
    * 3rd Party Email Marketing
    */
    'thirdPartyEmailMarketing': Array<ItemThirdPartyEmailMarketing>;
    /**
    * Variant Items
    */
    'variantItems': Array<ItemVariantItem>;
    /**
    * Variations
    */
    'variations': Array<ItemVariation>;
    'wishlistMember': ItemWishlistMember;
}

export class ItemAccounting {
    /**
    * QuickBooks item name if different than the item id
    */
    'accountingCode': string;
    /**
    * QuickBooks class if you are classifying items on your invoices/receipts
    */
    'qbClass': string;
}

export class ItemAmember {
    /**
    * The number of days that the customer should be given access to the item
    */
    'amemberPaymentDurationDays': number;
    /**
    * A-member product id give customer access to when they purchase this item
    */
    'amemberProductId': string;
}

export class ItemAutoOrder {
    /**
    * Amount to try and authorize for the future rebill
    */
    'authFutureAmount': number;
    /**
    * Amount to try and test authorize
    */
    'authTestAmount': number;
    /**
    * Item id to attempt charging the customer for if they cancel
    */
    'autoOrderCancelItemId': string;
    /**
    * Item object identifier to attempt charging the customer for if they cancel
    */
    'autoOrderCancelItemOid': number;
    /**
    * List of downgrade items presented to customer service representatives
    */
    'autoOrderDowngradeItems': Array<string>;
    /**
    * True if the rebill processing of this item is paused
    */
    'autoOrderPaused': boolean;
    /**
    * The user selectable schedules that are available
    */
    'autoOrderSchedules': Array<string>;
    /**
    * List of upgrade items presented to customer service representatives
    */
    'autoOrderUpgradeItems': Array<string>;
    /**
    * True if this item uses a fixed upsell step schedule
    */
    'autoOrderUpsell': boolean;
    /**
    * Do not send the easy cancel email to the customer
    */
    'autoOrderUpsellNoEasyCancel': boolean;
    /**
    * Limit the purchase of this item to one per customer
    */
    'autoOrderUpsellOnePerCustomer': boolean;
    /**
    * True if this item can be automatically ordered by the customer
    */
    'autoOrderable': boolean;
    /**
    * True if other auto orders for this customer should be canceled when this item is ordered
    */
    'cancelOtherAutoOrders': boolean;
    /**
    * True if the customer should be given free shipping
    */
    'freeShippingAutoOrder': boolean;
    /**
    * The rebill steps if this auto order is an upsell
    */
    'steps': Array<ItemAutoOrderStep>;
}

export class ItemAutoOrderStep {
    /**
    * If the schedule is arbitrary, then this is the number of days
    */
    'arbitraryScheduleDays': number;
    /**
    * Arbitrary unit cost used to override the regular item cost
    */
    'arbitraryUnitCost': number;
    /**
    * Arbitrary unit costs schedules for more advanced discounting by rebill attempt
    */
    'arbitraryUnitCostSchedules': Array<ItemAutoOrderStepArbitraryUnitCostSchedule>;
    /**
    * Grand-father pricing configuration if the rebill schedule has changed over time
    */
    'grandfatherPricing': Array<ItemAutoOrderStepGrandfatherPricing>;
    /**
    * Managed by (defaults to UltraCart)
    */
    'managedBy': string;
    /**
    * Number of days to pause
    */
    'pauseDays': number;
    /**
    * Wait for this step to happen until the specified date
    */
    'pauseUntilDate': string;
    /**
    * If set, a pre-shipment notice is sent to the customer this many days in advance
    */
    'preshipmentNoticeDays': number;
    /**
    * Item id to rebill
    */
    'recurringMerchantItemId': string;
    /**
    * Item object identifier to rebill
    */
    'recurringMerchantItemOid': number;
    /**
    * Number of times to rebill.  Last step can be null for infinite
    */
    'repeatCount': number;
    /**
    * Frequency of the rebill
    */
    'schedule': string;
    /**
    * Email list name to subscribe the customer to when the rebill occurs
    */
    'subscribeEmailListName': string;
    /**
    * Email list identifier to subscribe the customer to when this rebill occurs
    */
    'subscribeEmailListOid': number;
    /**
    * Type of step (item or pause)
    */
    'type': ItemAutoOrderStep.TypeEnum;
}

export namespace ItemAutoOrderStep {
    export enum TypeEnum {
        Item = <any> 'item',
        Pause = <any> 'pause'
    }
}
export class ItemAutoOrderStepArbitraryUnitCostSchedule {
    /**
    * Arbitrary unit cost
    */
    'arbitraryUnitCost': number;
    /**
    * Retry days
    */
    'retryDays': number;
}

export class ItemAutoOrderStepGrandfatherPricing {
    /**
    * On or before date
    */
    'onOrBeforeDate': string;
    /**
    * Unit cost
    */
    'unitCost': number;
}

export class ItemCCBill {
    /**
    * Allowed currencies
    */
    'ccbillAllowedCurrencies': string;
    /**
    * Allowed types
    */
    'ccbillAllowedTypes': string;
    /**
    * Currency code
    */
    'ccbillCurrencyCode': string;
    /**
    * Form name
    */
    'ccbillFormName': string;
    /**
    * Sub-account id
    */
    'ccbillSubaccountId': string;
    /**
    * Subscription type id
    */
    'ccbillSubscriptionTypeId': string;
}

export class ItemChannelPartnerMapping {
    /**
    * Barcode UA (EDI only)
    */
    'barcodeUa': string;
    /**
    * Barcode UC (EDI only)
    */
    'barcodeUc': string;
    /**
    * Barcode UI (EDI only)
    */
    'barcodeUi': string;
    /**
    * Barcode UK (EDI only)
    */
    'barcodeUk': string;
    /**
    * Buyer DPCI (EDI only)
    */
    'buyerDpci': string;
    /**
    * Buyer item number (EDI only)
    */
    'buyerItemNumber': string;
    /**
    * Channel partner code
    */
    'channelPartnerCode': string;
    /**
    * Channel partner object identifier
    */
    'channelPartnerOid': number;
    /**
    * From Item ID
    */
    'fromItemId': string;
    /**
    * From SKU
    */
    'fromSku': string;
    /**
    * Mutually defined number (EDI only)
    */
    'mutuallyDefinedNumber': string;
    /**
    * Ratio (Channel Partner)
    */
    'quantityRatioCp': number;
    /**
    * Ratio (UltraCart)
    */
    'quantityRatioUc': number;
    /**
    * SKU
    */
    'sku': string;
    /**
    * Unit of measure
    */
    'unitOfMeasure': string;
    /**
    * Vendor number (EDI only)
    */
    'vendorNumber': string;
    /**
    * Vendor style number (EDI only)
    */
    'vendorStyleNumber': string;
}

export class ItemChargeback {
    /**
    * Addendums
    */
    'addendums': Array<ItemChargebackAddendum>;
    /**
    * Adjustment requests
    */
    'adjustmentRequests': Array<ItemChargebackAdjustmentRequest>;
}

export class ItemChargebackAddendum {
    /**
    * Chargeback addendum object identifier
    */
    'chargebackAddendumOid': number;
    /**
    * Description
    */
    'description': string;
    /**
    * Size of the file
    */
    'fileSize': number;
    /**
    * Number of pages
    */
    'pages': number;
}

export class ItemChargebackAdjustmentRequest {
    /**
    * Chargeback adjustment request object identifier
    */
    'chargebackAdjustmentRequestOid': number;
    /**
    * Description
    */
    'description': string;
    /**
    * Reason code
    */
    'reasonCode': string;
}

export class ItemCheckout {
    /**
    * True to suppress buySAFE
    */
    'suppressBuysafe': boolean;
    /**
    * Terms for purchasing this item
    */
    'terms': string;
    /**
    * Terms translated text instance identifier
    */
    'termsTranslatedTextInstanceOid': number;
}

export class ItemContent {
    /**
    * StoreFront assignments
    */
    'assignments': Array<ItemContentAssignment>;
    /**
    * StoreFront attributes
    */
    'attributes': Array<ItemContentAttribute>;
    /**
    * Exclude from search
    */
    'excludeFromSearch': boolean;
    /**
    * Exclude from the top sellers list in the StoreFront
    */
    'excludeFromTopSellers': boolean;
    /**
    * Extended description (max 2000 characters)
    */
    'extendedDescription': string;
    /**
    * Extneded description text translation instance identifier
    */
    'extendedDescriptionTranslatedTextInstanceOid': number;
    /**
    * Multimedia
    */
    'multimedia': Array<ItemContentMultimedia>;
    /**
    * True if the item is new
    */
    'newItem': boolean;
    /**
    * The date the item should no longer be considered new
    */
    'newItemEnd': string;
    /**
    * The date the item should start being considered new
    */
    'newItemStart': string;
    /**
    * Legacy view URL (not used by StoreFronts)
    */
    'viewUrl': string;
}

export class ItemContentAssignment {
    /**
    * Page (group) object identifier
    */
    'groupOid': number;
    /**
    * Page (group) path
    */
    'groupPath': string;
    /**
    * StoreFront host name
    */
    'host': string;
    /**
    * Sort order (optional)
    */
    'sortOrder': number;
    /**
    * URL part if the item id is not used
    */
    'urlPart': string;
}

export class ItemContentAttribute {
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Attribute translated text instance identifier
    */
    'translatedTextInstanceOid': number;
    /**
    * Attribute type
    */
    'type': string;
    /**
    * Attribute value
    */
    'value': string;
}

export class ItemContentMultimedia {
    /**
    * URL where the image can be downloaded from the cloud
    */
    'cloudUrl': string;
    /**
    * Expiration date of the cloud URL
    */
    'cloudUrlExpiration': string;
    /**
    * Code assigned to the file
    */
    'code': string;
    /**
    * Description
    */
    'description': string;
    /**
    * True to exclude from multimedia gallery
    */
    'excludeFromGallery': boolean;
    /**
    * File name
    */
    'fileName': string;
    /**
    * Height of the image
    */
    'height': number;
    /**
    * Item multimedia object identifier
    */
    'merchantItemMultimediaOid': number;
    /**
    * True if the multimedia is an orphan of the active StoreFront themes
    */
    'orphan': boolean;
    /**
    * True if the object is a place holder that can be populated
    */
    'placeholder': boolean;
    /**
    * Temporary multimedia object identifier assigned if uploading new multimedia
    */
    'tempMultimediaOid': number;
    /**
    * Thumbnails of this image
    */
    'thumbnails': Array<ItemContentMultimediaThumbnail>;
    /**
    * Type of file
    */
    'type': ItemContentMultimedia.TypeEnum;
    /**
    * URL to download file
    */
    'url': string;
    /**
    * Width of the image
    */
    'width': number;
}

export namespace ItemContentMultimedia {
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}
export class ItemContentMultimediaThumbnail {
    /**
    * Height of the thumbnail
    */
    'height': number;
    /**
    * HTTP URL to view the thumbnail
    */
    'httpUrl': string;
    /**
    * HTTPS URL to view the thumbnail
    */
    'httpsUrl': string;
    /**
    * True if PNG, false if JPEG
    */
    'pngFormat': boolean;
    /**
    * True if the thumbnail is square
    */
    'square': boolean;
    /**
    * Width of the thumbnail
    */
    'width': number;
}

export class ItemDigitalDelivery {
    /**
    * Description of the activation code
    */
    'activationCodeDescription': string;
    /**
    * The number of activation codes whcih should generate a warning email
    */
    'activationCodeLowWarning': number;
    /**
    * The URL to retrieve activation codes from in real-time
    */
    'activationCodeRealtimeUrl': string;
    /**
    * Shared secret used when communicating with the real-time URL
    */
    'activationCodeSharedSecret': string;
    /**
    * Type of activation code
    */
    'activationCodeType': string;
    /**
    * Digital items that customer can download when this item is purchased
    */
    'digitalItems': Array<ItemDigitalItem>;
}

export class ItemDigitalItem {
    /**
    * File creation date
    */
    'creationDts': string;
    /**
    * Description of the digital item
    */
    'description': string;
    /**
    * File size
    */
    'fileSize': number;
    /**
    * Mime type associated with the file
    */
    'mimeType': string;
    /**
    * Original filename
    */
    'originalFilename': string;
}

export class ItemEbay {
    /**
    * True if the item is active for listing
    */
    'active': boolean;
    /**
    * e-Bay category ID
    */
    'categoryId': number;
    /**
    * Answers to category specific questions
    */
    'categorySpecifics': Array<ItemEbayCategorySpecific>;
    /**
    * Description of the condition (e-Bay constant)
    */
    'conditionDescription': string;
    /**
    * Numerical ID of the condition (e-Bay constant)
    */
    'conditionId': number;
    /**
    * Number of consecutive failures trying to list this item
    */
    'consecutiveFailures': number;
    /**
    * e-Bay Store category 1
    */
    'customCategory1': number;
    /**
    * e-Bay Store category 2
    */
    'customCategory2': number;
    /**
    * Maximum number of days it will take to ship the item
    */
    'dispatchTimeMax': number;
    /**
    * Domestic 1 method additional item cost
    */
    'domestic1AdditionalCost': number;
    /**
    * Domestic 1 method first item cost
    */
    'domestic1FirstCost': number;
    /**
    * Domestic 2 method additional item cost
    */
    'domestic2AdditionalCost': number;
    /**
    * Domestic 2 method first item cost
    */
    'domestic2FirstCost': number;
    /**
    * Domestic 3 method additional item cost
    */
    'domestic3AdditionalCost': number;
    /**
    * Domestic 3 method first item cost
    */
    'domestic3FirstCost': number;
    /**
    * Domestic 4 method additional item cost
    */
    'domestic4AdditionalCost': number;
    /**
    * Domestic 4 method first item cost
    */
    'domestic4FirstCost': number;
    /**
    * If listed, this is the e-Bay auction id
    */
    'ebayAuctionId': string;
    /**
    * e-Bay specific inventory
    */
    'ebaySpecificInventory': number;
    /**
    * The template name to use hwen rendering the e-Bay listing
    */
    'ebayTemplateName': string;
    /**
    * The template object identifier to use when rendering the e-Bay listing
    */
    'ebayTemplateOid': number;
    /**
    * Date/time of the auction end
    */
    'endTime': string;
    /**
    * True if item receives free shipping
    */
    'freeShipping': boolean;
    /**
    * The method that is free for free shipping
    */
    'freeShippingMethod': string;
    /**
    * International 1 method additional item cost
    */
    'international1AdditionalCost': number;
    /**
    * International 1 method first item cost
    */
    'international1FirstCost': number;
    /**
    * International 2 method additional item cost
    */
    'international2AdditionalCost': number;
    /**
    * International 2 method first item cost
    */
    'international2FirstCost': number;
    /**
    * International 3 method additional item cost
    */
    'international3AdditionalCost': number;
    /**
    * International 3 method first item cost
    */
    'international3FirstCost': number;
    /**
    * International 4 method additional item cost
    */
    'international4AdditionalCost': number;
    /**
    * International 4 method first item cost
    */
    'international4FirstCost': number;
    /**
    * Date/time of the last status check
    */
    'lastStatusDts': string;
    /**
    * Current listing dispatch time maximum
    */
    'listedDispatchTimeMax': number;
    /**
    * The template object identifier used for the listing
    */
    'listedEbayTemplateOid': number;
    /**
    * Date/time of the listing
    */
    'listingDts': string;
    /**
    * The duration of the listing
    */
    'listingDuration': string;
    /**
    * Price to list the item at
    */
    'listingPrice': number;
    /**
    * The price to list the item at if different than the regular UltraCart item price
    */
    'listingPriceOverride': number;
    /**
    * The type of e-Bay listing
    */
    'listingType': string;
    'marketplaceAnalysis': ItemEbayMarketPlaceAnalysis;
    /**
    * True if marketplace analysis should be performed
    */
    'marketplaceAnalysisPerform': boolean;
    /**
    * Marketplace FVF percentage
    */
    'marketplaceFinalValueFeePercentage': number;
    /**
    * Date/time of the marketplace analysis last check
    */
    'marketplaceLastCheckDts': string;
    /**
    * True if we are the lowest offer in the marketplace
    */
    'marketplaceLowest': boolean;
    /**
    * True if another seller is violating MAP
    */
    'marketplaceMapViolation': boolean;
    /**
    * Marketplace multiplier
    */
    'marketplaceMultiplier': number;
    /**
    * Marketplace other price
    */
    'marketplaceOtherPrice': number;
    /**
    * Marketplace other seller
    */
    'marketplaceOtherSeller': string;
    /**
    * Marketplace other shipping
    */
    'marketplaceOtherShipping': number;
    /**
    * Marketplace other total
    */
    'marketplaceOtherTotal': number;
    /**
    * Marketplace our additional profit potential
    */
    'marketplaceOurAdditionalProfitPotential': number;
    /**
    * Marketplace our price
    */
    'marketplaceOurPrice': number;
    /**
    * Marketplace our profit
    */
    'marketplaceOurProfit': number;
    /**
    * Marketplace our shipping
    */
    'marketplaceOurShipping': number;
    /**
    * Marketplace our total
    */
    'marketplaceOurTotal': number;
    /**
    * Marketplace overhead
    */
    'marketplaceOverhead': number;
    /**
    * True if our listing is profitable to sell
    */
    'marketplaceProfitable': boolean;
    /**
    * Date/time for the next attempt to list
    */
    'nextAttemptDts': string;
    /**
    * The next listing duration to use when the current listing ends.
    */
    'nextListingDuration': string;
    /**
    * True if the item should not qualify for promotional shipping
    */
    'noPromotionalShipping': boolean;
    /**
    * Packaging and handling costs
    */
    'packagingHandlingCosts': number;
    /**
    * Previous e-Bay auction id
    */
    'previousEbayAuctionId': string;
    /**
    * Quantity available of the item
    */
    'quantity': number;
    /**
    * Reserve price
    */
    'reservePrice': number;
    /**
    * How to send the item dimensions and weights to e-Bay
    */
    'sendDimensionsAndWeight': string;
    /**
    * Date/time of the auction start
    */
    'startTime': string;
    /**
    * Status of the item's listing
    */
    'status': string;
    /**
    * Typical number of days it will take to ship the item
    */
    'targetDispatchTimeMax': number;
}

export class ItemEbayCategorySpecific {
    /**
    * Name of the category specification field
    */
    'name': string;
    /**
    * Value
    */
    'value': string;
}

export class ItemEbayMarketListing {
    /**
    * Auction ID
    */
    'auctionId': string;
    /**
    * Price
    */
    'price': number;
    /**
    * Seller
    */
    'seller': string;
    /**
    * Shipping
    */
    'shipping': number;
    /**
    * Total
    */
    'total': number;
}

export class ItemEbayMarketPlaceAnalysis {
    /**
    * Adjusted price
    */
    'adjustedPrice': number;
    /**
    * Adjusted shipping
    */
    'adjustedShipping': number;
    /**
    * Adjusted total
    */
    'adjustedTotal': number;
    /**
    * Cost of goods sold
    */
    'cogs': number;
    /**
    * Final value fee
    */
    'finalValueFee': number;
    /**
    * Minimum advertised price
    */
    'minimumAdvertisedPrice': number;
    /**
    * Other listings
    */
    'otherListings': Array<ItemEbayMarketListing>;
    'ourListing': ItemEbayMarketListing;
    /**
    * Overhead
    */
    'overhead': number;
    /**
    * Profit potential
    */
    'profitPotential': number;
}

export class ItemEmailNotifications {
    /**
    * Skip receipt email to customer
    */
    'skipReceipt': boolean;
    /**
    * Skip shipment notification to customer
    */
    'skipShipmentNotification': boolean;
}

export class ItemEnrollment123 {
    /**
    * Enrolment 123 product code
    */
    'enrollment123ProductCode': string;
}

export class ItemGiftCertificate {
    /**
    * True if the purchase of this item generates a gift certificate
    */
    'giftCertificate': boolean;
    /**
    * The number of days that the gift certificate is good for (optional)
    */
    'giftCertificateExpirationDays': number;
}

export class ItemGoogleProductSearch {
    /**
    * Adwords grouping
    */
    'adwordsGrouping': string;
    /**
    * Adwords label 1
    */
    'adwordsLabel1': string;
    /**
    * Adwords label 2
    */
    'adwordsLabel2': string;
    /**
    * Adwords label 3
    */
    'adwordsLabel3': string;
    /**
    * Adwords label 4
    */
    'adwordsLabel4': string;
    /**
    * Adwords label 5
    */
    'adwordsLabel5': string;
    /**
    * Age group
    */
    'ageGroup': string;
    /**
    * Available at physical store
    */
    'availableAtPhysicalStore': boolean;
    /**
    * Book - author
    */
    'bookAuthor': string;
    /**
    * Book - format
    */
    'bookFormat': string;
    /**
    * Bood - ISBN
    */
    'bookIsbn': string;
    /**
    * Book - publisher
    */
    'bookPublisher': string;
    /**
    * Category description
    */
    'categoryDescription': string;
    /**
    * Color
    */
    'color': string;
    /**
    * Condition
    */
    'condition': string;
    /**
    * Custom label 0
    */
    'customLabel0': string;
    /**
    * Custom label 1
    */
    'customLabel1': string;
    /**
    * Custom label 2
    */
    'customLabel2': string;
    /**
    * Custom label 3
    */
    'customLabel3': string;
    /**
    * Custom label 4
    */
    'customLabel4': string;
    /**
    * Gender
    */
    'gender': string;
    /**
    * Google product category
    */
    'googleProductCategory': string;
    /**
    * Music - artist
    */
    'musicArtist': string;
    /**
    * Music - format
    */
    'musicFormat': string;
    /**
    * Music - release date
    */
    'musicReleaseDate': string;
    /**
    * Omit from feed
    */
    'omitFromFeed': boolean;
    /**
    * Product type
    */
    'productType': string;
    /**
    * Promotion ID 1
    */
    'promotionId1': string;
    /**
    * Promotion ID 10
    */
    'promotionId10': string;
    /**
    * Promotion ID 2
    */
    'promotionId2': string;
    /**
    * Promotion ID 3
    */
    'promotionId3': string;
    /**
    * Promotion ID 4
    */
    'promotionId4': string;
    /**
    * Promotion ID 5
    */
    'promotionId5': string;
    /**
    * Promotion ID 6
    */
    'promotionId6': string;
    /**
    * Promotion ID 7
    */
    'promotionId7': string;
    /**
    * Promotion ID 8
    */
    'promotionId8': string;
    /**
    * Promotion ID 9
    */
    'promotionId9': string;
    /**
    * Search date/time
    */
    'searchDts': string;
    /**
    * Search lowest price
    */
    'searchLowestPrice': number;
    /**
    * Search lowest URL
    */
    'searchLowestUrl': string;
    /**
    * Search position
    */
    'searchPosition': number;
    /**
    * Size
    */
    'size': string;
    /**
    * Video - director
    */
    'videoDirector': string;
    /**
    * Video - format
    */
    'videoFormat': string;
    /**
    * Video - rating
    */
    'videoRating': string;
    /**
    * Video - release date
    */
    'videoReleaseDate': string;
    /**
    * Video - starring
    */
    'videoStarring': string;
}

export class ItemIdentifiers {
    /**
    * Barcode
    */
    'barcode': string;
    /**
    * Manufacturer Name
    */
    'manufacturerName': string;
    /**
    * Manufacturer SKU
    */
    'manufacturerSku': string;
    /**
    * UNSPSC
    */
    'unspsc': string;
}

export class ItemInstantPaymentNotification {
    /**
    * True for HTTP POST instead of GET
    */
    'postOperation': boolean;
    /**
    * Successful response text
    */
    'successfulResponseText': string;
    /**
    * URL
    */
    'url': string;
}

export class ItemInstantPaymentNotifications {
    /**
    * Notifications
    */
    'notifications': Array<ItemInstantPaymentNotification>;
}

export class ItemInternal {
    /**
    * Memo
    */
    'memo': string;
}

export class ItemKitComponent {
    /**
    * Component item cost
    */
    'componentCost': number;
    /**
    * Component item description
    */
    'componentDescription': string;
    /**
    * Component item ID
    */
    'componentMerchantItemId': string;
    /**
    * Component item object identifier
    */
    'componentMerchantItemOid': number;
    /**
    * Quantity
    */
    'quantity': number;
}

export class ItemKitDefinition {
    /**
    * Components
    */
    'components': Array<ItemKitComponent>;
}

export class ItemOption {
    /**
    * Cost if specified
    */
    'costIfSpecified': number;
    /**
    * Cost per letter
    */
    'costPerLetter': number;
    /**
    * Cost per line
    */
    'costPerLine': number;
    /**
    * Ignore this option on the order if the default value is selected
    */
    'ignoreIfDefault': boolean;
    /**
    * Label
    */
    'label': string;
    /**
    * Label translated text instance ID
    */
    'labelTranslatedTextInstanceOid': number;
    /**
    * Name
    */
    'name': string;
    /**
    * Name translated text instance ID
    */
    'nameTranslatedTextInstanceOid': number;
    /**
    * One time fee
    */
    'oneTimeFee': boolean;
    /**
    * Option object identifier
    */
    'optionOid': number;
    /**
    * True if the customer is required to specify an answer
    */
    'required': boolean;
    /**
    * True if this is a system option
    */
    'systemOption': boolean;
    /**
    * Type of option
    */
    'type': ItemOption.TypeEnum;
    /**
    * Values
    */
    'values': Array<ItemOptionValue>;
}

export namespace ItemOption {
    export enum TypeEnum {
        Dropdown = <any> 'dropdown',
        FileAttachment = <any> 'file attachment',
        Fixed = <any> 'fixed',
        Hidden = <any> 'hidden',
        Multiline = <any> 'multiline',
        Radio = <any> 'radio',
        Single = <any> 'single'
    }
}
export class ItemOptionValue {
    /**
    * Additional dimensions application
    */
    'additionalDimensionApplication': ItemOptionValue.AdditionalDimensionApplicationEnum;
    /**
    * Additional items to add to the order if this value is selected
    */
    'additionalItems': Array<ItemOptionValueAdditionalItem>;
    /**
    * Cost change
    */
    'costChange': number;
    /**
    * True if default value
    */
    'defaultValue': boolean;
    /**
    * Digital items to allow the customer to download if this option value is selected
    */
    'digitalItems': Array<ItemOptionValueDigitalItem>;
    'height': Distance;
    'length': Distance;
    /**
    * Multimedia object identifier associated with this option value
    */
    'merchantItemMultimediaOid': number;
    /**
    * Option value object identifier
    */
    'optionValueOid': number;
    /**
    * Percentage cost change
    */
    'percentCostChange': number;
    /**
    * Translated text instance id
    */
    'translatedTextInstanceOid': number;
    /**
    * Value
    */
    'value': string;
    'weightChange': Weight;
    /**
    * Percentage weight change
    */
    'weightChangePercent': number;
    'width': Distance;
}

export namespace ItemOptionValue {
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}
export class ItemOptionValueAdditionalItem {
    /**
    * Additional item id
    */
    'additionalMerchantItemId': string;
    /**
    * Additional item object identifier
    */
    'additionalMerchantItemOid': number;
}

export class ItemOptionValueDigitalItem {
    /**
    * Digital item object identifier
    */
    'digitalItemOid': number;
    /**
    * Original filename
    */
    'originalFilename': string;
}

export class ItemPaymentProcessing {
    /**
    * True if prepaid cards should be blocked from buying this item
    */
    'blockPrepaid': boolean;
    /**
    * Credit card transaction type
    */
    'creditCardTransactionType': string;
    /**
    * True if no real-time charge should be performed on this item.
    */
    'noRealtimeCharge': boolean;
    /**
    * Payment method validity
    */
    'paymentMethodValidity': Array<string>;
    /**
    * Rotating transaction gateway codes
    */
    'rotatingTransactionGatewayCodes': Array<string>;
}

export class ItemPhysical {
    'height': Distance;
    'length': Distance;
    'weight': Weight;
    'width': Distance;
}

export class ItemPricing {
    /**
    * Allow arbitrary cost
    */
    'allowArbitraryCost': boolean;
    /**
    * Arbitrary cost velocity code
    */
    'arbitraryCostVelocityCode': string;
    /**
    * Automatic pricing tier name
    */
    'automaticPricingTierName': string;
    /**
    * Automatic pricing tier object identifier
    */
    'automaticPricingTierOid': number;
    /**
    * Cost of goods sold
    */
    'cogs': number;
    /**
    * Cost
    */
    'cost': number;
    /**
    * Currency code
    */
    'currencyCode': string;
    /**
    * Manufacturer suggested retail price
    */
    'manufacturerSuggestedRetailPrice': number;
    /**
    * Maximum arbitrary cost
    */
    'maximumArbitraryCost': number;
    /**
    * Minimum advertised price
    */
    'minimumAdvertisedPrice': number;
    /**
    * Minimum arbitrary cost
    */
    'minimumArbitraryCost': number;
    /**
    * Mix and match group
    */
    'mixAndMatchGroup': string;
    /**
    * Mix and match group object identifier
    */
    'mixAndMatchGroupOid': number;
    /**
    * Sale cost
    */
    'saleCost': number;
    /**
    * Sale end
    */
    'saleEnd': string;
    /**
    * Sale start
    */
    'saleStart': string;
    /**
    * Tiers
    */
    'tiers': Array<ItemPricingTier>;
}

export class ItemPricingTier {
    /**
    * True if this is the default tier
    */
    'defaultTier': boolean;
    /**
    * Discounts
    */
    'discounts': Array<ItemPricingTierDiscount>;
    'limit': ItemPricingTierLimit;
    /**
    * Pricing tier name
    */
    'name': string;
    /**
    * Pricing tier object identifier
    */
    'pricingTierOid': number;
}

export class ItemPricingTierDiscount {
    /**
    * Cost
    */
    'cost': number;
    /**
    * Quantity
    */
    'quantity': number;
}

export class ItemPricingTierLimit {
    /**
    * Cumulative order limit
    */
    'cumulativeOrderLimit': number;
    /**
    * Individual order limit
    */
    'individualOrderLimit': number;
    /**
    * Multiple quantity
    */
    'multipleQuantity': number;
}

export class ItemRealtimePricing {
    /**
    * Real-time pricing provider parameters
    */
    'realtimePricingParameter': string;
    /**
    * Real-time pricing provider name
    */
    'realtimePricingProvider': string;
    /**
    * Real-time pricing provide object identifier
    */
    'realtimePricingProviderOid': number;
}

export class ItemRelated {
    /**
    * True to suppress system calculated relationships
    */
    'noSystemCalculatedRelatedItems': boolean;
    /**
    * Not relatable
    */
    'notRelatable': boolean;
    /**
    * Related items
    */
    'relatedItems': Array<ItemRelatedItem>;
}

export class ItemRelatedItem {
    /**
    * Related item id
    */
    'relatedMerchantItemId': string;
    /**
    * Related item object identifier
    */
    'relatedMerchantItemOid': number;
    /**
    * Relationship type
    */
    'type': ItemRelatedItem.TypeEnum;
}

export namespace ItemRelatedItem {
    export enum TypeEnum {
        System = <any> 'System',
        UserDefined = <any> 'UserDefined'
    }
}
export class ItemReporting {
    /**
    * Report as an upsell
    */
    'reportAsUpsell': boolean;
    /**
    * Report pickable quantities
    */
    'reportPickableQuantities': Array<number>;
}

export class ItemResponse {
    'error': Error;
    'item': Item;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class ItemRestriction {
    /**
    * Exclude coupons
    */
    'excludeCoupon': boolean;
    /**
    * Exclude from free promotion
    */
    'excludeFromFreePromotion': boolean;
    /**
    * Items
    */
    'items': Array<ItemRestrictionItem>;
    /**
    * Maximum quantity
    */
    'maximumQuantity': number;
    /**
    * Minimum quantity (defaults to 1)
    */
    'minimumQuantity': number;
    /**
    * Multiple of quantity
    */
    'multipleQuantity': number;
    /**
    * One per customer
    */
    'onePerCustomer': boolean;
    /**
    * Purchase separately
    */
    'purchaseSeparately': boolean;
}

export class ItemRestrictionItem {
    /**
    * Restrict item id
    */
    'restrictMerchantItemId': string;
    /**
    * Restrict item object identifier
    */
    'restrictMerchantItemOid': number;
    /**
    * Restriction type
    */
    'type': ItemRestrictionItem.TypeEnum;
}

export namespace ItemRestrictionItem {
    export enum TypeEnum {
        CanNotBePurchasedWith = <any> 'can not be purchased with',
        CanOnlyBePurchasedWith = <any> 'can only be purchased with',
        MustBePurchasedWith = <any> 'must be purchased with'
    }
}
export class ItemRevguard {
    /**
    * Canceled CSR prompt group
    */
    'revguardCanceledCsrPromptGroup': number;
    /**
    * IVR prompt group
    */
    'revguardCanceledIvrPromptGroup': number;
    /**
    * Canceled web prompt group
    */
    'revguardCanceledWebPromptGroup': number;
    /**
    * Client brand
    */
    'revguardClientBrand': number;
    /**
    * CSR prompt group
    */
    'revguardCsrPromptGroup': number;
    /**
    * IVR prompt group
    */
    'revguardIvrPromptGroup': number;
    /**
    * Web prompt group
    */
    'revguardWebPromptGroup': number;
}

export class ItemReviews {
    /**
    * True if the item has an approved review
    */
    'hasApprovedReview': boolean;
    /**
    * True if the item has a review
    */
    'hasReview': boolean;
    /**
    * Number of approved reviews
    */
    'reviewCount': number;
    /**
    * Overall score of reviews
    */
    'reviewOverall': number;
    /**
    * Review template name
    */
    'reviewTemplateName': string;
    /**
    * Review template object identifier
    */
    'reviewTemplateOid': number;
    /**
    * True if the item is reviewable
    */
    'reviewable': boolean;
}

export class ItemSalesforce {
    /**
    * Salesforce.com pricebook id
    */
    'sfdcPricebookId': string;
    /**
    * Salesforce.com product id
    */
    'sfdcProductId': string;
}

export class ItemShipping {
    /**
    * Allow back order
    */
    'allowBackOrder': boolean;
    /**
    * Fulfillment by Amazon.com
    */
    'amazonFba': boolean;
    /**
    * Case inner packs
    */
    'caseInnerPacks': number;
    /**
    * Case units
    */
    'caseUnits': number;
    /**
    * Cases
    */
    'cases': Array<ItemShippingCase>;
    /**
    * Country code of origin for customs forms.  (ISO-3166 two letter code)
    */
    'countryCodeOfOrigin': string;
    /**
    * Customs description
    */
    'customsDescription': string;
    /**
    * Customs value
    */
    'customsValue': number;
    /**
    * Delivery on Friday
    */
    'deliveryOnFriday': boolean;
    /**
    * Delivery on Monday
    */
    'deliveryOnMonday': boolean;
    /**
    * Delivery on Saturday
    */
    'deliveryOnSaturday': boolean;
    /**
    * Delivery on Sunday
    */
    'deliveryOnSunday': boolean;
    /**
    * Delivery on Thursday
    */
    'deliveryOnThursday': boolean;
    /**
    * Delivery on Tuesday
    */
    'deliveryOnTuesday': boolean;
    /**
    * Delivery on Wednesday
    */
    'deliveryOnWednesday': boolean;
    /**
    * Destination markups
    */
    'destinationMarkups': Array<ItemShippingDestinationMarkup>;
    /**
    * Destination restrictions
    */
    'destinationRestrictions': Array<ItemShippingDestinationRestriction>;
    /**
    * Distribution centers
    */
    'distributionCenters': Array<ItemShippingDistributionCenter>;
    /**
    * Estimated time of arrival
    */
    'eta': string;
    /**
    * Qualifies for free shipping
    */
    'freeShipping': boolean;
    /**
    * Freight class
    */
    'freightClass': string;
    /**
    * Hazardous material
    */
    'hazmat': boolean;
    /**
    * True if this item is made to order
    */
    'madeToOrder': boolean;
    /**
    * Number of days lead time it takes to make the item before ite can ship
    */
    'madeToOrderLeadTime': number;
    /**
    * Maximum days allowed in transit
    */
    'maxDaysTimeInTransit': number;
    /**
    * Methods
    */
    'methods': Array<ItemShippingMethod>;
    /**
    * No shipping discounts
    */
    'noShippingDiscount': boolean;
    /**
    * Package requirements
    */
    'packageRequirements': Array<ItemShippingPackageRequirement>;
    /**
    * Perishable class name
    */
    'perishableClassName': string;
    /**
    * Perishable class object identifier
    */
    'perishableClassOid': number;
    /**
    * This item is on pre-order
    */
    'preorder': boolean;
    /**
    * True to require customer to select a delivery date
    */
    'requireDeliveryDate': boolean;
    /**
    * Restrict shipment on Friday
    */
    'restrictShipmentOnFriday': boolean;
    /**
    * Restrict shipment on Monday
    */
    'restrictShipmentOnMonday': boolean;
    /**
    * Restrict shipment on Saturday
    */
    'restrictShipmentOnSaturday': boolean;
    /**
    * Restrict shipment on Sunday
    */
    'restrictShipmentOnSunday': boolean;
    /**
    * Restrict shipment on Thursday
    */
    'restrictShipmentOnThursday': boolean;
    /**
    * Restrict shipment on Tuesday
    */
    'restrictShipmentOnTuesday': boolean;
    /**
    * Restrict shipment on Wednesday
    */
    'restrictShipmentOnWednesday': boolean;
    /**
    * Ship this item in a separate box
    */
    'shipSeparately': boolean;
    'shipSeparatelyAdditionalWeight': Weight;
    'shipSeparatelyHeight': Distance;
    'shipSeparatelyLength': Distance;
    /**
    * Ship separately package special type
    */
    'shipSeparatelyPackageSpecialType': string;
    'shipSeparatelyWidth': Distance;
    /**
    * Special product type (USPS Media Mail)
    */
    'specialProductType': string;
    /**
    * Track inventory
    */
    'trackInventory': boolean;
}

export class ItemShippingCase {
    /**
    * Case label
    */
    'caseLabel': string;
    /**
    * Case item id
    */
    'caseMerchantItemId': string;
    /**
    * Case item object identifier
    */
    'caseMerchantItemOid': number;
    /**
    * Case quantity
    */
    'quantity': number;
}

export class ItemShippingDestinationMarkup {
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode': string;
    /**
    * Flat fee
    */
    'flatFee': number;
    /**
    * Per item
    */
    'perItem': number;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * Shipping method
    */
    'shippingMethod': string;
    /**
    * State
    */
    'state': string;
}

export class ItemShippingDestinationRestriction {
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode': string;
    /**
    * State
    */
    'state': string;
    /**
    * Validity
    */
    'validity': ItemShippingDestinationRestriction.ValidityEnum;
}

export namespace ItemShippingDestinationRestriction {
    export enum ValidityEnum {
        ValidOnlyFor = <any> 'valid only for',
        InvalidFor = <any> 'invalid for'
    }
}
export class ItemShippingDistributionCenter {
    /**
    * Allocated to placed orders
    */
    'allocatedToPlacedOrders': number;
    /**
    * Allocated to shopping carts
    */
    'allocatedToShoppingCarts': number;
    /**
    * Available to allocate
    */
    'availableToAllocate': number;
    /**
    * Desired inventory level
    */
    'desiredInventoryLevel': number;
    /**
    * Distribution center code
    */
    'distributionCenterCode': string;
    /**
    * Distribution center object identifier
    */
    'distributionCenterOid': number;
    /**
    * Estimated time of arrival
    */
    'eta': string;
    /**
    * True if this distribution center handles this item
    */
    'handles': boolean;
    /**
    * Inventory level
    */
    'inventoryLevel': number;
    /**
    * Maximum back-order
    */
    'maximumBackorder': number;
    /**
    * Reorder inventory level (triggers notification)
    */
    'reorderInventoryLevel': number;
    /**
    * SKU
    */
    'sku': string;
    /**
    * Stock picking location
    */
    'stockPickingLocation': string;
}

export class ItemShippingMethod {
    /**
    * Cost
    */
    'cost': number;
    /**
    * Each additional item markup
    */
    'eachAdditionalItemMarkup': number;
    /**
    * Filter to this method if available
    */
    'filterToIfAvailable': boolean;
    /**
    * First item markup
    */
    'firstItemMarkup': number;
    /**
    * Fixed shipping cost
    */
    'fixedShippingCost': number;
    /**
    * Flat fee markup
    */
    'flatFeeMarkup': number;
    /**
    * Free shipping
    */
    'freeShipping': boolean;
    /**
    * Per item fee markup
    */
    'perItemFeeMarkup': number;
    /**
    * Percentage markup
    */
    'percentageMarkup': number;
    /**
    * Percentage of item markup
    */
    'percentageOfItemMarkup': number;
    /**
    * Relax restrictions on upsell
    */
    'relaxRestrictionsOnUpsell': boolean;
    /**
    * Shipping method name
    */
    'shippingMethod': string;
    /**
    * Shipping method object identifier
    */
    'shippingMethodOid': number;
    /**
    * Shipping method validity
    */
    'shippingMethodValidity': ItemShippingMethod.ShippingMethodValidityEnum;
    /**
    * Signature required
    */
    'signatureRequired': boolean;
}

export namespace ItemShippingMethod {
    export enum ShippingMethodValidityEnum {
        InvalidFor = <any> 'invalid for',
        ValidFor = <any> 'valid for',
        ValidOnlyFor = <any> 'valid only for'
    }
}
export class ItemShippingPackageRequirement {
    /**
    * Package name
    */
    'packageName': string;
    /**
    * Package object identifier
    */
    'packageOid': number;
}

export class ItemTax {
    /**
    * Exemptions
    */
    'exemptions': Array<ItemTaxExemption>;
    /**
    * True if tax free
    */
    'taxFree': boolean;
    /**
    * Taxable cost if different than regular cost
    */
    'taxableCost': number;
}

export class ItemTaxExemption {
    /**
    * City
    */
    'city': string;
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode': string;
    /**
    * County
    */
    'county': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State code
    */
    'stateCode': string;
}

export class ItemThirdPartyEmailMarketing {
    /**
    * Add tags
    */
    'addTags': Array<string>;
    /**
    * Provider name
    */
    'providerName': ItemThirdPartyEmailMarketing.ProviderNameEnum;
    /**
    * Remove tags
    */
    'removeTags': Array<string>;
    /**
    * Subscribe to lists
    */
    'subscribeLists': Array<string>;
    /**
    * Unsubscribe from lists
    */
    'unsubscribeLists': Array<string>;
}

export namespace ItemThirdPartyEmailMarketing {
    export enum ProviderNameEnum {
        ActiveCampaign = <any> 'ActiveCampaign',
        AWeber = <any> 'AWeber',
        CampaignMonitor = <any> 'Campaign Monitor',
        ConstantContact = <any> 'ConstantContact',
        Emma = <any> 'Emma',
        GetResponse = <any> 'GetResponse',
        IContact = <any> 'iContact',
        Klaviyo = <any> 'Klaviyo',
        Lyris = <any> 'Lyris',
        LyrisHQ = <any> 'LyrisHQ',
        MailChimp = <any> 'MailChimp',
        SilverPop = <any> 'SilverPop'
    }
}
export class ItemVariantItem {
    /**
    * Description
    */
    'description': string;
    /**
    * Multimedia object identifier
    */
    'merchantItemMultimediaOid': number;
    /**
    * Variant item id
    */
    'variantMerchantItemId': string;
    /**
    * Variant item object identifier
    */
    'variantMerchantItemOid': number;
    /**
    * Variation options
    */
    'variationOptions': Array<string>;
    /**
    * Variations
    */
    'variations': Array<string>;
}

export class ItemVariation {
    /**
    * Default text
    */
    'defaultText': string;
    /**
    * Default text translated text instance id
    */
    'defaultTextTranslatedTextInstanceOid': number;
    /**
    * Name
    */
    'name': string;
    /**
    * Name translated text instance id
    */
    'nameTranslatedTextInstanceOid': number;
    /**
    * Options
    */
    'options': Array<ItemVariationOption>;
}

export class ItemVariationOption {
    /**
    * True if default option
    */
    'defaultOption': boolean;
    /**
    * Multimedia object identifier
    */
    'merchantItemMultimediaOid': number;
    /**
    * Translated text instance id
    */
    'translatedTextInstanceOid': number;
    /**
    * Value
    */
    'value': string;
}

export class ItemWishlistMember {
    /**
    * WishList Member instance description
    */
    'wishlistMemberInstanceDescription': string;
    /**
    * WishList Member instance object identifier
    */
    'wishlistMemberInstanceOid': number;
    /**
    * WishList Member SKU
    */
    'wishlistMemberSku': string;
}

export class ItemsResponse {
    'error': Error;
    /**
    * items
    */
    'items': Array<Item>;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class OauthRevokeSuccessResponse {
    /**
    * Message confirming revocation of credentials
    */
    'message': string;
    /**
    * True if revoke was successful
    */
    'successful': boolean;
}

export class OauthTokenResponse {
    /**
    * Access token to use in OAuth authenticated API call
    */
    'accessToken': string;
    'error': string;
    'errorDescription': string;
    'errorUri': string;
    /**
    * The number of seconds since issuance when the access token will expire and need to be refreshed using the refresh token
    */
    'expiresIn': string;
    /**
    * The refresh token that should be used to fetch a new access token when the expiration occurs
    */
    'refreshToken': string;
    /**
    * The scope of permissions associated with teh access token
    */
    'scope': string;
    /**
    * Type of token
    */
    'tokenType': OauthTokenResponse.TokenTypeEnum;
}

export namespace OauthTokenResponse {
    export enum TokenTypeEnum {
        Bearer = <any> 'bearer'
    }
}
export class Order {
    /**
    * Affiliates if any were associated with the order.  The first one in the array sent the order and each subsequent affiliate is the recruiter that earns a downline commission.
    */
    'affiliates': Array<OrderAffiliate>;
    'autoOrder': OrderAutoOrder;
    'billing': OrderBilling;
    'buysafe': OrderBuysafe;
    'channelPartner': OrderChannelPartner;
    'checkout': OrderCheckout;
    /**
    * Coupons
    */
    'coupons': Array<OrderCoupon>;
    /**
    * Date/time that the order was created
    */
    'creationDts': string;
    /**
    * Currency code that the customer used if different than the merchant's base currency code
    */
    'currencyCode': string;
    /**
    * Current stage that the order is in.
    */
    'currentStage': Order.CurrentStageEnum;
    'customerProfile': Customer;
    'digitalOrder': OrderDigitalOrder;
    'edi': OrderEdi;
    /**
    * Exchange rate at the time the order was placed if currency code is different than the base currency
    */
    'exchangeRate': number;
    'fraudScore': OrderFraudScore;
    'gift': OrderGift;
    'giftCertificate': OrderGiftCertificate;
    'internal': OrderInternal;
    /**
    * Items
    */
    'items': Array<OrderItem>;
    /**
    * Three letter ISO-639 language code used by the customer during the checkout if different than the default language
    */
    'languageIsoCode': string;
    'linkedShipment': OrderLinkedShipment;
    'marketing': OrderMarketing;
    /**
    * UltraCart merchant ID owning this order
    */
    'merchantId': string;
    /**
    * Order ID
    */
    'orderId': string;
    'payment': OrderPayment;
    'quote': OrderQuote;
    /**
    * If the order was refunded, the date/time that the last refund occurred
    */
    'refundDts': string;
    /**
    * If the order was rejected, the date/time that the rejection occurred
    */
    'rejectDts': string;
    'salesforce': OrderSalesforce;
    'shipping': OrderShipping;
    'summary': OrderSummary;
    'taxes': OrderTaxes;
}

export namespace Order {
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown'
    }
}
export class OrderAffiliate {
    /**
    * Affiliate ID
    */
    'affiliateOid': number;
    /**
    * Ledger entries associated with all the commissions earned on this order
    */
    'ledgerEntries': Array<OrderAffiliateLedger>;
    /**
    * Sub identifier provided by the affiliate on the click that generated this order
    */
    'subId': string;
}

export class OrderAffiliateLedger {
    /**
    * UltraCart user name that assigned this commission if manually assigned
    */
    'assignedByUser': string;
    /**
    * Item ID that this ledger record is associated with
    */
    'itemId': string;
    /**
    * Tier number of this affiliate in the commission calculation
    */
    'tierNumber': number;
    /**
    * Amount of the transaction
    */
    'transactionAmount': number;
    /**
    * The amount that has been paid so far on the transaction
    */
    'transactionAmountPaid': number;
    /**
    * The date/time that the affiliate ledger was generated for the transaction
    */
    'transactionDts': string;
    /**
    * Details of the transaction suitable for display to the affiliate
    */
    'transactionMemo': string;
    /**
    * The percentage earned on the transaction
    */
    'transactionPercentage': number;
    /**
    * The state of the transaction
    */
    'transactionState': OrderAffiliateLedger.TransactionStateEnum;
}

export namespace OrderAffiliateLedger {
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}
export class OrderAutoOrder {
    /**
    * Unique identifier assigned to the auto order
    */
    'autoOrderCode': string;
    /**
    * Orignal order id that started this auto order sequence
    */
    'originalOrderId': string;
    /**
    * The status of the auto order
    */
    'status': OrderAutoOrder.StatusEnum;
}

export namespace OrderAutoOrder {
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}
export class OrderBilling {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
    */
    'ccEmails': Array<string>;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day time phone
    */
    'dayPhone': string;
    /**
    * Email
    */
    'email': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
}

export class OrderBuysafe {
    /**
    * True if a buySAFE bond was available for purchase on this order
    */
    'buysafeBondAvailable': boolean;
    'buysafeBondCost': Currency;
    /**
    * True if the buySAFE bond was free for this order
    */
    'buysafeBondFree': boolean;
    'buysafeBondRefunded': Currency;
    /**
    * True if the buySAFE bond was wanted by the customer
    */
    'buysafeBondWanted': boolean;
    /**
    * Shopping cart ID associated with the buySAFE bond
    */
    'buysafeShoppingCartId': string;
}

export class OrderChannelPartner {
    /**
    * The code of the channel partner
    */
    'channelPartnerCode': string;
    /**
    * Additional data provided by the channel partner
    */
    'channelPartnerData': string;
    /**
    * Channel partner object identifier
    */
    'channelPartnerOid': number;
    /**
    * The order ID assigned by the channel partner for this order
    */
    'channelPartnerOrderId': string;
}

export class OrderCheckout {
    /**
    * Comments from the customer.  Rarely used on the single page checkout.
    */
    'comments': string;
    /**
    * Custom field 1
    */
    'customField1': string;
    /**
    * Custom field 2
    */
    'customField2': string;
    /**
    * Custom field 3
    */
    'customField3': string;
    /**
    * Custom field 4
    */
    'customField4': string;
    /**
    * Custom field 5
    */
    'customField5': string;
    /**
    * Custom field 6
    */
    'customField6': string;
    /**
    * Custom field 7
    */
    'customField7': string;
    /**
    * IP address of the customer when placing the order
    */
    'customerIpAddress': string;
    /**
    * Screen branding theme code associated with the order (legacy checkout)
    */
    'screenBrandingThemeCode': string;
    /**
    * StoreFront host name associated with the order
    */
    'storefrontHostName': string;
    /**
    * Upsell path code assigned during the checkout that the customer went through
    */
    'upsellPathCode': string;
}

export class OrderCoupon {
    /**
    * QuickBooks accounting code for this coupon
    */
    'accountingCode': string;
    /**
    * Coupon code configured by the merchant.  Will differ if the customer used a one time coupon code generated off this base coupon
    */
    'baseCouponCode': string;
    /**
    * Coupon code entered by the customer
    */
    'couponCode': string;
}

export class OrderDigitalItem {
    /**
    * File size
    */
    'fileSize': number;
    /**
    * Last download
    */
    'lastDownload': string;
    /**
    * IP address that performed the last download
    */
    'lastDownloadIpAddress': string;
    /**
    * Original file name
    */
    'originalFilename': string;
    /**
    * Item id associated with this item
    */
    'productCode': string;
    /**
    * Item description associated with this item
    */
    'productDescription': string;
    /**
    * Remaining number of downloads
    */
    'remainingDownloads': number;
    /**
    * URL that the customer can click to download the specific digital item
    */
    'url': string;
}

export class OrderDigitalOrder {
    /**
    * Date/time that the digital order was created
    */
    'creationDts': string;
    /**
    * Expiration date/time of the digital order
    */
    'expirationDts': string;
    /**
    * Digital items associated with the digital order
    */
    'items': Array<OrderDigitalItem>;
    /**
    * URL where the customer can go to and download their digital order content
    */
    'url': string;
    /**
    * URL ID is a unique code that is part of the URLs
    */
    'urlId': string;
}

export class OrderEdi {
    /**
    * Billing address identification code from the EDI order.  Typically DUNS or DUNS+4
    */
    'billToEdiCode': string;
    /**
    * Department number associated with this EDI order
    */
    'ediDepartment': string;
    /**
    * Internal vendor number associated with this EDI order
    */
    'ediInternalVendorNumber': string;
    /**
    * Shipping address identification code from the EDI order.  Typically DUNS or DUNS+4
    */
    'shipToEdiCode': string;
}

export class OrderFraudScore {
    /**
    * True if the IP address is a known anonymous proxy server
    */
    'anonymousProxy': boolean;
    /**
    * Whether the BIN (first six digits) matched the country
    */
    'binMatch': OrderFraudScore.BinMatchEnum;
    /**
    * True if the email address belongs to a known credit card fraudster
    */
    'carderEmail': boolean;
    /**
    * Country code
    */
    'countryCode': string;
    /**
    * Country code matches BIN country
    */
    'countryMatch': boolean;
    /**
    * Whether the customer's phone number is located in the area of the billing address
    */
    'customerPhoneInBillingLocation': string;
    /**
    * Distance in kilometers between the IP address and the BIN
    */
    'distanceKm': number;
    /**
    * True if the email address is for a free service like gmail.com
    */
    'freeEmail': boolean;
    /**
    * True if the customer is in a high risk country known for internet fraud
    */
    'highRiskCountry': boolean;
    /**
    * City associated with the IP address
    */
    'ipCity': string;
    /**
    * ISP that owns the IP address
    */
    'ipIsp': string;
    /**
    * Approximate latitude associated with the IP address
    */
    'ipLatitude': string;
    /**
    * Approximate longitude associated with the IP address
    */
    'ipLongitude': string;
    /**
    * Organization that owns the IP address
    */
    'ipOrg': string;
    /**
    * State/region associated with the IP address
    */
    'ipRegion': string;
    /**
    * Likelihood of the IP address being a proxy server
    */
    'proxyScore': number;
    /**
    * Overall score.  This is the score that is compared to see if the order is rejected or held for review by the fraud filter rules.
    */
    'score': number;
    /**
    * True if the address is a known ship forwarding company
    */
    'shipForwarder': boolean;
    /**
    * Likelihood of the email address being associated with a spammer
    */
    'spamScore': number;
    /**
    * True if the IP address that placed the order is a transparent proxy server
    */
    'transparentProxy': boolean;
}

export namespace OrderFraudScore {
    export enum BinMatchEnum {
        NA = <any> 'NA',
        No = <any> 'No',
        NotFound = <any> 'NotFound',
        Yes = <any> 'Yes'
    }
}
export class OrderGift {
    /**
    * True if the order is a gift
    */
    'gift': boolean;
    'giftCharge': Currency;
    /**
    * QuickBooks code for the gift charge
    */
    'giftChargeAccountingCode': string;
    'giftChargeRefunded': Currency;
    /**
    * Email address of the gift recipient
    */
    'giftEmail': string;
    /**
    * Message to the gift recipient
    */
    'giftMessage': string;
    /**
    * QuickBooks code for the gift wrap charge
    */
    'giftWrapAccountingCode': string;
    'giftWrapCost': Currency;
    'giftWrapRefunded': Currency;
    /**
    * Title of the gift wrap that the customer wants used
    */
    'giftWrapTitle': string;
}

export class OrderGiftCertificate {
    'giftCertificateAmount': Currency;
    /**
    * Gift certificate code used on the order
    */
    'giftCertificateCode': string;
    /**
    * Gift certificate object identifier
    */
    'giftCertificateOid': number;
}

export class OrderInternal {
    /**
    * True if the order has been exported to QuickBooks. If QuickBooks is not configured, then this will already be true
    */
    'exportedToAccounting': boolean;
    /**
    * Merchant notes
    */
    'merchantNotes': string;
    /**
    * If placed via the BEOE, this is the user that placed the order
    */
    'placedByUser': string;
    /**
    * User that issued the refund
    */
    'refundByUser': string;
    /**
    * Sales rep code associated with the order
    */
    'salesRepCode': string;
}

export class OrderItem {
    /**
    * QuickBooks code
    */
    'accountingCode': string;
    /**
    * Activation codes assigned to this item
    */
    'activationCodes': Array<string>;
    /**
    * Barcode
    */
    'barcode': string;
    /**
    * Channel partner item id if this order came through a channel partner and the channel partner item id was mapped to an internal item id
    */
    'channelPartnerItemId': string;
    /**
    * Cost of goods sold
    */
    'cogs': number;
    /**
    * Value of the kit component item
    */
    'componentUnitValue': number;
    'cost': Currency;
    /**
    * Country of origin (ISO-3166 two letter code)
    */
    'countryCodeOfOrigin': string;
    /**
    * Customs description
    */
    'customsDescription': string;
    /**
    * Description
    */
    'description': string;
    'discount': Currency;
    /**
    * Discount quantity
    */
    'discountQuantity': number;
    'discountShippingWeight': Weight;
    /**
    * Distribution center code responsible for shipping this item
    */
    'distributionCenterCode': string;
    'edi': OrderItemEdi;
    /**
    * True if this item is excluded from coupons
    */
    'excludeCoupon': boolean;
    /**
    * True if the item receives free shipping
    */
    'freeShipping': boolean;
    /**
    * Hazardous materials indicator
    */
    'hazmat': boolean;
    'height': Distance;
    /**
    * Item reference object identifier used to linked to auto order item record
    */
    'itemReferenceOid': number;
    /**
    * True if this item is a kit
    */
    'kit': boolean;
    /**
    * True if this item is a kit component
    */
    'kitComponent': boolean;
    'length': Distance;
    /**
    * Manufacturer SKU
    */
    'manufacturerSku': string;
    /**
    * Maximum days that the item can be in transit before spoilage (perishable products)
    */
    'maxDaysTimeInTransit': number;
    /**
    * Item ID
    */
    'merchantItemId': string;
    /**
    * Mix and match group name
    */
    'mixAndMatchGroupName': string;
    /**
    * Mix and match group object identifier
    */
    'mixAndMatchGroupOid': number;
    /**
    * True if this item is excluded from shipping discounts
    */
    'noShippingDiscount': boolean;
    /**
    * Options
    */
    'options': Array<OrderItemOption>;
    /**
    * Packed by user
    */
    'packedByUser': string;
    /**
    * Perishable class of the item
    */
    'perishableClass': string;
    /**
    * Pricing tier that granted the particular price for this item if the customer profile had pricing tiers assigned
    */
    'pricingTierName': string;
    /**
    * Quantity
    */
    'quantity': number;
    /**
    * Quantity refunded on this item
    */
    'quantityRefunded': number;
    /**
    * QuickBooks class
    */
    'quickbooksClass': string;
    /**
    * True if this item ships in a separate box
    */
    'shipSeparately': boolean;
    /**
    * Shipped by user
    */
    'shippedByUser': string;
    /**
    * Date/time that this item was marked shipped
    */
    'shippedDts': string;
    /**
    * Special product type (USPS Media Mail)
    */
    'specialProductType': string;
    /**
    * True if the item is tax free
    */
    'taxFree': boolean;
    'taxableCost': Currency;
    'totalCostWithDiscount': Currency;
    'totalRefunded': Currency;
    /**
    * Date/time that this item was transmitted to the distribution center
    */
    'transmittedToDistributionCenterDts': string;
    'unitCostWithDiscount': Currency;
    /**
    * True if this item was added to the order as part of an upsell
    */
    'upsell': boolean;
    'weight': Weight;
    'width': Distance;
}

export class OrderItemEdi {
    /**
    * Identification information receives on the EDI purchase order
    */
    'identifications': Array<OrderItemEdiIdentification>;
    /**
    * Lot information
    */
    'lots': Array<OrderItemEdiLot>;
}

export class OrderItemEdiIdentification {
    /**
    * Identification value
    */
    'identification': string;
    /**
    * Quantity associated with this identifier
    */
    'quantity': number;
}

export class OrderItemEdiLot {
    /**
    * Log expiration
    */
    'lotExpiration': string;
    /**
    * Lot number
    */
    'lotNumber': string;
    /**
    * Lot quantity
    */
    'lotQuantity': number;
}

export class OrderItemOption {
    /**
    * How the additional dimensions are applied to the item.
    */
    'additionalDimensionApplication': OrderItemOption.AdditionalDimensionApplicationEnum;
    'costChange': Currency;
    'fileAttachment': OrderItemOptionFileAttachment;
    'height': Distance;
    /**
    * True if this option is hidden from display on the order
    */
    'hidden': boolean;
    /**
    * Label
    */
    'label': string;
    'length': Distance;
    /**
    * True if the cost associated with this option is a one time fee or multiplied by the quantity of the item
    */
    'oneTimeFee': boolean;
    /**
    * Value
    */
    'value': string;
    'weightChange': Weight;
    'width': Distance;
}

export namespace OrderItemOption {
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}
export class OrderItemOptionFileAttachment {
    /**
    * Expiration date/time
    */
    'expirationDts': string;
    /**
    * File name
    */
    'fileName': string;
    /**
    * Mime type
    */
    'mimeType': string;
    /**
    * Size
    */
    'size': number;
}

export class OrderLinkedShipment {
    /**
    * True if this order has child linked shipments
    */
    'hasLinkedShipment': boolean;
    /**
    * True if this order is linked to another parent order
    */
    'linkedShipment': boolean;
    /**
    * The child linked shipment channel partner order ids
    */
    'linkedShipmentChannelPartnerOrderIds': Array<string>;
    /**
    * The child linked shipment order ids
    */
    'linkedShipmentOrderIds': Array<string>;
    /**
    * The parent order id that this one is linked to
    */
    'linkedShipmentToOrderId': string;
}

export class OrderMarketing {
    /**
    * Advertising source
    */
    'advertisingSource': string;
    /**
    * True if the customer has opted into mailing list subscription
    */
    'mailingList': boolean;
    /**
    * Referral code
    */
    'referralCode': string;
}

export class OrderPayment {
    'check': OrderPaymentCheck;
    'creditCard': OrderPaymentCreditCard;
    'echeck': OrderPaymentECheck;
    /**
    * True if order has been held for fraud review
    */
    'holdForFraudReview': boolean;
    /**
    * Date/time that the payment was successfully processed
    */
    'paymentDts': string;
    /**
    * Payment method
    */
    'paymentMethod': OrderPayment.PaymentMethodEnum;
    /**
    * Payment method QuickBooks code
    */
    'paymentMethodAccountingCode': string;
    /**
    * Payment method QuickBooks deposit account
    */
    'paymentMethodDepositToAccount': string;
    /**
    * Payment status
    */
    'paymentStatus': OrderPayment.PaymentStatusEnum;
    'purchaseOrder': OrderPaymentPurchaseOrder;
    /**
    * Rotating transaction gateway code used to process this order
    */
    'rotatingTransactionGatewayCode': string;
    'surcharge': Currency;
    /**
    * Surcharge accounting code
    */
    'surchargeAccountingCode': string;
    /**
    * Surcharge transaction fee
    */
    'surchargeTransactionFee': number;
    /**
    * Surcharge transaction percentage
    */
    'surchargeTransactionPercentage': number;
    /**
    * True if this is a test order
    */
    'testOrder': boolean;
    /**
    * Transactions associated with processing this payment
    */
    'transactions': Array<OrderPaymentTransaction>;
}

export namespace OrderPayment {
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        Coinbase = <any> 'Coinbase',
        CreditCard = <any> 'Credit Card',
        ECheck = <any> 'eCheck',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer'
    }
    export enum PaymentStatusEnum {
        Unprocessed = <any> 'Unprocessed',
        Authorized = <any> 'Authorized',
        CaptureFailed = <any> 'Capture Failed',
        Processed = <any> 'Processed',
        Declined = <any> 'Declined',
        Voided = <any> 'Voided',
        Refunded = <any> 'Refunded',
        Skipped = <any> 'Skipped'
    }
}
export class OrderPaymentCheck {
    /**
    * Check number
    */
    'checkNumber': string;
}

export class OrderPaymentCreditCard {
    /**
    * Card authorization ticket
    */
    'cardAuthTicket': string;
    /**
    * Card authorization amount
    */
    'cardAuthorizationAmount': number;
    /**
    * Card authorization date/time
    */
    'cardAuthorizationDts': string;
    /**
    * Card authorization reference number
    */
    'cardAuthorizationReferenceNumber': string;
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (Four digit year)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked to last 4)
    */
    'cardNumber': string;
    /**
    * Card number token from hosted fields used to update the cart number
    */
    'cardNumberToken': string;
    /**
    * True if the card has been truncated
    */
    'cardNumberTruncated': boolean;
    /**
    * Card type
    */
    'cardType': OrderPaymentCreditCard.CardTypeEnum;
}

export namespace OrderPaymentCreditCard {
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        JCB = <any> 'JCB',
        MasterCard = <any> 'MasterCard',
        VISA = <any> 'VISA'
    }
}
export class OrderPaymentECheck {
    /**
    * Bank routing code
    */
    'bankAbaCode': string;
    /**
    * Bank account name
    */
    'bankAccountName': string;
    /**
    * Bank account number (masked to last 4)
    */
    'bankAccountNumber': string;
    /**
    * Bank account type
    */
    'bankAccountType': OrderPaymentECheck.BankAccountTypeEnum;
    /**
    * Bank name
    */
    'bankName': string;
    /**
    * Bank owner type
    */
    'bankOwnerType': OrderPaymentECheck.BankOwnerTypeEnum;
    /**
    * Customer tax id (masked to last 4)
    */
    'customerTaxId': string;
    /**
    * Driver license date of birth
    */
    'driversLicenseDob': string;
    /**
    * Driver license number (masked to last 4)
    */
    'driversLicenseNumber': string;
    /**
    * Driver license state
    */
    'driversLicenseState': string;
}

export namespace OrderPaymentECheck {
    export enum BankAccountTypeEnum {
        Checking = <any> 'Checking',
        Savings = <any> 'Savings'
    }
    export enum BankOwnerTypeEnum {
        Personal = <any> 'Personal',
        Business = <any> 'Business'
    }
}
export class OrderPaymentPurchaseOrder {
    /**
    * Purchase order number
    */
    'purchaseOrderNumber': string;
}

export class OrderPaymentTransaction {
    /**
    * Details
    */
    'details': Array<OrderPaymentTransactionDetail>;
    /**
    * True if the transaction was successful
    */
    'successful': boolean;
    /**
    * Transaction gateway
    */
    'transactionGateway': string;
    /**
    * Transaction date/time
    */
    'transactionTimestamp': string;
}

export class OrderPaymentTransactionDetail {
    /**
    * Name
    */
    'name': string;
    /**
    * Type
    */
    'type': string;
    /**
    * Value
    */
    'value': string;
}

export class OrderQuote {
    /**
    * Expiration of quote at date/time
    */
    'quoteExpirationDts': string;
    /**
    * Quoted by user
    */
    'quotedBy': string;
    /**
    * Quoted on date/time
    */
    'quotedDts': string;
}

export class OrderResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'order': Order;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class OrderSalesforce {
    /**
    * Salesforce.com opportunity id
    */
    'salesforceOpportunityId': string;
}

export class OrderShipping {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day time phone
    */
    'dayPhone': string;
    /**
    * Date the customer is requesting delivery on.  Typically used for perishable product delivery.
    */
    'deliveryDate': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Lift gate requested (LTL shipping methods only)
    */
    'liftGate': boolean;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * RMA number
    */
    'rma': string;
    /**
    * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
    */
    'shipOnDate': string;
    /**
    * True if the shipping address is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
    */
    'shipToResidential': boolean;
    /**
    * Shipping 3rd party account number
    */
    'shipping3rdPartyAccountNumber': string;
    /**
    * Date/time the order shipped on.  This date is set once the first shipment is sent to the customer.
    */
    'shippingDate': string;
    /**
    * Shipping department status
    */
    'shippingDepartmentStatus': string;
    /**
    * Shipping method
    */
    'shippingMethod': string;
    /**
    * Shipping method accounting code
    */
    'shippingMethodAccountingCode': string;
    /**
    * Special instructions from the customer regarding shipping
    */
    'specialInstructions': string;
    /**
    * State
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
    /**
    * Tracking numbers
    */
    'trackingNumbers': Array<string>;
    'weight': Weight;
}

export class OrderSummary {
    'otherRefunded': Currency;
    'shippingHandlingRefunded': Currency;
    'shippingHandlingTotal': Currency;
    'shippingHandlingTotalDiscount': Currency;
    'subtotal': Currency;
    'subtotalDiscount': Currency;
    'subtotalDiscountRefunded': Currency;
    'subtotalRefunded': Currency;
    'tax': Currency;
    'taxRefunded': Currency;
    'taxableSubtotal': Currency;
    'taxableSubtotalDiscount': Currency;
    'total': Currency;
    'totalRefunded': Currency;
}

export class OrderTaxes {
    /**
    * QuickBooks tax city code
    */
    'taxCityAccountingCode': string;
    /**
    * QuickBooks tax country code
    */
    'taxCountryAccountingCode': string;
    /**
    * County used for tax calculation purposes (only in the United States)
    */
    'taxCounty': string;
    /**
    * QuickBooks tax county code
    */
    'taxCountyAccountingCode': string;
    /**
    * QuickBooks tax postal code code
    */
    'taxPostalCodeAccountingCode': string;
    /**
    * Tax rate
    */
    'taxRate': number;
    /**
    * Tax rate at the city level
    */
    'taxRateCity': number;
    /**
    * Tax rate at the country level
    */
    'taxRateCountry': number;
    /**
    * Tax rate at the county level
    */
    'taxRateCounty': number;
    /**
    * Tax rate at the postal code level
    */
    'taxRatePostalCode': number;
    /**
    * Tax rate at the state level
    */
    'taxRateState': number;
    /**
    * QuickBOoks tax state code
    */
    'taxStateAccountingCode': string;
}

export class OrdersResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * orders
    */
    'orders': Array<Order>;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class ResponseMetadata {
    /**
    * Payload name
    */
    'payloadName': string;
    'resultSet': ResultSet;
}

export class ResultSet {
    /**
    * Number of results in this set
    */
    'count': number;
    /**
    * Maximum number of results that can be returned in a set
    */
    'limit': number;
    /**
    * True if there are more results to query
    */
    'more': boolean;
    /**
    * The next offset that you should query to retrieve more results
    */
    'nextOffset': number;
    /**
    * Offset of this result set (zero based)
    */
    'offset': number;
    /**
    * The total number of records in the result set.  May be null if the number is not known and the client should continue iterating as long as more is true.
    */
    'totalRecords': number;
}

export class TempMultimedia {
    /**
    * Filename
    */
    'filename': string;
    /**
    * Height
    */
    'height': number;
    /**
    * Multimedia type
    */
    'multimediaType': TempMultimedia.MultimediaTypeEnum;
    /**
    * Size
    */
    'size': number;
    /**
    * Temporary multimedia object identifier
    */
    'tempMultimediaOid': number;
    /**
    * URL
    */
    'url': string;
    /**
    * Width
    */
    'width': number;
}

export namespace TempMultimedia {
    export enum MultimediaTypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Video = <any> 'Video'
    }
}
export class TempMultimediaResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'tempMultimedia': TempMultimedia;
}

export class Webhook {
    /**
    * Populated if webhook associated with an API user
    */
    'apiUserOid': number;
    /**
    * Version of the API objects that are sent in notifications
    */
    'apiVersion': Webhook.ApiVersionEnum;
    'applicationProfile': ApiUserApplicationProfile;
    /**
    * The type of authentication this webhook will use when communicating with your server
    */
    'authenticationType': Webhook.AuthenticationTypeEnum;
    /**
    * Basic authentication password
    */
    'basicPassword': string;
    /**
    * Basic authentication user name
    */
    'basicUsername': string;
    /**
    * The number of consecutive failures that have occurred trying to deliver notifications to the target server
    */
    'consecutiveFailures': number;
    /**
    * True if the webhook has been disabled
    */
    'disabled': boolean;
    /**
    * The categories of events.  Individual events and subscriptions are handled in the child objects.  _placeholders parameter effects the population of this on a retrieval.
    */
    'eventCategories': Array<WebhookEventCategory>;
    /**
    * The maximum number of events in the payload that UltraCart will deliver
    */
    'maximumEvents': number;
    /**
    * The maximum size of the payload that UltraCart will deliver
    */
    'maximumSize': number;
    /**
    * The UltraCart merchant ID that owns this webhook
    */
    'merchantId': string;
    /**
    * The next time UltraCart will attempt delivery if failures have been occurring
    */
    'nextRetryAfter': string;
    /**
    * The number of pending events for this webhook
    */
    'pending': number;
    /**
    * The object identifier for this webhook
    */
    'webhookOid': number;
    /**
    * The URL to deliver events to.  Must be HTTPS for customer related information.
    */
    'webhookUrl': string;
}

export namespace Webhook {
    export enum ApiVersionEnum {
        _01 = <any> '2017-03-01'
    }
    export enum AuthenticationTypeEnum {
        None = <any> 'none',
        Basic = <any> 'basic'
    }
}
export class WebhookEventCategory {
    /**
    * Name of the event category
    */
    'eventCategory': string;
    /**
    * The events within the category.  Individual subscription flags contained within the child object.
    */
    'events': Array<WebhookEventSubscription>;
    /**
    * True if all the events within this category are subscribed.  This is a convenience flag to make user interfaces easier.
    */
    'subscribed': boolean;
}

export class WebhookEventSubscription {
    /**
    * Comment about the event to provide further clarification to the end user
    */
    'comments': string;
    /**
    * True if the event is deprecated.  See the API change log for details on when it will be discontinued.
    */
    'deprecatedFlag': boolean;
    /**
    * True if the event is discontinued.  See the API change log for details on migration details.
    */
    'discontinuedFlag': boolean;
    /**
    * Description of the event
    */
    'eventDescription': string;
    /**
    * Event name
    */
    'eventName': string;
    /**
    * The expand string for the notification object.  See the individual resource _expand documentation for valid values.
    */
    'expansion': string;
    /**
    * True if this is event is subscribed to
    */
    'subscribed': boolean;
    /**
    * The webhook event object identifier
    */
    'webhookEventOid': number;
}

export class WebhookLog {
    /**
    * Date/time of delivery
    */
    'deliveryDts': string;
    /**
    * Number of milliseconds to process the notification
    */
    'duration': number;
    /**
    * Request payload (first 100,000 characters)
    */
    'request': string;
    /**
    * Request headers sent to the server
    */
    'requestHeaders': Array<HTTPHeader>;
    /**
    * Request id is a unique string that you can look up in the logs
    */
    'requestId': string;
    /**
    * Response payload (first 100,000 characters)
    */
    'response': string;
    /**
    * Response headers received from the server
    */
    'responseHeaders': Array<HTTPHeader>;
    /**
    * HTTP status code received from the server
    */
    'statusCode': number;
    /**
    * True if the delivery was successful
    */
    'success': boolean;
    /**
    * URI of the webhook delivered to
    */
    'uri': string;
}

export class WebhookLogResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhookLog': WebhookLog;
}

export class WebhookLogSummariesResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    /**
    * Webhook log summaries
    */
    'webhookLogSummaries': Array<WebhookLogSummary>;
}

export class WebhookLogSummary {
    /**
    * Date/time of the delivery
    */
    'deliveryDts': string;
    /**
    * Request id
    */
    'requestId': string;
    /**
    * True if the notification was successful
    */
    'success': boolean;
}

export class WebhookResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhook': Webhook;
}

export class WebhookSampleRequest {
    /**
    * Request
    */
    'request': string;
    /**
    * Request headers
    */
    'requestHeaders': Array<HTTPHeader>;
    /**
    * Request id
    */
    'requestId': string;
    /**
    * URI to send request to
    */
    'uri': string;
}

export class WebhookSampleRequestResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhookSampleRequest': WebhookSampleRequest;
}

export class WebhooksResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhooks': Array<Webhook>;
}

export class Weight {
    /**
    * Unit of measure
    */
    'uom': Weight.UomEnum;
    /**
    * Weight
    */
    'value': number;
}

export namespace Weight {
    export enum UomEnum {
        KG = <any> 'KG',
        LB = <any> 'LB',
        OZ = <any> 'OZ'
    }
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum AutoorderApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class AutoorderApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AutoorderApiApiKeys, value: string) {
        this.authentications[AutoorderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve an auto order
     * Retrieves a single auto order using the specified auto order oid. 
     * @param autoOrderOid The auto order oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getAutoOrder (autoOrderOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/{auto_order_oid}'
            .replace('{' + 'auto_order_oid' + '}', String(autoOrderOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'autoOrderOid' is not null or undefined
        if (autoOrderOid === null || autoOrderOid === undefined) {
            throw new Error('Required parameter autoOrderOid was null or undefined when calling getAutoOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve auto orders
     * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param autoOrderCode Auto order code
     * @param originalOrderId Original order id
     * @param firstName First name
     * @param lastName Last name
     * @param company Company
     * @param city City
     * @param state State
     * @param postalCode Postal code
     * @param countryCode Country code (ISO-3166 two letter)
     * @param phone Phone
     * @param email Email
     * @param originalOrderDateBegin Original order date begin
     * @param originalOrderDateEnd Original order date end
     * @param nextShipmentDateBegin Next shipment date begin
     * @param nextShipmentDateEnd Next shipment date end
     * @param cardType Card type
     * @param itemId Item ID
     * @param status Status
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch auto orders that have been created/modified since this date/time.
     * @param sort The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getAutoOrders (autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (autoOrderCode !== undefined) {
            queryParameters['auto_order_code'] = autoOrderCode;
        }

        if (originalOrderId !== undefined) {
            queryParameters['original_order_id'] = originalOrderId;
        }

        if (firstName !== undefined) {
            queryParameters['first_name'] = firstName;
        }

        if (lastName !== undefined) {
            queryParameters['last_name'] = lastName;
        }

        if (company !== undefined) {
            queryParameters['company'] = company;
        }

        if (city !== undefined) {
            queryParameters['city'] = city;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (postalCode !== undefined) {
            queryParameters['postal_code'] = postalCode;
        }

        if (countryCode !== undefined) {
            queryParameters['country_code'] = countryCode;
        }

        if (phone !== undefined) {
            queryParameters['phone'] = phone;
        }

        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (originalOrderDateBegin !== undefined) {
            queryParameters['original_order_date_begin'] = originalOrderDateBegin;
        }

        if (originalOrderDateEnd !== undefined) {
            queryParameters['original_order_date_end'] = originalOrderDateEnd;
        }

        if (nextShipmentDateBegin !== undefined) {
            queryParameters['next_shipment_date_begin'] = nextShipmentDateBegin;
        }

        if (nextShipmentDateEnd !== undefined) {
            queryParameters['next_shipment_date_end'] = nextShipmentDateEnd;
        }

        if (cardType !== undefined) {
            queryParameters['card_type'] = cardType;
        }

        if (itemId !== undefined) {
            queryParameters['item_id'] = itemId;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an auto order
     * Update an auto order on the UltraCart account. 
     * @param autoOrder Auto order to update
     * @param autoOrderOid The auto order oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateAutoOrder (autoOrder: AutoOrder, autoOrderOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/{auto_order_oid}'
            .replace('{' + 'auto_order_oid' + '}', String(autoOrderOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'autoOrder' is not null or undefined
        if (autoOrder === null || autoOrder === undefined) {
            throw new Error('Required parameter autoOrder was null or undefined when calling updateAutoOrder.');
        }

        // verify required parameter 'autoOrderOid' is not null or undefined
        if (autoOrderOid === null || autoOrderOid === undefined) {
            throw new Error('Required parameter autoOrderOid was null or undefined when calling updateAutoOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: autoOrder,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChargebackApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class ChargebackApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ChargebackApiApiKeys, value: string) {
        this.authentications[ChargebackApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a chargeback
     * Delete a chargeback on the UltraCart account. 
     * @param chargebackDisputeOid The chargeback_dispute_oid to delete.
     */
    public deleteChargeback (chargebackDisputeOid: number) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', String(chargebackDisputeOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling deleteChargeback.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a chargeback
     * Retrieves a single chargeback using the specified chargeback dispute oid. 
     * @param chargebackDisputeOid The chargeback dispute oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getChargebackDispute (chargebackDisputeOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', String(chargebackDisputeOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling getChargebackDispute.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve chargebacks
     * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param orderId Order Id
     * @param caseNumber Case number
     * @param status Status
     * @param expirationDtsStart Expiration dts start
     * @param expirationDtsEnd Expiration dts end
     * @param chargebackDtsStart Chargeback dts start
     * @param chargebackDtsEnd Chargeback dts end
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch chargebacks that have been created/modified since this date/time.
     * @param sort The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getChargebackDisputes (orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputesResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (orderId !== undefined) {
            queryParameters['order_id'] = orderId;
        }

        if (caseNumber !== undefined) {
            queryParameters['case_number'] = caseNumber;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (expirationDtsStart !== undefined) {
            queryParameters['expiration_dts_start'] = expirationDtsStart;
        }

        if (expirationDtsEnd !== undefined) {
            queryParameters['expiration_dts_end'] = expirationDtsEnd;
        }

        if (chargebackDtsStart !== undefined) {
            queryParameters['chargeback_dts_start'] = chargebackDtsStart;
        }

        if (chargebackDtsEnd !== undefined) {
            queryParameters['chargeback_dts_end'] = chargebackDtsEnd;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a chargeback
     * Insert a chargeback on the UltraCart account. 
     * @param chargeback Chargeback to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public insertChargeback (chargeback: ChargebackDispute, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargeback' is not null or undefined
        if (chargeback === null || chargeback === undefined) {
            throw new Error('Required parameter chargeback was null or undefined when calling insertChargeback.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: chargeback,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a chargeback
     * Update a chargeback on the UltraCart account. 
     * @param chargeback Chargeback to update
     * @param chargebackDisputeOid The chargeback_dispute_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateChargeback (chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', String(chargebackDisputeOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargeback' is not null or undefined
        if (chargeback === null || chargeback === undefined) {
            throw new Error('Required parameter chargeback was null or undefined when calling updateChargeback.');
        }

        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling updateChargeback.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: chargeback,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CheckoutApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CheckoutApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CheckoutApiApiKeys, value: string) {
        this.authentications[CheckoutApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * City/State for Zip
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @param cart Cart
     */
    public cityState (cart: Cart) : Promise<{ response: http.ClientResponse; body: CityStateZip;  }> {
        const localVarPath = this.basePath + '/checkout/city_state';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling cityState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CityStateZip;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Finalize Order
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @param finalizeRequest Finalize request
     */
    public finalizeOrder (finalizeRequest: CartFinalizeOrderRequest) : Promise<{ response: http.ClientResponse; body: CartFinalizeOrderResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/finalizeOrder';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'finalizeRequest' is not null or undefined
        if (finalizeRequest === null || finalizeRequest === undefined) {
            throw new Error('Required parameter finalizeRequest was null or undefined when calling finalizeOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: finalizeRequest,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartFinalizeOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get cart
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCart (expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get cart (by cart id)
     * Get a cart specified by the cart_id parameter. 
     * @param cartId Cart ID to retrieve
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCartByCartId (cartId: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/{cart_id}'
            .replace('{' + 'cart_id' + '}', String(cartId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cartId' is not null or undefined
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getCartByCartId.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get cart (by return code)
     * Get a cart specified by the return code parameter. 
     * @param returnCode Return code to lookup cart ID by
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCartByReturnCode (returnCode: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/return/{return_code}'
            .replace('{' + 'return_code' + '}', String(returnCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'returnCode' is not null or undefined
        if (returnCode === null || returnCode === undefined) {
            throw new Error('Required parameter returnCode was null or undefined when calling getCartByReturnCode.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Handoff cart
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal or finalization of the order (including upsell processing). 
     * @param handoffRequest Handoff request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public handoffCart (handoffRequest: CheckoutHandoffRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CheckoutHandoffResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/handoff';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'handoffRequest' is not null or undefined
        if (handoffRequest === null || handoffRequest === undefined) {
            throw new Error('Required parameter handoffRequest was null or undefined when calling handoffCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: handoffRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutHandoffResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Profile login
     * Login in to the customer profile specified by cart.billing.email and password 
     * @param loginRequest Login request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public login (loginRequest: CartProfileLoginRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CartProfileLoginResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/login';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loginRequest' is not null or undefined
        if (loginRequest === null || loginRequest === undefined) {
            throw new Error('Required parameter loginRequest was null or undefined when calling login.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loginRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartProfileLoginResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Profile logout
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public logout (cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/logout';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling logout.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Profile registration
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @param registerRequest Register request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public register (registerRequest: CartProfileRegisterRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CartProfileRegisterResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/register';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'registerRequest' is not null or undefined
        if (registerRequest === null || registerRequest === undefined) {
            throw new Error('Required parameter registerRequest was null or undefined when calling register.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: registerRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartProfileRegisterResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Related items
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See item resource documentation for examples
     */
    public relatedItemsForCart (cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/checkout/related_items';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling relatedItemsForCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Related items (specific item)
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @param itemId Item ID to retrieve related items for
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See item resource documentation for examples
     */
    public relatedItemsForItem (itemId: string, cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/checkout/relatedItems/{item_id}'
            .replace('{' + 'item_id' + '}', String(itemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling relatedItemsForItem.');
        }

        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling relatedItemsForItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Setup Browser Application
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @param browserKeyRequest Setup browser key request
     */
    public setupBrowserKey (browserKeyRequest: CheckoutSetupBrowserKeyRequest) : Promise<{ response: http.ClientResponse; body: CheckoutSetupBrowserKeyResponse;  }> {
        const localVarPath = this.basePath + '/checkout/browser_key';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'browserKeyRequest' is not null or undefined
        if (browserKeyRequest === null || browserKeyRequest === undefined) {
            throw new Error('Required parameter browserKeyRequest was null or undefined when calling setupBrowserKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: browserKeyRequest,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutSetupBrowserKeyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update cart
     * Update the cart. 
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateCart (cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling updateCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Validate
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @param validationRequest Validation request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public validateCart (validationRequest: CartValidationRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CartValidationResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/validate';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'validationRequest' is not null or undefined
        if (validationRequest === null || validationRequest === undefined) {
            throw new Error('Required parameter validationRequest was null or undefined when calling validateCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: validationRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartValidationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CustomerApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CustomerApiApiKeys, value: string) {
        this.authentications[CustomerApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a customer
     * Delete a customer on the UltraCart account. 
     * @param customerProfileOid The customer_profile_oid to delete.
     */
    public deleteCustomer (customerProfileOid: number) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', String(customerProfileOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling deleteCustomer.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a customer
     * Retrieves a single customer using the specified customer profile oid. 
     * @param customerProfileOid The customer oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCustomer (customerProfileOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', String(customerProfileOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling getCustomer.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve customers
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param email Email
     * @param qbClass Quickbooks class
     * @param quickbooksCode Quickbooks code
     * @param lastModifiedDtsStart Last modified date start
     * @param lastModifiedDtsEnd Last modified date end
     * @param signupDtsStart Signup date start
     * @param signupDtsEnd Signup date end
     * @param billingFirstName Billing first name
     * @param billingLastName Billing last name
     * @param billingCompany Billing company
     * @param billingCity Billing city
     * @param billingState Billing state
     * @param billingPostalCode Billing postal code
     * @param billingCountryCode Billing country code
     * @param billingDayPhone Billing day phone
     * @param billingEveningPhone Billing evening phone
     * @param shippingFirstName Shipping first name
     * @param shippingLastName Shipping last name
     * @param shippingCompany Shipping company
     * @param shippingCity Shipping city
     * @param shippingState Shipping state
     * @param shippingPostalCode Shipping postal code
     * @param shippingCountryCode Shipping country code
     * @param shippingDayPhone Shipping day phone
     * @param shippingEveningPhone Shipping evening phone
     * @param pricingTierOid Pricing tier oid
     * @param pricingTierName Pricing tier name
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch customers that have been created/modified since this date/time.
     * @param sort The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCustomers (email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomersResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (qbClass !== undefined) {
            queryParameters['qb_class'] = qbClass;
        }

        if (quickbooksCode !== undefined) {
            queryParameters['quickbooks_code'] = quickbooksCode;
        }

        if (lastModifiedDtsStart !== undefined) {
            queryParameters['last_modified_dts_start'] = lastModifiedDtsStart;
        }

        if (lastModifiedDtsEnd !== undefined) {
            queryParameters['last_modified_dts_end'] = lastModifiedDtsEnd;
        }

        if (signupDtsStart !== undefined) {
            queryParameters['signup_dts_start'] = signupDtsStart;
        }

        if (signupDtsEnd !== undefined) {
            queryParameters['signup_dts_end'] = signupDtsEnd;
        }

        if (billingFirstName !== undefined) {
            queryParameters['billing_first_name'] = billingFirstName;
        }

        if (billingLastName !== undefined) {
            queryParameters['billing_last_name'] = billingLastName;
        }

        if (billingCompany !== undefined) {
            queryParameters['billing_company'] = billingCompany;
        }

        if (billingCity !== undefined) {
            queryParameters['billing_city'] = billingCity;
        }

        if (billingState !== undefined) {
            queryParameters['billing_state'] = billingState;
        }

        if (billingPostalCode !== undefined) {
            queryParameters['billing_postal_code'] = billingPostalCode;
        }

        if (billingCountryCode !== undefined) {
            queryParameters['billing_country_code'] = billingCountryCode;
        }

        if (billingDayPhone !== undefined) {
            queryParameters['billing_day_phone'] = billingDayPhone;
        }

        if (billingEveningPhone !== undefined) {
            queryParameters['billing_evening_phone'] = billingEveningPhone;
        }

        if (shippingFirstName !== undefined) {
            queryParameters['shipping_first_name'] = shippingFirstName;
        }

        if (shippingLastName !== undefined) {
            queryParameters['shipping_last_name'] = shippingLastName;
        }

        if (shippingCompany !== undefined) {
            queryParameters['shipping_company'] = shippingCompany;
        }

        if (shippingCity !== undefined) {
            queryParameters['shipping_city'] = shippingCity;
        }

        if (shippingState !== undefined) {
            queryParameters['shipping_state'] = shippingState;
        }

        if (shippingPostalCode !== undefined) {
            queryParameters['shipping_postal_code'] = shippingPostalCode;
        }

        if (shippingCountryCode !== undefined) {
            queryParameters['shipping_country_code'] = shippingCountryCode;
        }

        if (shippingDayPhone !== undefined) {
            queryParameters['shipping_day_phone'] = shippingDayPhone;
        }

        if (shippingEveningPhone !== undefined) {
            queryParameters['shipping_evening_phone'] = shippingEveningPhone;
        }

        if (pricingTierOid !== undefined) {
            queryParameters['pricing_tier_oid'] = pricingTierOid;
        }

        if (pricingTierName !== undefined) {
            queryParameters['pricing_tier_name'] = pricingTierName;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a customer
     * Insert a customer on the UltraCart account. 
     * @param customer Customer to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public insertCustomer (customer: Customer, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling insertCustomer.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customer,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a customer
     * Update a customer on the UltraCart account. 
     * @param customer Customer to update
     * @param customerProfileOid The customer_profile_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateCustomer (customer: Customer, customerProfileOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', String(customerProfileOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling updateCustomer.');
        }

        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling updateCustomer.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customer,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FulfillmentApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class FulfillmentApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FulfillmentApiApiKeys, value: string) {
        this.authentications[FulfillmentApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Acknowledge receipt of orders.
     * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
     * @param distributionCenterCode Distribution center code
     * @param orderIds Orders to acknowledge receipt of (limit 100)
     */
    public acknowledgeOrders (distributionCenterCode: string, orderIds: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/acknowledgements'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling acknowledgeOrders.');
        }

        // verify required parameter 'orderIds' is not null or undefined
        if (orderIds === null || orderIds === undefined) {
            throw new Error('Required parameter orderIds was null or undefined when calling acknowledgeOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: orderIds,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve orders queued up for this distribution center.
     * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You&#39;ll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
     * @param distributionCenterCode Distribution center code
     */
    public getDistributionCenterOrders (distributionCenterCode: string) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/orders'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling getDistributionCenterOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve distribution centers
     * Retrieves the distribution centers that this user has access to. 
     */
    public getDistributionCenters () : Promise<{ response: http.ClientResponse; body: DistributionCentersResponse;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DistributionCentersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark orders as shipped
     * Store the tracking information and mark the order shipped for this distribution center. 
     * @param distributionCenterCode Distribution center code
     * @param shipments Orders to mark shipped
     */
    public shipOrders (distributionCenterCode: string, shipments: Array<FulfillmentShipment>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/shipments'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling shipOrders.');
        }

        // verify required parameter 'shipments' is not null or undefined
        if (shipments === null || shipments === undefined) {
            throw new Error('Required parameter shipments was null or undefined when calling shipOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shipments,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update inventory
     * Update the inventory for items associated with this distribution center 
     * @param distributionCenterCode Distribution center code
     * @param inventories Inventory updates (limit 500)
     */
    public updateInventory (distributionCenterCode: string, inventories: Array<FulfillmentInventory>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/inventory'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling updateInventory.');
        }

        // verify required parameter 'inventories' is not null or undefined
        if (inventories === null || inventories === undefined) {
            throw new Error('Required parameter inventories was null or undefined when calling updateInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inventories,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ItemApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class ItemApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ItemApiApiKeys, value: string) {
        this.authentications[ItemApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete an item
     * Delete an item on the UltraCart account. 
     * @param merchantItemOid The item oid to delete.
     */
    public deleteItem (merchantItemOid: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', String(merchantItemOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling deleteItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an item
     * Retrieves a single item using the specified item oid. 
     * @param merchantItemOid The item oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public getItem (merchantItemOid: number, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', String(merchantItemOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling getItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve items
     * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param parentCategoryId The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
     * @param parentCategoryPath The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
     * @param limit The maximum number of records to return on this one API call. (Default 100, Max 2000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch items that have been created/modified since this date/time.
     * @param sort The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public getItems (parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/item/items';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (parentCategoryId !== undefined) {
            queryParameters['parent_category_id'] = parentCategoryId;
        }

        if (parentCategoryPath !== undefined) {
            queryParameters['parent_category_path'] = parentCategoryPath;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an item
     * Create a new item on the UltraCart account. 
     * @param item Item to create
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public insertItem (item: Item, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling insertItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: item,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an item
     * Update a new item on the UltraCart account. 
     * @param item Item to update
     * @param merchantItemOid The item oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public updateItem (item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', String(merchantItemOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling updateItem.');
        }

        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling updateItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: item,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload an image to the temporary multimedia.
     * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
     * @param file File to upload
     */
    public uploadTemporaryMultimedia (file: any) : Promise<{ response: http.ClientResponse; body: TempMultimediaResponse;  }> {
        const localVarPath = this.basePath + '/item/temp_multimedia';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling uploadTemporaryMultimedia.');
        }

        let useFormData = false;

        if (file !== undefined) {
            formParams['file'] = file;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TempMultimediaResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OauthApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class OauthApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OauthApiApiKeys, value: string) {
        this.authentications[OauthApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Exchange authorization code for access token.
     * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
     * @param clientId The OAuth application client_id.
     * @param grantType Type of grant
     * @param code Authorization code received back from the browser redirect
     * @param redirectUri The URI that you redirect the browser to to start the authorization process
     * @param refreshToken The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
     */
    public oauthAccessToken (clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string) : Promise<{ response: http.ClientResponse; body: OauthTokenResponse;  }> {
        const localVarPath = this.basePath + '/oauth/token';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling oauthAccessToken.');
        }

        // verify required parameter 'grantType' is not null or undefined
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling oauthAccessToken.');
        }

        let useFormData = false;

        if (clientId !== undefined) {
            formParams['client_id'] = clientId;
        }

        if (grantType !== undefined) {
            formParams['grant_type'] = grantType;
        }

        if (code !== undefined) {
            formParams['code'] = code;
        }

        if (redirectUri !== undefined) {
            formParams['redirect_uri'] = redirectUri;
        }

        if (refreshToken !== undefined) {
            formParams['refresh_token'] = refreshToken;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthTokenResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revoke this OAuth application.
     * Revokes the OAuth application associated with the specified client_id and token. 
     * @param clientId The OAuth application client_id.
     * @param token The OAuth access token that is to be revoked..
     */
    public oauthRevoke (clientId: string, token: string) : Promise<{ response: http.ClientResponse; body: OauthRevokeSuccessResponse;  }> {
        const localVarPath = this.basePath + '/oauth/revoke';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling oauthRevoke.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling oauthRevoke.');
        }

        let useFormData = false;

        if (clientId !== undefined) {
            formParams['client_id'] = clientId;
        }

        if (token !== undefined) {
            formParams['token'] = token;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthRevokeSuccessResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class OrderApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OrderApiApiKeys, value: string) {
        this.authentications[OrderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Cancel an order
     * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
     * @param orderId The order id to cancel.
     */
    public cancelOrder (orderId: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/cancel'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an order
     * Delete an order on the UltraCart account. 
     * @param orderId The order id to delete.
     */
    public deleteOrder (orderId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling deleteOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an order
     * Retrieves a single order using the specified order id. 
     * @param orderId The order id to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getOrder (orderId: string, expand?: string) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve orders
     * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param orderId Order Id
     * @param paymentMethod Payment Method
     * @param company Company
     * @param firstName First Name
     * @param lastName Last Name
     * @param city City
     * @param stateRegion State/Region
     * @param postalCode Postal Code
     * @param countryCode Country Code (ISO-3166 two letter)
     * @param phone Phone
     * @param email Email
     * @param ccEmail CC Email
     * @param total Total
     * @param screenBrandingThemeCode Screen Branding Theme Code
     * @param storefrontHostName StoreFront Host Name
     * @param creationDateBegin Creation Date Begin
     * @param creationDateEnd Creation Date End
     * @param paymentDateBegin Payment Date Begin
     * @param paymentDateEnd Payment Date End
     * @param shipmentDateBegin Shipment Date Begin
     * @param shipmentDateEnd Shipment Date End
     * @param rma RMA
     * @param purchaseOrderNumber Purchase Order Number
     * @param itemId Item Id
     * @param currentStage Current Stage
     * @param channelPartnerCode Channel Partner Code
     * @param channelPartnerOrderId Channel Partner Order ID
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.
     */
    public getOrders (orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, limit?: number, offset?: number, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/order/orders';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (orderId !== undefined) {
            queryParameters['order_id'] = orderId;
        }

        if (paymentMethod !== undefined) {
            queryParameters['payment_method'] = paymentMethod;
        }

        if (company !== undefined) {
            queryParameters['company'] = company;
        }

        if (firstName !== undefined) {
            queryParameters['first_name'] = firstName;
        }

        if (lastName !== undefined) {
            queryParameters['last_name'] = lastName;
        }

        if (city !== undefined) {
            queryParameters['city'] = city;
        }

        if (stateRegion !== undefined) {
            queryParameters['state_region'] = stateRegion;
        }

        if (postalCode !== undefined) {
            queryParameters['postal_code'] = postalCode;
        }

        if (countryCode !== undefined) {
            queryParameters['country_code'] = countryCode;
        }

        if (phone !== undefined) {
            queryParameters['phone'] = phone;
        }

        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (ccEmail !== undefined) {
            queryParameters['cc_email'] = ccEmail;
        }

        if (total !== undefined) {
            queryParameters['total'] = total;
        }

        if (screenBrandingThemeCode !== undefined) {
            queryParameters['screen_branding_theme_code'] = screenBrandingThemeCode;
        }

        if (storefrontHostName !== undefined) {
            queryParameters['storefront_host_name'] = storefrontHostName;
        }

        if (creationDateBegin !== undefined) {
            queryParameters['creation_date_begin'] = creationDateBegin;
        }

        if (creationDateEnd !== undefined) {
            queryParameters['creation_date_end'] = creationDateEnd;
        }

        if (paymentDateBegin !== undefined) {
            queryParameters['payment_date_begin'] = paymentDateBegin;
        }

        if (paymentDateEnd !== undefined) {
            queryParameters['payment_date_end'] = paymentDateEnd;
        }

        if (shipmentDateBegin !== undefined) {
            queryParameters['shipment_date_begin'] = shipmentDateBegin;
        }

        if (shipmentDateEnd !== undefined) {
            queryParameters['shipment_date_end'] = shipmentDateEnd;
        }

        if (rma !== undefined) {
            queryParameters['rma'] = rma;
        }

        if (purchaseOrderNumber !== undefined) {
            queryParameters['purchase_order_number'] = purchaseOrderNumber;
        }

        if (itemId !== undefined) {
            queryParameters['item_id'] = itemId;
        }

        if (currentStage !== undefined) {
            queryParameters['current_stage'] = currentStage;
        }

        if (channelPartnerCode !== undefined) {
            queryParameters['channel_partner_code'] = channelPartnerCode;
        }

        if (channelPartnerOrderId !== undefined) {
            queryParameters['channel_partner_order_id'] = channelPartnerOrderId;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend receipt
     * Resend the receipt for an order on the UltraCart account. 
     * @param orderId The order id to resend the receipt for.
     */
    public resendReceipt (orderId: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/resend_receipt'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling resendReceipt.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend shipment confirmation
     * Resend shipment confirmation for an order on the UltraCart account. 
     * @param orderId The order id to resend the shipment notification for.
     */
    public resendShipmentConfirmation (orderId: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/resend_shipment_confirmation'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling resendShipmentConfirmation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an order
     * Update a new order on the UltraCart account. 
     * @param order Order to update
     * @param orderId The order id to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateOrder (order: Order, orderId: string, expand?: string) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling updateOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: order,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhookApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class WebhookApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WebhookApiApiKeys, value: string) {
        this.authentications[WebhookApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a webhook
     * Delete a webhook on the UltraCart account. 
     * @param webhookOid The webhook oid to delete.
     */
    public deleteWebhook (webhookOid: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling deleteWebhook.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an individual log
     * Retrieves an individual log for a webhook given the webhook oid the request id. 
     * @param webhookOid The webhook oid that owns the log.
     * @param requestId The request id associated with the log to view.
     */
    public getWebhookLog (webhookOid: number, requestId: string) : Promise<{ response: http.ClientResponse; body: WebhookLogResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/logs/{requestId}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid))
            .replace('{' + 'requestId' + '}', String(requestId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling getWebhookLog.');
        }

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getWebhookLog.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookLogResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the log summaries
     * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
     * @param webhookOid The webhook oid to retrieve log summaries for.
     * @param limit The maximum number of records to return on this one API call.
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch log summaries that have been delivered since this date/time.
     */
    public getWebhookLogSummaries (webhookOid: number, limit?: number, offset?: number, since?: string) : Promise<{ response: http.ClientResponse; body: WebhookLogSummariesResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/logs'
            .replace('{' + 'webhookOid' + '}', String(webhookOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling getWebhookLogSummaries.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookLogSummariesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve webhooks
     * Retrieves the webhooks associated with this application. 
     * @param limit The maximum number of records to return on this one API call.
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the webhooks.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public getWebhooks (limit?: number, offset?: number, sort?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: WebhooksResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhooksResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a webhook
     * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
     * @param webhook Webhook to create
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public insertWebhook (webhook: Webhook, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling insertWebhook.');
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhook,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend events to the webhook endpoint.
     * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
     * @param webhookOid The webhook oid that is receiving the reflowed events.
     * @param eventName The event to reflow.
     */
    public resendEvent (webhookOid: number, eventName: string) : Promise<{ response: http.ClientResponse; body: WebhookSampleRequestResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/reflow/{eventName}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid))
            .replace('{' + 'eventName' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling resendEvent.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling resendEvent.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookSampleRequestResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a webhook
     * Update a webhook on the account 
     * @param webhook Webhook to update
     * @param webhookOid The webhook oid to update.
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public updateWebhook (webhook: Webhook, webhookOid: number, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling updateWebhook.');
        }

        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling updateWebhook.');
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhook,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
