/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://secure.ultracart.com/rest/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryConfig
 */
export interface AccountsReceivableRetryConfig {
    /**
     * True if the retry should run daily.  False puts the retry service into an inactive state for this merchant.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    active?: boolean;
    /**
     * True if this account has linked accounts that it can process.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    allow_process_linked_accounts?: boolean;
    /**
     * The current service plan that the account is on.
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    current_service_plan?: string;
    /**
     * A list of days and what actions should take place on those days after an order reaches accounts receivable
     * @type {Array<AccountsReceivableRetryDayActivity>}
     * @memberof AccountsReceivableRetryConfig
     */
    daily_activity_list?: Array<AccountsReceivableRetryDayActivity>;
    /**
     * If not null, this account is managed by the specified parent merchant id.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    managed_by_linked_account_merchant_id?: boolean;
    /**
     * UltraCart merchant ID
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    merchant_id?: string;
    /**
     * A list of email addresses to receive summary notifications from the retry service.
     * @type {Array<string>}
     * @memberof AccountsReceivableRetryConfig
     */
    notify_emails?: Array<string>;
    /**
     * If true, email addresses are notified of rejections.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    notify_rejections?: boolean;
    /**
     * If true, email addresses are notified of successful charges.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    notify_successes?: boolean;
    /**
     * If true, all linked accounts are also processed using the same rules.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    process_linked_accounts?: boolean;
    /**
     * The percentage rate charged for the service.
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    processing_percentage?: string;
    /**
     * If true, the order is rejected the day after the last configured activity day
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    reject_at_end?: boolean;
    /**
     * True if the account is currently in trial mode.  Set to false to exit trial mode.
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfig
     */
    trial_mode?: boolean;
    /**
     * The date when trial mode expires.  If this date is reached without exiting trial mode, the service will de-activate.
     * @type {string}
     * @memberof AccountsReceivableRetryConfig
     */
    trial_mode_expiration_dts?: string;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryConfigResponse
 */
export interface AccountsReceivableRetryConfigResponse {
    /**
     * 
     * @type {AccountsReceivableRetryConfig}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    config?: AccountsReceivableRetryConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    coupon_codes?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    emails?: Array<string>;
    /**
     * 
     * @type {ModelError}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    has_linked_accounts?: boolean;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AccountsReceivableRetryConfigResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryDayActivity
 */
export interface AccountsReceivableRetryDayActivity {
    /**
     * True if a charge attempt should be made on this day.  False means the order should be rejected on this day.
     * @type {boolean}
     * @memberof AccountsReceivableRetryDayActivity
     */
    charge?: boolean;
    /**
     * The coupon code that should be applied to this order.
     * @type {string}
     * @memberof AccountsReceivableRetryDayActivity
     */
    coupon_code?: string;
    /**
     * The number of days since the order placed in Accounts Receivable
     * @type {number}
     * @memberof AccountsReceivableRetryDayActivity
     */
    day?: number;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatAccount
 */
export interface AccountsReceivableRetryStatAccount {
    /**
     * 
     * @type {Array<AccountsReceivableRetryStatMetrics>}
     * @memberof AccountsReceivableRetryStatAccount
     */
    days?: Array<AccountsReceivableRetryStatMetrics>;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatAccount
     */
    merchant_id?: string;
    /**
     * 
     * @type {AccountsReceivableRetryStatMetrics}
     * @memberof AccountsReceivableRetryStatAccount
     */
    overall?: AccountsReceivableRetryStatMetrics;
    /**
     * 
     * @type {Array<AccountsReceivableRetryStatRevenue>}
     * @memberof AccountsReceivableRetryStatAccount
     */
    revenue_for_period?: Array<AccountsReceivableRetryStatRevenue>;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatMetrics
 */
export interface AccountsReceivableRetryStatMetrics {
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    attempts?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    attempts_formatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    conversion_rate?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    conversion_rate_formatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    day?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    discounts?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    discounts_formatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    revenue?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    revenue_formatted?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    successes?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatMetrics
     */
    successes_formatted?: string;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatRevenue
 */
export interface AccountsReceivableRetryStatRevenue {
    /**
     * 
     * @type {string}
     * @memberof AccountsReceivableRetryStatRevenue
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsReceivableRetryStatRevenue
     */
    revenue?: number;
}

/**
 * 
 * @export
 * @interface AccountsReceivableRetryStatsResponse
 */
export interface AccountsReceivableRetryStatsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<AccountsReceivableRetryStatAccount>}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    linked_accounts?: Array<AccountsReceivableRetryStatAccount>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {AccountsReceivableRetryStatAccount}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    overall?: AccountsReceivableRetryStatAccount;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AccountsReceivableRetryStatsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    metric?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    subject?: string;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    ts?: number;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface AddLibraryItemRequest
 */
export interface AddLibraryItemRequest {
    /**
     * Attributes associated with the library item to contain additional configuration.
     * @type {Array<LibraryItemAttribute>}
     * @memberof AddLibraryItemRequest
     */
    attributes?: Array<LibraryItemAttribute>;
    /**
     * Cjson to be added to library
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    cjson?: string;
    /**
     * flow, campaign, cjson, email, transactional_email, postcard or upsell
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    content_type?: string;
    /**
     * description of library item
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    description?: string;
    /**
     * Required if content_type is transactional_email. This is the name of the email template (html, not text).  This name should have a .vm file extension.  An example is auto_order_cancel_html.vm
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    email_name?: string;
    /**
     * Required if content_type is transactional_email. This is the full path to the email template stored in the file system.  This defines which StoreFront contains the desired email template.  An example is /themes/Elements/core/emails/auto_order_cancel_html.vm
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    email_path?: string;
    /**
     * Screenshot urls for display
     * @type {Array<LibraryItemScreenshot>}
     * @memberof AddLibraryItemRequest
     */
    screenshots?: Array<LibraryItemScreenshot>;
    /**
     * StoreFront oid where content originates necessary for tracking down relative assets
     * @type {number}
     * @memberof AddLibraryItemRequest
     */
    storefront_oid?: number;
    /**
     * title of library item, usually the name of the flow or campaign, or description of cjson
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    title?: string;
    /**
     * Required if content_type is upsell. This is object identifier of a StoreFront Upsell Offer.
     * @type {number}
     * @memberof AddLibraryItemRequest
     */
    upsell_offer_oid?: number;
    /**
     * UUID of communication flow, campaign, email, postcard, or null if this item is something else. transactional_email do not have a uuid because they are singleton objects within a storefront and easily identifiable by name
     * @type {string}
     * @memberof AddLibraryItemRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface AffiliateClick
 */
export interface AffiliateClick {
    /**
     * Unique object identifier for this click
     * @type {number}
     * @memberof AffiliateClick
     */
    affiliate_click_oid?: number;
    /**
     * Unique object identifier for for the link that this click is associated with
     * @type {number}
     * @memberof AffiliateClick
     */
    affiliate_link_oid?: number;
    /**
     * Affiliate object ID associated with this click
     * @type {number}
     * @memberof AffiliateClick
     */
    affiliate_oid?: number;
    /**
     * Date/time that the click was made
     * @type {string}
     * @memberof AffiliateClick
     */
    click_dts?: string;
    /**
     * IP address that generated the click
     * @type {string}
     * @memberof AffiliateClick
     */
    ip_address?: string;
    /**
     * URL of the landing page the customer was sent to.
     * @type {string}
     * @memberof AffiliateClick
     */
    landing_page?: string;
    /**
     * Query string on the landing page URL the customer was sent to.
     * @type {string}
     * @memberof AffiliateClick
     */
    landing_page_query_string?: string;
    /**
     * 
     * @type {AffiliateLink}
     * @memberof AffiliateClick
     */
    link?: AffiliateLink;
    /**
     * URL that referred the click (Browser Header Referer)
     * @type {string}
     * @memberof AffiliateClick
     */
    referrer?: string;
    /**
     * Query string that was on the referrer URL.
     * @type {string}
     * @memberof AffiliateClick
     */
    referrer_query_string?: string;
    /**
     * Sub ID value passed on the click
     * @type {string}
     * @memberof AffiliateClick
     */
    sub_id?: string;
}

/**
 * 
 * @export
 * @interface AffiliateClickQuery
 */
export interface AffiliateClickQuery {
    /**
     * Unique object identifier for for the link that this click is associated with
     * @type {number}
     * @memberof AffiliateClickQuery
     */
    affiliate_link_oid?: number;
    /**
     * Affiliate ID associated with the click
     * @type {number}
     * @memberof AffiliateClickQuery
     */
    affiliate_oid?: number;
    /**
     * Minimum click date/time to return
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    click_dts_begin?: string;
    /**
     * Maximum click date/time to return
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    click_dts_end?: string;
    /**
     * IP address that generated the click
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    ip_address?: string;
    /**
     * Sub ID value passed on the click
     * @type {string}
     * @memberof AffiliateClickQuery
     */
    sub_id?: string;
}

/**
 * 
 * @export
 * @interface AffiliateClicksResponse
 */
export interface AffiliateClicksResponse {
    /**
     * clicks
     * @type {Array<AffiliateClick>}
     * @memberof AffiliateClicksResponse
     */
    clicks?: Array<AffiliateClick>;
    /**
     * 
     * @type {ModelError}
     * @memberof AffiliateClicksResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AffiliateClicksResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AffiliateClicksResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AffiliateClicksResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AffiliateLedger
 */
export interface AffiliateLedger {
    /**
     * Unique object identifier for the click associated with this ledger entry
     * @type {number}
     * @memberof AffiliateLedger
     */
    affiliate_click_oid?: number;
    /**
     * Affiliate ledger object ID associated with this ledger
     * @type {number}
     * @memberof AffiliateLedger
     */
    affiliate_ledger_oid?: number;
    /**
     * Unique object identifier for the link that this click is associated with
     * @type {number}
     * @memberof AffiliateLedger
     */
    affiliate_link_oid?: number;
    /**
     * Affiliate object ID associated with this transaction
     * @type {number}
     * @memberof AffiliateLedger
     */
    affiliate_oid?: number;
    /**
     * User that assigned the transaction if it was done manually
     * @type {string}
     * @memberof AffiliateLedger
     */
    assigned_by_user?: string;
    /**
     * 
     * @type {AffiliateClick}
     * @memberof AffiliateLedger
     */
    click?: AffiliateClick;
    /**
     * Item ID associated with this transaction
     * @type {string}
     * @memberof AffiliateLedger
     */
    item_id?: string;
    /**
     * 
     * @type {AffiliateLink}
     * @memberof AffiliateLedger
     */
    link?: AffiliateLink;
    /**
     * 
     * @type {Order}
     * @memberof AffiliateLedger
     */
    order?: Order;
    /**
     * Order ID associated with this transaction
     * @type {string}
     * @memberof AffiliateLedger
     */
    order_id?: string;
    /**
     * Date/time of the original transaction for reversals
     * @type {string}
     * @memberof AffiliateLedger
     */
    original_transaction_dts?: string;
    /**
     * Sub ID associated with transaction (from the click)
     * @type {string}
     * @memberof AffiliateLedger
     */
    sub_id?: string;
    /**
     * Tier number that this transaction earned
     * @type {number}
     * @memberof AffiliateLedger
     */
    tier_number?: number;
    /**
     * Transaction amount
     * @type {number}
     * @memberof AffiliateLedger
     */
    transaction_amount?: number;
    /**
     * Amount of the transaction that has been paid out.
     * @type {number}
     * @memberof AffiliateLedger
     */
    transaction_amount_paid?: number;
    /**
     * Date/time that the transaction was made
     * @type {string}
     * @memberof AffiliateLedger
     */
    transaction_dts?: string;
    /**
     * Memo explaining the transaction
     * @type {string}
     * @memberof AffiliateLedger
     */
    transaction_memo?: string;
    /**
     * Percentage associated with this transaction
     * @type {number}
     * @memberof AffiliateLedger
     */
    transaction_percentage?: number;
    /**
     * Transaction state
     * @type {string}
     * @memberof AffiliateLedger
     */
    transaction_state?: AffiliateLedger.TransactionStateEnum;
}

/**
 * @export
 * @namespace AffiliateLedger
 */
export namespace AffiliateLedger {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}

/**
 * 
 * @export
 * @interface AffiliateLedgerQuery
 */
export interface AffiliateLedgerQuery {
    /**
     * Affiliate ID associated with the ledger
     * @type {number}
     * @memberof AffiliateLedgerQuery
     */
    affiliate_oid?: number;
    /**
     * Item id associated with the ledger entry
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    item_id?: string;
    /**
     * Order ID associated with the ledger entries
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    order_id?: string;
    /**
     * Sub ID value passed on the click that generated the ledger
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    sub_id?: string;
    /**
     * Minimum transaction date/time to return
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    transaction_dts_begin?: string;
    /**
     * Maximum transaction date/time to return
     * @type {string}
     * @memberof AffiliateLedgerQuery
     */
    transaction_dts_end?: string;
}

/**
 * 
 * @export
 * @interface AffiliateLedgersResponse
 */
export interface AffiliateLedgersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof AffiliateLedgersResponse
     */
    error?: ModelError;
    /**
     * ledgers
     * @type {Array<AffiliateLedger>}
     * @memberof AffiliateLedgersResponse
     */
    ledgers?: Array<AffiliateLedger>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AffiliateLedgersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AffiliateLedgersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AffiliateLedgersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AffiliateLink
 */
export interface AffiliateLink {
    /**
     * Unique object identifier associated with this link
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliate_link_oid?: number;
    /**
     * Managed link OID that this link object was generated from
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliate_managed_link_oid?: number;
    /**
     * Affiliate object ID associated with this link
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliate_oid?: number;
    /**
     * The affiliate program item this managed link is associated with
     * @type {number}
     * @memberof AffiliateLink
     */
    affiliate_program_item_oid?: number;
    /**
     * Code associated with the link
     * @type {string}
     * @memberof AffiliateLink
     */
    code?: string;
    /**
     * Creative (image or text) associated with this link
     * @type {number}
     * @memberof AffiliateLink
     */
    creative_oid?: number;
    /**
     * Custom HTML associated with this link
     * @type {string}
     * @memberof AffiliateLink
     */
    custom_html?: string;
    /**
     * Approved status of the custom html
     * @type {string}
     * @memberof AffiliateLink
     */
    custom_html_approval_status?: AffiliateLink.CustomHtmlApprovalStatusEnum;
    /**
     * Custom landing page URL if configured
     * @type {string}
     * @memberof AffiliateLink
     */
    custom_landing_url?: string;
    /**
     * True if the link has been deleted
     * @type {boolean}
     * @memberof AffiliateLink
     */
    deleted?: boolean;
    /**
     * Invisible link approval status
     * @type {string}
     * @memberof AffiliateLink
     */
    invisible_link_approval_status?: AffiliateLink.InvisibleLinkApprovalStatusEnum;
    /**
     * Invisible link URL prefix
     * @type {string}
     * @memberof AffiliateLink
     */
    invisible_link_url_prefix?: string;
    /**
     * Name of the link
     * @type {string}
     * @memberof AffiliateLink
     */
    name?: string;
    /**
     * Type of link
     * @type {string}
     * @memberof AffiliateLink
     */
    type?: AffiliateLink.TypeEnum;
}

/**
 * @export
 * @namespace AffiliateLink
 */
export namespace AffiliateLink {
    /**
     * @export
     * @enum {string}
     */
    export enum CustomHtmlApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InvisibleLinkApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Image = <any> 'image',
        Text = <any> 'text',
        Invisible = <any> 'invisible',
        Direct = <any> 'direct'
    }
}

/**
 * 
 * @export
 * @interface ApiUserApplicationProfile
 */
export interface ApiUserApplicationProfile {
    /**
     * Application logo URL
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    api_application_logo_url?: string;
    /**
     * Application description
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    application_description?: string;
    /**
     * Application name
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    application_name?: string;
    /**
     * Developer name
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    developer_name?: string;
    /**
     * Developer website
     * @type {string}
     * @memberof ApiUserApplicationProfile
     */
    developer_website?: string;
}

/**
 * 
 * @export
 * @interface ApplyLibraryItemRequest
 */
export interface ApplyLibraryItemRequest {
    /**
     * Normal emails are applied to an existing email object, so when requesting a library item to be applied to an email, supply the email uuid.  This is only for normal emails.  Transactional emails do not have a uuid.
     * @type {string}
     * @memberof ApplyLibraryItemRequest
     */
    email_uuid?: string;
    /**
     * Library item oid that you wish to apply to the given StoreFront
     * @type {number}
     * @memberof ApplyLibraryItemRequest
     */
    library_item_oid?: number;
    /**
     * The postcard uuid you wish to apply to a given StoreFront.
     * @type {string}
     * @memberof ApplyLibraryItemRequest
     */
    postcard_uuid?: string;
    /**
     * StoreFront oid where content originates necessary for tracking down relative assets
     * @type {number}
     * @memberof ApplyLibraryItemRequest
     */
    storefront_oid?: number;
}

/**
 * 
 * @export
 * @interface ApplyLibraryItemResponse
 */
export interface ApplyLibraryItemResponse {
    /**
     * Attributes from the library item
     * @type {Array<LibraryItemAttribute>}
     * @memberof ApplyLibraryItemResponse
     */
    attributes?: Array<LibraryItemAttribute>;
    /**
     * Cjson from library item, only populated if this library item was a cjson snippet or marketing email (not transactional)
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    cjson?: string;
    /**
     * flow, campaign, cjson, upsell, postcard, transactional_email or email
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    content_type?: string;
    /**
     * If a marketing email was applied, this is the path to the template encapsulating the cjson.  This is needed for the UltraCart UI.
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    email_template_vm_path?: string;
    /**
     * 
     * @type {ModelError}
     * @memberof ApplyLibraryItemResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ApplyLibraryItemResponse
     */
    metadata?: ResponseMetadata;
    /**
     * StoreFront oid where content originates necessary for tracking down relative assets
     * @type {number}
     * @memberof ApplyLibraryItemResponse
     */
    storefront_oid?: number;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ApplyLibraryItemResponse
     */
    success?: boolean;
    /**
     * title of library item, usually the name of the flow or campaign, or description of cjson
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    title?: string;
    /**
     * UUID of marketing email or communication flow/campaign if this library item was an email, campaign or flow
     * @type {string}
     * @memberof ApplyLibraryItemResponse
     */
    uuid?: string;
    /**
     * 
     * @type {Warning}
     * @memberof ApplyLibraryItemResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AutoOrder
 */
export interface AutoOrder {
    /**
     * Unique code assigned to this auto order
     * @type {string}
     * @memberof AutoOrder
     */
    auto_order_code?: string;
    /**
     * Auto order object identifier
     * @type {number}
     * @memberof AutoOrder
     */
    auto_order_oid?: number;
    /**
     * Cancel this auto order after X additional rebills
     * @type {number}
     * @memberof AutoOrder
     */
    cancel_after_next_x_orders?: number;
    /**
     * True if the auto order was canceled because the customer purchased a downgrade item
     * @type {boolean}
     * @memberof AutoOrder
     */
    cancel_downgrade?: boolean;
    /**
     * True if the auto order was canceled because the customer purchased an upgrade item
     * @type {boolean}
     * @memberof AutoOrder
     */
    cancel_upgrade?: boolean;
    /**
     * The user that canceled the auto order
     * @type {string}
     * @memberof AutoOrder
     */
    canceled_by_user?: string;
    /**
     * The date/time that the auto order was canceled
     * @type {string}
     * @memberof AutoOrder
     */
    canceled_dts?: string;
    /**
     * True if the auto order ran successfully to completion
     * @type {boolean}
     * @memberof AutoOrder
     */
    completed?: boolean;
    /**
     * The number of credit card attempts that have taken place
     * @type {number}
     * @memberof AutoOrder
     */
    credit_card_attempt?: number;
    /**
     * The date/time the auto order was disabled due to failed rebills
     * @type {string}
     * @memberof AutoOrder
     */
    disabled_dts?: string;
    /**
     * True if this auto order is enabled
     * @type {boolean}
     * @memberof AutoOrder
     */
    enabled?: boolean;
    /**
     * The reason this auto order failed during the last rebill attempt
     * @type {string}
     * @memberof AutoOrder
     */
    failure_reason?: string;
    /**
     * The items that are setup to rebill
     * @type {Array<AutoOrderItem>}
     * @memberof AutoOrder
     */
    items?: Array<AutoOrderItem>;
    /**
     * The next time that the auto order will be attempted for processing
     * @type {string}
     * @memberof AutoOrder
     */
    next_attempt?: string;
    /**
     * 
     * @type {Order}
     * @memberof AutoOrder
     */
    original_order?: Order;
    /**
     * The original order id that this auto order is associated with.
     * @type {string}
     * @memberof AutoOrder
     */
    original_order_id?: string;
    /**
     * Override the affiliate id given credit for rebills of this auto order
     * @type {number}
     * @memberof AutoOrder
     */
    override_affiliate_id?: number;
    /**
     * Rebill orders that have taken place on this auto order
     * @type {Array<Order>}
     * @memberof AutoOrder
     */
    rebill_orders?: Array<Order>;
    /**
     * The RTG code associated with this order for future rebills
     * @type {string}
     * @memberof AutoOrder
     */
    rotating_transaction_gateway_code?: string;
    /**
     * The status of the auto order
     * @type {string}
     * @memberof AutoOrder
     */
    status?: AutoOrder.StatusEnum;
}

/**
 * @export
 * @namespace AutoOrder
 */
export namespace AutoOrder {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}

/**
 * 
 * @export
 * @interface AutoOrderItem
 */
export interface AutoOrderItem {
    /**
     * Arbitrary item id that should be rebilled instead of the normal schedule
     * @type {string}
     * @memberof AutoOrderItem
     */
    arbitrary_item_id?: string;
    /**
     * An arbitrary percentage discount to provide on future rebills
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitrary_percentage_discount?: number;
    /**
     * Arbitrary quantity to rebill
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitrary_quantity?: number;
    /**
     * The number of days to rebill if the frequency is set to an arbitrary number of days
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitrary_schedule_days?: number;
    /**
     * Arbitrary unit cost that rebills of this item should occur at
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitrary_unit_cost?: number;
    /**
     * The number of rebills to give the arbitrary unit cost on before reverting to normal pricing.
     * @type {number}
     * @memberof AutoOrderItem
     */
    arbitrary_unit_cost_remaining_orders?: number;
    /**
     * Primary key of AutoOrderItem
     * @type {number}
     * @memberof AutoOrderItem
     */
    auto_order_item_oid?: number;
    /**
     * Frequency of the rebill if not a fixed schedule
     * @type {string}
     * @memberof AutoOrderItem
     */
    frequency?: AutoOrderItem.FrequencyEnum;
    /**
     * The future rebill schedule for this item up to the next ten rebills
     * @type {Array<AutoOrderItemFutureSchedule>}
     * @memberof AutoOrderItem
     */
    future_schedules?: Array<AutoOrderItemFutureSchedule>;
    /**
     * Date/time of the last order of this item
     * @type {string}
     * @memberof AutoOrderItem
     */
    last_order_dts?: string;
    /**
     * The life time value of this item including the original purchase
     * @type {number}
     * @memberof AutoOrderItem
     */
    life_time_value?: number;
    /**
     * The date/time of when the next pre-shipment notice should be sent
     * @type {string}
     * @memberof AutoOrderItem
     */
    next_preshipment_notice_dts?: string;
    /**
     * Date/time that this item is scheduled to rebill
     * @type {string}
     * @memberof AutoOrderItem
     */
    next_shipment_dts?: string;
    /**
     * Date/time after which no additional rebills of this item should occur
     * @type {string}
     * @memberof AutoOrderItem
     */
    no_order_after_dts?: string;
    /**
     * The number of times this item has rebilled
     * @type {number}
     * @memberof AutoOrderItem
     */
    number_of_rebills?: number;
    /**
     * Options associated with this item
     * @type {Array<AutoOrderItemOption>}
     * @memberof AutoOrderItem
     */
    options?: Array<AutoOrderItemOption>;
    /**
     * The original item id purchased.  This item controls scheduling.  If you wish to modify a schedule, for example, from monthly to yearly, change this item from your monthly item to your yearly item, and then change the next_shipment_dts to your desired date.
     * @type {string}
     * @memberof AutoOrderItem
     */
    original_item_id?: string;
    /**
     * The original quantity purchased
     * @type {number}
     * @memberof AutoOrderItem
     */
    original_quantity?: number;
    /**
     * The PayPal Payer ID tied to this item
     * @type {string}
     * @memberof AutoOrderItem
     */
    paypal_payer_id?: string;
    /**
     * The PayPal Profile ID tied to this item
     * @type {string}
     * @memberof AutoOrderItem
     */
    paypal_recurring_payment_profile_id?: string;
    /**
     * True if the preshipment notice associated with the next rebill has been sent
     * @type {boolean}
     * @memberof AutoOrderItem
     */
    preshipment_notice_sent?: boolean;
    /**
     * The value of the rebills of this item
     * @type {number}
     * @memberof AutoOrderItem
     */
    rebill_value?: number;
    /**
     * The number of rebills remaining before this item is complete
     * @type {number}
     * @memberof AutoOrderItem
     */
    remaining_repeat_count?: number;
    /**
     * 
     * @type {AutoOrderItemSimpleSchedule}
     * @memberof AutoOrderItem
     */
    simple_schedule?: AutoOrderItemSimpleSchedule;
}

/**
 * @export
 * @namespace AutoOrderItem
 */
export namespace AutoOrderItem {
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}

/**
 * 
 * @export
 * @interface AutoOrderItemFutureSchedule
 */
export interface AutoOrderItemFutureSchedule {
    /**
     * Item ID that should rebill
     * @type {string}
     * @memberof AutoOrderItemFutureSchedule
     */
    item_id?: string;
    /**
     * The number of times this rebill represents
     * @type {number}
     * @memberof AutoOrderItemFutureSchedule
     */
    rebill_count?: number;
    /**
     * Date/time that this item is scheduled to rebill
     * @type {string}
     * @memberof AutoOrderItemFutureSchedule
     */
    shipment_dts?: string;
    /**
     * The unit cost of the item rebilling
     * @type {number}
     * @memberof AutoOrderItemFutureSchedule
     */
    unit_cost?: number;
}

/**
 * 
 * @export
 * @interface AutoOrderItemOption
 */
export interface AutoOrderItemOption {
    /**
     * Label
     * @type {string}
     * @memberof AutoOrderItemOption
     */
    label?: string;
    /**
     * Value
     * @type {string}
     * @memberof AutoOrderItemOption
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface AutoOrderItemSimpleSchedule
 */
export interface AutoOrderItemSimpleSchedule {
    /**
     * Frequency of the rebill if not a fixed schedule
     * @type {string}
     * @memberof AutoOrderItemSimpleSchedule
     */
    frequency?: AutoOrderItemSimpleSchedule.FrequencyEnum;
    /**
     * Item ID that should rebill
     * @type {string}
     * @memberof AutoOrderItemSimpleSchedule
     */
    item_id?: string;
    /**
     * The number of times this simple schedule is configured for
     * @type {number}
     * @memberof AutoOrderItemSimpleSchedule
     */
    repeat_count?: number;
}

/**
 * @export
 * @namespace AutoOrderItemSimpleSchedule
 */
export namespace AutoOrderItemSimpleSchedule {
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}

/**
 * 
 * @export
 * @interface AutoOrderQuery
 */
export interface AutoOrderQuery {
    /**
     * Auto order code
     * @type {string}
     * @memberof AutoOrderQuery
     */
    auto_order_code?: string;
    /**
     * Card type
     * @type {string}
     * @memberof AutoOrderQuery
     */
    card_type?: string;
    /**
     * City
     * @type {string}
     * @memberof AutoOrderQuery
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof AutoOrderQuery
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof AutoOrderQuery
     */
    country_code?: string;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof AutoOrderQuery
     */
    customer_profile_oid?: number;
    /**
     * Email
     * @type {string}
     * @memberof AutoOrderQuery
     */
    email?: string;
    /**
     * First name
     * @type {string}
     * @memberof AutoOrderQuery
     */
    first_name?: string;
    /**
     * Item ID.  Deprecated query field.  This incorrectly meant the original order contained this item id.
     * @type {string}
     * @memberof AutoOrderQuery
     */
    item_id?: string;
    /**
     * Last name
     * @type {string}
     * @memberof AutoOrderQuery
     */
    last_name?: string;
    /**
     * Next Item ID that is supposed to ship.  This is calculated based upon the schedule associated with the original item id.
     * @type {string}
     * @memberof AutoOrderQuery
     */
    next_item_id?: string;
    /**
     * Next shipment date begin
     * @type {string}
     * @memberof AutoOrderQuery
     */
    next_shipment_date_begin?: string;
    /**
     * Next shipment date end
     * @type {string}
     * @memberof AutoOrderQuery
     */
    next_shipment_date_end?: string;
    /**
     * Original Item ID purchased on auto order.
     * @type {string}
     * @memberof AutoOrderQuery
     */
    original_item_id?: string;
    /**
     * Original order date begin
     * @type {string}
     * @memberof AutoOrderQuery
     */
    original_order_date_begin?: string;
    /**
     * Original order date end
     * @type {string}
     * @memberof AutoOrderQuery
     */
    original_order_date_end?: string;
    /**
     * Original order ID
     * @type {string}
     * @memberof AutoOrderQuery
     */
    original_order_id?: string;
    /**
     * Phone
     * @type {string}
     * @memberof AutoOrderQuery
     */
    phone?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof AutoOrderQuery
     */
    postal_code?: string;
    /**
     * State
     * @type {string}
     * @memberof AutoOrderQuery
     */
    state?: string;
    /**
     * Status
     * @type {string}
     * @memberof AutoOrderQuery
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface AutoOrderQueryBatch
 */
export interface AutoOrderQueryBatch {
    /**
     * Auto order oids
     * @type {Array<number>}
     * @memberof AutoOrderQueryBatch
     */
    auto_order_oids?: Array<number>;
}

/**
 * 
 * @export
 * @interface AutoOrderResponse
 */
export interface AutoOrderResponse {
    /**
     * 
     * @type {AutoOrder}
     * @memberof AutoOrderResponse
     */
    auto_order?: AutoOrder;
    /**
     * 
     * @type {ModelError}
     * @memberof AutoOrderResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AutoOrderResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AutoOrderResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AutoOrderResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AutoOrdersRequest
 */
export interface AutoOrdersRequest {
    /**
     * auto_orders
     * @type {Array<AutoOrder>}
     * @memberof AutoOrdersRequest
     */
    autoOrders?: Array<AutoOrder>;
}

/**
 * 
 * @export
 * @interface AutoOrdersResponse
 */
export interface AutoOrdersResponse {
    /**
     * 
     * @type {Array<AutoOrder>}
     * @memberof AutoOrdersResponse
     */
    auto_orders?: Array<AutoOrder>;
    /**
     * 
     * @type {ModelError}
     * @memberof AutoOrdersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof AutoOrdersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof AutoOrdersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof AutoOrdersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface AvalaraConfig
 */
export interface AvalaraConfig {
    /**
     * Avalara account ID
     * @type {string}
     * @memberof AvalaraConfig
     */
    account_id?: string;
    /**
     * True if Avalara is active for this merchant
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    active?: boolean;
    /**
     * Unique identifier for this avalara config object
     * @type {number}
     * @memberof AvalaraConfig
     */
    avalara_oid?: number;
    /**
     * Avalara company ID
     * @type {string}
     * @memberof AvalaraConfig
     */
    company_id?: string;
    /**
     * True if this Avalara configuration is set to enable tax valuation by UPC
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    enable_upc?: boolean;
    /**
     * True if this Avalara configuration is to estimate taxes only and not report placed orders to Avalara
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    estimate_only?: boolean;
    /**
     * Optional customer code for customers without profiles, defaults to GuestCustomer
     * @type {string}
     * @memberof AvalaraConfig
     */
    guest_customer_code?: string;
    /**
     * Date/time of the connection test to Avalara
     * @type {string}
     * @memberof AvalaraConfig
     */
    last_test_dts?: string;
    /**
     * Avalara license key
     * @type {string}
     * @memberof AvalaraConfig
     */
    license_key?: string;
    /**
     * True if this Avalara instance is pointed at the Avalara Sandbox
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    sandbox?: boolean;
    /**
     * Send test orders through to Avalara.  The default is to not transmit test orders to Avalara.
     * @type {boolean}
     * @memberof AvalaraConfig
     */
    send_test_orders?: boolean;
    /**
     * Avalara service URL
     * @type {string}
     * @memberof AvalaraConfig
     */
    service_url?: string;
    /**
     * Test results of the last connection test to Avalara
     * @type {string}
     * @memberof AvalaraConfig
     */
    test_results?: string;
}

/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof BaseResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof BaseResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof BaseResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof BaseResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * 
     * @type {CartAffiliate}
     * @memberof Cart
     */
    affiliate?: CartAffiliate;
    /**
     * The ISO-4217 three letter base currency code of the account
     * @type {string}
     * @memberof Cart
     */
    base_currency_code?: string;
    /**
     * 
     * @type {CartBilling}
     * @memberof Cart
     */
    billing?: CartBilling;
    /**
     * 
     * @type {CartBuysafe}
     * @memberof Cart
     */
    buysafe?: CartBuysafe;
    /**
     * Unique identifier for this cart
     * @type {string}
     * @memberof Cart
     */
    cart_id?: string;
    /**
     * 
     * @type {CartCheckout}
     * @memberof Cart
     */
    checkout?: CartCheckout;
    /**
     * Coupons
     * @type {Array<CartCoupon>}
     * @memberof Cart
     */
    coupons?: Array<CartCoupon>;
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof Cart
     */
    currency_code?: string;
    /**
     * 
     * @type {CartCurrencyConversion}
     * @memberof Cart
     */
    currency_conversion?: CartCurrencyConversion;
    /**
     * 
     * @type {CartCustomerProfile}
     * @memberof Cart
     */
    customer_profile?: CartCustomerProfile;
    /**
     * The exchange rate if the customer is viewing a different currency than the base
     * @type {number}
     * @memberof Cart
     */
    exchange_rate?: number;
    /**
     * 
     * @type {CartGift}
     * @memberof Cart
     */
    gift?: CartGift;
    /**
     * 
     * @type {CartGiftCertificate}
     * @memberof Cart
     */
    gift_certificate?: CartGiftCertificate;
    /**
     * Items
     * @type {Array<CartItem>}
     * @memberof Cart
     */
    items?: Array<CartItem>;
    /**
     * The ISO-631 three letter code the customer would like to checkout with
     * @type {string}
     * @memberof Cart
     */
    language_iso_code?: string;
    /**
     * True if the customer is logged into their profile
     * @type {boolean}
     * @memberof Cart
     */
    logged_in?: boolean;
    /**
     * 
     * @type {CartMarketing}
     * @memberof Cart
     */
    marketing?: CartMarketing;
    /**
     * Merchant ID this cart is associated with
     * @type {string}
     * @memberof Cart
     */
    merchant_id?: string;
    /**
     * 
     * @type {CartPayment}
     * @memberof Cart
     */
    payment?: CartPayment;
    /**
     * Properties associated with the cart
     * @type {Array<CartProperty>}
     * @memberof Cart
     */
    properties?: Array<CartProperty>;
    /**
     * 
     * @type {CartSettings}
     * @memberof Cart
     */
    settings?: CartSettings;
    /**
     * 
     * @type {CartShipping}
     * @memberof Cart
     */
    shipping?: CartShipping;
    /**
     * 
     * @type {CartSummary}
     * @memberof Cart
     */
    summary?: CartSummary;
    /**
     * 
     * @type {CartTaxes}
     * @memberof Cart
     */
    taxes?: CartTaxes;
    /**
     * 
     * @type {CartUpsellAfter}
     * @memberof Cart
     */
    upsell_after?: CartUpsellAfter;
}

/**
 * 
 * @export
 * @interface CartAffiliate
 */
export interface CartAffiliate {
    /**
     * Affiliate id associated with the cart
     * @type {number}
     * @memberof CartAffiliate
     */
    affiliate_id?: number;
    /**
     * Affiliate sub id associated with the cart
     * @type {string}
     * @memberof CartAffiliate
     */
    affiliate_sub_id?: string;
}

/**
 * 
 * @export
 * @interface CartAffirmCheckoutResponse
 */
export interface CartAffirmCheckoutResponse {
    /**
     * Checkout JSON object
     * @type {string}
     * @memberof CartAffirmCheckoutResponse
     */
    checkout_json?: string;
    /**
     * Errors that should be displayed to the customer
     * @type {Array<string>}
     * @memberof CartAffirmCheckoutResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartBilling
 */
export interface CartBilling {
    /**
     * Address line 1
     * @type {string}
     * @memberof CartBilling
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CartBilling
     */
    address2?: string;
    /**
     * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
     * @type {Array<string>}
     * @memberof CartBilling
     */
    cc_emails?: Array<string>;
    /**
     * City
     * @type {string}
     * @memberof CartBilling
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CartBilling
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CartBilling
     */
    country_code?: string;
    /**
     * Day phone
     * @type {string}
     * @memberof CartBilling
     */
    day_phone?: string;
    /**
     * Email
     * @type {string}
     * @memberof CartBilling
     */
    email?: string;
    /**
     * Email entered for confirmation
     * @type {string}
     * @memberof CartBilling
     */
    email_confirm?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof CartBilling
     */
    evening_phone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CartBilling
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CartBilling
     */
    last_name?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof CartBilling
     */
    postal_code?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CartBilling
     */
    state_region?: string;
    /**
     * Title
     * @type {string}
     * @memberof CartBilling
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CartBuysafe
 */
export interface CartBuysafe {
    /**
     * True if buySAFE is willing to bond the order
     * @type {boolean}
     * @memberof CartBuysafe
     */
    bond_available?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartBuysafe
     */
    bond_cost?: Currency;
    /**
     * True if the bond is free (merchant paying for it)
     * @type {boolean}
     * @memberof CartBuysafe
     */
    bond_free?: boolean;
    /**
     * True if the customer wants the bond
     * @type {boolean}
     * @memberof CartBuysafe
     */
    bond_wanted?: boolean;
    /**
     * Recommend text to display to the customer
     * @type {string}
     * @memberof CartBuysafe
     */
    cart_display_text?: string;
    /**
     * URL associated with the recommended text
     * @type {string}
     * @memberof CartBuysafe
     */
    cart_display_url?: string;
}

/**
 * 
 * @export
 * @interface CartCheckout
 */
export interface CartCheckout {
    /**
     * Comments from the customer.  Rarely used on the single page checkout.
     * @type {string}
     * @memberof CartCheckout
     */
    comments?: string;
    /**
     * Custom field 1
     * @type {string}
     * @memberof CartCheckout
     */
    custom_field1?: string;
    /**
     * Custom field 2
     * @type {string}
     * @memberof CartCheckout
     */
    custom_field2?: string;
    /**
     * Custom field 3
     * @type {string}
     * @memberof CartCheckout
     */
    custom_field3?: string;
    /**
     * Custom field 4
     * @type {string}
     * @memberof CartCheckout
     */
    custom_field4?: string;
    /**
     * Custom field 5
     * @type {string}
     * @memberof CartCheckout
     */
    custom_field5?: string;
    /**
     * Custom field 6
     * @type {string}
     * @memberof CartCheckout
     */
    custom_field6?: string;
    /**
     * Custom field 7
     * @type {string}
     * @memberof CartCheckout
     */
    custom_field7?: string;
    /**
     * IP Address (read only unless non-browser key authenticated)
     * @type {string}
     * @memberof CartCheckout
     */
    ip_address?: string;
    /**
     * Return code assigned for send return email operation
     * @type {string}
     * @memberof CartCheckout
     */
    return_code?: string;
    /**
     * The URL to redirect the customer to when they return from an abandon cart email.  Must be https protocol.
     * @type {string}
     * @memberof CartCheckout
     */
    return_url?: string;
    /**
     * Screen branding theme code
     * @type {string}
     * @memberof CartCheckout
     */
    screen_branding_theme_code?: string;
    /**
     * StoreFront Host Name
     * @type {string}
     * @memberof CartCheckout
     */
    storefront_host_name?: string;
    /**
     * User agent of the browser
     * @type {string}
     * @memberof CartCheckout
     */
    user_agent?: string;
}

/**
 * 
 * @export
 * @interface CartCoupon
 */
export interface CartCoupon {
    /**
     * Coupon code
     * @type {string}
     * @memberof CartCoupon
     */
    coupon_code?: string;
}

/**
 * 
 * @export
 * @interface CartCurrencyConversion
 */
export interface CartCurrencyConversion {
    /**
     * Base currency code for this merchant
     * @type {string}
     * @memberof CartCurrencyConversion
     */
    base_currency_Code?: string;
    /**
     * Conversion information for 1 unit of base currency to target currencies
     * @type {Array<Currency>}
     * @memberof CartCurrencyConversion
     */
    currencies?: Array<Currency>;
}

/**
 * 
 * @export
 * @interface CartCustomerProfile
 */
export interface CartCustomerProfile {
    /**
     * True if profile is allowed to bill to their 3rd party shipping account
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    allow_3rd_party_billing?: boolean;
    /**
     * True if this profile is allowed to use a COD
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    allow_cod?: boolean;
    /**
     * True if this profile is allowed to use a purchase order
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    allow_purchase_order?: boolean;
    /**
     * Billing addresses on file for this profile
     * @type {Array<CartCustomerProfileAddress>}
     * @memberof CartCustomerProfile
     */
    billing_addresses?: Array<CartCustomerProfileAddress>;
    /**
     * Credit cards on file for this profile (masked)
     * @type {Array<CartCustomerProfileCreditCard>}
     * @memberof CartCustomerProfile
     */
    credit_cards?: Array<CartCustomerProfileCreditCard>;
    /**
     * Unique identifier
     * @type {number}
     * @memberof CartCustomerProfile
     */
    customer_profile_oid?: number;
    /**
     * DHL account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    dhl_account_number?: string;
    /**
     * DHL duty account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    dhl_duty_account_number?: string;
    /**
     * Email
     * @type {string}
     * @memberof CartCustomerProfile
     */
    email?: string;
    /**
     * FedEx account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    fedex_account_number?: string;
    /**
     * True if this profile always qualifies for free shipping
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    free_shipping?: boolean;
    /**
     * The minimum aount that this profile has to purchase to qualify for free shipping
     * @type {number}
     * @memberof CartCustomerProfile
     */
    free_shipping_minimum?: number;
    /**
     * Maximum item count this profile can purchase
     * @type {number}
     * @memberof CartCustomerProfile
     */
    maximum_item_count?: number;
    /**
     * Minimum item count this profile must purchase
     * @type {number}
     * @memberof CartCustomerProfile
     */
    minimum_item_count?: number;
    /**
     * Minimum subtotal this profile must purchase
     * @type {number}
     * @memberof CartCustomerProfile
     */
    minimum_subtotal?: number;
    /**
     * True if this profile is prevented from using coupons
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    no_coupons?: boolean;
    /**
     * True if this profile is never given free shipping
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    no_free_shipping?: boolean;
    /**
     * True if this customers orders are not charged in real-time
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    no_realtime_charge?: boolean;
    /**
     * Pricing tier names this profile qualifies for
     * @type {Array<string>}
     * @memberof CartCustomerProfile
     */
    pricing_tiers?: Array<string>;
    /**
     * Shipping addresses on file for this profile
     * @type {Array<CartCustomerProfileAddress>}
     * @memberof CartCustomerProfile
     */
    shipping_addresses?: Array<CartCustomerProfileAddress>;
    /**
     * True if this profile is exempt from sales tax
     * @type {boolean}
     * @memberof CartCustomerProfile
     */
    tax_exempt?: boolean;
    /**
     * UPS account number on file
     * @type {string}
     * @memberof CartCustomerProfile
     */
    ups_account_number?: string;
}

/**
 * 
 * @export
 * @interface CartCustomerProfileAddress
 */
export interface CartCustomerProfileAddress {
    /**
     * Address 1
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    address1?: string;
    /**
     * Address 2
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    company?: string;
    /**
     * ISO-3166 Country code
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    country_code?: string;
    /**
     * Day phone
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    day_phone?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    evening_phone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    last_name?: string;
    /**
     * Unique identifier for this address
     * @type {number}
     * @memberof CartCustomerProfileAddress
     */
    oid?: number;
    /**
     * Postal code
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    postal_code?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    state_region?: string;
    /**
     * Tax county if a billing address
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    tax_county?: string;
    /**
     * Title
     * @type {string}
     * @memberof CartCustomerProfileAddress
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CartCustomerProfileCreditCard
 */
export interface CartCustomerProfileCreditCard {
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof CartCustomerProfileCreditCard
     */
    card_expiration_month?: number;
    /**
     * Card expiration year (four digit)
     * @type {number}
     * @memberof CartCustomerProfileCreditCard
     */
    card_expiration_year?: number;
    /**
     * Card number (masked last 4 digits)
     * @type {string}
     * @memberof CartCustomerProfileCreditCard
     */
    card_number?: string;
    /**
     * Card type
     * @type {string}
     * @memberof CartCustomerProfileCreditCard
     */
    card_type?: CartCustomerProfileCreditCard.CardTypeEnum;
    /**
     * Unique identifier for this stored card
     * @type {number}
     * @memberof CartCustomerProfileCreditCard
     */
    customer_profile_credit_card_id?: number;
    /**
     * Last used
     * @type {string}
     * @memberof CartCustomerProfileCreditCard
     */
    last_used_date?: string;
}

/**
 * @export
 * @namespace CartCustomerProfileCreditCard
 */
export namespace CartCustomerProfileCreditCard {
    /**
     * @export
     * @enum {string}
     */
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        MasterCard = <any> 'MasterCard',
        JCB = <any> 'JCB',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface CartFinalizeOrderRequest
 */
export interface CartFinalizeOrderRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartFinalizeOrderRequest
     */
    cart?: Cart;
    /**
     * 
     * @type {CartFinalizeOrderRequestOptions}
     * @memberof CartFinalizeOrderRequest
     */
    options?: CartFinalizeOrderRequestOptions;
}

/**
 * 
 * @export
 * @interface CartFinalizeOrderRequestOptions
 */
export interface CartFinalizeOrderRequestOptions {
    /**
     * Automatically approve the purchase order
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    auto_approve_purchase_order?: boolean;
    /**
     * Channel partner code to associate this order with
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    channel_partner_code?: string;
    /**
     * Channel partner oid to associate this order with
     * @type {number}
     * @memberof CartFinalizeOrderRequestOptions
     */
    channel_partner_oid?: number;
    /**
     * Channel partner order id for reference
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    channel_partner_order_id?: string;
    /**
     * Consider this order a recurring order for the purposes of payment gateway recurring flag
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    consider_recurring?: boolean;
    /**
     * If the order was authorized outside of UltraCart, this is the amount of the authorization
     * @type {number}
     * @memberof CartFinalizeOrderRequestOptions
     */
    credit_card_authorization_amount?: number;
    /**
     * If the order was authorized outside of UltraCart, this is the date/time of the authorization
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    credit_card_authorization_date?: string;
    /**
     * If the order was authorized outside of UltraCart, this is the authorization reference number
     * @type {string}
     * @memberof CartFinalizeOrderRequestOptions
     */
    credit_card_authorization_reference_number?: string;
    /**
     * Prevents normal real-time processing of the payment and sends the order to Accounts Receivable
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    no_realtime_payment_processing?: boolean;
    /**
     * True if the system should create another cart automatically if the current cart was logged into a profile
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    setup_next_cart?: boolean;
    /**
     * Skip payment processing and move the order on to shipping (or completed if no shipping required)
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    skip_payment_processing?: boolean;
    /**
     * True the order in the completed stage
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    store_completed?: boolean;
    /**
     * Store the order in accounts receivable if the payment declines
     * @type {boolean}
     * @memberof CartFinalizeOrderRequestOptions
     */
    store_if_payment_declines?: boolean;
}

/**
 * 
 * @export
 * @interface CartFinalizeOrderResponse
 */
export interface CartFinalizeOrderResponse {
    /**
     * Error messages if the order could not be completed
     * @type {Array<string>}
     * @memberof CartFinalizeOrderResponse
     */
    errors?: Array<string>;
    /**
     * 
     * @type {Cart}
     * @memberof CartFinalizeOrderResponse
     */
    next_cart?: Cart;
    /**
     * 
     * @type {Order}
     * @memberof CartFinalizeOrderResponse
     */
    order?: Order;
    /**
     * Order ID assigned to the order
     * @type {string}
     * @memberof CartFinalizeOrderResponse
     */
    order_id?: string;
    /**
     * True if the cart was converted successfully to an order
     * @type {boolean}
     * @memberof CartFinalizeOrderResponse
     */
    successful?: boolean;
}

/**
 * 
 * @export
 * @interface CartGift
 */
export interface CartGift {
    /**
     * True if this order is a gift
     * @type {boolean}
     * @memberof CartGift
     */
    gift?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartGift
     */
    gift_charge?: Currency;
    /**
     * Email address of the gift recipient
     * @type {string}
     * @memberof CartGift
     */
    gift_email?: string;
    /**
     * Message to the gift recipient
     * @type {string}
     * @memberof CartGift
     */
    gift_message?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartGift
     */
    gift_wrap_cost?: Currency;
    /**
     * Title of the selected gift wrap
     * @type {string}
     * @memberof CartGift
     */
    gift_wrap_title?: string;
}

/**
 * 
 * @export
 * @interface CartGiftCertificate
 */
export interface CartGiftCertificate {
    /**
     * 
     * @type {Currency}
     * @memberof CartGiftCertificate
     */
    gift_certificate_amount?: Currency;
    /**
     * Gift certificate code
     * @type {string}
     * @memberof CartGiftCertificate
     */
    gift_certificate_code?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartGiftCertificate
     */
    gift_certificate_remaining_balance_after_order?: Currency;
}

/**
 * 
 * @export
 * @interface CartItem
 */
export interface CartItem {
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    arbitrary_unit_cost?: Currency;
    /**
     * Attributes
     * @type {Array<CartItemAttribute>}
     * @memberof CartItem
     */
    attributes?: Array<CartItemAttribute>;
    /**
     * Auto order schedule the customer selected
     * @type {string}
     * @memberof CartItem
     */
    auto_order_schedule?: string;
    /**
     * URL to the default multimedia image
     * @type {string}
     * @memberof CartItem
     */
    default_image_url?: string;
    /**
     * URL to the default multimedia thumbnail
     * @type {string}
     * @memberof CartItem
     */
    default_thumbnail_url?: string;
    /**
     * Description of the item
     * @type {string}
     * @memberof CartItem
     */
    description?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    discount?: Currency;
    /**
     * Extended description of the item
     * @type {string}
     * @memberof CartItem
     */
    extended_description?: string;
    /**
     * Item ID
     * @type {string}
     * @memberof CartItem
     */
    item_id?: string;
    /**
     * Item object identifier
     * @type {number}
     * @memberof CartItem
     */
    item_oid?: number;
    /**
     * True if this item is a kit
     * @type {boolean}
     * @memberof CartItem
     */
    kit?: boolean;
    /**
     * Options associated with the kit components
     * @type {Array<CartKitComponentOption>}
     * @memberof CartItem
     */
    kit_component_options?: Array<CartKitComponentOption>;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    manufacturer_suggested_retail_price?: Currency;
    /**
     * Maximum quantity the customer can purchase
     * @type {number}
     * @memberof CartItem
     */
    maximum_quantity?: number;
    /**
     * Minimum quantity the customer can purchase
     * @type {number}
     * @memberof CartItem
     */
    minimum_quantity?: number;
    /**
     * Multimedia
     * @type {Array<CartItemMultimedia>}
     * @memberof CartItem
     */
    multimedia?: Array<CartItemMultimedia>;
    /**
     * Options
     * @type {Array<CartItemOption>}
     * @memberof CartItem
     */
    options?: Array<CartItemOption>;
    /**
     * 
     * @type {CartItemPhysical}
     * @memberof CartItem
     */
    phsyical?: CartItemPhysical;
    /**
     * Position of the item in the cart
     * @type {number}
     * @memberof CartItem
     */
    position?: number;
    /**
     * True if this item is on pre-order
     * @type {boolean}
     * @memberof CartItem
     */
    preorder?: boolean;
    /**
     * quantity
     * @type {number}
     * @memberof CartItem
     */
    quantity?: number;
    /**
     * Customer selectable auto order schedules
     * @type {Array<string>}
     * @memberof CartItem
     */
    schedules?: Array<string>;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    total_cost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    total_cost_with_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    unit_cost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItem
     */
    unit_cost_with_discount?: Currency;
    /**
     * True if this item was added to the cart as part of an upsell
     * @type {boolean}
     * @memberof CartItem
     */
    upsell?: boolean;
    /**
     * Variations
     * @type {Array<CartItemVariationSelection>}
     * @memberof CartItem
     */
    variations?: Array<CartItemVariationSelection>;
    /**
     * URL to view the product on the site
     * @type {string}
     * @memberof CartItem
     */
    view_url?: string;
}

/**
 * 
 * @export
 * @interface CartItemAttribute
 */
export interface CartItemAttribute {
    /**
     * Name of the attribute
     * @type {string}
     * @memberof CartItemAttribute
     */
    name?: string;
    /**
     * Type of attribute
     * @type {string}
     * @memberof CartItemAttribute
     */
    type?: string;
    /**
     * Value of the attribute
     * @type {string}
     * @memberof CartItemAttribute
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface CartItemMultimedia
 */
export interface CartItemMultimedia {
    /**
     * Code assigned to the multimedia
     * @type {string}
     * @memberof CartItemMultimedia
     */
    code?: string;
    /**
     * Description
     * @type {string}
     * @memberof CartItemMultimedia
     */
    description?: string;
    /**
     * True if the image should be excluded from galleries
     * @type {boolean}
     * @memberof CartItemMultimedia
     */
    exclude_from_gallery?: boolean;
    /**
     * Image height
     * @type {number}
     * @memberof CartItemMultimedia
     */
    image_height?: number;
    /**
     * Image width
     * @type {number}
     * @memberof CartItemMultimedia
     */
    image_width?: number;
    /**
     * True if the multimedia is the default for this type
     * @type {boolean}
     * @memberof CartItemMultimedia
     */
    is_default?: boolean;
    /**
     * Thumbnails of the images
     * @type {Array<CartItemMultimediaThumbnail>}
     * @memberof CartItemMultimedia
     */
    thumbnails?: Array<CartItemMultimediaThumbnail>;
    /**
     * Type of multimedia
     * @type {string}
     * @memberof CartItemMultimedia
     */
    type?: CartItemMultimedia.TypeEnum;
    /**
     * URL to view multimedia at
     * @type {string}
     * @memberof CartItemMultimedia
     */
    url?: string;
}

/**
 * @export
 * @namespace CartItemMultimedia
 */
export namespace CartItemMultimedia {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}

/**
 * 
 * @export
 * @interface CartItemMultimediaThumbnail
 */
export interface CartItemMultimediaThumbnail {
    /**
     * Height in pixels
     * @type {number}
     * @memberof CartItemMultimediaThumbnail
     */
    height?: number;
    /**
     * True if thumbnail is a PNG, otherwise its a JPEG
     * @type {boolean}
     * @memberof CartItemMultimediaThumbnail
     */
    png?: boolean;
    /**
     * True if the thumbnail is square
     * @type {boolean}
     * @memberof CartItemMultimediaThumbnail
     */
    square?: boolean;
    /**
     * URL for the thumbnail
     * @type {string}
     * @memberof CartItemMultimediaThumbnail
     */
    url?: string;
    /**
     * Width in pixels
     * @type {number}
     * @memberof CartItemMultimediaThumbnail
     */
    width?: number;
}

/**
 * 
 * @export
 * @interface CartItemOption
 */
export interface CartItemOption {
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOption
     */
    cost_if_specified?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOption
     */
    cost_per_letter?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOption
     */
    cost_per_line?: Currency;
    /**
     * True if the default answer is ignored
     * @type {boolean}
     * @memberof CartItemOption
     */
    ignore_if_default?: boolean;
    /**
     * Display label for the option
     * @type {string}
     * @memberof CartItemOption
     */
    label?: string;
    /**
     * Name of the option
     * @type {string}
     * @memberof CartItemOption
     */
    name?: string;
    /**
     * Charge the fee a single time instead of multiplying by the quantity
     * @type {boolean}
     * @memberof CartItemOption
     */
    one_time_fee?: boolean;
    /**
     * Unique identifier for the option
     * @type {number}
     * @memberof CartItemOption
     */
    option_oid?: number;
    /**
     * True if the customer is required to select a value
     * @type {boolean}
     * @memberof CartItemOption
     */
    required?: boolean;
    /**
     * The value of the option specified by the customer
     * @type {string}
     * @memberof CartItemOption
     */
    selected_value?: string;
    /**
     * Type of option
     * @type {string}
     * @memberof CartItemOption
     */
    type?: CartItemOption.TypeEnum;
    /**
     * Values that the customer can select from for radio or select type options
     * @type {Array<CartItemOptionValue>}
     * @memberof CartItemOption
     */
    values?: Array<CartItemOptionValue>;
}

/**
 * @export
 * @namespace CartItemOption
 */
export namespace CartItemOption {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}

/**
 * 
 * @export
 * @interface CartItemOptionValue
 */
export interface CartItemOptionValue {
    /**
     * 
     * @type {Currency}
     * @memberof CartItemOptionValue
     */
    additional_cost?: Currency;
    /**
     * 
     * @type {Weight}
     * @memberof CartItemOptionValue
     */
    additional_weight?: Weight;
    /**
     * True if this is the default value
     * @type {boolean}
     * @memberof CartItemOptionValue
     */
    default_value?: boolean;
    /**
     * Display order of the option value
     * @type {number}
     * @memberof CartItemOptionValue
     */
    display_order?: number;
    /**
     * Value of the option the customer can select
     * @type {string}
     * @memberof CartItemOptionValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface CartItemPhysical
 */
export interface CartItemPhysical {
    /**
     * 
     * @type {Distance}
     * @memberof CartItemPhysical
     */
    height?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof CartItemPhysical
     */
    length?: Distance;
    /**
     * 
     * @type {Weight}
     * @memberof CartItemPhysical
     */
    weight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof CartItemPhysical
     */
    width?: Distance;
}

/**
 * 
 * @export
 * @interface CartItemVariationSelection
 */
export interface CartItemVariationSelection {
    /**
     * Variation name
     * @type {string}
     * @memberof CartItemVariationSelection
     */
    variation_name?: string;
    /**
     * Variation value
     * @type {string}
     * @memberof CartItemVariationSelection
     */
    variation_value?: string;
}

/**
 * 
 * @export
 * @interface CartKitComponentOption
 */
export interface CartKitComponentOption {
    /**
     * 
     * @type {Currency}
     * @memberof CartKitComponentOption
     */
    cost_if_specified?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartKitComponentOption
     */
    cost_per_letter?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartKitComponentOption
     */
    cost_per_line?: Currency;
    /**
     * True if the default answer is ignored
     * @type {boolean}
     * @memberof CartKitComponentOption
     */
    ignore_if_default?: boolean;
    /**
     * Kit component item id
     * @type {string}
     * @memberof CartKitComponentOption
     */
    item_id?: string;
    /**
     * Unique identifier for the kit component item
     * @type {number}
     * @memberof CartKitComponentOption
     */
    item_oid?: number;
    /**
     * Display label for the option
     * @type {string}
     * @memberof CartKitComponentOption
     */
    label?: string;
    /**
     * Name of the option
     * @type {string}
     * @memberof CartKitComponentOption
     */
    name?: string;
    /**
     * Charge the fee a single time instead of multiplying by the quantity
     * @type {boolean}
     * @memberof CartKitComponentOption
     */
    one_time_fee?: boolean;
    /**
     * Unique identifier for the option
     * @type {number}
     * @memberof CartKitComponentOption
     */
    option_oid?: number;
    /**
     * True if the customer is required to select a value
     * @type {boolean}
     * @memberof CartKitComponentOption
     */
    required?: boolean;
    /**
     * The value of the option specified by the customer
     * @type {string}
     * @memberof CartKitComponentOption
     */
    selected_value?: string;
    /**
     * Type of option
     * @type {string}
     * @memberof CartKitComponentOption
     */
    type?: CartKitComponentOption.TypeEnum;
    /**
     * Values that the customer can select from for radio or select type options
     * @type {Array<CartItemOptionValue>}
     * @memberof CartKitComponentOption
     */
    values?: Array<CartItemOptionValue>;
}

/**
 * @export
 * @namespace CartKitComponentOption
 */
export namespace CartKitComponentOption {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}

/**
 * 
 * @export
 * @interface CartMarketing
 */
export interface CartMarketing {
    /**
     * The advertising source the customer indicated
     * @type {string}
     * @memberof CartMarketing
     */
    advertising_source?: string;
    /**
     * True if the customer agrees to receiving marketing emails
     * @type {boolean}
     * @memberof CartMarketing
     */
    mailing_list_opt_in?: boolean;
}

/**
 * 
 * @export
 * @interface CartPayment
 */
export interface CartPayment {
    /**
     * 
     * @type {CartPaymentAffirm}
     * @memberof CartPayment
     */
    affirm?: CartPaymentAffirm;
    /**
     * 
     * @type {CartPaymentAmazon}
     * @memberof CartPayment
     */
    amazon?: CartPaymentAmazon;
    /**
     * 
     * @type {CartPaymentCheck}
     * @memberof CartPayment
     */
    check?: CartPaymentCheck;
    /**
     * 
     * @type {CartPaymentCreditCard}
     * @memberof CartPayment
     */
    credit_card?: CartPaymentCreditCard;
    /**
     * Payment method
     * @type {string}
     * @memberof CartPayment
     */
    payment_method?: string;
    /**
     * 
     * @type {CartPaymentPurchaseOrder}
     * @memberof CartPayment
     */
    purchase_order?: CartPaymentPurchaseOrder;
    /**
     * Rotating transaction gateway code
     * @type {string}
     * @memberof CartPayment
     */
    rtg_code?: string;
}

/**
 * 
 * @export
 * @interface CartPaymentAffirm
 */
export interface CartPaymentAffirm {
    /**
     * Affirm checkout token
     * @type {string}
     * @memberof CartPaymentAffirm
     */
    affirm_checkout_token?: string;
}

/**
 * 
 * @export
 * @interface CartPaymentAmazon
 */
export interface CartPaymentAmazon {
    /**
     * Amazon order reference id
     * @type {string}
     * @memberof CartPaymentAmazon
     */
    amazon_order_reference_id?: string;
}

/**
 * 
 * @export
 * @interface CartPaymentCheck
 */
export interface CartPaymentCheck {
    /**
     * Check number they are paying with
     * @type {number}
     * @memberof CartPaymentCheck
     */
    check_number?: number;
}

/**
 * 
 * @export
 * @interface CartPaymentCreditCard
 */
export interface CartPaymentCreditCard {
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof CartPaymentCreditCard
     */
    card_expiration_month?: number;
    /**
     * Card expiration year (four digit year)
     * @type {number}
     * @memberof CartPaymentCreditCard
     */
    card_expiration_year?: number;
    /**
     * Card number (masked to the last 4)
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    card_number?: string;
    /**
     * Hosted field token for the card number
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    card_number_token?: string;
    /**
     * Card type
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    card_type?: string;
    /**
     * Card verification number (masked)
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    card_verification_number?: string;
    /**
     * Hosted field token for the card verification number
     * @type {string}
     * @memberof CartPaymentCreditCard
     */
    card_verification_number_token?: string;
    /**
     * ID of the stored credit card to use
     * @type {number}
     * @memberof CartPaymentCreditCard
     */
    customer_profile_credit_card_id?: number;
    /**
     * True if the customer wants to store the card on their profile for future re-use
     * @type {boolean}
     * @memberof CartPaymentCreditCard
     */
    store_credit_card?: boolean;
}

/**
 * 
 * @export
 * @interface CartPaymentPurchaseOrder
 */
export interface CartPaymentPurchaseOrder {
    /**
     * Purchase order number
     * @type {string}
     * @memberof CartPaymentPurchaseOrder
     */
    purchase_order_number?: string;
}

/**
 * 
 * @export
 * @interface CartProfileLoginRequest
 */
export interface CartProfileLoginRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileLoginRequest
     */
    cart?: Cart;
    /**
     * Unique identifier for customer profile.  Can not be used with browser key authentication type.
     * @type {number}
     * @memberof CartProfileLoginRequest
     */
    customer_profile_oid?: number;
    /**
     * Password for the profile
     * @type {string}
     * @memberof CartProfileLoginRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface CartProfileLoginResponse
 */
export interface CartProfileLoginResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileLoginResponse
     */
    cart?: Cart;
    /**
     * Errors to display to the customer if they failed any of the validations checked
     * @type {Array<string>}
     * @memberof CartProfileLoginResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartProfileRegisterRequest
 */
export interface CartProfileRegisterRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileRegisterRequest
     */
    cart?: Cart;
    /**
     * Password for the profile
     * @type {string}
     * @memberof CartProfileRegisterRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface CartProfileRegisterResponse
 */
export interface CartProfileRegisterResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartProfileRegisterResponse
     */
    cart?: Cart;
    /**
     * Errors to display to the customer if they failed any of the validations checked
     * @type {Array<string>}
     * @memberof CartProfileRegisterResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartProperty
 */
export interface CartProperty {
    /**
     * True if this property is displayed to the customer
     * @type {boolean}
     * @memberof CartProperty
     */
    display?: boolean;
    /**
     * The date/time that the property expires and is deleted
     * @type {string}
     * @memberof CartProperty
     */
    expiration_dts?: string;
    /**
     * Name
     * @type {string}
     * @memberof CartProperty
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof CartProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface CartResponse
 */
export interface CartResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartResponse
     */
    cart?: Cart;
    /**
     * Errors that should be displayed to the customer
     * @type {Array<string>}
     * @memberof CartResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartSettings
 */
export interface CartSettings {
    /**
     * 
     * @type {CartSettingsBilling}
     * @memberof CartSettings
     */
    billing?: CartSettingsBilling;
    /**
     * 
     * @type {CartSettingsGift}
     * @memberof CartSettings
     */
    gift?: CartSettingsGift;
    /**
     * 
     * @type {CartSettingsPayment}
     * @memberof CartSettings
     */
    payment?: CartSettingsPayment;
    /**
     * 
     * @type {CartSettingsShipping}
     * @memberof CartSettings
     */
    shipping?: CartSettingsShipping;
    /**
     * 
     * @type {CartSettingsTaxes}
     * @memberof CartSettings
     */
    taxes?: CartSettingsTaxes;
    /**
     * 
     * @type {CartSettingsTerms}
     * @memberof CartSettings
     */
    terms?: CartSettingsTerms;
}

/**
 * 
 * @export
 * @interface CartSettingsBilling
 */
export interface CartSettingsBilling {
    /**
     * Provinces
     * @type {Array<CartSettingsProvince>}
     * @memberof CartSettingsBilling
     */
    provinces?: Array<CartSettingsProvince>;
}

/**
 * 
 * @export
 * @interface CartSettingsGift
 */
export interface CartSettingsGift {
    /**
     * True if this checkout supports gift giving
     * @type {boolean}
     * @memberof CartSettingsGift
     */
    allow_gifts?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsGift
     */
    gift_charge?: Currency;
    /**
     * The gift wraps available for the customer to select from
     * @type {Array<CartSettingsGiftWrap>}
     * @memberof CartSettingsGift
     */
    gift_wraps?: Array<CartSettingsGiftWrap>;
    /**
     * The maximum length of the gift message the giver can enter
     * @type {number}
     * @memberof CartSettingsGift
     */
    max_message_length?: number;
}

/**
 * 
 * @export
 * @interface CartSettingsGiftWrap
 */
export interface CartSettingsGiftWrap {
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsGiftWrap
     */
    cost?: Currency;
    /**
     * Title of the gift wrap
     * @type {string}
     * @memberof CartSettingsGiftWrap
     */
    title?: string;
    /**
     * URL for the sample of the gift wrap
     * @type {string}
     * @memberof CartSettingsGiftWrap
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsPayment
 */
export interface CartSettingsPayment {
    /**
     * 
     * @type {CartSettingsPaymentAmazon}
     * @memberof CartSettingsPayment
     */
    amazon?: CartSettingsPaymentAmazon;
    /**
     * 
     * @type {CartSettingsPaymentCreditCard}
     * @memberof CartSettingsPayment
     */
    credit_card?: CartSettingsPaymentCreditCard;
    /**
     * True if this card requires a payment from the customer
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    need_payment?: boolean;
    /**
     * 
     * @type {CartSettingsPaymentPayPal}
     * @memberof CartSettingsPayment
     */
    paypal?: CartSettingsPaymentPayPal;
    /**
     * True if Amazon payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_amazon?: boolean;
    /**
     * True if check payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_check?: boolean;
    /**
     * True if COD payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_cod?: boolean;
    /**
     * True if credit card payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_credit_card?: boolean;
    /**
     * True if money order payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_money_order?: boolean;
    /**
     * True if PayPal payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_paypal?: boolean;
    /**
     * True if purchase order payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_purchase_order?: boolean;
    /**
     * True if quote requests payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_quote_request?: boolean;
    /**
     * True if wire transfer payments are available on this order
     * @type {boolean}
     * @memberof CartSettingsPayment
     */
    supports_wire_transfer?: boolean;
}

/**
 * 
 * @export
 * @interface CartSettingsPaymentAmazon
 */
export interface CartSettingsPaymentAmazon {
    /**
     * Amazon button URL
     * @type {string}
     * @memberof CartSettingsPaymentAmazon
     */
    amazon_button_url?: string;
    /**
     * Amazon merchant ID
     * @type {string}
     * @memberof CartSettingsPaymentAmazon
     */
    amazon_merchant_id?: string;
    /**
     * Amazon widget URL
     * @type {string}
     * @memberof CartSettingsPaymentAmazon
     */
    amazon_widget_url?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsPaymentCreditCard
 */
export interface CartSettingsPaymentCreditCard {
    /**
     * True if the credit card verification number should be collected
     * @type {boolean}
     * @memberof CartSettingsPaymentCreditCard
     */
    collect_credit_card_verification_number?: boolean;
    /**
     * Available credit card types
     * @type {Array<string>}
     * @memberof CartSettingsPaymentCreditCard
     */
    credit_card_types?: Array<string>;
    /**
     * The shoppingCartToken needed for proper initialization of hosted fields collection
     * @type {string}
     * @memberof CartSettingsPaymentCreditCard
     */
    hosted_fields_shopping_cart_token?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsPaymentPayPal
 */
export interface CartSettingsPaymentPayPal {
    /**
     * PayPal button alt text
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypal_button_alt_text?: string;
    /**
     * PayPal button URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypal_button_url?: string;
    /**
     * PayPal Credit button URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypal_credit_button_url?: string;
    /**
     * PayPal Credit legal image URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypal_credit_legal_image_url?: string;
    /**
     * PayPal Credit legal URL
     * @type {string}
     * @memberof CartSettingsPaymentPayPal
     */
    paypal_credit_legal_url?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsProvince
 */
export interface CartSettingsProvince {
    /**
     * 
     * @type {string}
     * @memberof CartSettingsProvince
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof CartSettingsProvince
     */
    province?: string;
}

/**
 * 
 * @export
 * @interface CartSettingsShipping
 */
export interface CartSettingsShipping {
    /**
     * 
     * @type {CartSettingsShippingCalendar}
     * @memberof CartSettingsShipping
     */
    deliver_on_date?: CartSettingsShippingCalendar;
    /**
     * Estimates for this cart
     * @type {Array<CartSettingsShippingEstimate>}
     * @memberof CartSettingsShipping
     */
    estimates?: Array<CartSettingsShippingEstimate>;
    /**
     * True if this order needs shipping
     * @type {boolean}
     * @memberof CartSettingsShipping
     */
    need_shipping?: boolean;
    /**
     * Provinces
     * @type {Array<CartSettingsProvince>}
     * @memberof CartSettingsShipping
     */
    provinces?: Array<CartSettingsProvince>;
    /**
     * 
     * @type {CartSettingsShippingCalendar}
     * @memberof CartSettingsShipping
     */
    ship_on_date?: CartSettingsShippingCalendar;
}

/**
 * 
 * @export
 * @interface CartSettingsShippingCalendar
 */
export interface CartSettingsShippingCalendar {
    /**
     * Specified dates that are blacked out on the calendar in ISO8601 format
     * @type {Array<string>}
     * @memberof CartSettingsShippingCalendar
     */
    blackouts?: Array<string>;
    /**
     * Days of week that should be enabled on the calendar (0 - Sunday through 6 - Saturday)
     * @type {Array<boolean>}
     * @memberof CartSettingsShippingCalendar
     */
    days_of_week?: Array<boolean>;
    /**
     * The earliest date that can be selected on the calendar
     * @type {string}
     * @memberof CartSettingsShippingCalendar
     */
    earliest?: string;
    /**
     * True if the customer is required to select a date
     * @type {boolean}
     * @memberof CartSettingsShippingCalendar
     */
    require?: boolean;
    /**
     * True if this calendar should be shown to the customer
     * @type {boolean}
     * @memberof CartSettingsShippingCalendar
     */
    show?: boolean;
}

/**
 * 
 * @export
 * @interface CartSettingsShippingEstimate
 */
export interface CartSettingsShippingEstimate {
    /**
     * True if this method allows the customer to use their own shipper account number
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    allow_3rd_party_billing?: boolean;
    /**
     * Comment to display to the customer about this method
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    comment?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    cost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    cost_before_discount?: Currency;
    /**
     * True if this is the default method
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    default_method?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    discount?: Currency;
    /**
     * True if this method is discounted because of a coupon
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    discounted?: boolean;
    /**
     * The name to display to the customer
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    display_name?: string;
    /**
     * Date of the estimated delivery (or range)
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    estimated_delivery?: string;
    /**
     * True if a lift gate option for this method should be offered to the customer
     * @type {boolean}
     * @memberof CartSettingsShippingEstimate
     */
    lift_gate_option?: boolean;
    /**
     * Shipping method name
     * @type {string}
     * @memberof CartSettingsShippingEstimate
     */
    name?: string;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    tax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSettingsShippingEstimate
     */
    total_tax?: Currency;
}

/**
 * 
 * @export
 * @interface CartSettingsTaxes
 */
export interface CartSettingsTaxes {
    /**
     * 
     * @type {Array<string>}
     * @memberof CartSettingsTaxes
     */
    counties?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartSettingsTerms
 */
export interface CartSettingsTerms {
    /**
     * HTML version of the terms
     * @type {string}
     * @memberof CartSettingsTerms
     */
    html?: string;
    /**
     * Text version of the terms.
     * @type {string}
     * @memberof CartSettingsTerms
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface CartShipping
 */
export interface CartShipping {
    /**
     * Address line 1
     * @type {string}
     * @memberof CartShipping
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CartShipping
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CartShipping
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CartShipping
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CartShipping
     */
    country_code?: string;
    /**
     * Day time phone
     * @type {string}
     * @memberof CartShipping
     */
    day_phone?: string;
    /**
     * Date the customer is requesting delivery on. Typically used for perishable product delivery.
     * @type {string}
     * @memberof CartShipping
     */
    delivery_date?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof CartShipping
     */
    evening_phone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CartShipping
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CartShipping
     */
    last_name?: string;
    /**
     * Lift gate requested (LTL shipping methods only)
     * @type {boolean}
     * @memberof CartShipping
     */
    lift_gate?: boolean;
    /**
     * Postal code
     * @type {string}
     * @memberof CartShipping
     */
    postal_code?: string;
    /**
     * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
     * @type {string}
     * @memberof CartShipping
     */
    ship_on_date?: string;
    /**
     * True if the shipping adress is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
     * @type {boolean}
     * @memberof CartShipping
     */
    ship_to_residential?: boolean;
    /**
     * 3rd party account number to ship against for UPS or FedEx
     * @type {string}
     * @memberof CartShipping
     */
    shipping_3rd_party_account_number?: string;
    /**
     * Shipping method
     * @type {string}
     * @memberof CartShipping
     */
    shipping_method?: string;
    /**
     * Special instructions from the customer regarding shipping
     * @type {string}
     * @memberof CartShipping
     */
    special_instructions?: string;
    /**
     * State/Region
     * @type {string}
     * @memberof CartShipping
     */
    state_region?: string;
    /**
     * Title
     * @type {string}
     * @memberof CartShipping
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CartSummary
 */
export interface CartSummary {
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitrary_shipping_handling_total?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitrary_tax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitrary_tax_rate?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    arbitrary_taxable_subtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    shipping_handling?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    shipping_handling_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    shipping_handling_with_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    subtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    subtotal_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    subtotal_with_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    surcharge?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    tax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    taxable_subtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    taxable_subtotal_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    taxable_subtotal_with_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof CartSummary
     */
    total?: Currency;
}

/**
 * 
 * @export
 * @interface CartTaxes
 */
export interface CartTaxes {
    /**
     * Tax county if the state requires it.
     * @type {string}
     * @memberof CartTaxes
     */
    county?: string;
    /**
     * True if tax exempt
     * @type {boolean}
     * @memberof CartTaxes
     */
    exempt?: boolean;
    /**
     * Tax rate
     * @type {number}
     * @memberof CartTaxes
     */
    rate?: number;
}

/**
 * 
 * @export
 * @interface CartUpsellAfter
 */
export interface CartUpsellAfter {
    /**
     * The date/time after which the cart will finalize into an order.
     * @type {string}
     * @memberof CartUpsellAfter
     */
    finalize_after_dts?: string;
    /**
     * The amount of inactivity in minutes after which the cart should be finalized into an order.  This will calculate the finalize_after_dts field.
     * @type {number}
     * @memberof CartUpsellAfter
     */
    finalize_after_minutes?: number;
    /**
     * Upsell path code
     * @type {string}
     * @memberof CartUpsellAfter
     */
    upsell_path_code?: string;
}

/**
 * 
 * @export
 * @interface CartValidationRequest
 */
export interface CartValidationRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CartValidationRequest
     */
    cart?: Cart;
    /**
     * Checks to perform
     * @type {Array<string>}
     * @memberof CartValidationRequest
     */
    checks?: Array<string>;
}

/**
 * 
 * @export
 * @interface CartValidationResponse
 */
export interface CartValidationResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CartValidationResponse
     */
    cart?: Cart;
    /**
     * Errors to display to the customer if they failed any of the validations checked
     * @type {Array<string>}
     * @memberof CartValidationResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface ChargebackDispute
 */
export interface ChargebackDispute {
    /**
     * Account number
     * @type {string}
     * @memberof ChargebackDispute
     */
    account_number?: string;
    /**
     * Adjustment request text
     * @type {string}
     * @memberof ChargebackDispute
     */
    adjustment_request_text?: string;
    /**
     * Amount
     * @type {number}
     * @memberof ChargebackDispute
     */
    amount?: number;
    /**
     * Auth code
     * @type {string}
     * @memberof ChargebackDispute
     */
    auth_code?: string;
    /**
     * Case number
     * @type {string}
     * @memberof ChargebackDispute
     */
    case_number?: string;
    /**
     * Chargeback Dispute Oid
     * @type {number}
     * @memberof ChargebackDispute
     */
    chargeback_dispute_oid?: number;
    /**
     * Chargeback dts
     * @type {string}
     * @memberof ChargebackDispute
     */
    chargeback_dts?: string;
    /**
     * Currency
     * @type {string}
     * @memberof ChargebackDispute
     */
    currency?: string;
    /**
     * Customer care notes
     * @type {string}
     * @memberof ChargebackDispute
     */
    customer_care_notes?: string;
    /**
     * Encryption key
     * @type {string}
     * @memberof ChargebackDispute
     */
    encryption_key?: string;
    /**
     * Expiration Dts
     * @type {string}
     * @memberof ChargebackDispute
     */
    expiration_dts?: string;
    /**
     * Fax failure reason
     * @type {string}
     * @memberof ChargebackDispute
     */
    fax_failure_reason?: string;
    /**
     * Fax number
     * @type {string}
     * @memberof ChargebackDispute
     */
    fax_number?: string;
    /**
     * Fax transaction id
     * @type {number}
     * @memberof ChargebackDispute
     */
    fax_transaction_id?: number;
    /**
     * icsid
     * @type {string}
     * @memberof ChargebackDispute
     */
    icsid?: string;
    /**
     * Merchant account profile oid
     * @type {number}
     * @memberof ChargebackDispute
     */
    merchant_account_profile_oid?: number;
    /**
     * 
     * @type {Order}
     * @memberof ChargebackDispute
     */
    order?: Order;
    /**
     * Order Id
     * @type {string}
     * @memberof ChargebackDispute
     */
    order_id?: string;
    /**
     * Partial card number
     * @type {string}
     * @memberof ChargebackDispute
     */
    partial_card_number?: string;
    /**
     * PDF file oid
     * @type {string}
     * @memberof ChargebackDispute
     */
    pdf_file_oid?: string;
    /**
     * Reason code
     * @type {string}
     * @memberof ChargebackDispute
     */
    reason_code?: string;
    /**
     * Status
     * @type {string}
     * @memberof ChargebackDispute
     */
    status?: string;
    /**
     * Website URL
     * @type {string}
     * @memberof ChargebackDispute
     */
    website_url?: string;
}

/**
 * 
 * @export
 * @interface ChargebackDisputeResponse
 */
export interface ChargebackDisputeResponse {
    /**
     * 
     * @type {ChargebackDispute}
     * @memberof ChargebackDisputeResponse
     */
    chargeback?: ChargebackDispute;
    /**
     * 
     * @type {ModelError}
     * @memberof ChargebackDisputeResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ChargebackDisputeResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ChargebackDisputeResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ChargebackDisputeResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ChargebackDisputesResponse
 */
export interface ChargebackDisputesResponse {
    /**
     * 
     * @type {Array<ChargebackDispute>}
     * @memberof ChargebackDisputesResponse
     */
    chargebacks?: Array<ChargebackDispute>;
    /**
     * 
     * @type {ModelError}
     * @memberof ChargebackDisputesResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ChargebackDisputesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ChargebackDisputesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ChargebackDisputesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CheckoutAllowedCountriesResponse
 */
export interface CheckoutAllowedCountriesResponse {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CheckoutAllowedCountriesResponse
     */
    countries?: Array<Country>;
}

/**
 * 
 * @export
 * @interface CheckoutHandoffRequest
 */
export interface CheckoutHandoffRequest {
    /**
     * 
     * @type {Cart}
     * @memberof CheckoutHandoffRequest
     */
    cart?: Cart;
    /**
     * If any error happen during the processing on the UltraCart side, the browser will be redirected to your error_return_url with the error passed in this parameter name.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    error_parameter_name?: string;
    /**
     * The URL to return the browser to if there are processing errors on the UltraCart side.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    error_return_url?: string;
    /**
     * The type of handoff operation to perform
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    operation?: CheckoutHandoffRequest.OperationEnum;
    /**
     * The maximum amount of revenue that you think the customer could add during a custom upsell after sequence on your checkout.
     * @type {number}
     * @memberof CheckoutHandoffRequest
     */
    paypal_maximum_upsell_revenue?: number;
    /**
     * The URl to return the customers browser to after they have completed the PayPal process.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    paypal_return_url?: string;
    /**
     * The desired secure host name to perform the handoff on.  This should match the desired StoreFront.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    secure_host_name?: string;
    /**
     * The UltraCart Analytics cookie value.  Populate this if you're handing off from a different domain than the checkout.
     * @type {string}
     * @memberof CheckoutHandoffRequest
     */
    ucacid?: string;
}

/**
 * @export
 * @namespace CheckoutHandoffRequest
 */
export namespace CheckoutHandoffRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        Checkout = <any> 'checkout',
        PayPal = <any> 'payPal',
        PayPalCredit = <any> 'payPalCredit',
        View = <any> 'view',
        Affirm = <any> 'affirm',
        Sezzle = <any> 'sezzle'
    }
}

/**
 * 
 * @export
 * @interface CheckoutHandoffResponse
 */
export interface CheckoutHandoffResponse {
    /**
     * 
     * @type {Cart}
     * @memberof CheckoutHandoffResponse
     */
    cart?: Cart;
    /**
     * Errors that occurred which are preventing the handoff operation.  Display these to the customer.
     * @type {Array<string>}
     * @memberof CheckoutHandoffResponse
     */
    errors?: Array<string>;
    /**
     * The URL that you should redirect the customers browser to
     * @type {string}
     * @memberof CheckoutHandoffResponse
     */
    redirect_to_url?: string;
}

/**
 * 
 * @export
 * @interface CheckoutSetupBrowserKeyRequest
 */
export interface CheckoutSetupBrowserKeyRequest {
    /**
     * Allowed referrers.  If URLs are specified, automatic translation will convert them to proper allowed referrer maskes.
     * @type {Array<string>}
     * @memberof CheckoutSetupBrowserKeyRequest
     */
    allowed_referrers?: Array<string>;
}

/**
 * 
 * @export
 * @interface CheckoutSetupBrowserKeyResponse
 */
export interface CheckoutSetupBrowserKeyResponse {
    /**
     * Browser key that is used to authenticate against the new linked application.
     * @type {string}
     * @memberof CheckoutSetupBrowserKeyResponse
     */
    browser_key?: string;
}

/**
 * 
 * @export
 * @interface CheckoutStateProvinceResponse
 */
export interface CheckoutStateProvinceResponse {
    /**
     * 
     * @type {Array<StateProvince>}
     * @memberof CheckoutStateProvinceResponse
     */
    stateProvinces?: Array<StateProvince>;
}

/**
 * 
 * @export
 * @interface CityStateZip
 */
export interface CityStateZip {
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    state?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CityStateZip
     */
    validZip?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CityStateZip
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface CountriesResponse
 */
export interface CountriesResponse {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CountriesResponse
     */
    countries?: Array<Country>;
}

/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * iso_2_code
     * @type {string}
     * @memberof Country
     */
    iso_2_code?: string;
    /**
     * name
     * @type {string}
     * @memberof Country
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface Coupon
 */
export interface Coupon {
    /**
     * Associates an order with an affiliate when this value is set.
     * @type {number}
     * @memberof Coupon
     */
    affiliate_oid?: number;
    /**
     * True if multiple one time codes for this coupon can be used on a cart at the same time.
     * @type {boolean}
     * @memberof Coupon
     */
    allow_multiple_one_time_codes?: boolean;
    /**
     * 
     * @type {CouponAmountOffItems}
     * @memberof Coupon
     */
    amount_off_items?: CouponAmountOffItems;
    /**
     * 
     * @type {CouponAmountOffShipping}
     * @memberof Coupon
     */
    amount_off_shipping?: CouponAmountOffShipping;
    /**
     * 
     * @type {CouponAmountOffShippingWithItemsPurchase}
     * @memberof Coupon
     */
    amount_off_shipping_with_items_purchase?: CouponAmountOffShippingWithItemsPurchase;
    /**
     * 
     * @type {CouponAmountOffSubtotal}
     * @memberof Coupon
     */
    amount_off_subtotal?: CouponAmountOffSubtotal;
    /**
     * 
     * @type {CouponAmountOffSubtotalFreeShippingWithPurchase}
     * @memberof Coupon
     */
    amount_off_subtotal_and_free_shipping?: CouponAmountOffSubtotalFreeShippingWithPurchase;
    /**
     * 
     * @type {CouponAmountOffSubtotalAndShipping}
     * @memberof Coupon
     */
    amount_off_subtotal_and_shipping?: CouponAmountOffSubtotalAndShipping;
    /**
     * 
     * @type {CouponAmountOffSubtotalWithBlockPurchase}
     * @memberof Coupon
     */
    amount_off_subtotal_with_block_purchase?: CouponAmountOffSubtotalWithBlockPurchase;
    /**
     * 
     * @type {CouponAmountOffSubtotalWithItemsPurchase}
     * @memberof Coupon
     */
    amount_off_subtotal_with_items_purchase?: CouponAmountOffSubtotalWithItemsPurchase;
    /**
     * 
     * @type {CouponAmountOffSubtotalWithPurchase}
     * @memberof Coupon
     */
    amount_off_subtotal_with_purchase?: CouponAmountOffSubtotalWithPurchase;
    /**
     * 
     * @type {CouponAutomaticallyApplyCouponCodes}
     * @memberof Coupon
     */
    automatically_apply_coupon_codes?: CouponAutomaticallyApplyCouponCodes;
    /**
     * 
     * @type {CouponBuyOneGetOneLimit}
     * @memberof Coupon
     */
    buy_one_get_one?: CouponBuyOneGetOneLimit;
    /**
     * Calculated description displayed to the customer if no description is specified.
     * @type {string}
     * @memberof Coupon
     */
    calculated_description?: string;
    /**
     * True if this coupon can be used with other coupons in a single order.
     * @type {boolean}
     * @memberof Coupon
     */
    can_be_used_with_other_coupons?: boolean;
    /**
     * Coupon oid.
     * @type {number}
     * @memberof Coupon
     */
    coupon_oid?: number;
    /**
     * Coupon type.
     * @type {string}
     * @memberof Coupon
     */
    coupon_type?: string;
    /**
     * Description of the coupon up to 50 characters.
     * @type {string}
     * @memberof Coupon
     */
    description?: string;
    /**
     * 
     * @type {CouponDiscountItemWithItemPurchase}
     * @memberof Coupon
     */
    discount_item_with_item_purchase?: CouponDiscountItemWithItemPurchase;
    /**
     * 
     * @type {CouponDiscountItems}
     * @memberof Coupon
     */
    discount_items?: CouponDiscountItems;
    /**
     * Date/time when coupon expires
     * @type {string}
     * @memberof Coupon
     */
    expiration_dts?: string;
    /**
     * 
     * @type {CouponFreeItemAndShippingWithSubtotal}
     * @memberof Coupon
     */
    free_item_and_shipping_with_subtotal?: CouponFreeItemAndShippingWithSubtotal;
    /**
     * 
     * @type {CouponFreeItemWithItemPurchase}
     * @memberof Coupon
     */
    free_item_with_item_purchase?: CouponFreeItemWithItemPurchase;
    /**
     * 
     * @type {CouponFreeItemWithSubtotal}
     * @memberof Coupon
     */
    free_item_with_subtotal?: CouponFreeItemWithSubtotal;
    /**
     * 
     * @type {CouponFreeItemsWithItemPurchase}
     * @memberof Coupon
     */
    free_items_with_item_purchase?: CouponFreeItemsWithItemPurchase;
    /**
     * 
     * @type {CouponFreeItemsWithMixMatchPurchase}
     * @memberof Coupon
     */
    free_items_with_mixmatch_purchase?: CouponFreeItemsWithMixMatchPurchase;
    /**
     * 
     * @type {CouponFreeShipping}
     * @memberof Coupon
     */
    free_shipping?: CouponFreeShipping;
    /**
     * 
     * @type {CouponFreeShippingSpecificItems}
     * @memberof Coupon
     */
    free_shipping_specific_items?: CouponFreeShippingSpecificItems;
    /**
     * 
     * @type {CouponFreeShippingWithItemsPurchase}
     * @memberof Coupon
     */
    free_shipping_with_items_purchase?: CouponFreeShippingWithItemsPurchase;
    /**
     * 
     * @type {CouponFreeShippingWithSubtotal}
     * @memberof Coupon
     */
    free_shipping_with_subtotal?: CouponFreeShippingWithSubtotal;
    /**
     * Hide coupon from customer during checkout.  Often used when coupons are automatic discounting mechanisms.
     * @type {boolean}
     * @memberof Coupon
     */
    hide_from_customer?: boolean;
    /**
     * Merchant code of coupon up to 20 characters.
     * @type {string}
     * @memberof Coupon
     */
    merchant_code?: string;
    /**
     * Internal notes about this coupon.  These are not visible to customer.
     * @type {string}
     * @memberof Coupon
     */
    merchant_notes?: string;
    /**
     * 
     * @type {CouponMultipleAmountsOffItems}
     * @memberof Coupon
     */
    multiple_amounts_off_items?: CouponMultipleAmountsOffItems;
    /**
     * 
     * @type {CouponNoDiscount}
     * @memberof Coupon
     */
    no_discount?: CouponNoDiscount;
    /**
     * 
     * @type {CouponPercentOffItemWithItemsQuantityPurchase}
     * @memberof Coupon
     */
    percent_off_item_with_items_quantity_purchase?: CouponPercentOffItemWithItemsQuantityPurchase;
    /**
     * 
     * @type {CouponPercentOffItems}
     * @memberof Coupon
     */
    percent_off_items?: CouponPercentOffItems;
    /**
     * 
     * @type {CouponPercentOffItemsAndFreeShipping}
     * @memberof Coupon
     */
    percent_off_items_and_free_shipping?: CouponPercentOffItemsAndFreeShipping;
    /**
     * 
     * @type {CouponPercentOffItemsWithItemsPurchase}
     * @memberof Coupon
     */
    percent_off_items_with_items_purchase?: CouponPercentOffItemsWithItemsPurchase;
    /**
     * 
     * @type {CouponPercentOffMsrpItems}
     * @memberof Coupon
     */
    percent_off_msrp_items?: CouponPercentOffMsrpItems;
    /**
     * 
     * @type {CouponPercentOffRetailPriceItems}
     * @memberof Coupon
     */
    percent_off_retail_price_items?: CouponPercentOffRetailPriceItems;
    /**
     * 
     * @type {CouponPercentOffShipping}
     * @memberof Coupon
     */
    percent_off_shipping?: CouponPercentOffShipping;
    /**
     * 
     * @type {CouponPercentOffSubtotal}
     * @memberof Coupon
     */
    percent_off_subtotal?: CouponPercentOffSubtotal;
    /**
     * 
     * @type {CouponPercentOffSubtotalAndFreeShipping}
     * @memberof Coupon
     */
    percent_off_subtotal_and_free_shipping?: CouponPercentOffSubtotalAndFreeShipping;
    /**
     * 
     * @type {CouponPercentOffSubtotalLimit}
     * @memberof Coupon
     */
    percent_off_subtotal_limit?: CouponPercentOffSubtotalLimit;
    /**
     * 
     * @type {CouponPercentOffSubtotalWithItemsPurchase}
     * @memberof Coupon
     */
    percent_off_subtotal_with_items_purchase?: CouponPercentOffSubtotalWithItemsPurchase;
    /**
     * 
     * @type {CouponPercentOffSubtotalWithSubtotal}
     * @memberof Coupon
     */
    percent_off_subtotal_with_subtotal?: CouponPercentOffSubtotalWithSubtotal;
    /**
     * Quickbooks accounting code.
     * @type {string}
     * @memberof Coupon
     */
    quickbooks_code?: string;
    /**
     * Optional list of postal codes which restrict a coupon to within these postal codes.
     * @type {Array<string>}
     * @memberof Coupon
     */
    restrict_by_postal_codes?: Array<string>;
    /**
     * Optional list of legacy screen branding theme codes to limit coupon use to only those themes.
     * @type {Array<CouponRestriction>}
     * @memberof Coupon
     */
    restrict_by_screen_branding_theme_codes?: Array<CouponRestriction>;
    /**
     * Optional list of storefronts to limit coupon use to only those storefronts.
     * @type {Array<CouponRestriction>}
     * @memberof Coupon
     */
    restrict_by_storefronts?: Array<CouponRestriction>;
    /**
     * Date/time when coupon is valid
     * @type {string}
     * @memberof Coupon
     */
    start_dts?: string;
    /**
     * If true, this coupon can be used with ANY other coupon regardless of the other coupons configuration
     * @type {boolean}
     * @memberof Coupon
     */
    super_coupon?: boolean;
    /**
     * 
     * @type {CouponTieredAmountOffItems}
     * @memberof Coupon
     */
    tiered_amount_off_items?: CouponTieredAmountOffItems;
    /**
     * 
     * @type {CouponTieredAmountOffSubtotal}
     * @memberof Coupon
     */
    tiered_amount_off_subtotal?: CouponTieredAmountOffSubtotal;
    /**
     * 
     * @type {CouponTieredPercentOffItems}
     * @memberof Coupon
     */
    tiered_percent_off_items?: CouponTieredPercentOffItems;
    /**
     * 
     * @type {CouponTieredPercentOffShipping}
     * @memberof Coupon
     */
    tiered_percent_off_shipping?: CouponTieredPercentOffShipping;
    /**
     * 
     * @type {CouponTieredPercentOffSubtotal}
     * @memberof Coupon
     */
    tiered_percent_off_subtotal?: CouponTieredPercentOffSubtotal;
    /**
     * Who may use this coupon.
     * @type {string}
     * @memberof Coupon
     */
    usable_by?: string;
}

/**
 * 
 * @export
 * @interface CouponAmountOffItems
 */
export interface CouponAmountOffItems {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffItems
     */
    currency_code?: string;
    /**
     * The amount of shipping discount
     * @type {number}
     * @memberof CouponAmountOffItems
     */
    discount_amount?: number;
    /**
     * A list of items which are eligible for the discount amount.
     * @type {Array<string>}
     * @memberof CouponAmountOffItems
     */
    items?: Array<string>;
    /**
     * The limit of items which are eligible for the discount amount.
     * @type {number}
     * @memberof CouponAmountOffItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffShipping
 */
export interface CouponAmountOffShipping {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffShipping
     */
    currency_code?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffShipping
     */
    discount_amount?: number;
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponAmountOffShipping
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponAmountOffShippingWithItemsPurchase
 */
export interface CouponAmountOffShippingWithItemsPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    currency_code?: string;
    /**
     * The amount of shipping discount
     * @type {number}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    discount_amount?: number;
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * One or more shipping methods that may receive this discount
     * @type {Array<string>}
     * @memberof CouponAmountOffShippingWithItemsPurchase
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotal
 */
export interface CouponAmountOffSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotal
     */
    currency_code?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotal
     */
    discount_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalAndShipping
 */
export interface CouponAmountOffSubtotalAndShipping {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalAndShipping
     */
    currency_code?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalAndShipping
     */
    discount_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalFreeShippingWithPurchase
 */
export interface CouponAmountOffSubtotalFreeShippingWithPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    currency_code?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    discount_amount?: number;
    /**
     * The purchase amount to qualify for subtotal discount and free shipping
     * @type {number}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    purchase_amount?: number;
    /**
     * One or more shipping methods that may be free
     * @type {Array<string>}
     * @memberof CouponAmountOffSubtotalFreeShippingWithPurchase
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalWithBlockPurchase
 */
export interface CouponAmountOffSubtotalWithBlockPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    currency_code?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    discount_amount?: number;
    /**
     * Required item that must be purchased for coupon to be valid
     * @type {string}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    required_purchase_item?: string;
    /**
     * Discount amount is multiplied by the number of blocks.  A block is this many quantity of the required item.
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithBlockPurchase
     */
    required_purchase_quantity?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalWithItemsPurchase
 */
export interface CouponAmountOffSubtotalWithItemsPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    currency_code?: string;
    /**
     * The amount of shipping discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    discount_amount?: number;
    /**
     * A list of items of which a quantity of one or many must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * The quantity of items that must be purchased for the discount to be applied.
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithItemsPurchase
     */
    required_purchase_quantity?: number;
}

/**
 * 
 * @export
 * @interface CouponAmountOffSubtotalWithPurchase
 */
export interface CouponAmountOffSubtotalWithPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponAmountOffSubtotalWithPurchase
     */
    currency_code?: string;
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithPurchase
     */
    discount_amount?: number;
    /**
     * The purchase amount to qualify for subtotal discount and free shipping
     * @type {number}
     * @memberof CouponAmountOffSubtotalWithPurchase
     */
    purchase_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponAutoApplyCondition
 */
export interface CouponAutoApplyCondition {
    /**
     * 
     * @type {string}
     * @memberof CouponAutoApplyCondition
     */
    coupon_code?: string;
    /**
     * The minimum subtotal that must be purchased to receive this coupon. Item and subtotal are exclusive.  Only one can be populated.
     * @type {number}
     * @memberof CouponAutoApplyCondition
     */
    minimum_subtotal?: number;
    /**
     * The item that must be purchased to receive this coupon. Item and subtotal are exclusive.  Only one can be populated.
     * @type {string}
     * @memberof CouponAutoApplyCondition
     */
    required_item_id?: string;
}

/**
 * 
 * @export
 * @interface CouponAutoApplyConditions
 */
export interface CouponAutoApplyConditions {
    /**
     * 
     * @type {ModelError}
     * @memberof CouponAutoApplyConditions
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponAutoApplyConditions
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<CouponAutoApplyCondition>}
     * @memberof CouponAutoApplyConditions
     */
    required_items?: Array<CouponAutoApplyCondition>;
    /**
     * 
     * @type {Array<CouponAutoApplyCondition>}
     * @memberof CouponAutoApplyConditions
     */
    subtotal_levels?: Array<CouponAutoApplyCondition>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponAutoApplyConditions
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponAutoApplyConditions
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponAutomaticallyApplyCouponCodes
 */
export interface CouponAutomaticallyApplyCouponCodes {
    /**
     * The coupon codes to automatically apply if this coupon is applied
     * @type {Array<string>}
     * @memberof CouponAutomaticallyApplyCouponCodes
     */
    coupon_codes?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponBuyOneGetOneLimit
 */
export interface CouponBuyOneGetOneLimit {
    /**
     * An optional list of items of which one must be purchased to receive free quantity of the same item.
     * @type {Array<string>}
     * @memberof CouponBuyOneGetOneLimit
     */
    items?: Array<string>;
    /**
     * The limit of free items that may be received when purchasing multiple items
     * @type {number}
     * @memberof CouponBuyOneGetOneLimit
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponCodesRequest
 */
export interface CouponCodesRequest {
    /**
     * 
     * @type {ModelError}
     * @memberof CouponCodesRequest
     */
    error?: ModelError;
    /**
     * Expiration Date
     * @type {string}
     * @memberof CouponCodesRequest
     */
    expiration_dts?: string;
    /**
     * Expiration seconds
     * @type {number}
     * @memberof CouponCodesRequest
     */
    expiration_seconds?: number;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponCodesRequest
     */
    metadata?: ResponseMetadata;
    /**
     * Quantity
     * @type {number}
     * @memberof CouponCodesRequest
     */
    quantity?: number;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponCodesRequest
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponCodesRequest
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponCodesResponse
 */
export interface CouponCodesResponse {
    /**
     * Coupon codes
     * @type {Array<string>}
     * @memberof CouponCodesResponse
     */
    coupon_codes?: Array<string>;
    /**
     * 
     * @type {ModelError}
     * @memberof CouponCodesResponse
     */
    error?: ModelError;
    /**
     * Expiration date
     * @type {string}
     * @memberof CouponCodesResponse
     */
    expiration_dts?: string;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponCodesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponCodesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponCodesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponDeletesRequest
 */
export interface CouponDeletesRequest {
    /**
     * Coupon codes
     * @type {Array<string>}
     * @memberof CouponDeletesRequest
     */
    coupon_codes?: Array<string>;
    /**
     * Coupon oids
     * @type {Array<number>}
     * @memberof CouponDeletesRequest
     */
    coupon_oids?: Array<number>;
}

/**
 * 
 * @export
 * @interface CouponDiscountItemWithItemPurchase
 */
export interface CouponDiscountItemWithItemPurchase {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    currency_code?: string;
    /**
     * The item that will be sold at the discount_price when required_purchase_item is purchased.
     * @type {string}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    discount_item?: string;
    /**
     * The price (unit cost) of the discounted item
     * @type {number}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    discount_price?: number;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    limit?: number;
    /**
     * The item that must be purchased for the discount to be applied to the discount item.
     * @type {string}
     * @memberof CouponDiscountItemWithItemPurchase
     */
    required_purchase_item?: string;
}

/**
 * 
 * @export
 * @interface CouponDiscountItems
 */
export interface CouponDiscountItems {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponDiscountItems
     */
    currency_code?: string;
    /**
     * The price (unit cost) of the discounted item
     * @type {number}
     * @memberof CouponDiscountItems
     */
    discount_price?: number;
    /**
     * A list of items that are eligible for this discount_price.
     * @type {Array<string>}
     * @memberof CouponDiscountItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponDiscountItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponEditorValues
 */
export interface CouponEditorValues {
    /**
     * affiliates
     * @type {Array<SimpleValue>}
     * @memberof CouponEditorValues
     */
    affiliates?: Array<SimpleValue>;
    /**
     * coupon_types
     * @type {Array<string>}
     * @memberof CouponEditorValues
     */
    coupon_types?: Array<string>;
    /**
     * coupon_types_for_display
     * @type {Array<CouponType>}
     * @memberof CouponEditorValues
     */
    coupon_types_for_display?: Array<CouponType>;
    /**
     * currency_codes
     * @type {Array<string>}
     * @memberof CouponEditorValues
     */
    currency_codes?: Array<string>;
    /**
     * deprecated_themes
     * @type {Array<SimpleValue>}
     * @memberof CouponEditorValues
     */
    deprecated_themes?: Array<SimpleValue>;
    /**
     * mix_and_match_names
     * @type {Array<string>}
     * @memberof CouponEditorValues
     */
    mix_and_match_names?: Array<string>;
    /**
     * shipping_methods
     * @type {Array<string>}
     * @memberof CouponEditorValues
     */
    shipping_methods?: Array<string>;
    /**
     * storefronts
     * @type {Array<SimpleValue>}
     * @memberof CouponEditorValues
     */
    storefronts?: Array<SimpleValue>;
    /**
     * usable_by
     * @type {Array<SimpleValue>}
     * @memberof CouponEditorValues
     */
    usable_by?: Array<SimpleValue>;
    /**
     * valid_with_other_coupons
     * @type {Array<string>}
     * @memberof CouponEditorValues
     */
    valid_with_other_coupons?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponExistsResponse
 */
export interface CouponExistsResponse {
    /**
     * Coupon Code
     * @type {string}
     * @memberof CouponExistsResponse
     */
    coupon_code?: string;
    /**
     * 
     * @type {ModelError}
     * @memberof CouponExistsResponse
     */
    error?: ModelError;
    /**
     * Exists
     * @type {boolean}
     * @memberof CouponExistsResponse
     */
    exists?: boolean;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponExistsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponExistsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponExistsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponFreeItemAndShippingWithSubtotal
 */
export interface CouponFreeItemAndShippingWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    currency_code?: string;
    /**
     * A list of items that are eligible for this discount_price.
     * @type {Array<string>}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    items?: Array<string>;
    /**
     * The limit of free items that may be received when purchasing multiple items
     * @type {number}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    limit?: number;
    /**
     * One or more shipping methods that may be free
     * @type {Array<string>}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    shipping_methods?: Array<string>;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponFreeItemAndShippingWithSubtotal
     */
    subtotal_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeItemWithItemPurchase
 */
export interface CouponFreeItemWithItemPurchase {
    /**
     * A list of free items which will receive a discount if one of the required purchase items is purchased.
     * @type {Array<string>}
     * @memberof CouponFreeItemWithItemPurchase
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponFreeItemWithItemPurchase
     */
    limit?: number;
    /**
     * If true then the free item is matched 1:1 with the free item in the list.
     * @type {boolean}
     * @memberof CouponFreeItemWithItemPurchase
     */
    match_required_purchase_item_to_free_item?: boolean;
    /**
     * Required items (at least one from the list) that must be purchased for coupon to be valid
     * @type {Array<string>}
     * @memberof CouponFreeItemWithItemPurchase
     */
    required_purchase_items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeItemWithSubtotal
 */
export interface CouponFreeItemWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponFreeItemWithSubtotal
     */
    currency_code?: string;
    /**
     * A list of items that are eligible for this discount_price.
     * @type {Array<string>}
     * @memberof CouponFreeItemWithSubtotal
     */
    items?: Array<string>;
    /**
     * The limit of free items that may be received when purchasing multiple items
     * @type {number}
     * @memberof CouponFreeItemWithSubtotal
     */
    limit?: number;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponFreeItemWithSubtotal
     */
    subtotal_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeItemsWithItemPurchase
 */
export interface CouponFreeItemsWithItemPurchase {
    /**
     * The item id of the free item that will be received when the required mix and match group quantity is purchased.
     * @type {string}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    free_item?: string;
    /**
     * The quantity of free item that will be received.
     * @type {number}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    free_quantity?: number;
    /**
     * The limit of free items that may be received when purchasing multiple items
     * @type {number}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    limit?: number;
    /**
     * Required item that must be purchased for coupon to be valid
     * @type {string}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    required_purchase_item?: string;
    /**
     * Required quantity of mix and match group items that must be purchased for coupon to be valid
     * @type {number}
     * @memberof CouponFreeItemsWithItemPurchase
     */
    required_purchase_quantity?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeItemsWithMixMatchPurchase
 */
export interface CouponFreeItemsWithMixMatchPurchase {
    /**
     * The item id of the free item that will be received when the required mix and match group quantity is purchased.
     * @type {string}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    free_item?: string;
    /**
     * The quantity of free item that will be received.
     * @type {number}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    free_quantity?: number;
    /**
     * The limit of free items that may be received when purchasing multiple mix and match group items
     * @type {number}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    limit?: number;
    /**
     * Required mix and match group that must be purchased for coupon to be valid
     * @type {string}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    required_purchase_mix_and_match_group?: string;
    /**
     * Required quantity of mix and match group items that must be purchased for coupon to be valid
     * @type {number}
     * @memberof CouponFreeItemsWithMixMatchPurchase
     */
    required_purchase_quantity?: number;
}

/**
 * 
 * @export
 * @interface CouponFreeShipping
 */
export interface CouponFreeShipping {
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponFreeShipping
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeShippingSpecificItems
 */
export interface CouponFreeShippingSpecificItems {
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponFreeShippingSpecificItems
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeShippingWithItemsPurchase
 */
export interface CouponFreeShippingWithItemsPurchase {
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponFreeShippingWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * One or more shipping methods that may receive this discount
     * @type {Array<string>}
     * @memberof CouponFreeShippingWithItemsPurchase
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponFreeShippingWithSubtotal
 */
export interface CouponFreeShippingWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponFreeShippingWithSubtotal
     */
    currency_code?: string;
    /**
     * The purchase amount to qualify for subtotal discount and free shipping
     * @type {number}
     * @memberof CouponFreeShippingWithSubtotal
     */
    purchase_amount?: number;
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponFreeShippingWithSubtotal
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponItemSearchResult
 */
export interface CouponItemSearchResult {
    /**
     * The cost of this item.
     * @type {string}
     * @memberof CouponItemSearchResult
     */
    cost?: string;
    /**
     * A human readable description of this item.
     * @type {string}
     * @memberof CouponItemSearchResult
     */
    description?: string;
    /**
     * The manufacturer of this item.
     * @type {string}
     * @memberof CouponItemSearchResult
     */
    manufacturer_name?: string;
    /**
     * The manufacturer sku of this item.
     * @type {string}
     * @memberof CouponItemSearchResult
     */
    manufacturer_sku?: string;
    /**
     * The merchant item identifier, which is unique for this merchant, but not across all of UltraCart.
     * @type {string}
     * @memberof CouponItemSearchResult
     */
    merchant_item_id?: string;
    /**
     * The unique internal identifier used by UltraCart to manage this item.
     * @type {number}
     * @memberof CouponItemSearchResult
     */
    merchant_item_oid?: number;
    /**
     * The search score of this item.  Larger scores mean more accurate matches against the search term.
     * @type {string}
     * @memberof CouponItemSearchResult
     */
    score?: string;
    /**
     * A url for displaying a thumbnail of this item
     * @type {string}
     * @memberof CouponItemSearchResult
     */
    thumbnail_url?: string;
}

/**
 * 
 * @export
 * @interface CouponItemSearchResultsResponse
 */
export interface CouponItemSearchResultsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof CouponItemSearchResultsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponItemSearchResultsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * search_results
     * @type {Array<CouponItemSearchResult>}
     * @memberof CouponItemSearchResultsResponse
     */
    search_results?: Array<CouponItemSearchResult>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponItemSearchResultsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponItemSearchResultsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponMultipleAmountsOffItems
 */
export interface CouponMultipleAmountsOffItems {
    /**
     * A list of item discounts.
     * @type {Array<CouponTierItemDiscount>}
     * @memberof CouponMultipleAmountsOffItems
     */
    discounts?: Array<CouponTierItemDiscount>;
    /**
     * The (optional) maximum quantity of items that may receive a discount.
     * @type {number}
     * @memberof CouponMultipleAmountsOffItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponNoDiscount
 */
export interface CouponNoDiscount {
}

/**
 * 
 * @export
 * @interface CouponPercentOffItemWithItemsQuantityPurchase
 */
export interface CouponPercentOffItemWithItemsQuantityPurchase {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    discount_percent?: number;
    /**
     * A list of items which will receive a discount if one of the required purchase items is purchased.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    limit?: number;
    /**
     * Required items (at least one from the list) that must be purchased for coupon to be valid
     * @type {Array<string>}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    required_purchase_items?: Array<string>;
    /**
     * The quantity of items that must be purchased for the discount to be applied.
     * @type {number}
     * @memberof CouponPercentOffItemWithItemsQuantityPurchase
     */
    required_purchase_quantity?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffItems
 */
export interface CouponPercentOffItems {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItems
     */
    discount_percent?: number;
    /**
     * A list of items which cannot be discounted.
     * @type {Array<string>}
     * @memberof CouponPercentOffItems
     */
    excluded_items?: Array<string>;
    /**
     * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
     * @type {Array<string>}
     * @memberof CouponPercentOffItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffItemsAndFreeShipping
 */
export interface CouponPercentOffItemsAndFreeShipping {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItemsAndFreeShipping
     */
    discount_percent?: number;
    /**
     * A list of items which cannot be discounted.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsAndFreeShipping
     */
    excluded_items?: Array<string>;
    /**
     * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsAndFreeShipping
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffItemsWithItemsPurchase
 */
export interface CouponPercentOffItemsWithItemsPurchase {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    discount_percent?: number;
    /**
     * A list of items which will receive a discount if one of the required purchase items is purchased.
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    limit?: number;
    /**
     * Required items (at least one from the list) that must be purchased for coupon to be valid
     * @type {Array<string>}
     * @memberof CouponPercentOffItemsWithItemsPurchase
     */
    required_purchase_items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffMsrpItems
 */
export interface CouponPercentOffMsrpItems {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffMsrpItems
     */
    discount_percent?: number;
    /**
     * A list of items which cannot be discounted.
     * @type {Array<string>}
     * @memberof CouponPercentOffMsrpItems
     */
    excluded_items?: Array<string>;
    /**
     * An list of items which will receive a discount.
     * @type {Array<string>}
     * @memberof CouponPercentOffMsrpItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffMsrpItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffRetailPriceItems
 */
export interface CouponPercentOffRetailPriceItems {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffRetailPriceItems
     */
    discount_percent?: number;
    /**
     * A list of items which cannot be discounted.
     * @type {Array<string>}
     * @memberof CouponPercentOffRetailPriceItems
     */
    excluded_items?: Array<string>;
    /**
     * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
     * @type {Array<string>}
     * @memberof CouponPercentOffRetailPriceItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponPercentOffRetailPriceItems
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffShipping
 */
export interface CouponPercentOffShipping {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffShipping
     */
    discount_percent?: number;
    /**
     * One or more shipping methods that may be used with this coupon
     * @type {Array<string>}
     * @memberof CouponPercentOffShipping
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotal
 */
export interface CouponPercentOffSubtotal {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotal
     */
    discount_percent?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalAndFreeShipping
 */
export interface CouponPercentOffSubtotalAndFreeShipping {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalAndFreeShipping
     */
    discount_percent?: number;
    /**
     * One or more shipping methods that may be free
     * @type {Array<string>}
     * @memberof CouponPercentOffSubtotalAndFreeShipping
     */
    shipping_methods?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalLimit
 */
export interface CouponPercentOffSubtotalLimit {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponPercentOffSubtotalLimit
     */
    currency_code?: string;
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalLimit
     */
    discount_percent?: number;
    /**
     * The maximum amount of subtotal used to determine discount.
     * @type {number}
     * @memberof CouponPercentOffSubtotalLimit
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalWithItemsPurchase
 */
export interface CouponPercentOffSubtotalWithItemsPurchase {
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalWithItemsPurchase
     */
    discount_percent?: number;
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponPercentOffSubtotalWithItemsPurchase
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponPercentOffSubtotalWithSubtotal
 */
export interface CouponPercentOffSubtotalWithSubtotal {
    /**
     * The ISO-4217 three letter currency code the customer is viewing prices in
     * @type {string}
     * @memberof CouponPercentOffSubtotalWithSubtotal
     */
    currency_code?: string;
    /**
     * The percentage of subtotal discount
     * @type {number}
     * @memberof CouponPercentOffSubtotalWithSubtotal
     */
    discount_percent?: number;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponPercentOffSubtotalWithSubtotal
     */
    subtotal_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponQuery
 */
export interface CouponQuery {
    /**
     * Affiliate oid
     * @type {number}
     * @memberof CouponQuery
     */
    affiliate_oid?: number;
    /**
     * The type of coupon.
     * @type {string}
     * @memberof CouponQuery
     */
    coupon_type?: string;
    /**
     * Description of this coupon
     * @type {string}
     * @memberof CouponQuery
     */
    description?: string;
    /**
     * Exclude expired coupons if true
     * @type {boolean}
     * @memberof CouponQuery
     */
    exclude_expired?: boolean;
    /**
     * Expiration date begin
     * @type {string}
     * @memberof CouponQuery
     */
    expiration_dts_begin?: string;
    /**
     * Expiration date begin
     * @type {string}
     * @memberof CouponQuery
     */
    expiration_dts_end?: string;
    /**
     * Merchant code is a unique character string for this coupon.
     * @type {string}
     * @memberof CouponQuery
     */
    merchant_code?: string;
    /**
     * Merchant code description used for searching
     * @type {string}
     * @memberof CouponQuery
     */
    merchant_code_or_description?: string;
    /**
     * Start date begin
     * @type {string}
     * @memberof CouponQuery
     */
    start_dts_begin?: string;
    /**
     * Start date end
     * @type {string}
     * @memberof CouponQuery
     */
    start_dts_end?: string;
}

/**
 * 
 * @export
 * @interface CouponResponse
 */
export interface CouponResponse {
    /**
     * 
     * @type {Coupon}
     * @memberof CouponResponse
     */
    coupon?: Coupon;
    /**
     * 
     * @type {ModelError}
     * @memberof CouponResponse
     */
    error?: ModelError;
    /**
     * Items invalid for coupons.  These will display as warnings within the UI.
     * @type {Array<string>}
     * @memberof CouponResponse
     */
    items_invalid_for_coupons?: Array<string>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CouponRestriction
 */
export interface CouponRestriction {
    /**
     * 
     * @type {boolean}
     * @memberof CouponRestriction
     */
    invalidForThis?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CouponRestriction
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CouponRestriction
     */
    validForThis?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CouponRestriction
     */
    validOnlyForThis?: boolean;
}

/**
 * 
 * @export
 * @interface CouponTierAmount
 */
export interface CouponTierAmount {
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponTierAmount
     */
    discount_amount?: number;
    /**
     * Quickbooks accounting code.
     * @type {string}
     * @memberof CouponTierAmount
     */
    quickbooks_code?: string;
    /**
     * The amount of subtotal required to receive the discount amount
     * @type {number}
     * @memberof CouponTierAmount
     */
    subtotal_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponTierItemDiscount
 */
export interface CouponTierItemDiscount {
    /**
     * The amount of subtotal discount
     * @type {number}
     * @memberof CouponTierItemDiscount
     */
    discount_amount?: number;
    /**
     * A list of items which will receive this discount.
     * @type {Array<string>}
     * @memberof CouponTierItemDiscount
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface CouponTierPercent
 */
export interface CouponTierPercent {
    /**
     * The percent of subtotal discount
     * @type {number}
     * @memberof CouponTierPercent
     */
    discount_percent?: number;
    /**
     * Quickbooks accounting code.
     * @type {string}
     * @memberof CouponTierPercent
     */
    quickbooks_code?: string;
    /**
     * The amount of subtotal required to receive the discount percent
     * @type {number}
     * @memberof CouponTierPercent
     */
    subtotal_amount?: number;
}

/**
 * 
 * @export
 * @interface CouponTierQuantityAmount
 */
export interface CouponTierQuantityAmount {
    /**
     * The amount of discount per item.
     * @type {number}
     * @memberof CouponTierQuantityAmount
     */
    discount_amount?: number;
    /**
     * The quantity of item purchased (in units)
     * @type {number}
     * @memberof CouponTierQuantityAmount
     */
    item_quantity?: number;
    /**
     * Quickbooks accounting code.
     * @type {string}
     * @memberof CouponTierQuantityAmount
     */
    quickbooks_code?: string;
}

/**
 * 
 * @export
 * @interface CouponTierQuantityPercent
 */
export interface CouponTierQuantityPercent {
    /**
     * The percent of discount per item.
     * @type {number}
     * @memberof CouponTierQuantityPercent
     */
    discount_percent?: number;
    /**
     * The quantity of item purchased (in units)
     * @type {number}
     * @memberof CouponTierQuantityPercent
     */
    item_quantity?: number;
    /**
     * Quickbooks accounting code.
     * @type {string}
     * @memberof CouponTierQuantityPercent
     */
    quickbooks_code?: string;
}

/**
 * 
 * @export
 * @interface CouponTieredAmountOffItems
 */
export interface CouponTieredAmountOffItems {
    /**
     * The items being discounted by this coupon.
     * @type {Array<string>}
     * @memberof CouponTieredAmountOffItems
     */
    items?: Array<string>;
    /**
     * The maximum number of discounted items.
     * @type {number}
     * @memberof CouponTieredAmountOffItems
     */
    limit?: number;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierQuantityAmount>}
     * @memberof CouponTieredAmountOffItems
     */
    tiers?: Array<CouponTierQuantityAmount>;
}

/**
 * 
 * @export
 * @interface CouponTieredAmountOffSubtotal
 */
export interface CouponTieredAmountOffSubtotal {
    /**
     * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
     * @type {Array<string>}
     * @memberof CouponTieredAmountOffSubtotal
     */
    items?: Array<string>;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierAmount>}
     * @memberof CouponTieredAmountOffSubtotal
     */
    tiers?: Array<CouponTierAmount>;
}

/**
 * 
 * @export
 * @interface CouponTieredPercentOffItems
 */
export interface CouponTieredPercentOffItems {
    /**
     * A list of items of which at least one must be purchased for coupon to be valid.
     * @type {Array<string>}
     * @memberof CouponTieredPercentOffItems
     */
    items?: Array<string>;
    /**
     * The (optional) maximum quantity of discounted items.
     * @type {number}
     * @memberof CouponTieredPercentOffItems
     */
    limit?: number;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierQuantityPercent>}
     * @memberof CouponTieredPercentOffItems
     */
    tiers?: Array<CouponTierQuantityPercent>;
}

/**
 * 
 * @export
 * @interface CouponTieredPercentOffShipping
 */
export interface CouponTieredPercentOffShipping {
    /**
     * Quickbooks accounting code.
     * @type {string}
     * @memberof CouponTieredPercentOffShipping
     */
    quickbooks_code?: string;
    /**
     * One or more shipping methods that may receive this discount
     * @type {Array<string>}
     * @memberof CouponTieredPercentOffShipping
     */
    shipping_methods?: Array<string>;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierPercent>}
     * @memberof CouponTieredPercentOffShipping
     */
    tiers?: Array<CouponTierPercent>;
}

/**
 * 
 * @export
 * @interface CouponTieredPercentOffSubtotal
 */
export interface CouponTieredPercentOffSubtotal {
    /**
     * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
     * @type {Array<string>}
     * @memberof CouponTieredPercentOffSubtotal
     */
    items?: Array<string>;
    /**
     * A list of discount tiers.
     * @type {Array<CouponTierPercent>}
     * @memberof CouponTieredPercentOffSubtotal
     */
    tiers?: Array<CouponTierPercent>;
}

/**
 * 
 * @export
 * @interface CouponType
 */
export interface CouponType {
    /**
     * A friendly display of the coupon type suitable for human reading
     * @type {string}
     * @memberof CouponType
     */
    localized?: string;
    /**
     * The name of the coupon type
     * @type {string}
     * @memberof CouponType
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CouponsRequest
 */
export interface CouponsRequest {
    /**
     * coupons
     * @type {Array<Coupon>}
     * @memberof CouponsRequest
     */
    coupons?: Array<Coupon>;
}

/**
 * 
 * @export
 * @interface CouponsResponse
 */
export interface CouponsResponse {
    /**
     * 
     * @type {Array<Coupon>}
     * @memberof CouponsResponse
     */
    coupons?: Array<Coupon>;
    /**
     * 
     * @type {ModelError}
     * @memberof CouponsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CouponsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CouponsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CouponsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * Currency code of the localized value
     * @type {string}
     * @memberof Currency
     */
    currency_code?: string;
    /**
     * Exchange rate used to localize
     * @type {number}
     * @memberof Currency
     */
    exchange_rate?: number;
    /**
     * Value localized to the customer
     * @type {number}
     * @memberof Currency
     */
    localized?: number;
    /**
     * Value localized and formatted for the customer
     * @type {string}
     * @memberof Currency
     */
    localized_formatted?: string;
    /**
     * Value in base currency
     * @type {number}
     * @memberof Currency
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {CustomerActivity}
     * @memberof Customer
     */
    activity?: CustomerActivity;
    /**
     * Affiliate oid
     * @type {number}
     * @memberof Customer
     */
    affiliate_oid?: number;
    /**
     * Allow 3rd party billing
     * @type {boolean}
     * @memberof Customer
     */
    allow_3rd_party_billing?: boolean;
    /**
     * Allow COD
     * @type {boolean}
     * @memberof Customer
     */
    allow_cod?: boolean;
    /**
     * Allow Drop Shipping
     * @type {boolean}
     * @memberof Customer
     */
    allow_drop_shipping?: boolean;
    /**
     * Allow purchase orders by this customer
     * @type {boolean}
     * @memberof Customer
     */
    allow_purchase_order?: boolean;
    /**
     * Allow quote request
     * @type {boolean}
     * @memberof Customer
     */
    allow_quote_request?: boolean;
    /**
     * Allow selection of residential or business address type
     * @type {boolean}
     * @memberof Customer
     */
    allow_selection_of_address_type?: boolean;
    /**
     * Attachments
     * @type {Array<CustomerAttachment>}
     * @memberof Customer
     */
    attachments?: Array<CustomerAttachment>;
    /**
     * Auto approve COD
     * @type {boolean}
     * @memberof Customer
     */
    auto_approve_cod?: boolean;
    /**
     * Auto approve purchase orders by this customer
     * @type {boolean}
     * @memberof Customer
     */
    auto_approve_purchase_order?: boolean;
    /**
     * Automatic merchant notes are added to every order placed
     * @type {string}
     * @memberof Customer
     */
    automatic_merchant_notes?: string;
    /**
     * Billing addresses for this customer
     * @type {Array<CustomerBilling>}
     * @memberof Customer
     */
    billing?: Array<CustomerBilling>;
    /**
     * Business notes (internally visible only)
     * @type {string}
     * @memberof Customer
     */
    business_notes?: string;
    /**
     * Credit Cards for this customer
     * @type {Array<CustomerCard>}
     * @memberof Customer
     */
    cards?: Array<CustomerCard>;
    /**
     * Additional emails to CC notification
     * @type {Array<CustomerEmail>}
     * @memberof Customer
     */
    cc_emails?: Array<CustomerEmail>;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof Customer
     */
    customer_profile_oid?: number;
    /**
     * DHL account number
     * @type {string}
     * @memberof Customer
     */
    dhl_account_number?: string;
    /**
     * DHL duty account number
     * @type {string}
     * @memberof Customer
     */
    dhl_duty_account_number?: string;
    /**
     * Email address of this customer profile
     * @type {string}
     * @memberof Customer
     */
    email?: string;
    /**
     * Exempt shipping handling charge
     * @type {boolean}
     * @memberof Customer
     */
    exempt_shipping_handling_charge?: boolean;
    /**
     * FedEx account number
     * @type {string}
     * @memberof Customer
     */
    fedex_account_number?: string;
    /**
     * This customer always receives free shipping
     * @type {boolean}
     * @memberof Customer
     */
    free_shipping?: boolean;
    /**
     * If free_shipping is true, this is the minimum subtotal required for free shipping
     * @type {number}
     * @memberof Customer
     */
    free_shipping_minimum?: number;
    /**
     * Last modified by
     * @type {string}
     * @memberof Customer
     */
    last_modified_by?: string;
    /**
     * Last modified date
     * @type {string}
     * @memberof Customer
     */
    last_modified_dts?: string;
    /**
     * 
     * @type {CustomerLoyalty}
     * @memberof Customer
     */
    loyalty?: CustomerLoyalty;
    /**
     * Maximum item count
     * @type {number}
     * @memberof Customer
     */
    maximum_item_count?: number;
    /**
     * Minimum item count
     * @type {number}
     * @memberof Customer
     */
    minimum_item_count?: number;
    /**
     * Minimum subtotal
     * @type {number}
     * @memberof Customer
     */
    minimum_subtotal?: number;
    /**
     * No coupons
     * @type {boolean}
     * @memberof Customer
     */
    no_coupons?: boolean;
    /**
     * No free shipping regardless of coupons or item level settings
     * @type {boolean}
     * @memberof Customer
     */
    no_free_shipping?: boolean;
    /**
     * No realtime charge
     * @type {boolean}
     * @memberof Customer
     */
    no_realtime_charge?: boolean;
    /**
     * Orders associated with this customer profile
     * @type {Array<Order>}
     * @memberof Customer
     */
    orders?: Array<Order>;
    /**
     * 
     * @type {CustomerOrdersSummary}
     * @memberof Customer
     */
    orders_summary?: CustomerOrdersSummary;
    /**
     * Password (may only be set, never read)
     * @type {string}
     * @memberof Customer
     */
    password?: string;
    /**
     * Pricing tiers for this customer
     * @type {Array<CustomerPricingTier>}
     * @memberof Customer
     */
    pricing_tiers?: Array<CustomerPricingTier>;
    /**
     * 
     * @type {CustomerPrivacy}
     * @memberof Customer
     */
    privacy?: CustomerPrivacy;
    /**
     * QuickBooks class to import this customer as
     * @type {string}
     * @memberof Customer
     */
    qb_class?: string;
    /**
     * QuickBooks name to import this customer as
     * @type {string}
     * @memberof Customer
     */
    qb_code?: string;
    /**
     * Quotes associated with this customer profile
     * @type {Array<Order>}
     * @memberof Customer
     */
    quotes?: Array<Order>;
    /**
     * 
     * @type {CustomerQuotesSummary}
     * @memberof Customer
     */
    quotes_summary?: CustomerQuotesSummary;
    /**
     * Referral Source
     * @type {string}
     * @memberof Customer
     */
    referral_source?: string;
    /**
     * 
     * @type {CustomerReviewer}
     * @memberof Customer
     */
    reviewer?: CustomerReviewer;
    /**
     * Sales rep code
     * @type {string}
     * @memberof Customer
     */
    sales_rep_code?: string;
    /**
     * Send signup notification, if true during customer creation, will send a notification.
     * @type {boolean}
     * @memberof Customer
     */
    send_signup_notification?: boolean;
    /**
     * Shipping addresses for this customer
     * @type {Array<CustomerShipping>}
     * @memberof Customer
     */
    shipping?: Array<CustomerShipping>;
    /**
     * Signup date
     * @type {string}
     * @memberof Customer
     */
    signup_dts?: string;
    /**
     * Software entitlements owned by this customer
     * @type {Array<CustomerSoftwareEntitlement>}
     * @memberof Customer
     */
    software_entitlements?: Array<CustomerSoftwareEntitlement>;
    /**
     * Suppress buySAFE (deprecated)
     * @type {boolean}
     * @memberof Customer
     */
    suppress_buysafe?: boolean;
    /**
     * Tags for this customer
     * @type {Array<CustomerTag>}
     * @memberof Customer
     */
    tags?: Array<CustomerTag>;
    /**
     * 
     * @type {CustomerTaxCodes}
     * @memberof Customer
     */
    tax_codes?: CustomerTaxCodes;
    /**
     * True if the customer is tax exempt
     * @type {boolean}
     * @memberof Customer
     */
    tax_exempt?: boolean;
    /**
     * Tax ID
     * @type {string}
     * @memberof Customer
     */
    tax_id?: string;
    /**
     * Terms for this customer
     * @type {string}
     * @memberof Customer
     */
    terms?: string;
    /**
     * True if the customer should be tracked separately in QuickBooks
     * @type {boolean}
     * @memberof Customer
     */
    track_separately?: boolean;
    /**
     * Unapproved
     * @type {boolean}
     * @memberof Customer
     */
    unapproved?: boolean;
    /**
     * UPS account number
     * @type {string}
     * @memberof Customer
     */
    ups_account_number?: string;
    /**
     * Website url
     * @type {string}
     * @memberof Customer
     */
    website_url?: string;
}

/**
 * 
 * @export
 * @interface CustomerActivity
 */
export interface CustomerActivity {
    /**
     * 
     * @type {Array<Activity>}
     * @memberof CustomerActivity
     */
    activities?: Array<Activity>;
    /**
     * 
     * @type {Array<ListSegmentMembership>}
     * @memberof CustomerActivity
     */
    memberships?: Array<ListSegmentMembership>;
    /**
     * 
     * @type {Array<Metric>}
     * @memberof CustomerActivity
     */
    metrics?: Array<Metric>;
    /**
     * 
     * @type {Array<Property>}
     * @memberof CustomerActivity
     */
    properties_list?: Array<Property>;
}

/**
 * 
 * @export
 * @interface CustomerAffiliate
 */
export interface CustomerAffiliate {
    /**
     * Affiliate object identifier
     * @type {number}
     * @memberof CustomerAffiliate
     */
    affiliate_oid?: number;
    /**
     * email
     * @type {string}
     * @memberof CustomerAffiliate
     */
    email?: string;
    /**
     * First name
     * @type {string}
     * @memberof CustomerAffiliate
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CustomerAffiliate
     */
    last_name?: string;
}

/**
 * 
 * @export
 * @interface CustomerAttachment
 */
export interface CustomerAttachment {
    /**
     * Attachment identifier
     * @type {number}
     * @memberof CustomerAttachment
     */
    customer_profile_attachment_oid?: number;
    /**
     * Description
     * @type {string}
     * @memberof CustomerAttachment
     */
    description?: string;
    /**
     * File name
     * @type {string}
     * @memberof CustomerAttachment
     */
    file_name?: string;
    /**
     * Mime typoe
     * @type {string}
     * @memberof CustomerAttachment
     */
    mime_type?: string;
    /**
     * Upload date/time
     * @type {string}
     * @memberof CustomerAttachment
     */
    upload_dts?: string;
}

/**
 * 
 * @export
 * @interface CustomerBilling
 */
export interface CustomerBilling {
    /**
     * Address line 1
     * @type {string}
     * @memberof CustomerBilling
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CustomerBilling
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CustomerBilling
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CustomerBilling
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CustomerBilling
     */
    country_code?: string;
    /**
     * Customer profile billing object identifier
     * @type {number}
     * @memberof CustomerBilling
     */
    customer_billing_oid?: number;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof CustomerBilling
     */
    customer_profile_oid?: number;
    /**
     * Day phone
     * @type {string}
     * @memberof CustomerBilling
     */
    day_phone?: string;
    /**
     * Default billing
     * @type {boolean}
     * @memberof CustomerBilling
     */
    default_billing?: boolean;
    /**
     * Evening phone
     * @type {string}
     * @memberof CustomerBilling
     */
    evening_phone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CustomerBilling
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CustomerBilling
     */
    last_name?: string;
    /**
     * Last used date
     * @type {string}
     * @memberof CustomerBilling
     */
    last_used_dts?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof CustomerBilling
     */
    postal_code?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CustomerBilling
     */
    state_region?: string;
    /**
     * Tax County
     * @type {string}
     * @memberof CustomerBilling
     */
    tax_county?: string;
    /**
     * Title
     * @type {string}
     * @memberof CustomerBilling
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CustomerCard
 */
export interface CustomerCard {
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof CustomerCard
     */
    card_expiration_month?: number;
    /**
     * Card expiration year (four digit year)
     * @type {number}
     * @memberof CustomerCard
     */
    card_expiration_year?: number;
    /**
     * Card number (masked to the last 4)
     * @type {string}
     * @memberof CustomerCard
     */
    card_number?: string;
    /**
     * Hosted field token for the card number
     * @type {string}
     * @memberof CustomerCard
     */
    card_number_token?: string;
    /**
     * Card type
     * @type {string}
     * @memberof CustomerCard
     */
    card_type?: string;
    /**
     * ID of the stored credit card to use
     * @type {number}
     * @memberof CustomerCard
     */
    customer_profile_credit_card_id?: number;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof CustomerCard
     */
    customer_profile_oid?: number;
    /**
     * Last used date
     * @type {string}
     * @memberof CustomerCard
     */
    last_used_dts?: string;
}

/**
 * 
 * @export
 * @interface CustomerEditorValues
 */
export interface CustomerEditorValues {
    /**
     * affiliates
     * @type {Array<CustomerAffiliate>}
     * @memberof CustomerEditorValues
     */
    affiliates?: Array<CustomerAffiliate>;
    /**
     * card_exp_months
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    card_exp_months?: Array<string>;
    /**
     * card_exp_years
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    card_exp_years?: Array<string>;
    /**
     * card_types
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    card_types?: Array<string>;
    /**
     * countries
     * @type {Array<Country>}
     * @memberof CustomerEditorValues
     */
    countries?: Array<Country>;
    /**
     * qb_classes
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    qb_classes?: Array<string>;
    /**
     * sales_rep_codes
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    sales_rep_codes?: Array<string>;
    /**
     * state_optional_countries
     * @type {Array<Country>}
     * @memberof CustomerEditorValues
     */
    state_optional_countries?: Array<Country>;
    /**
     * terms
     * @type {Array<string>}
     * @memberof CustomerEditorValues
     */
    terms?: Array<string>;
}

/**
 * 
 * @export
 * @interface CustomerEmail
 */
export interface CustomerEmail {
    /**
     * ID of the email
     * @type {number}
     * @memberof CustomerEmail
     */
    customer_profile_email_oid?: number;
    /**
     * Email
     * @type {string}
     * @memberof CustomerEmail
     */
    email?: string;
    /**
     * Label
     * @type {string}
     * @memberof CustomerEmail
     */
    label?: string;
    /**
     * CC this email on receipt notifications
     * @type {boolean}
     * @memberof CustomerEmail
     */
    receipt_notification?: boolean;
    /**
     * CC this email on refund notifications
     * @type {boolean}
     * @memberof CustomerEmail
     */
    refund_notification?: boolean;
    /**
     * CC this email on shipment notifications
     * @type {boolean}
     * @memberof CustomerEmail
     */
    shipment_notification?: boolean;
}

/**
 * 
 * @export
 * @interface CustomerEmailListChanges
 */
export interface CustomerEmailListChanges {
    /**
     * Add this customer to these email lists
     * @type {Array<string>}
     * @memberof CustomerEmailListChanges
     */
    add_to_lists?: Array<string>;
    /**
     * Remove this customer from these email lists
     * @type {Array<string>}
     * @memberof CustomerEmailListChanges
     */
    remove_from_lists?: Array<string>;
}

/**
 * 
 * @export
 * @interface CustomerLoyalty
 */
export interface CustomerLoyalty {
    /**
     * Current Points
     * @type {number}
     * @memberof CustomerLoyalty
     */
    current_points?: number;
    /**
     * Ledger entries
     * @type {Array<CustomerLoyaltyLedger>}
     * @memberof CustomerLoyalty
     */
    ledger_entries?: Array<CustomerLoyaltyLedger>;
    /**
     * Pending Points
     * @type {number}
     * @memberof CustomerLoyalty
     */
    pending_points?: number;
    /**
     * Redemptions
     * @type {Array<CustomerLoyaltyRedemption>}
     * @memberof CustomerLoyalty
     */
    redemptions?: Array<CustomerLoyaltyRedemption>;
}

/**
 * 
 * @export
 * @interface CustomerLoyaltyLedger
 */
export interface CustomerLoyaltyLedger {
    /**
     * Created By
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    created_by?: string;
    /**
     * Created date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    created_dts?: string;
    /**
     * Description
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    description?: string;
    /**
     * Email
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    email?: string;
    /**
     * Item Id
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    item_id?: string;
    /**
     * Item Index
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    item_index?: number;
    /**
     * Ledger date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    ledger_dts?: string;
    /**
     * Loyalty campaign oid
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    loyalty_campaign_oid?: number;
    /**
     * Loyalty ledger oid
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    loyalty_ledger_oid?: number;
    /**
     * Loyalty points
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    loyalty_points?: number;
    /**
     * Modified By
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    modified_by?: string;
    /**
     * Modified date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    modified_dts?: string;
    /**
     * Order Id
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    order_id?: string;
    /**
     * Quantity
     * @type {number}
     * @memberof CustomerLoyaltyLedger
     */
    quantity?: number;
    /**
     * Vesting date
     * @type {string}
     * @memberof CustomerLoyaltyLedger
     */
    vesting_dts?: string;
}

/**
 * 
 * @export
 * @interface CustomerLoyaltyRedemption
 */
export interface CustomerLoyaltyRedemption {
    /**
     * Coupon code
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    coupon_code?: string;
    /**
     * Coupon code OID
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    coupon_code_oid?: number;
    /**
     * Coupon used
     * @type {boolean}
     * @memberof CustomerLoyaltyRedemption
     */
    coupon_used?: boolean;
    /**
     * Description for customer
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    description_for_customer?: string;
    /**
     * Expiration date
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    expiration_dts?: string;
    /**
     * Gift certificate code
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    gift_certificate_code?: string;
    /**
     * Gift certificate oid
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    gift_certificate_oid?: number;
    /**
     * Loyalty ledger OID
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    loyalty_ledger_oid?: number;
    /**
     * Loyalty points
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    loyalty_points?: number;
    /**
     * Loyalty redemption OID
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    loyalty_redemption_oid?: number;
    /**
     * Order id
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    order_id?: string;
    /**
     * Redemption date
     * @type {string}
     * @memberof CustomerLoyaltyRedemption
     */
    redemption_dts?: string;
    /**
     * Remaining balance
     * @type {number}
     * @memberof CustomerLoyaltyRedemption
     */
    remaining_balance?: number;
}

/**
 * 
 * @export
 * @interface CustomerOrdersSummary
 */
export interface CustomerOrdersSummary {
    /**
     * First order date
     * @type {string}
     * @memberof CustomerOrdersSummary
     */
    first_order_dts?: string;
    /**
     * Last order date
     * @type {string}
     * @memberof CustomerOrdersSummary
     */
    last_order_dts?: string;
    /**
     * Total number of orders
     * @type {number}
     * @memberof CustomerOrdersSummary
     */
    order_count?: number;
    /**
     * Total amount associated with the orders
     * @type {number}
     * @memberof CustomerOrdersSummary
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface CustomerPricingTier
 */
export interface CustomerPricingTier {
    /**
     * Name
     * @type {string}
     * @memberof CustomerPricingTier
     */
    name?: string;
    /**
     * Pricing Tier Oid
     * @type {number}
     * @memberof CustomerPricingTier
     */
    pricing_tier_oid?: number;
}

/**
 * 
 * @export
 * @interface CustomerPrivacy
 */
export interface CustomerPrivacy {
    /**
     * Last update date
     * @type {string}
     * @memberof CustomerPrivacy
     */
    last_update_dts?: string;
    /**
     * The customer has opted in to marketing
     * @type {boolean}
     * @memberof CustomerPrivacy
     */
    marketing?: boolean;
    /**
     * The customer has opted in to preference tracking
     * @type {boolean}
     * @memberof CustomerPrivacy
     */
    preference?: boolean;
    /**
     * The customer has opted in to statistics collection
     * @type {boolean}
     * @memberof CustomerPrivacy
     */
    statistics?: boolean;
}

/**
 * 
 * @export
 * @interface CustomerQuery
 */
export interface CustomerQuery {
    /**
     * All tags the customer must have
     * @type {Array<string>}
     * @memberof CustomerQuery
     */
    all_tags?: Array<string>;
    /**
     * Any of these tags the customer must have
     * @type {Array<string>}
     * @memberof CustomerQuery
     */
    any_tags?: Array<string>;
    /**
     * Billing city
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_city?: string;
    /**
     * Billing company
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_company?: string;
    /**
     * Billing country code
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_country_code?: string;
    /**
     * Billing day phone
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_day_phone?: string;
    /**
     * Billing evening phone
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_evening_phone?: string;
    /**
     * Billing first name
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_first_name?: string;
    /**
     * Billing last name
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_last_name?: string;
    /**
     * Billing postal code
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_postal_code?: string;
    /**
     * Billing state
     * @type {string}
     * @memberof CustomerQuery
     */
    billing_state?: string;
    /**
     * Email address of this customer profile
     * @type {string}
     * @memberof CustomerQuery
     */
    email?: string;
    /**
     * Last modified date end
     * @type {string}
     * @memberof CustomerQuery
     */
    last_modified_dts_end?: string;
    /**
     * Last modified date start
     * @type {string}
     * @memberof CustomerQuery
     */
    last_modified_dts_start?: string;
    /**
     * Pricing tier name
     * @type {string}
     * @memberof CustomerQuery
     */
    pricing_tier_name?: string;
    /**
     * Pricing tier oid
     * @type {number}
     * @memberof CustomerQuery
     */
    pricing_tier_oid?: number;
    /**
     * QuickBooks class to import this customer as
     * @type {string}
     * @memberof CustomerQuery
     */
    qb_class?: string;
    /**
     * QuickBooks name to import this customer as
     * @type {string}
     * @memberof CustomerQuery
     */
    quickbooks_code?: string;
    /**
     * Billing city
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_city?: string;
    /**
     * Billing company
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_company?: string;
    /**
     * Billing country code
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_country_code?: string;
    /**
     * Billing day phone
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_day_phone?: string;
    /**
     * Billing evening phone
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_evening_phone?: string;
    /**
     * Billing first name
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_first_name?: string;
    /**
     * Billing last name
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_last_name?: string;
    /**
     * Billing postal code
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_postal_code?: string;
    /**
     * Billing state
     * @type {string}
     * @memberof CustomerQuery
     */
    shipping_state?: string;
    /**
     * Signup date end
     * @type {string}
     * @memberof CustomerQuery
     */
    signup_dts_end?: string;
    /**
     * Signup date start
     * @type {string}
     * @memberof CustomerQuery
     */
    signup_dts_start?: string;
}

/**
 * 
 * @export
 * @interface CustomerQuotesSummary
 */
export interface CustomerQuotesSummary {
    /**
     * First quote date
     * @type {string}
     * @memberof CustomerQuotesSummary
     */
    first_quote_dts?: string;
    /**
     * Last quote date
     * @type {string}
     * @memberof CustomerQuotesSummary
     */
    last_quote_dts?: string;
    /**
     * Total number of quote
     * @type {number}
     * @memberof CustomerQuotesSummary
     */
    quote_count?: number;
    /**
     * Total amount associated with the quotes
     * @type {number}
     * @memberof CustomerQuotesSummary
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface CustomerResponse
 */
export interface CustomerResponse {
    /**
     * 
     * @type {Customer}
     * @memberof CustomerResponse
     */
    customer?: Customer;
    /**
     * 
     * @type {ModelError}
     * @memberof CustomerResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CustomerResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CustomerResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CustomerResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface CustomerReviewer
 */
export interface CustomerReviewer {
    /**
     * True if reviewes from this customer profile should automatically be approved
     * @type {boolean}
     * @memberof CustomerReviewer
     */
    auto_approve?: boolean;
    /**
     * Average overall rating of items reviewed
     * @type {number}
     * @memberof CustomerReviewer
     */
    average_overall_rating?: number;
    /**
     * True if the customer is an expert
     * @type {boolean}
     * @memberof CustomerReviewer
     */
    expert?: boolean;
    /**
     * First review
     * @type {string}
     * @memberof CustomerReviewer
     */
    first_review?: string;
    /**
     * Last review
     * @type {string}
     * @memberof CustomerReviewer
     */
    last_review?: string;
    /**
     * Location of the reviewer
     * @type {string}
     * @memberof CustomerReviewer
     */
    location?: string;
    /**
     * Nickname of the reviewer
     * @type {string}
     * @memberof CustomerReviewer
     */
    nickname?: string;
    /**
     * Number of helpful review votes
     * @type {number}
     * @memberof CustomerReviewer
     */
    number_helpful_review_votes?: number;
    /**
     * Rank of this reviewer
     * @type {number}
     * @memberof CustomerReviewer
     */
    rank?: number;
    /**
     * Number of reviews contributed
     * @type {number}
     * @memberof CustomerReviewer
     */
    reviews_contributed?: number;
}

/**
 * 
 * @export
 * @interface CustomerShipping
 */
export interface CustomerShipping {
    /**
     * Address line 1
     * @type {string}
     * @memberof CustomerShipping
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof CustomerShipping
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof CustomerShipping
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof CustomerShipping
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof CustomerShipping
     */
    country_code?: string;
    /**
     * Customer profile object identifier
     * @type {number}
     * @memberof CustomerShipping
     */
    customer_profile_oid?: number;
    /**
     * Customer profile shipping object identifier
     * @type {number}
     * @memberof CustomerShipping
     */
    customer_shipping_oid?: number;
    /**
     * Day phone
     * @type {string}
     * @memberof CustomerShipping
     */
    day_phone?: string;
    /**
     * Default shipping
     * @type {boolean}
     * @memberof CustomerShipping
     */
    default_shipping?: boolean;
    /**
     * Evening phone
     * @type {string}
     * @memberof CustomerShipping
     */
    evening_phone?: string;
    /**
     * First name
     * @type {string}
     * @memberof CustomerShipping
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof CustomerShipping
     */
    last_name?: string;
    /**
     * Last used date
     * @type {string}
     * @memberof CustomerShipping
     */
    last_used_dts?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof CustomerShipping
     */
    postal_code?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof CustomerShipping
     */
    state_region?: string;
    /**
     * Tax County
     * @type {string}
     * @memberof CustomerShipping
     */
    tax_county?: string;
    /**
     * Title
     * @type {string}
     * @memberof CustomerShipping
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface CustomerSoftwareEntitlement
 */
export interface CustomerSoftwareEntitlement {
    /**
     * Activation Code Associated with the software
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    activation_code?: string;
    /**
     * Date/time when the activation code was created
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    activation_dts?: string;
    /**
     * Customer profile software entitlement object identifier
     * @type {number}
     * @memberof CustomerSoftwareEntitlement
     */
    customer_software_entitlement_oid?: number;
    /**
     * Date/time when the activation code will expire
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    expiration_dts?: string;
    /**
     * Item description used to purchase this software.
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    purchased_via_item_description?: string;
    /**
     * Item ID used to purchase this software.
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    purchased_via_item_id?: string;
    /**
     * Order ID used to purchase this software.
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    purchased_via_order_id?: string;
    /**
     * SKU of the software
     * @type {string}
     * @memberof CustomerSoftwareEntitlement
     */
    software_sku?: string;
}

/**
 * 
 * @export
 * @interface CustomerTag
 */
export interface CustomerTag {
    /**
     * Tag Value
     * @type {string}
     * @memberof CustomerTag
     */
    tag_value?: string;
}

/**
 * 
 * @export
 * @interface CustomerTaxCodes
 */
export interface CustomerTaxCodes {
    /**
     * Avalara customer code
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    avalara_customer_code?: string;
    /**
     * Avalara entity use code
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    avalara_entity_use_code?: string;
    /**
     * Sovos customer code
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    sovos_customer_code?: string;
    /**
     * TaxJar customer id
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    taxjar_customer_id?: string;
    /**
     * TaxJar exemption type
     * @type {string}
     * @memberof CustomerTaxCodes
     */
    taxjar_exemption_type?: string;
}

/**
 * 
 * @export
 * @interface CustomersResponse
 */
export interface CustomersResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomersResponse
     */
    customers?: Array<Customer>;
    /**
     * 
     * @type {ModelError}
     * @memberof CustomersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof CustomersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof CustomersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof CustomersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface DataTablesServerSideResponse
 */
export interface DataTablesServerSideResponse {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof DataTablesServerSideResponse
     */
    data?: Array<Customer>;
    /**
     * 
     * @type {number}
     * @memberof DataTablesServerSideResponse
     */
    draw?: number;
    /**
     * 
     * @type {number}
     * @memberof DataTablesServerSideResponse
     */
    recordsFiltered?: number;
    /**
     * 
     * @type {number}
     * @memberof DataTablesServerSideResponse
     */
    recordsTotal?: number;
}

/**
 * 
 * @export
 * @interface DelayAutoOrdersResponse
 */
export interface DelayAutoOrdersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof DelayAutoOrdersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {string}
     * @memberof DelayAutoOrdersResponse
     */
    message?: string;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof DelayAutoOrdersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof DelayAutoOrdersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof DelayAutoOrdersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Distance
 */
export interface Distance {
    /**
     * Unit of measure
     * @type {string}
     * @memberof Distance
     */
    uom?: Distance.UomEnum;
    /**
     * The distance measured in UOM
     * @type {number}
     * @memberof Distance
     */
    value?: number;
}

/**
 * @export
 * @namespace Distance
 */
export namespace Distance {
    /**
     * @export
     * @enum {string}
     */
    export enum UomEnum {
        IN = <any> 'IN',
        CM = <any> 'CM'
    }
}

/**
 * 
 * @export
 * @interface DistributionCenter
 */
export interface DistributionCenter {
    /**
     * Address line 1 of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    address1?: string;
    /**
     * Address line 2 of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    address2?: string;
    /**
     * City of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    city?: string;
    /**
     * Unique code for this distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    code?: string;
    /**
     * Country code of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    country_code?: string;
    /**
     * True if this is the default distribution center on the account
     * @type {boolean}
     * @memberof DistributionCenter
     */
    default_center?: boolean;
    /**
     * True if this distribution center handles all new items by default
     * @type {boolean}
     * @memberof DistributionCenter
     */
    default_handles_all_items?: boolean;
    /**
     * Distribution center object identifier
     * @type {number}
     * @memberof DistributionCenter
     */
    distribution_center_oid?: number;
    /**
     * DUNS number assigned to this distribution center (EDI)
     * @type {string}
     * @memberof DistributionCenter
     */
    duns?: string;
    /**
     * Estimate shipments for this distribution center as if they came from the other distribution center
     * @type {number}
     * @memberof DistributionCenter
     */
    estimate_from_distribution_center_oid?: number;
    /**
     * Password associated with the virtual FTP
     * @type {string}
     * @memberof DistributionCenter
     */
    ftp_password?: string;
    /**
     * The number of minutes to hold a shipment
     * @type {number}
     * @memberof DistributionCenter
     */
    hold_before_shipment_minutes?: number;
    /**
     * True if the shipment should be held before transmission and require a manual release
     * @type {boolean}
     * @memberof DistributionCenter
     */
    hold_before_transmission?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DistributionCenter
     */
    holdAutoOrderBeforeShipmentMinutes?: number;
    /**
     * Latitude where the distribution center is located
     * @type {number}
     * @memberof DistributionCenter
     */
    latitude?: number;
    /**
     * Longitude where the distribution center is located
     * @type {number}
     * @memberof DistributionCenter
     */
    longitude?: number;
    /**
     * Name of this distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    name?: string;
    /**
     * True if this distribution center does not handle customer direct shipments
     * @type {boolean}
     * @memberof DistributionCenter
     */
    no_customer_direct_shipments?: boolean;
    /**
     * True if this distribution center is not allowed to participate in a split shipment.
     * @type {boolean}
     * @memberof DistributionCenter
     */
    no_split_shipment?: boolean;
    /**
     * Postal code of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    postal_code?: string;
    /**
     * The number of processing days required before an order ships
     * @type {number}
     * @memberof DistributionCenter
     */
    process_days?: number;
    /**
     * The time (EST) after which inventory updates will be processed
     * @type {string}
     * @memberof DistributionCenter
     */
    process_inventory_start_time?: string;
    /**
     * The time (EST) before which inventory updates will be processed
     * @type {string}
     * @memberof DistributionCenter
     */
    process_inventory_stop_time?: string;
    /**
     * True if ASNs are required for this distribution center (EDI)
     * @type {boolean}
     * @memberof DistributionCenter
     */
    require_asn?: boolean;
    /**
     * True if we should send the kit instead of the components
     * @type {boolean}
     * @memberof DistributionCenter
     */
    send_kit_instead_of_components?: boolean;
    /**
     * The time (EST) after which shipments will not be processed on Friday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipment_cutoff_time_friday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Monday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipment_cutoff_time_monday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Saturday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipment_cutoff_time_saturday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Sunday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipment_cutoff_time_sunday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Thursday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipment_cutoff_time_thursday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Tuesday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipment_cutoff_time_tuesday?: string;
    /**
     * The time (EST) after which shipments will not be processed on Wednesday
     * @type {string}
     * @memberof DistributionCenter
     */
    shipment_cutoff_time_wednesday?: string;
    /**
     * State of the distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    state?: string;
    /**
     * Transport mechanism for this distribution center
     * @type {string}
     * @memberof DistributionCenter
     */
    transport?: string;
}

/**
 * 
 * @export
 * @interface DistributionCentersResponse
 */
export interface DistributionCentersResponse {
    /**
     * 
     * @type {Array<DistributionCenter>}
     * @memberof DistributionCentersResponse
     */
    distribution_centers?: Array<DistributionCenter>;
    /**
     * 
     * @type {ModelError}
     * @memberof DistributionCentersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof DistributionCentersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof DistributionCentersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof DistributionCentersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailBaseTemplateListResponse
 */
export interface EmailBaseTemplateListResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailBaseTemplateListResponse
     */
    templatePaths?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailCampaign
 */
export interface EmailCampaign {
    /**
     * Click rate of emails
     * @type {string}
     * @memberof EmailCampaign
     */
    click_rate_formatted?: string;
    /**
     * Created date
     * @type {string}
     * @memberof EmailCampaign
     */
    created_dts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailCampaign
     */
    deleted?: boolean;
    /**
     * Email campaign UUID
     * @type {string}
     * @memberof EmailCampaign
     */
    email_campaign_uuid?: string;
    /**
     * Email communication sequence UUID
     * @type {string}
     * @memberof EmailCampaign
     */
    email_communication_sequence_uuid?: string;
    /**
     * True if the customer should end the flow once they purchase from this campaign
     * @type {boolean}
     * @memberof EmailCampaign
     */
    end_once_customer_purchases?: boolean;
    /**
     * True if the customer should end the flow once they purchase from anywhere
     * @type {boolean}
     * @memberof EmailCampaign
     */
    end_once_customer_purchases_anywhere?: boolean;
    /**
     * Campaign folder UUID.  Null for uncategorized
     * @type {string}
     * @memberof EmailCampaign
     */
    esp_campaign_folder_uuid?: string;
    /**
     * User of the sending address
     * @type {string}
     * @memberof EmailCampaign
     */
    esp_domain_user?: string;
    /**
     * UUID of the sending domain
     * @type {string}
     * @memberof EmailCampaign
     */
    esp_domain_uuid?: string;
    /**
     * Friendly name of the sending email
     * @type {string}
     * @memberof EmailCampaign
     */
    esp_friendly_name?: string;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof EmailCampaign
     */
    library_item_oid?: number;
    /**
     * List and segment memberships
     * @type {Array<EmailListSegmentMembership>}
     * @memberof EmailCampaign
     */
    memberships?: Array<EmailListSegmentMembership>;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCampaign
     */
    merchant_id?: string;
    /**
     * Name of email campaign
     * @type {string}
     * @memberof EmailCampaign
     */
    name?: string;
    /**
     * Open rate of emails
     * @type {string}
     * @memberof EmailCampaign
     */
    open_rate_formatted?: string;
    /**
     * True if this campaign is prevented from sending at this time due to spam complaints.
     * @type {boolean}
     * @memberof EmailCampaign
     */
    prevent_sending_due_to_spam?: boolean;
    /**
     * Revenue associated with campaign
     * @type {string}
     * @memberof EmailCampaign
     */
    revenue_formatted?: string;
    /**
     * Revenue per customer associated with campaign
     * @type {string}
     * @memberof EmailCampaign
     */
    revenue_per_customer_formatted?: string;
    /**
     * Scheduled date
     * @type {string}
     * @memberof EmailCampaign
     */
    scheduled_dts?: string;
    /**
     * URL to a large full length screenshot
     * @type {string}
     * @memberof EmailCampaign
     */
    screenshot_large_full_url?: string;
    /**
     * Status of the campaign of draft, archived, and sent
     * @type {string}
     * @memberof EmailCampaign
     */
    status?: string;
    /**
     * Timestamp when the last status change happened
     * @type {string}
     * @memberof EmailCampaign
     */
    status_dts?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCampaign
     */
    storefront_oid?: number;
}

/**
 * 
 * @export
 * @interface EmailCampaignFolder
 */
export interface EmailCampaignFolder {
    /**
     * Email campaign folder UUID
     * @type {string}
     * @memberof EmailCampaignFolder
     */
    esp_campaign_folder_uuid?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCampaignFolder
     */
    merchant_id?: string;
    /**
     * Name of email campaign folder
     * @type {string}
     * @memberof EmailCampaignFolder
     */
    name?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCampaignFolder
     */
    storefront_oid?: number;
    /**
     * System generated folder
     * @type {boolean}
     * @memberof EmailCampaignFolder
     */
    system_generated?: boolean;
}

/**
 * 
 * @export
 * @interface EmailCampaignFolderResponse
 */
export interface EmailCampaignFolderResponse {
    /**
     * 
     * @type {EmailCampaignFolder}
     * @memberof EmailCampaignFolderResponse
     */
    campaign_folder?: EmailCampaignFolder;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCampaignFolderResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCampaignFolderResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCampaignFolderResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCampaignFolderResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCampaignFoldersResponse
 */
export interface EmailCampaignFoldersResponse {
    /**
     * 
     * @type {Array<EmailCampaignFolder>}
     * @memberof EmailCampaignFoldersResponse
     */
    campaign_folders?: Array<EmailCampaignFolder>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCampaignFoldersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCampaignFoldersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCampaignFoldersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCampaignFoldersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCampaignResponse
 */
export interface EmailCampaignResponse {
    /**
     * 
     * @type {EmailCampaign}
     * @memberof EmailCampaignResponse
     */
    campaign?: EmailCampaign;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCampaignResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCampaignResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCampaignResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCampaignResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCampaignsResponse
 */
export interface EmailCampaignsResponse {
    /**
     * 
     * @type {Array<EmailCampaign>}
     * @memberof EmailCampaignsResponse
     */
    campaigns?: Array<EmailCampaign>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCampaignsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCampaignsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCampaignsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCampaignsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailClick
 */
export interface EmailClick {
    /**
     * Click Count
     * @type {number}
     * @memberof EmailClick
     */
    click_count?: number;
    /**
     * url
     * @type {string}
     * @memberof EmailClick
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface EmailClicksResponse
 */
export interface EmailClicksResponse {
    /**
     * 
     * @type {Array<EmailClick>}
     * @memberof EmailClicksResponse
     */
    clicks?: Array<EmailClick>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailClicksResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailClicksResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailClicksResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailClicksResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseq
 */
export interface EmailCommseq {
    /**
     * Array of steps
     * @type {Array<EmailCommseqStep>}
     * @memberof EmailCommseq
     */
    email_communication_sequence_steps?: Array<EmailCommseqStep>;
    /**
     * Email commseq UUID
     * @type {string}
     * @memberof EmailCommseq
     */
    email_communication_sequence_uuid?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseq
     */
    merchant_id?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseq
     */
    storefront_oid?: number;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmail
 */
export interface EmailCommseqEmail {
    /**
     * Deleted
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    deleted?: boolean;
    /**
     * Edited by user
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    edited_by_user?: string;
    /**
     * Email communication sequence email uuid
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    email_communication_sequence_email_uuid?: string;
    /**
     * Email commseq UUID
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    email_communication_sequence_uuid?: string;
    /**
     * Email container cjson
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    email_container_cjson?: string;
    /**
     * Timestamp the last time the container was modified.
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    email_container_cjson_last_modified_dts?: string;
    /**
     * Email template virtual path
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    email_template_vm_path?: string;
    /**
     * Filter profile equation json
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    filter_profile_equation_json?: string;
    /**
     * Individually render
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    individually_render?: boolean;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof EmailCommseqEmail
     */
    library_item_oid?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    merchant_id?: string;
    /**
     * True if the content of this email is pending review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    pending_review?: boolean;
    /**
     * Preview text
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    preview_text?: string;
    /**
     * True if the content of this email was rejected during review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    rejected?: boolean;
    /**
     * True if the content of this email is requires review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    requires_review?: boolean;
    /**
     * URL to screenshot in large form factor full page
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshot_large_full_url?: string;
    /**
     * URL to screenshot in large form factor viewport
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshot_large_viewport_url?: string;
    /**
     * URL to screenshot in small form factor full page
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshot_small_full_url?: string;
    /**
     * URL to screenshot in small form factor viewport
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    screenshot_small_viewport_url?: string;
    /**
     * Smart sending
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    smart_sending?: boolean;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseqEmail
     */
    storefront_oid?: number;
    /**
     * Subject
     * @type {string}
     * @memberof EmailCommseqEmail
     */
    subject?: string;
    /**
     * True if the email was suspended for too high of a spam rate.
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    suspended_for_spam?: boolean;
    /**
     * Transactional email
     * @type {boolean}
     * @memberof EmailCommseqEmail
     */
    transactional_email?: boolean;
    /**
     * Version
     * @type {number}
     * @memberof EmailCommseqEmail
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailResponse
 */
export interface EmailCommseqEmailResponse {
    /**
     * 
     * @type {EmailCommseqEmail}
     * @memberof EmailCommseqEmailResponse
     */
    email?: EmailCommseqEmail;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqEmailResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailSendTestRequest
 */
export interface EmailCommseqEmailSendTestRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    cart_id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    cart_item_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    esp_commseq_email_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    esp_commseq_step_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    esp_commseq_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    order_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    please_review?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    send_to_additional_emails?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof EmailCommseqEmailSendTestRequest
     */
    send_to_logged_in_user?: boolean;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailSendTestResponse
 */
export interface EmailCommseqEmailSendTestResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailSendTestResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailsRequest
 */
export interface EmailCommseqEmailsRequest {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqEmailsRequest
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqEmailsRequest
     */
    esp_commseq_email_uuids?: Array<string>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailsRequest
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailsRequest
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailsRequest
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqEmailsResponse
 */
export interface EmailCommseqEmailsResponse {
    /**
     * 
     * @type {Array<EmailCommseqEmail>}
     * @memberof EmailCommseqEmailsResponse
     */
    emails?: Array<EmailCommseqEmail>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqEmailsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqEmailsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqEmailsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqEmailsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcard
 */
export interface EmailCommseqPostcard {
    /**
     * Deleted
     * @type {boolean}
     * @memberof EmailCommseqPostcard
     */
    deleted?: boolean;
    /**
     * Edited by user
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    edited_by_user?: string;
    /**
     * communication sequence postcard uuid
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    email_communication_sequence_postcard_uuid?: string;
    /**
     * Filter profile equation json
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    filter_profile_equation_json?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    merchant_id?: string;
    /**
     * Postcard back container cjson
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcard_back_container_cjson?: string;
    /**
     * Postcard back container uuid
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcard_back_container_uuid?: string;
    /**
     * Timestamp the last time the container was modified.
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcard_container_cjson_last_modified_dts?: string;
    /**
     * Postcard front container cjson
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcard_front_container_cjson?: string;
    /**
     * Postcard front container uuid
     * @type {string}
     * @memberof EmailCommseqPostcard
     */
    postcard_front_container_uuid?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseqPostcard
     */
    storefront_oid?: number;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardResponse
 */
export interface EmailCommseqPostcardResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqPostcardResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqPostcardResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailCommseqPostcard}
     * @memberof EmailCommseqPostcardResponse
     */
    postcard?: EmailCommseqPostcard;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqPostcardResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqPostcardResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardSendTestRequest
 */
export interface EmailCommseqPostcardSendTestRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    address_1?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    address_2?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    cart_id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    cart_item_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    esp_commseq_postcard_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    esp_commseq_step_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    esp_commseq_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    order_id?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    postal_code?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestRequest
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardSendTestResponse
 */
export interface EmailCommseqPostcardSendTestResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    backThumbnail?: string;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    frontThumbnail?: string;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    renderedPdf?: string;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqPostcardSendTestResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardsRequest
 */
export interface EmailCommseqPostcardsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqPostcardsRequest
     */
    esp_commseq_postcard_uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailCommseqPostcardsResponse
 */
export interface EmailCommseqPostcardsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqPostcardsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqPostcardsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailCommseqPostcard>}
     * @memberof EmailCommseqPostcardsResponse
     */
    postcards?: Array<EmailCommseqPostcard>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqPostcardsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqPostcardsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqResponse
 */
export interface EmailCommseqResponse {
    /**
     * 
     * @type {EmailCommseq}
     * @memberof EmailCommseqResponse
     */
    communication_sequence?: EmailCommseq;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqStat
 */
export interface EmailCommseqStat {
    /**
     * Count of clicked emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    click_count?: number;
    /**
     * Count of clicked emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    click_count_formatted?: string;
    /**
     * Count of conversion
     * @type {number}
     * @memberof EmailCommseqStat
     */
    conversion_count?: number;
    /**
     * Count of conversions, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    conversion_count_formatted?: string;
    /**
     * Count of delivered emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    delivered_count?: number;
    /**
     * Count of delivered emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    delivered_count_formatted?: string;
    /**
     * UUID associated with the communication sequence
     * @type {string}
     * @memberof EmailCommseqStat
     */
    email_communication_sequence_uuid?: string;
    /**
     * Count of customers that finished the sequence
     * @type {number}
     * @memberof EmailCommseqStat
     */
    finished_count?: number;
    /**
     * Count of customers that finished the sequence, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    finished_count_formatted?: string;
    /**
     * Count of customers in progress
     * @type {number}
     * @memberof EmailCommseqStat
     */
    in_progress_count?: number;
    /**
     * Count of customers in progress, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    in_progress_count_formatted?: string;
    /**
     * Count of emails kicked
     * @type {number}
     * @memberof EmailCommseqStat
     */
    kickbox_count?: number;
    /**
     * Count of emails kicked, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    kickbox_count_formatted?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailCommseqStat
     */
    merchant_id?: string;
    /**
     * Count of opened emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    open_count?: number;
    /**
     * Count of opened emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    open_count_formatted?: string;
    /**
     * Count of orders
     * @type {number}
     * @memberof EmailCommseqStat
     */
    order_count?: number;
    /**
     * Count of orders, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    order_count_formatted?: string;
    /**
     * Count of emails permanently bounced
     * @type {number}
     * @memberof EmailCommseqStat
     */
    permanent_bounce_count?: number;
    /**
     * Count of emails permanently bounced, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    permanent_bounce_count_formatted?: string;
    /**
     * Profit
     * @type {number}
     * @memberof EmailCommseqStat
     */
    profit?: number;
    /**
     * Profit, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    profit_formatted?: string;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailCommseqStat
     */
    revenue?: number;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    revenue_formatted?: string;
    /**
     * Count of emails sent
     * @type {number}
     * @memberof EmailCommseqStat
     */
    send_count?: number;
    /**
     * Count of emails sent, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    send_count_formatted?: string;
    /**
     * Count of skipped emails
     * @type {number}
     * @memberof EmailCommseqStat
     */
    skipped_count?: number;
    /**
     * Count of skipped emails, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    skipped_count_formatted?: string;
    /**
     * Count of emails classified as spam
     * @type {number}
     * @memberof EmailCommseqStat
     */
    spam_count?: number;
    /**
     * Count of emails classified as spam, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    spam_count_formatted?: string;
    /**
     * Count of customers that started the sequence
     * @type {number}
     * @memberof EmailCommseqStat
     */
    started_count?: number;
    /**
     * Count of customers that started the sequence, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    started_count_formatted?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailCommseqStat
     */
    storefront_oid?: number;
    /**
     * Count of unsubscribes caused
     * @type {number}
     * @memberof EmailCommseqStat
     */
    unsubscribe_count?: number;
    /**
     * Count of unsubscribes caused, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    unsubscribe_count_formatted?: string;
    /**
     * Count of views
     * @type {number}
     * @memberof EmailCommseqStat
     */
    view_count?: number;
    /**
     * Count of views, formatted
     * @type {string}
     * @memberof EmailCommseqStat
     */
    view_count_formatted?: string;
}

/**
 * 
 * @export
 * @interface EmailCommseqStatResponse
 */
export interface EmailCommseqStatResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqStatResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqStatResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailCommseqStat}
     * @memberof EmailCommseqStatResponse
     */
    stats?: EmailCommseqStat;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqStatResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqStatResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqStep
 */
export interface EmailCommseqStep {
    /**
     * Array of child steps for the alternate path
     * @type {Array<EmailCommseqStep>}
     * @memberof EmailCommseqStep
     */
    alt_child_email_communication_sequence_steps?: Array<EmailCommseqStep>;
    /**
     * Array of child steps
     * @type {Array<EmailCommseqStep>}
     * @memberof EmailCommseqStep
     */
    child_email_communication_sequence_steps?: Array<EmailCommseqStep>;
    /**
     * Email commseq step UUID
     * @type {string}
     * @memberof EmailCommseqStep
     */
    email_communication_sequence_step_uuid?: string;
    /**
     * True if the content of the email associated with this step is pending review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqStep
     */
    email_pending_review?: boolean;
    /**
     * True if the content of the email associated with this step was rejected during review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqStep
     */
    email_rejected?: boolean;
    /**
     * True if the content of the email associated with this step requires review by UltraCart
     * @type {boolean}
     * @memberof EmailCommseqStep
     */
    email_requires_review?: boolean;
    /**
     * Filter profile equation JSON
     * @type {string}
     * @memberof EmailCommseqStep
     */
    filter_profile_equation_json?: string;
    /**
     * Internal merchant notes
     * @type {string}
     * @memberof EmailCommseqStep
     */
    merchant_notes?: string;
    /**
     * Arbitrary Configuration for a step
     * @type {string}
     * @memberof EmailCommseqStep
     */
    step_config_json?: string;
    /**
     * Type of step
     * @type {string}
     * @memberof EmailCommseqStep
     */
    type?: EmailCommseqStep.TypeEnum;
}

/**
 * @export
 * @namespace EmailCommseqStep
 */
export namespace EmailCommseqStep {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Begin = <any> 'begin',
        Wait = <any> 'wait',
        Email = <any> 'email',
        Merge = <any> 'merge',
        Condition = <any> 'condition',
        End = <any> 'end'
    }
}

/**
 * 
 * @export
 * @interface EmailCommseqStepLog
 */
export interface EmailCommseqStepLog {
    /**
     * Email
     * @type {string}
     * @memberof EmailCommseqStepLog
     */
    email?: string;
    /**
     * Log text
     * @type {string}
     * @memberof EmailCommseqStepLog
     */
    log?: string;
    /**
     * Log date/time
     * @type {string}
     * @memberof EmailCommseqStepLog
     */
    log_dts?: string;
}

/**
 * 
 * @export
 * @interface EmailCommseqStepLogsResponse
 */
export interface EmailCommseqStepLogsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqStepLogsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<EmailCommseqStepLog>}
     * @memberof EmailCommseqStepLogsResponse
     */
    logs?: Array<EmailCommseqStepLog>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqStepLogsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqStepLogsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqStepLogsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCommseqWebhookSendTestRequest
 */
export interface EmailCommseqWebhookSendTestRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqWebhookSendTestRequest
     */
    cart_id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCommseqWebhookSendTestRequest
     */
    cart_item_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqWebhookSendTestRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqWebhookSendTestRequest
     */
    esp_commseq_step_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqWebhookSendTestRequest
     */
    esp_commseq_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqWebhookSendTestRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailCommseqWebhookSendTestRequest
     */
    order_id?: string;
}

/**
 * 
 * @export
 * @interface EmailCommseqsResponse
 */
export interface EmailCommseqsResponse {
    /**
     * 
     * @type {Array<EmailCommseq>}
     * @memberof EmailCommseqsResponse
     */
    communication_sequences?: Array<EmailCommseq>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCommseqsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCommseqsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCommseqsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCommseqsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCustomer
 */
export interface EmailCustomer {
    /**
     * True if the customer is flagged as active within StoreFront Communications
     * @type {boolean}
     * @memberof EmailCustomer
     */
    active?: boolean;
    /**
     * Email
     * @type {string}
     * @memberof EmailCustomer
     */
    email?: string;
    /**
     * Email customer UUID
     * @type {string}
     * @memberof EmailCustomer
     */
    email_customer_uuid?: string;
    /**
     * First name
     * @type {string}
     * @memberof EmailCustomer
     */
    first_name?: string;
    /**
     * True if the customer has globally unsubscribed from all communication.
     * @type {boolean}
     * @memberof EmailCustomer
     */
    global_unsubscribe?: boolean;
    /**
     * Last interaction
     * @type {string}
     * @memberof EmailCustomer
     */
    last_interaction_dts?: string;
    /**
     * Last name
     * @type {string}
     * @memberof EmailCustomer
     */
    last_name?: string;
    /**
     * UUIDs of the lists they are subscribed to
     * @type {Array<string>}
     * @memberof EmailCustomer
     */
    list_uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailCustomerEditorUrlResponse
 */
export interface EmailCustomerEditorUrlResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailCustomerEditorUrlResponse
     */
    editor_url?: string;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailCustomerEditorUrlResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailCustomerEditorUrlResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailCustomerEditorUrlResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailCustomerEditorUrlResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailCustomersResponse
 */
export interface EmailCustomersResponse {
    /**
     * Customers on the page
     * @type {Array<EmailCustomer>}
     * @memberof EmailCustomersResponse
     */
    customers?: Array<EmailCustomer>;
    /**
     * Page number (one based offset)
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    page_number?: number;
    /**
     * Number of records per page
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    page_size?: number;
    /**
     * Total customers
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    total_customers?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof EmailCustomersResponse
     */
    total_pages?: number;
}

/**
 * 
 * @export
 * @interface EmailDashboardActivity
 */
export interface EmailDashboardActivity {
    /**
     * Type of action such as add, remove, subscribe, unsubscribe
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    action?: string;
    /**
     * Date/time of the activity
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    activity_dts?: string;
    /**
     * List or segment name
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    destination_name?: string;
    /**
     * List or segment uuid
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    destination_uuid?: string;
    /**
     * Email address
     * @type {string}
     * @memberof EmailDashboardActivity
     */
    email?: string;
    /**
     * true if activity is related to list
     * @type {boolean}
     * @memberof EmailDashboardActivity
     */
    is_list?: boolean;
    /**
     * true if activity is related to segment
     * @type {boolean}
     * @memberof EmailDashboardActivity
     */
    is_segment?: boolean;
}

/**
 * 
 * @export
 * @interface EmailDashboardActivityResponse
 */
export interface EmailDashboardActivityResponse {
    /**
     * 
     * @type {Array<EmailDashboardActivity>}
     * @memberof EmailDashboardActivityResponse
     */
    activity?: Array<EmailDashboardActivity>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailDashboardActivityResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailDashboardActivityResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailDashboardActivityResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailDashboardActivityResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailDashboardStatsResponse
 */
export interface EmailDashboardStatsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailDashboardStatsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailDashboardStatsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailStat>}
     * @memberof EmailDashboardStatsResponse
     */
    stats?: Array<EmailStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailDashboardStatsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailDashboardStatsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailDomain
 */
export interface EmailDomain {
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    comment?: string;
    /**
     * 
     * @type {Array<VerificationRecord>}
     * @memberof EmailDomain
     */
    dkim?: Array<VerificationRecord>;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    dkim_status?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    domain?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    esp_domain_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    identity_status?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    merchant_id?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    start_dkim_dts?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDomain
     */
    start_identity_dts?: string;
    /**
     * 
     * @type {VerificationRecord}
     * @memberof EmailDomain
     */
    verification?: VerificationRecord;
}

/**
 * 
 * @export
 * @interface EmailEditorTokenResponse
 */
export interface EmailEditorTokenResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailEditorTokenResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailEditorTokenResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailEditorTokenResponse
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmailEditorTokenResponse
     */
    token?: string;
    /**
     * 
     * @type {Warning}
     * @memberof EmailEditorTokenResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlow
 */
export interface EmailFlow {
    /**
     * True if a customer may be enrolled in this flow multiple times
     * @type {boolean}
     * @memberof EmailFlow
     */
    allow_multiple_concurrent_enrollments?: boolean;
    /**
     * True if the flow is currently performing a back population.
     * @type {boolean}
     * @memberof EmailFlow
     */
    back_populating?: boolean;
    /**
     * Click rate of emails, formatted
     * @type {string}
     * @memberof EmailFlow
     */
    click_rate_formatted?: string;
    /**
     * Created date
     * @type {string}
     * @memberof EmailFlow
     */
    created_dts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailFlow
     */
    deleted?: boolean;
    /**
     * Email communication sequence UUID
     * @type {string}
     * @memberof EmailFlow
     */
    email_communication_sequence_uuid?: string;
    /**
     * Email flow UUID
     * @type {string}
     * @memberof EmailFlow
     */
    email_flow_uuid?: string;
    /**
     * True if the customer should end the flow once they purchase from an email on this flow
     * @type {boolean}
     * @memberof EmailFlow
     */
    end_once_customer_purchases?: boolean;
    /**
     * True if the customer should end the flow once they purchase from any source
     * @type {boolean}
     * @memberof EmailFlow
     */
    end_once_customer_purchases_anywhere?: boolean;
    /**
     * Number of enrolled customers.
     * @type {number}
     * @memberof EmailFlow
     */
    enrolled_customers?: number;
    /**
     * Username of sending email
     * @type {string}
     * @memberof EmailFlow
     */
    esp_domain_user?: string;
    /**
     * UUID of sending domain
     * @type {string}
     * @memberof EmailFlow
     */
    esp_domain_uuid?: string;
    /**
     * Flow folder UUID.  Null for uncategorized
     * @type {string}
     * @memberof EmailFlow
     */
    esp_flow_folder_uuid?: string;
    /**
     * Friendly name of the sending email
     * @type {string}
     * @memberof EmailFlow
     */
    esp_friendly_name?: string;
    /**
     * File profile equation json
     * @type {string}
     * @memberof EmailFlow
     */
    filter_profile_equation_json?: string;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof EmailFlow
     */
    library_item_oid?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailFlow
     */
    merchant_id?: string;
    /**
     * Name of email flow
     * @type {string}
     * @memberof EmailFlow
     */
    name?: string;
    /**
     * Open rate of emails, formatted
     * @type {string}
     * @memberof EmailFlow
     */
    open_rate_formatted?: string;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailFlow
     */
    revenue_formatted?: string;
    /**
     * Revenue per customer, formatted
     * @type {string}
     * @memberof EmailFlow
     */
    revenue_per_customer_formatted?: string;
    /**
     * URL to a large full length screenshot
     * @type {string}
     * @memberof EmailFlow
     */
    screenshot_large_full_url?: string;
    /**
     * Status of the campaign of draft, archived, active, and inactive
     * @type {string}
     * @memberof EmailFlow
     */
    status?: string;
    /**
     * Timestamp when the last status change happened
     * @type {string}
     * @memberof EmailFlow
     */
    status_dts?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailFlow
     */
    storefront_oid?: number;
    /**
     * Trigger parameter
     * @type {string}
     * @memberof EmailFlow
     */
    trigger_parameter?: string;
    /**
     * Trigger parameter name
     * @type {string}
     * @memberof EmailFlow
     */
    trigger_parameter_name?: string;
    /**
     * Trigger type
     * @type {string}
     * @memberof EmailFlow
     */
    trigger_type?: string;
}

/**
 * 
 * @export
 * @interface EmailFlowBackPopulateRequest
 */
export interface EmailFlowBackPopulateRequest {
    /**
     * The age of the orders that should be considered for order triggers.
     * @type {number}
     * @memberof EmailFlowBackPopulateRequest
     */
    order_days_old?: number;
    /**
     * True if the age of the event should be considered when reducing the initial flow wait step
     * @type {boolean}
     * @memberof EmailFlowBackPopulateRequest
     */
    relative_to_event?: boolean;
}

/**
 * 
 * @export
 * @interface EmailFlowBackPopulateResponse
 */
export interface EmailFlowBackPopulateResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailFlowBackPopulateResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowBackPopulateResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowBackPopulateResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowBackPopulateResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlowFolder
 */
export interface EmailFlowFolder {
    /**
     * Email flow folder UUID
     * @type {string}
     * @memberof EmailFlowFolder
     */
    esp_flow_folder_uuid?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailFlowFolder
     */
    merchant_id?: string;
    /**
     * Name of email flow folder
     * @type {string}
     * @memberof EmailFlowFolder
     */
    name?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailFlowFolder
     */
    storefront_oid?: number;
    /**
     * System generated folder
     * @type {boolean}
     * @memberof EmailFlowFolder
     */
    system_generated?: boolean;
}

/**
 * 
 * @export
 * @interface EmailFlowFolderResponse
 */
export interface EmailFlowFolderResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailFlowFolderResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {EmailFlowFolder}
     * @memberof EmailFlowFolderResponse
     */
    flow_folder?: EmailFlowFolder;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowFolderResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowFolderResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowFolderResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlowFoldersResponse
 */
export interface EmailFlowFoldersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailFlowFoldersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<EmailFlowFolder>}
     * @memberof EmailFlowFoldersResponse
     */
    flow_folders?: Array<EmailFlowFolder>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowFoldersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowFoldersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowFoldersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlowResponse
 */
export interface EmailFlowResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailFlowResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {EmailFlow}
     * @memberof EmailFlowResponse
     */
    flow?: EmailFlow;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailFlowsResponse
 */
export interface EmailFlowsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailFlowsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<EmailFlow>}
     * @memberof EmailFlowsResponse
     */
    flows?: Array<EmailFlow>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailFlowsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailFlowsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailFlowsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailGlobalSettings
 */
export interface EmailGlobalSettings {
    /**
     * 
     * @type {boolean}
     * @memberof EmailGlobalSettings
     */
    dedicated_ip?: boolean;
}

/**
 * 
 * @export
 * @interface EmailGlobalSettingsResponse
 */
export interface EmailGlobalSettingsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailGlobalSettingsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {EmailGlobalSettings}
     * @memberof EmailGlobalSettingsResponse
     */
    global_settings?: EmailGlobalSettings;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailGlobalSettingsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailGlobalSettingsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailGlobalSettingsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailGlobalUnsubscribeRequest
 */
export interface EmailGlobalUnsubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailGlobalUnsubscribeRequest
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface EmailGlobalUnsubscribeResponse
 */
export interface EmailGlobalUnsubscribeResponse {
    /**
     * 
     * @type {number}
     * @memberof EmailGlobalUnsubscribeResponse
     */
    listsUnsubscribed?: number;
}

/**
 * 
 * @export
 * @interface EmailHistogramPropertyNamesResponse
 */
export interface EmailHistogramPropertyNamesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailHistogramPropertyNamesResponse
     */
    property_names?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailHistogramPropertyValuesResponse
 */
export interface EmailHistogramPropertyValuesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailHistogramPropertyValuesResponse
     */
    property_values?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailList
 */
export interface EmailList {
    /**
     * True if the current user has the rights to download this list.
     * @type {boolean}
     * @memberof EmailList
     */
    allow_csv_download?: boolean;
    /**
     * Created date
     * @type {string}
     * @memberof EmailList
     */
    created_dts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailList
     */
    deleted?: boolean;
    /**
     * Email list UUID
     * @type {string}
     * @memberof EmailList
     */
    email_list_uuid?: string;
    /**
     * List/Segment folder UUID
     * @type {string}
     * @memberof EmailList
     */
    esp_list_segment_folder_uuid?: string;
    /**
     * Count of members in this list
     * @type {number}
     * @memberof EmailList
     */
    member_count?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailList
     */
    merchant_id?: string;
    /**
     * Name of email list
     * @type {string}
     * @memberof EmailList
     */
    name?: string;
    /**
     * Description of list shown to customer.
     * @type {string}
     * @memberof EmailList
     */
    public_description?: string;
    /**
     * True if this list is public
     * @type {boolean}
     * @memberof EmailList
     */
    public_list?: boolean;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailList
     */
    storefront_oid?: number;
    /**
     * Details on the flows or campaigns that use this list.
     * @type {Array<EmailListSegmentUsedBy>}
     * @memberof EmailList
     */
    used_by?: Array<EmailListSegmentUsedBy>;
}

/**
 * 
 * @export
 * @interface EmailListArchiveResponse
 */
export interface EmailListArchiveResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailListArchiveResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {boolean}
     * @memberof EmailListArchiveResponse
     */
    list_in_use?: boolean;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListArchiveResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListArchiveResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListArchiveResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailListCustomer
 */
export interface EmailListCustomer {
    /**
     * Added timestamp
     * @type {string}
     * @memberof EmailListCustomer
     */
    add_dts?: string;
    /**
     * Email
     * @type {string}
     * @memberof EmailListCustomer
     */
    email?: string;
    /**
     * Email customer UUID
     * @type {string}
     * @memberof EmailListCustomer
     */
    email_customer_uuid?: string;
    /**
     * Email list member UUID
     * @type {string}
     * @memberof EmailListCustomer
     */
    email_list_member_uuid?: string;
}

/**
 * 
 * @export
 * @interface EmailListCustomersResponse
 */
export interface EmailListCustomersResponse {
    /**
     * Customers on the page
     * @type {Array<EmailListCustomer>}
     * @memberof EmailListCustomersResponse
     */
    customers?: Array<EmailListCustomer>;
    /**
     * Page number (one based offset)
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    page_number?: number;
    /**
     * Number of records per page
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    page_size?: number;
    /**
     * Total customers
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    total_customers?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof EmailListCustomersResponse
     */
    total_pages?: number;
}

/**
 * 
 * @export
 * @interface EmailListResponse
 */
export interface EmailListResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailListResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {EmailList}
     * @memberof EmailListResponse
     */
    list?: EmailList;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailListSegmentFolder
 */
export interface EmailListSegmentFolder {
    /**
     * Email list segment folder UUID
     * @type {string}
     * @memberof EmailListSegmentFolder
     */
    esp_list_segment_folder_uuid?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailListSegmentFolder
     */
    merchant_id?: string;
    /**
     * Name of email campaign folder
     * @type {string}
     * @memberof EmailListSegmentFolder
     */
    name?: string;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailListSegmentFolder
     */
    storefront_oid?: number;
    /**
     * System generated folder
     * @type {boolean}
     * @memberof EmailListSegmentFolder
     */
    system_generated?: boolean;
}

/**
 * 
 * @export
 * @interface EmailListSegmentFolderResponse
 */
export interface EmailListSegmentFolderResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailListSegmentFolderResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {EmailListSegmentFolder}
     * @memberof EmailListSegmentFolderResponse
     */
    list_segment_folder?: EmailListSegmentFolder;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListSegmentFolderResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListSegmentFolderResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListSegmentFolderResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailListSegmentFoldersResponse
 */
export interface EmailListSegmentFoldersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailListSegmentFoldersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<EmailListSegmentFolder>}
     * @memberof EmailListSegmentFoldersResponse
     */
    list_segment_folders?: Array<EmailListSegmentFolder>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListSegmentFoldersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListSegmentFoldersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListSegmentFoldersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailListSegmentMembership
 */
export interface EmailListSegmentMembership {
    /**
     * UUID identifying this email list or null if this is a segment
     * @type {string}
     * @memberof EmailListSegmentMembership
     */
    email_list_uuid?: string;
    /**
     * UUID identifying this email segment or null if this is a list
     * @type {string}
     * @memberof EmailListSegmentMembership
     */
    email_segment_uuid?: string;
    /**
     * true if customers from this list/segment is excluded from membership
     * @type {boolean}
     * @memberof EmailListSegmentMembership
     */
    exclude?: boolean;
    /**
     * Name of this email list or segment
     * @type {string}
     * @memberof EmailListSegmentMembership
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EmailListSegmentUsedBy
 */
export interface EmailListSegmentUsedBy {
    /**
     * Email campaign UUID
     * @type {string}
     * @memberof EmailListSegmentUsedBy
     */
    email_campaign_uuid?: string;
    /**
     * Email flow UUID
     * @type {string}
     * @memberof EmailListSegmentUsedBy
     */
    email_flow_uuid?: string;
    /**
     * Name of the list or segment.
     * @type {string}
     * @memberof EmailListSegmentUsedBy
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EmailListSubscribeResponse
 */
export interface EmailListSubscribeResponse {
    /**
     * 
     * @type {number}
     * @memberof EmailListSubscribeResponse
     */
    added?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailListSubscribeResponse
     */
    memberCount?: number;
}

/**
 * 
 * @export
 * @interface EmailListsResponse
 */
export interface EmailListsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailListsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<EmailList>}
     * @memberof EmailListsResponse
     */
    lists?: Array<EmailList>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailListsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailListsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailListsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailOrder
 */
export interface EmailOrder {
    /**
     * email
     * @type {string}
     * @memberof EmailOrder
     */
    email?: string;
    /**
     * order_dts
     * @type {string}
     * @memberof EmailOrder
     */
    order_dts?: string;
    /**
     * order_id
     * @type {string}
     * @memberof EmailOrder
     */
    order_id?: string;
    /**
     * 
     * @type {Currency}
     * @memberof EmailOrder
     */
    total?: Currency;
}

/**
 * 
 * @export
 * @interface EmailOrdersResponse
 */
export interface EmailOrdersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailOrdersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailOrdersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailOrder>}
     * @memberof EmailOrdersResponse
     */
    orders?: Array<EmailOrder>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailOrdersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailOrdersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailPerformance
 */
export interface EmailPerformance {
    /**
     * Active customers.  The value will be -1 if calculation is pending.
     * @type {number}
     * @memberof EmailPerformance
     */
    active_customers?: number;
    /**
     * Actual customers that they have regardless of active state.  The value will be -1 if calculation is pending.
     * @type {number}
     * @memberof EmailPerformance
     */
    actual_customers?: number;
    /**
     * Bounce count
     * @type {number}
     * @memberof EmailPerformance
     */
    bounce_count?: number;
    /**
     * bounce percentage rate based upon our look back window.  This should be under five percent or the account will be paused for sending.
     * @type {number}
     * @memberof EmailPerformance
     */
    bounce_percentage?: number;
    /**
     * bounce percentage rate (formatted) based upon our look back window.  This should be under five percent or the account will be paused for sending.
     * @type {string}
     * @memberof EmailPerformance
     */
    bounce_percentage_formatted?: string;
    /**
     * 
     * @type {EmailPerformanceCustomerHistogram}
     * @memberof EmailPerformance
     */
    customer_histogram?: EmailPerformanceCustomerHistogram;
    /**
     * Daily statistics used for charting
     * @type {Array<EmailPerformanceDaily>}
     * @memberof EmailPerformance
     */
    daily_stats?: Array<EmailPerformanceDaily>;
    /**
     * Delivered count
     * @type {number}
     * @memberof EmailPerformance
     */
    delivered_count?: number;
    /**
     * Maximum active customers allowed under their billing plan
     * @type {number}
     * @memberof EmailPerformance
     */
    max_active_customers?: number;
    /**
     * Max emails per day
     * @type {number}
     * @memberof EmailPerformance
     */
    max_emails_per_day?: number;
    /**
     * Max emails per hour
     * @type {number}
     * @memberof EmailPerformance
     */
    max_emails_per_hour?: number;
    /**
     * Max emails per month
     * @type {number}
     * @memberof EmailPerformance
     */
    max_emails_per_month?: number;
    /**
     * True if campaign/flow emails are paused due to spam complaints.
     * @type {boolean}
     * @memberof EmailPerformance
     */
    paused_for_spam?: boolean;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailPerformance
     */
    revenue?: number;
    /**
     * Sent emails last 24 hours
     * @type {number}
     * @memberof EmailPerformance
     */
    sent_emails_per_day?: number;
    /**
     * Sent emails last hour
     * @type {number}
     * @memberof EmailPerformance
     */
    sent_emails_per_hour?: number;
    /**
     * Sent emails last 31 days
     * @type {number}
     * @memberof EmailPerformance
     */
    sent_emails_per_month?: number;
    /**
     * Total sequence (campaign/flow) emails sent
     * @type {number}
     * @memberof EmailPerformance
     */
    sequence_send_count?: number;
    /**
     * Spam complaints
     * @type {number}
     * @memberof EmailPerformance
     */
    spam_count?: number;
    /**
     * Spam percentage rate based upon our look back window.  This should be under one half a percent or the account will be paused for sending.
     * @type {number}
     * @memberof EmailPerformance
     */
    spam_percentage?: number;
    /**
     * Spam percentage rate (formatted) based upon our look back window.  This should be under one half a percent or the account will be paused for sending.
     * @type {string}
     * @memberof EmailPerformance
     */
    spam_percentage_formatted?: string;
    /**
     * Total transactions emails sent
     * @type {number}
     * @memberof EmailPerformance
     */
    transactional_send_count?: number;
}

/**
 * 
 * @export
 * @interface EmailPerformanceCustomerHistogram
 */
export interface EmailPerformanceCustomerHistogram {
    /**
     * Periods (newest to oldest)
     * @type {Array<EmailPerformanceCustomerHistogramPeriod>}
     * @memberof EmailPerformanceCustomerHistogram
     */
    periods?: Array<EmailPerformanceCustomerHistogramPeriod>;
}

/**
 * 
 * @export
 * @interface EmailPerformanceCustomerHistogramPeriod
 */
export interface EmailPerformanceCustomerHistogramPeriod {
    /**
     * Active customers last active in this period
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    active?: number;
    /**
     * Inactive customers last active in this period
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    inactive?: number;
    /**
     * Month (1 = January)
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    month?: number;
    /**
     * Total customers last active in this period
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    total?: number;
    /**
     * Year (four digits)
     * @type {number}
     * @memberof EmailPerformanceCustomerHistogramPeriod
     */
    year?: number;
}

/**
 * 
 * @export
 * @interface EmailPerformanceDaily
 */
export interface EmailPerformanceDaily {
    /**
     * Bounce count
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    bounce_count?: number;
    /**
     * Delivered count
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    delivered_count?: number;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    revenue?: number;
    /**
     * Total sequence (campaign/flow) emails sent
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    sequence_send_count?: number;
    /**
     * Spam complaints
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    spam_count?: number;
    /**
     * The date that these statistcs are for
     * @type {string}
     * @memberof EmailPerformanceDaily
     */
    stat_dts?: string;
    /**
     * Total transactions emails sent
     * @type {number}
     * @memberof EmailPerformanceDaily
     */
    transactional_send_count?: number;
}

/**
 * 
 * @export
 * @interface EmailPerformanceResponse
 */
export interface EmailPerformanceResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailPerformanceResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailPerformanceResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailPerformance}
     * @memberof EmailPerformanceResponse
     */
    performance?: EmailPerformance;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailPerformanceResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailPerformanceResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailPlan
 */
export interface EmailPlan {
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    additional_customers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    additional_emails?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    additional_fee?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlan
     */
    allow_list_import?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlan
     */
    allow_tracking_emails?: boolean;
    /**
     * 
     * @type {Array<EmailPlanAdditional>}
     * @memberof EmailPlan
     */
    customer_tiers?: Array<EmailPlanAdditional>;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    initial_sending_limits?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    plan_customers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    plan_emails?: number;
    /**
     * 
     * @type {string}
     * @memberof EmailPlan
     */
    plan_name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailPlan
     */
    plan_name_formatted?: string;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    require_order_within_last_days?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    revenue_percent?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    spam_percent_limit?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    total_customers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    total_emails?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlan
     */
    upgrade_to?: number;
}

/**
 * 
 * @export
 * @interface EmailPlanAdditional
 */
export interface EmailPlanAdditional {
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlanAdditional
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlanAdditional
     */
    can_downgrade?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmailPlanAdditional
     */
    can_upgrade?: boolean;
    /**
     * 
     * @type {number}
     * @memberof EmailPlanAdditional
     */
    cost?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlanAdditional
     */
    cost_change?: number;
    /**
     * 
     * @type {string}
     * @memberof EmailPlanAdditional
     */
    cost_change_formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailPlanAdditional
     */
    cost_formatted?: string;
    /**
     * 
     * @type {number}
     * @memberof EmailPlanAdditional
     */
    customers?: number;
    /**
     * 
     * @type {number}
     * @memberof EmailPlanAdditional
     */
    emails?: number;
}

/**
 * 
 * @export
 * @interface EmailPlanResponse
 */
export interface EmailPlanResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailPlanResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailPlanResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailPlan}
     * @memberof EmailPlanResponse
     */
    plan?: EmailPlan;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailPlanResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailPlanResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailPostcardStat
 */
export interface EmailPostcardStat {
    /**
     * Count of clicked emails
     * @type {number}
     * @memberof EmailPostcardStat
     */
    click_count?: number;
    /**
     * Count of clicked emails, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    click_count_formatted?: string;
    /**
     * Count of conversions
     * @type {number}
     * @memberof EmailPostcardStat
     */
    conversion_count?: number;
    /**
     * Count of conversions, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    conversion_count_formatted?: string;
    /**
     * Count of delivered emails
     * @type {number}
     * @memberof EmailPostcardStat
     */
    delivered_count?: number;
    /**
     * Count of delivered emails, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    delivered_count_formatted?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailPostcardStat
     */
    merchant_id?: string;
    /**
     * List or segment name
     * @type {string}
     * @memberof EmailPostcardStat
     */
    name?: string;
    /**
     * Count of orders
     * @type {number}
     * @memberof EmailPostcardStat
     */
    order_count?: number;
    /**
     * Count of orders, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    order_count_formatted?: string;
    /**
     * Profit
     * @type {number}
     * @memberof EmailPostcardStat
     */
    profit?: number;
    /**
     * Profit, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    profit_formatted?: string;
    /**
     * Count of return to sender
     * @type {number}
     * @memberof EmailPostcardStat
     */
    return_to_sender_count?: number;
    /**
     * Count of return to sender, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    return_to_sender_count_formatted?: string;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailPostcardStat
     */
    revenue?: number;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    revenue_formatted?: string;
    /**
     * Count of emails sent
     * @type {number}
     * @memberof EmailPostcardStat
     */
    send_count?: number;
    /**
     * Count of emails sent, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    send_count_formatted?: string;
    /**
     * Count of skipped emails
     * @type {number}
     * @memberof EmailPostcardStat
     */
    skipped_count?: number;
    /**
     * Count of skipped emails, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    skipped_count_formatted?: string;
    /**
     * Count of emails classified as spam
     * @type {number}
     * @memberof EmailPostcardStat
     */
    spam_count?: number;
    /**
     * Count of emails classified as spam, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    spam_count_formatted?: string;
    /**
     * Campaign, Flow or None (for anything else)
     * @type {string}
     * @memberof EmailPostcardStat
     */
    stat_type?: string;
    /**
     * Status of campaign or flow
     * @type {string}
     * @memberof EmailPostcardStat
     */
    status?: string;
    /**
     * Status dts of campaign or flow
     * @type {string}
     * @memberof EmailPostcardStat
     */
    status_dts?: string;
    /**
     * 
     * @type {Array<EmailPostcardStat>}
     * @memberof EmailPostcardStat
     */
    steps?: Array<EmailPostcardStat>;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailPostcardStat
     */
    storefront_oid?: number;
    /**
     * Count of emails classified as unsubscribe
     * @type {number}
     * @memberof EmailPostcardStat
     */
    unsubscribe_count?: number;
    /**
     * Count of emails classified as unsubscribe, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    unsubscribe_count_formatted?: string;
    /**
     * List or segment uuid
     * @type {string}
     * @memberof EmailPostcardStat
     */
    uuid?: string;
    /**
     * Count of views
     * @type {number}
     * @memberof EmailPostcardStat
     */
    view_count?: number;
    /**
     * Count of views, formatted
     * @type {string}
     * @memberof EmailPostcardStat
     */
    view_count_formatted?: string;
}

/**
 * 
 * @export
 * @interface EmailSegment
 */
export interface EmailSegment {
    /**
     * True if the current user has the rights to download this segment.
     * @type {boolean}
     * @memberof EmailSegment
     */
    allow_csv_download?: boolean;
    /**
     * True if this StoreFront has the Facebook Analytics app connected and supports them
     * @type {boolean}
     * @memberof EmailSegment
     */
    allow_facebook_audiences?: boolean;
    /**
     * Created date
     * @type {string}
     * @memberof EmailSegment
     */
    created_dts?: string;
    /**
     * True if this campaign was deleted
     * @type {boolean}
     * @memberof EmailSegment
     */
    deleted?: boolean;
    /**
     * Email segment UUID
     * @type {string}
     * @memberof EmailSegment
     */
    email_segment_uuid?: string;
    /**
     * List/Segment folder UUID
     * @type {string}
     * @memberof EmailSegment
     */
    esp_list_segment_folder_uuid?: string;
    /**
     * True if you want to sync to a facebook custom audience
     * @type {boolean}
     * @memberof EmailSegment
     */
    facebook_custom_audience?: boolean;
    /**
     * File profile equation json
     * @type {string}
     * @memberof EmailSegment
     */
    filter_profile_equation_json?: string;
    /**
     * Count of members in this segment
     * @type {number}
     * @memberof EmailSegment
     */
    member_count?: number;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailSegment
     */
    merchant_id?: string;
    /**
     * Name of email segment
     * @type {string}
     * @memberof EmailSegment
     */
    name?: string;
    /**
     * Rank settings json
     * @type {string}
     * @memberof EmailSegment
     */
    rank_json?: string;
    /**
     * True if a rebuild is required because some part of the segment has changed
     * @type {boolean}
     * @memberof EmailSegment
     */
    rebuild_required?: boolean;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailSegment
     */
    storefront_oid?: number;
    /**
     * Details on the flows or campaigns that use this list.
     * @type {Array<EmailListSegmentUsedBy>}
     * @memberof EmailSegment
     */
    used_by?: Array<EmailListSegmentUsedBy>;
}

/**
 * 
 * @export
 * @interface EmailSegmentArchiveResponse
 */
export interface EmailSegmentArchiveResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailSegmentArchiveResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentArchiveResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof EmailSegmentArchiveResponse
     */
    segment_in_use?: boolean;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentArchiveResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentArchiveResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSegmentCustomer
 */
export interface EmailSegmentCustomer {
    /**
     * Added timestamp
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    add_dts?: string;
    /**
     * Email
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    email?: string;
    /**
     * Email customer UUID
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    email_customer_uuid?: string;
    /**
     * Email segment member UUID
     * @type {string}
     * @memberof EmailSegmentCustomer
     */
    email_segment_member_uuid?: string;
}

/**
 * 
 * @export
 * @interface EmailSegmentCustomersResponse
 */
export interface EmailSegmentCustomersResponse {
    /**
     * Customers on the page
     * @type {Array<EmailSegmentCustomer>}
     * @memberof EmailSegmentCustomersResponse
     */
    customers?: Array<EmailSegmentCustomer>;
    /**
     * Page number (one based offset)
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    page_number?: number;
    /**
     * Number of records per page
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    page_size?: number;
    /**
     * Total customers
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    total_customers?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof EmailSegmentCustomersResponse
     */
    total_pages?: number;
}

/**
 * 
 * @export
 * @interface EmailSegmentDownloadPrepareResponse
 */
export interface EmailSegmentDownloadPrepareResponse {
    /**
     * 
     * @type {string}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    email_segment_rebuild_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    email_segment_uuid?: string;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {number}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    percentage_complete?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    proceed?: boolean;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentDownloadPrepareResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSegmentResponse
 */
export interface EmailSegmentResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailSegmentResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailSegment}
     * @memberof EmailSegmentResponse
     */
    segment?: EmailSegment;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSegmentsResponse
 */
export interface EmailSegmentsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailSegmentsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSegmentsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailSegment>}
     * @memberof EmailSegmentsResponse
     */
    segments?: Array<EmailSegment>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSegmentsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSegmentsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSendingDomainResponse
 */
export interface EmailSendingDomainResponse {
    /**
     * 
     * @type {EmailDomain}
     * @memberof EmailSendingDomainResponse
     */
    domain?: EmailDomain;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailSendingDomainResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSendingDomainResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSendingDomainResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSendingDomainResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSendingDomainsResponse
 */
export interface EmailSendingDomainsResponse {
    /**
     * 
     * @type {Array<EmailDomain>}
     * @memberof EmailSendingDomainsResponse
     */
    domains?: Array<EmailDomain>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailSendingDomainsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSendingDomainsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSendingDomainsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSendingDomainsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailSettings
 */
export interface EmailSettings {
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    marketing_esp_domain_user?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    marketing_esp_domain_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    marketing_esp_friendly_name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcard_from_address1?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcard_from_address2?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcard_from_city?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcard_from_name?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcard_from_postal_code?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    postcard_from_state?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    transactional_esp_domain_user?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    transactional_esp_domain_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailSettings
     */
    transactional_esp_friendly_name?: string;
}

/**
 * 
 * @export
 * @interface EmailSettingsResponse
 */
export interface EmailSettingsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailSettingsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailSettingsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {EmailSettings}
     * @memberof EmailSettingsResponse
     */
    settings?: EmailSettings;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailSettingsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailSettingsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStat
 */
export interface EmailStat {
    /**
     * Count of clicked emails
     * @type {number}
     * @memberof EmailStat
     */
    click_count?: number;
    /**
     * Count of clicked emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    click_count_formatted?: string;
    /**
     * Count of conversions
     * @type {number}
     * @memberof EmailStat
     */
    conversion_count?: number;
    /**
     * Count of conversions, formatted
     * @type {string}
     * @memberof EmailStat
     */
    conversion_count_formatted?: string;
    /**
     * True if campaign/flow has been archived
     * @type {boolean}
     * @memberof EmailStat
     */
    deleted?: boolean;
    /**
     * Count of delivered emails
     * @type {number}
     * @memberof EmailStat
     */
    delivered_count?: number;
    /**
     * Count of delivered emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    delivered_count_formatted?: string;
    /**
     * Count of emails kicked
     * @type {number}
     * @memberof EmailStat
     */
    kickbox_count?: number;
    /**
     * Count of emails kicked, formatted
     * @type {string}
     * @memberof EmailStat
     */
    kickbox_count_formatted?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailStat
     */
    merchant_id?: string;
    /**
     * List or segment name
     * @type {string}
     * @memberof EmailStat
     */
    name?: string;
    /**
     * Count of opened emails
     * @type {number}
     * @memberof EmailStat
     */
    open_count?: number;
    /**
     * Count of opened emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    open_count_formatted?: string;
    /**
     * Count of orders
     * @type {number}
     * @memberof EmailStat
     */
    order_count?: number;
    /**
     * Count of orders, formatted
     * @type {string}
     * @memberof EmailStat
     */
    order_count_formatted?: string;
    /**
     * Count of emails permanently bounced
     * @type {number}
     * @memberof EmailStat
     */
    permanent_bounce_count?: number;
    /**
     * Count of emails permanently bounced, formatted
     * @type {string}
     * @memberof EmailStat
     */
    permanent_bounce_count_formatted?: string;
    /**
     * Profit
     * @type {number}
     * @memberof EmailStat
     */
    profit?: number;
    /**
     * Profit, formatted
     * @type {string}
     * @memberof EmailStat
     */
    profit_formatted?: string;
    /**
     * Revenue
     * @type {number}
     * @memberof EmailStat
     */
    revenue?: number;
    /**
     * Revenue, formatted
     * @type {string}
     * @memberof EmailStat
     */
    revenue_formatted?: string;
    /**
     * Count of emails sent
     * @type {number}
     * @memberof EmailStat
     */
    send_count?: number;
    /**
     * Count of emails sent, formatted
     * @type {string}
     * @memberof EmailStat
     */
    send_count_formatted?: string;
    /**
     * Count of skipped emails
     * @type {number}
     * @memberof EmailStat
     */
    skipped_count?: number;
    /**
     * Count of skipped emails, formatted
     * @type {string}
     * @memberof EmailStat
     */
    skipped_count_formatted?: string;
    /**
     * Count of emails classified as spam
     * @type {number}
     * @memberof EmailStat
     */
    spam_count?: number;
    /**
     * Count of emails classified as spam, formatted
     * @type {string}
     * @memberof EmailStat
     */
    spam_count_formatted?: string;
    /**
     * Campaign, Flow or None (for anything else)
     * @type {string}
     * @memberof EmailStat
     */
    stat_type?: string;
    /**
     * Status of campaign or flow
     * @type {string}
     * @memberof EmailStat
     */
    status?: string;
    /**
     * Status dts of campaign or flow
     * @type {string}
     * @memberof EmailStat
     */
    status_dts?: string;
    /**
     * Step UUID if the statistics are at the step/email level
     * @type {string}
     * @memberof EmailStat
     */
    step_uuid?: string;
    /**
     * 
     * @type {Array<EmailStat>}
     * @memberof EmailStat
     */
    steps?: Array<EmailStat>;
    /**
     * Storefront oid
     * @type {number}
     * @memberof EmailStat
     */
    storefront_oid?: number;
    /**
     * Count of emails classified as unsubscribe
     * @type {number}
     * @memberof EmailStat
     */
    unsubscribe_count?: number;
    /**
     * Count of emails classified as unsubscribe, formatted
     * @type {string}
     * @memberof EmailStat
     */
    unsubscribe_count_formatted?: string;
    /**
     * List/Segment uuid, or Flow/Campaign uuid depending on level of stat aggregation.
     * @type {string}
     * @memberof EmailStat
     */
    uuid?: string;
    /**
     * Count of views
     * @type {number}
     * @memberof EmailStat
     */
    view_count?: number;
    /**
     * Count of views, formatted
     * @type {string}
     * @memberof EmailStat
     */
    view_count_formatted?: string;
}

/**
 * 
 * @export
 * @interface EmailStatPostcardSummaryRequest
 */
export interface EmailStatPostcardSummaryRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStatPostcardSummaryRequest
     */
    commseq_postcard_uuids?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof EmailStatPostcardSummaryRequest
     */
    days?: number;
}

/**
 * 
 * @export
 * @interface EmailStatPostcardSummaryResponse
 */
export interface EmailStatPostcardSummaryResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailStatPostcardSummaryResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailStatPostcardSummaryResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailPostcardStat>}
     * @memberof EmailStatPostcardSummaryResponse
     */
    stats?: Array<EmailPostcardStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailStatPostcardSummaryResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailStatPostcardSummaryResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStatSummaryRequest
 */
export interface EmailStatSummaryRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStatSummaryRequest
     */
    commseq_email_uuids?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStatSummaryRequest
     */
    commseq_step_uuids?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof EmailStatSummaryRequest
     */
    days?: number;
}

/**
 * 
 * @export
 * @interface EmailStatSummaryResponse
 */
export interface EmailStatSummaryResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailStatSummaryResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailStatSummaryResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailStat>}
     * @memberof EmailStatSummaryResponse
     */
    stats?: Array<EmailStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailStatSummaryResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailStatSummaryResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStepStat
 */
export interface EmailStepStat {
    /**
     * conversion count (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    left_conversion_count?: number;
    /**
     * conversion count formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    left_conversion_count_formatted?: string;
    /**
     * customer count (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    left_customer_count?: number;
    /**
     * customer count formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    left_customer_count_formatted?: string;
    /**
     * order count (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    left_order_count?: number;
    /**
     * order count formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    left_order_count_formatted?: string;
    /**
     * profit (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    left_profit?: number;
    /**
     * profit formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    left_profit_formatted?: string;
    /**
     * revenue (left/default side)
     * @type {number}
     * @memberof EmailStepStat
     */
    left_revenue?: number;
    /**
     * revenue formatted (left/default side)
     * @type {string}
     * @memberof EmailStepStat
     */
    left_revenue_formatted?: string;
    /**
     * conversion count (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    right_conversion_count?: number;
    /**
     * conversion count formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    right_conversion_count_formatted?: string;
    /**
     * customer count (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    right_customer_count?: number;
    /**
     * customer count formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    right_customer_count_formatted?: string;
    /**
     * order count (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    right_order_count?: number;
    /**
     * order count formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    right_order_count_formatted?: string;
    /**
     * profit (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    right_profit?: number;
    /**
     * profit formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    right_profit_formatted?: string;
    /**
     * revenue (right side)
     * @type {number}
     * @memberof EmailStepStat
     */
    right_revenue?: number;
    /**
     * revenue formatted (right side)
     * @type {string}
     * @memberof EmailStepStat
     */
    right_revenue_formatted?: string;
}

/**
 * 
 * @export
 * @interface EmailStepStatRequest
 */
export interface EmailStepStatRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStepStatRequest
     */
    commseq_step_uuids?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof EmailStepStatRequest
     */
    days?: number;
}

/**
 * 
 * @export
 * @interface EmailStepStatResponse
 */
export interface EmailStepStatResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailStepStatResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailStepStatResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailStepStat>}
     * @memberof EmailStepStatResponse
     */
    stats?: Array<EmailStepStat>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailStepStatResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailStepStatResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailStepWaitingRequest
 */
export interface EmailStepWaitingRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailStepWaitingRequest
     */
    commseq_step_uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface EmailStepWaitingResponse
 */
export interface EmailStepWaitingResponse {
    /**
     * 
     * @type {Array<StepWaiting>}
     * @memberof EmailStepWaitingResponse
     */
    step_waitings?: Array<StepWaiting>;
}

/**
 * 
 * @export
 * @interface EmailTemplate
 */
export interface EmailTemplate {
    /**
     * Container cjson
     * @type {string}
     * @memberof EmailTemplate
     */
    container_cjson?: string;
    /**
     * Description of email template
     * @type {string}
     * @memberof EmailTemplate
     */
    description?: string;
    /**
     * Email template oid
     * @type {number}
     * @memberof EmailTemplate
     */
    email_template_oid?: number;
    /**
     * Email Template VM Path
     * @type {string}
     * @memberof EmailTemplate
     */
    email_template_vm_path?: string;
    /**
     * Merchant ID
     * @type {string}
     * @memberof EmailTemplate
     */
    merchant_id?: string;
    /**
     * Name of email template
     * @type {string}
     * @memberof EmailTemplate
     */
    name?: string;
    /**
     * Amazon key for preview png image
     * @type {string}
     * @memberof EmailTemplate
     */
    preview_amazon_listing_key?: string;
    /**
     * Sort order (optional)
     * @type {number}
     * @memberof EmailTemplate
     */
    sort_order?: number;
    /**
     * StoreFront oid
     * @type {number}
     * @memberof EmailTemplate
     */
    storefront_oid?: number;
    /**
     * True if this email template is system-wide,false if merchant specific
     * @type {boolean}
     * @memberof EmailTemplate
     */
    system?: boolean;
    /**
     * Trigger type
     * @type {string}
     * @memberof EmailTemplate
     */
    trigger_type?: string;
}

/**
 * 
 * @export
 * @interface EmailTemplatesResponse
 */
export interface EmailTemplatesResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailTemplatesResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailTemplatesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailTemplatesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<EmailTemplate>}
     * @memberof EmailTemplatesResponse
     */
    templates?: Array<EmailTemplate>;
    /**
     * 
     * @type {Warning}
     * @memberof EmailTemplatesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyList
 */
export interface EmailThirdPartyList {
    /**
     * id
     * @type {string}
     * @memberof EmailThirdPartyList
     */
    id?: string;
    /**
     * name
     * @type {string}
     * @memberof EmailThirdPartyList
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyListImportRequest
 */
export interface EmailThirdPartyListImportRequest {
    /**
     * providers
     * @type {Array<EmailThirdPartyProvider>}
     * @memberof EmailThirdPartyListImportRequest
     */
    providers?: Array<EmailThirdPartyProvider>;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyProvider
 */
export interface EmailThirdPartyProvider {
    /**
     * URL to the settings screen to connect.  Null if the provider is already connected.
     * @type {string}
     * @memberof EmailThirdPartyProvider
     */
    connect_url?: string;
    /**
     * list_count
     * @type {number}
     * @memberof EmailThirdPartyProvider
     */
    list_count?: number;
    /**
     * lists
     * @type {Array<EmailThirdPartyList>}
     * @memberof EmailThirdPartyProvider
     */
    lists?: Array<EmailThirdPartyList>;
    /**
     * logo_url
     * @type {string}
     * @memberof EmailThirdPartyProvider
     */
    logo_url?: string;
    /**
     * name
     * @type {string}
     * @memberof EmailThirdPartyProvider
     */
    name?: string;
    /**
     * True if this provider can support adding tags
     * @type {boolean}
     * @memberof EmailThirdPartyProvider
     */
    supports_add_tags?: boolean;
    /**
     * True if this provider can support list subscribe
     * @type {boolean}
     * @memberof EmailThirdPartyProvider
     */
    supports_list_subscribe?: boolean;
    /**
     * True if this provider can support list unsubscribe
     * @type {boolean}
     * @memberof EmailThirdPartyProvider
     */
    supports_list_unsubscribe?: boolean;
    /**
     * True if this provider can support remove tags
     * @type {boolean}
     * @memberof EmailThirdPartyProvider
     */
    supports_remove_tags?: boolean;
}

/**
 * 
 * @export
 * @interface EmailThirdPartyProvidersResponse
 */
export interface EmailThirdPartyProvidersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailThirdPartyProvidersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailThirdPartyProvidersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<EmailThirdPartyProvider>}
     * @memberof EmailThirdPartyProvidersResponse
     */
    providers?: Array<EmailThirdPartyProvider>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailThirdPartyProvidersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailThirdPartyProvidersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailVerifyTokenRequest
 */
export interface EmailVerifyTokenRequest {
    /**
     * email
     * @type {string}
     * @memberof EmailVerifyTokenRequest
     */
    email?: string;
    /**
     * password
     * @type {string}
     * @memberof EmailVerifyTokenRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface EmailVerifyTokenResponse
 */
export interface EmailVerifyTokenResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailVerifyTokenResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailVerifyTokenResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailVerifyTokenResponse
     */
    success?: boolean;
    /**
     * token
     * @type {string}
     * @memberof EmailVerifyTokenResponse
     */
    token?: string;
    /**
     * 
     * @type {Warning}
     * @memberof EmailVerifyTokenResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailVerifyTokenValidateRequest
 */
export interface EmailVerifyTokenValidateRequest {
    /**
     * token
     * @type {string}
     * @memberof EmailVerifyTokenValidateRequest
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface EmailVerifyTokenValidateResponse
 */
export interface EmailVerifyTokenValidateResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof EmailVerifyTokenValidateResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailVerifyTokenValidateResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailVerifyTokenValidateResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailVerifyTokenValidateResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface EmailWebhookEditorValuesResponse
 */
export interface EmailWebhookEditorValuesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailWebhookEditorValuesResponse
     */
    available_expansions?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailWebhookEditorValuesResponse
     */
    available_tokens?: Array<string>;
    /**
     * 
     * @type {ModelError}
     * @memberof EmailWebhookEditorValuesResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof EmailWebhookEditorValuesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {string}
     * @memberof EmailWebhookEditorValuesResponse
     */
    rest_object_type?: string;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof EmailWebhookEditorValuesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof EmailWebhookEditorValuesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ErrorResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ErrorResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ErrorResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ErrorResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * Contained ID where the experiment element was located
     * @type {string}
     * @memberof Experiment
     */
    container_id?: string;
    /**
     * Duration in days
     * @type {number}
     * @memberof Experiment
     */
    duration_days?: number;
    /**
     * End date/time
     * @type {string}
     * @memberof Experiment
     */
    end_dts?: string;
    /**
     * Whether or not traffic is equally weighted or shifts over time during the experiment
     * @type {boolean}
     * @memberof Experiment
     */
    equal_weighting?: boolean;
    /**
     * The type of experiment
     * @type {string}
     * @memberof Experiment
     */
    experiment_type?: string;
    /**
     * Experiment id
     * @type {string}
     * @memberof Experiment
     */
    id?: string;
    /**
     * Experiment name
     * @type {string}
     * @memberof Experiment
     */
    name?: string;
    /**
     * Notes about the experiment
     * @type {string}
     * @memberof Experiment
     */
    notes?: string;
    /**
     * Objective that is being optimized
     * @type {string}
     * @memberof Experiment
     */
    objective?: string;
    /**
     * Objective parameter (such as event name) that is being optimized
     * @type {string}
     * @memberof Experiment
     */
    objective_parameter?: string;
    /**
     * Type of optimization
     * @type {string}
     * @memberof Experiment
     */
    optimization_type?: string;
    /**
     * Total number of sessions in the experiment
     * @type {number}
     * @memberof Experiment
     */
    session_count?: number;
    /**
     * Start date/time
     * @type {string}
     * @memberof Experiment
     */
    start_dts?: string;
    /**
     * Status of the experiment
     * @type {string}
     * @memberof Experiment
     */
    status?: Experiment.StatusEnum;
    /**
     * Storefront Experiment Oid
     * @type {number}
     * @memberof Experiment
     */
    storefront_experiment_oid?: number;
    /**
     * Storefront oid
     * @type {number}
     * @memberof Experiment
     */
    storefront_oid?: number;
    /**
     * URI the experiment was started on
     * @type {string}
     * @memberof Experiment
     */
    uri?: string;
    /**
     * Variations being tested in the experiment
     * @type {Array<ExperimentVariation>}
     * @memberof Experiment
     */
    variations?: Array<ExperimentVariation>;
}

/**
 * @export
 * @namespace Experiment
 */
export namespace Experiment {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Running = <any> 'Running',
        Ended = <any> 'Ended',
        Deleted = <any> 'Deleted'
    }
}

/**
 * 
 * @export
 * @interface ExperimentResponse
 */
export interface ExperimentResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ExperimentResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Experiment}
     * @memberof ExperimentResponse
     */
    experiment?: Experiment;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ExperimentResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ExperimentResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ExperimentResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ExperimentVariation
 */
export interface ExperimentVariation {
    /**
     * Total add to cart count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    add_to_cart_count?: number;
    /**
     * Average duration seconds per session for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    average_duration_seconds?: number;
    /**
     * Average objective value per session for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    average_objective_per_session?: number;
    /**
     * Average order value for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    average_order_value?: number;
    /**
     * Total bounce count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    bounce_count?: number;
    /**
     * Conversion rate for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    conversion_rate?: number;
    /**
     * Array of daily statistics for this variation
     * @type {Array<ExperimentVariationStat>}
     * @memberof ExperimentVariation
     */
    daily_statistics?: Array<ExperimentVariationStat>;
    /**
     * Total number of seconds spent on the site for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    duration_seconds_sum?: number;
    /**
     * Total event ocunt for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    event_count?: number;
    /**
     * Total initiate checkout count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    initiate_checkout_count?: number;
    /**
     * Total order count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    order_count?: number;
    /**
     * Total order item count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    order_item_count?: number;
    /**
     * Percentage of the traffic the variation originally started out with
     * @type {number}
     * @memberof ExperimentVariation
     */
    original_traffic_percentage?: number;
    /**
     * Total page view count for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    page_view_count?: number;
    /**
     * Total revenue for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    revenue?: number;
    /**
     * Total sessions for this variation
     * @type {number}
     * @memberof ExperimentVariation
     */
    session_count?: number;
    /**
     * Percentage of the traffic this variation is currently receiving
     * @type {number}
     * @memberof ExperimentVariation
     */
    traffic_percentage?: number;
    /**
     * Url of the variation if this experiment is a url experiment.
     * @type {string}
     * @memberof ExperimentVariation
     */
    url?: string;
    /**
     * Name of the variation
     * @type {string}
     * @memberof ExperimentVariation
     */
    variation_name?: string;
    /**
     * Variation number
     * @type {number}
     * @memberof ExperimentVariation
     */
    variation_number?: number;
    /**
     * True if this variation has been declared the winner
     * @type {boolean}
     * @memberof ExperimentVariation
     */
    winner?: boolean;
}

/**
 * 
 * @export
 * @interface ExperimentVariationStat
 */
export interface ExperimentVariationStat {
    /**
     * Total add to cart count for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    add_to_cart_count?: number;
    /**
     * Total bounce count for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    bounce_count?: number;
    /**
     * Total number of seconds spent on the site for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    duration_seconds_sum?: number;
    /**
     * Total event count for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    event_count?: number;
    /**
     * Total initiate checkout count for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    initiate_checkout_count?: number;
    /**
     * Total order count for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    order_count?: number;
    /**
     * Total order item count for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    order_item_count?: number;
    /**
     * Total page view count for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    page_view_count?: number;
    /**
     * Total revenue for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    revenue?: number;
    /**
     * Total sessions for this variation
     * @type {number}
     * @memberof ExperimentVariationStat
     */
    session_count?: number;
    /**
     * Date/time that the statistic was created
     * @type {string}
     * @memberof ExperimentVariationStat
     */
    stat_dts?: string;
}

/**
 * 
 * @export
 * @interface ExperimentsResponse
 */
export interface ExperimentsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ExperimentsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<Experiment>}
     * @memberof ExperimentsResponse
     */
    experiments?: Array<Experiment>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ExperimentsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ExperimentsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ExperimentsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface FulfillmentInventory
 */
export interface FulfillmentInventory {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentInventory
     */
    itemId?: string;
    /**
     * 
     * @type {number}
     * @memberof FulfillmentInventory
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface FulfillmentShipment
 */
export interface FulfillmentShipment {
    /**
     * Fees charged by the fulfillment company other than the shipping cost to process the order.
     * @type {number}
     * @memberof FulfillmentShipment
     */
    fulfillment_fee?: number;
    /**
     * Order ID that was shipped
     * @type {string}
     * @memberof FulfillmentShipment
     */
    order_id?: string;
    /**
     * The cost of the packaging used to sent this shipment
     * @type {number}
     * @memberof FulfillmentShipment
     */
    package_cost?: number;
    /**
     * The actual total cost of shipping this order
     * @type {number}
     * @memberof FulfillmentShipment
     */
    shipping_cost?: number;
    /**
     * Tracking numbers associated with the shipment
     * @type {Array<string>}
     * @memberof FulfillmentShipment
     */
    tracking_numbers?: Array<string>;
}

/**
 * 
 * @export
 * @interface GeoPoint
 */
export interface GeoPoint {
    /**
     * 
     * @type {number}
     * @memberof GeoPoint
     */
    lat?: number;
    /**
     * 
     * @type {number}
     * @memberof GeoPoint
     */
    lon?: number;
}

/**
 * 
 * @export
 * @interface GeocodeRequest
 */
export interface GeocodeRequest {
    /**
     * address
     * @type {string}
     * @memberof GeocodeRequest
     */
    address?: string;
    /**
     * city
     * @type {string}
     * @memberof GeocodeRequest
     */
    city?: string;
    /**
     * country_code
     * @type {string}
     * @memberof GeocodeRequest
     */
    country_code?: string;
    /**
     * postal_code
     * @type {string}
     * @memberof GeocodeRequest
     */
    postal_code?: string;
    /**
     * state
     * @type {string}
     * @memberof GeocodeRequest
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface GeocodeResponse
 */
export interface GeocodeResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof GeocodeResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {number}
     * @memberof GeocodeResponse
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof GeocodeResponse
     */
    longitude?: number;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GeocodeResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof GeocodeResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof GeocodeResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * The unique object identifier (oid for short) for this group
     * @type {number}
     * @memberof Group
     */
    group_oid?: number;
    /**
     * The name of this group.
     * @type {string}
     * @memberof Group
     */
    name?: string;
    /**
     * A list of notifications the user receives.
     * @type {Array<Notification>}
     * @memberof Group
     */
    notifications?: Array<Notification>;
    /**
     * A list of permissions the user enjoys for accessing the backend of UltraCart.
     * @type {Array<Permission>}
     * @memberof Group
     */
    permissions?: Array<Permission>;
    /**
     * A list of users that belong to this group.
     * @type {Array<GroupUserMembership>}
     * @memberof Group
     */
    users?: Array<GroupUserMembership>;
}

/**
 * 
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof GroupResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Group}
     * @memberof GroupResponse
     */
    group?: Group;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GroupResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof GroupResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof GroupResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface GroupUserMembership
 */
export interface GroupUserMembership {
    /**
     * The email for this user.
     * @type {string}
     * @memberof GroupUserMembership
     */
    email?: string;
    /**
     * The full name for this user.
     * @type {string}
     * @memberof GroupUserMembership
     */
    fullName?: string;
    /**
     * The login for this user.
     * @type {string}
     * @memberof GroupUserMembership
     */
    login?: string;
    /**
     * True if this user belongs to the parent group, false otherwise.
     * @type {boolean}
     * @memberof GroupUserMembership
     */
    member?: boolean;
    /**
     * The user id for this user.
     * @type {number}
     * @memberof GroupUserMembership
     */
    user_id?: number;
}

/**
 * 
 * @export
 * @interface GroupsResponse
 */
export interface GroupsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof GroupsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<Group>}
     * @memberof GroupsResponse
     */
    groups?: Array<Group>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof GroupsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof GroupsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof GroupsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface HTTPHeader
 */
export interface HTTPHeader {
    /**
     * Name of the HTTP header
     * @type {string}
     * @memberof HTTPHeader
     */
    name?: string;
    /**
     * Value of the HTTP header
     * @type {string}
     * @memberof HTTPHeader
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface IntegrationLog
 */
export interface IntegrationLog {
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    direction?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    email?: string;
    /**
     * 
     * @type {Array<IntegrationLogFile>}
     * @memberof IntegrationLog
     */
    files?: Array<IntegrationLogFile>;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLog
     */
    integration_log_oid?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    item_id?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLog
     */
    item_ipn_oid?: number;
    /**
     * Date/time the integration log was created
     * @type {string}
     * @memberof IntegrationLog
     */
    log_dts?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    log_type?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    logger_id?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    logger_name?: string;
    /**
     * 
     * @type {Array<IntegrationLogLog>}
     * @memberof IntegrationLog
     */
    logs?: Array<IntegrationLogLog>;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationLog
     */
    omit_log_map?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLog
     */
    order_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    pk?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    sk?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLog
     */
    status_code?: number;
}

/**
 * 
 * @export
 * @interface IntegrationLogFile
 */
export interface IntegrationLogFile {
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogFile
     */
    mime_type?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogFile
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogFile
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogFile
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface IntegrationLogLog
 */
export interface IntegrationLogLog {
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogLog
     */
    contents?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogLog
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface IntegrationLogQueryFilterValues
 */
export interface IntegrationLogQueryFilterValues {
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    actions?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    directions?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    emails?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    file_names?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    item_ids?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IntegrationLogQueryFilterValues
     */
    item_ipn_oids?: Array<number>;
    /**
     * Maximum date/time log date/time
     * @type {string}
     * @memberof IntegrationLogQueryFilterValues
     */
    log_dts_max?: string;
    /**
     * Minimum date/time log date/time
     * @type {string}
     * @memberof IntegrationLogQueryFilterValues
     */
    log_dts_min?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    log_types?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    logger_names?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    order_ids?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryFilterValues
     */
    statuses?: Array<string>;
}

/**
 * 
 * @export
 * @interface IntegrationLogQueryRequest
 */
export interface IntegrationLogQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    action?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    direction?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    email?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryRequest
     */
    file_names?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    item_id?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogQueryRequest
     */
    item_ipn_oid?: number;
    /**
     * Log date/time begin
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    log_dts_begin?: string;
    /**
     * Log date/time end
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    log_dts_end?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    log_type?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    logger_id?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    logger_name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntegrationLogQueryRequest
     */
    order_ids?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogQueryRequest
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface IntegrationLogQueryResponse
 */
export interface IntegrationLogQueryResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof IntegrationLogQueryResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {IntegrationLogQueryFilterValues}
     * @memberof IntegrationLogQueryResponse
     */
    filter_values?: IntegrationLogQueryFilterValues;
    /**
     * 
     * @type {Array<IntegrationLog>}
     * @memberof IntegrationLogQueryResponse
     */
    integration_logs?: Array<IntegrationLog>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof IntegrationLogQueryResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof IntegrationLogQueryResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof IntegrationLogQueryResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface IntegrationLogResponse
 */
export interface IntegrationLogResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof IntegrationLogResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {IntegrationLog}
     * @memberof IntegrationLogResponse
     */
    integration_log?: IntegrationLog;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof IntegrationLogResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof IntegrationLogResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof IntegrationLogResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface IntegrationLogSummary
 */
export interface IntegrationLogSummary {
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogSummary
     */
    critical?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogSummary
     */
    error?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogSummary
     */
    events?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogSummary
     */
    log_type?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogSummary
     */
    logger_id?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogSummary
     */
    logger_name?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogSummary
     */
    success?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogSummary
     */
    view_url?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogSummary
     */
    warning?: number;
}

/**
 * 
 * @export
 * @interface IntegrationLogSummaryQueryRequest
 */
export interface IntegrationLogSummaryQueryRequest {
    /**
     * Log date/time begin
     * @type {string}
     * @memberof IntegrationLogSummaryQueryRequest
     */
    log_dts_begin?: string;
    /**
     * Log date/time end
     * @type {string}
     * @memberof IntegrationLogSummaryQueryRequest
     */
    log_dts_end?: string;
}

/**
 * 
 * @export
 * @interface IntegrationLogSummaryQueryResponse
 */
export interface IntegrationLogSummaryQueryResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof IntegrationLogSummaryQueryResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<IntegrationLogSummary>}
     * @memberof IntegrationLogSummaryQueryResponse
     */
    integration_log_summaries?: Array<IntegrationLogSummary>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof IntegrationLogSummaryQueryResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof IntegrationLogSummaryQueryResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof IntegrationLogSummaryQueryResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {ItemAccounting}
     * @memberof Item
     */
    accounting?: ItemAccounting;
    /**
     * 
     * @type {ItemAmember}
     * @memberof Item
     */
    amember?: ItemAmember;
    /**
     * 
     * @type {ItemAutoOrder}
     * @memberof Item
     */
    auto_order?: ItemAutoOrder;
    /**
     * 
     * @type {ItemCCBill}
     * @memberof Item
     */
    ccbill?: ItemCCBill;
    /**
     * Channel Partner Item Mapping
     * @type {Array<ItemChannelPartnerMapping>}
     * @memberof Item
     */
    channel_partner_item_mappings?: Array<ItemChannelPartnerMapping>;
    /**
     * 
     * @type {ItemChargeback}
     * @memberof Item
     */
    chargeback?: ItemChargeback;
    /**
     * 
     * @type {ItemCheckout}
     * @memberof Item
     */
    checkout?: ItemCheckout;
    /**
     * 
     * @type {ItemContent}
     * @memberof Item
     */
    content?: ItemContent;
    /**
     * Date/time of creation
     * @type {string}
     * @memberof Item
     */
    creation_dts?: string;
    /**
     * Description of the item up to 500 characters.
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * Description translated text instance id
     * @type {number}
     * @memberof Item
     */
    description_translated_text_instance_oid?: number;
    /**
     * 
     * @type {ItemDigitalDelivery}
     * @memberof Item
     */
    digital_delivery?: ItemDigitalDelivery;
    /**
     * 
     * @type {ItemEbay}
     * @memberof Item
     */
    ebay?: ItemEbay;
    /**
     * 
     * @type {ItemEmailNotifications}
     * @memberof Item
     */
    email_notifications?: ItemEmailNotifications;
    /**
     * 
     * @type {ItemEnrollment123}
     * @memberof Item
     */
    enrollment123?: ItemEnrollment123;
    /**
     * Fulfillment Add-ons
     * @type {Array<ItemFulfillmentAddon>}
     * @memberof Item
     */
    fulfillment_addons?: Array<ItemFulfillmentAddon>;
    /**
     * 
     * @type {ItemGiftCertificate}
     * @memberof Item
     */
    gift_certificate?: ItemGiftCertificate;
    /**
     * 
     * @type {ItemGoogleProductSearch}
     * @memberof Item
     */
    google_product_search?: ItemGoogleProductSearch;
    /**
     * 
     * @type {ItemIdentifiers}
     * @memberof Item
     */
    identifiers?: ItemIdentifiers;
    /**
     * True if this item is inactive and can not be purchased
     * @type {boolean}
     * @memberof Item
     */
    inactive?: boolean;
    /**
     * 
     * @type {ItemInstantPaymentNotifications}
     * @memberof Item
     */
    instant_payment_notifications?: ItemInstantPaymentNotifications;
    /**
     * 
     * @type {ItemInternal}
     * @memberof Item
     */
    internal?: ItemInternal;
    /**
     * True if this item is a kit
     * @type {boolean}
     * @memberof Item
     */
    kit?: boolean;
    /**
     * True if this item can only be usd as a kit component
     * @type {boolean}
     * @memberof Item
     */
    kit_component_only?: boolean;
    /**
     * 
     * @type {ItemKitDefinition}
     * @memberof Item
     */
    kit_definition?: ItemKitDefinition;
    /**
     * Date/time of last modification
     * @type {string}
     * @memberof Item
     */
    last_modified_dts?: string;
    /**
     * UltraCart merchant ID owning item
     * @type {string}
     * @memberof Item
     */
    merchant_id?: string;
    /**
     * Unique item id assigned to this item
     * @type {string}
     * @memberof Item
     */
    merchant_item_id?: string;
    /**
     * Unique object identifier for this item
     * @type {number}
     * @memberof Item
     */
    merchant_item_oid?: number;
    /**
     * Options
     * @type {Array<ItemOption>}
     * @memberof Item
     */
    options?: Array<ItemOption>;
    /**
     * Parent category of the item.  Zero indicates the root folder.
     * @type {number}
     * @memberof Item
     */
    parent_category_id?: number;
    /**
     * Parent category path.  / indicates the root folder.
     * @type {string}
     * @memberof Item
     */
    parent_category_path?: string;
    /**
     * 
     * @type {ItemPaymentProcessing}
     * @memberof Item
     */
    payment_processing?: ItemPaymentProcessing;
    /**
     * 
     * @type {ItemPhysical}
     * @memberof Item
     */
    physical?: ItemPhysical;
    /**
     * 
     * @type {ItemPricing}
     * @memberof Item
     */
    pricing?: ItemPricing;
    /**
     * Properties
     * @type {Array<ItemProperty>}
     * @memberof Item
     */
    properties?: Array<ItemProperty>;
    /**
     * 
     * @type {ItemRealtimePricing}
     * @memberof Item
     */
    realtime_pricing?: ItemRealtimePricing;
    /**
     * Number of days to recommend replenishment after.  Null is not configured.  Set to zero to disable.
     * @type {number}
     * @memberof Item
     */
    recommend_replenishment_days?: number;
    /**
     * 
     * @type {ItemRelated}
     * @memberof Item
     */
    related?: ItemRelated;
    /**
     * 
     * @type {ItemReporting}
     * @memberof Item
     */
    reporting?: ItemReporting;
    /**
     * 
     * @type {ItemRestriction}
     * @memberof Item
     */
    restriction?: ItemRestriction;
    /**
     * 
     * @type {ItemRevguard}
     * @memberof Item
     */
    revguard?: ItemRevguard;
    /**
     * 
     * @type {ItemReviews}
     * @memberof Item
     */
    reviews?: ItemReviews;
    /**
     * 
     * @type {ItemSalesforce}
     * @memberof Item
     */
    salesforce?: ItemSalesforce;
    /**
     * 
     * @type {ItemShipping}
     * @memberof Item
     */
    shipping?: ItemShipping;
    /**
     * 
     * @type {ItemTags}
     * @memberof Item
     */
    tags?: ItemTags;
    /**
     * 
     * @type {ItemTax}
     * @memberof Item
     */
    tax?: ItemTax;
    /**
     * 3rd Party Email Marketing
     * @type {Array<ItemThirdPartyEmailMarketing>}
     * @memberof Item
     */
    third_party_email_marketing?: Array<ItemThirdPartyEmailMarketing>;
    /**
     * Variant Items
     * @type {Array<ItemVariantItem>}
     * @memberof Item
     */
    variant_items?: Array<ItemVariantItem>;
    /**
     * Variations
     * @type {Array<ItemVariation>}
     * @memberof Item
     */
    variations?: Array<ItemVariation>;
    /**
     * 
     * @type {ItemWishlistMember}
     * @memberof Item
     */
    wishlist_member?: ItemWishlistMember;
}

/**
 * 
 * @export
 * @interface ItemAccounting
 */
export interface ItemAccounting {
    /**
     * QuickBooks item name if different than the item id
     * @type {string}
     * @memberof ItemAccounting
     */
    accounting_code?: string;
    /**
     * QuickBooks class if you are classifying items on your invoices/receipts
     * @type {string}
     * @memberof ItemAccounting
     */
    qb_class?: string;
}

/**
 * 
 * @export
 * @interface ItemAmember
 */
export interface ItemAmember {
    /**
     * The number of days that the customer should be given access to the item
     * @type {number}
     * @memberof ItemAmember
     */
    amember_payment_duration_days?: number;
    /**
     * A-member product id give customer access to when they purchase this item
     * @type {string}
     * @memberof ItemAmember
     */
    amember_product_id?: string;
}

/**
 * 
 * @export
 * @interface ItemAutoOrder
 */
export interface ItemAutoOrder {
    /**
     * Amount to try and authorize for the future rebill
     * @type {number}
     * @memberof ItemAutoOrder
     */
    auth_future_amount?: number;
    /**
     * Amount to try and test authorize
     * @type {number}
     * @memberof ItemAutoOrder
     */
    auth_test_amount?: number;
    /**
     * Item id to attempt charging the customer for if they cancel
     * @type {string}
     * @memberof ItemAutoOrder
     */
    auto_order_cancel_item_id?: string;
    /**
     * Item object identifier to attempt charging the customer for if they cancel
     * @type {number}
     * @memberof ItemAutoOrder
     */
    auto_order_cancel_item_oid?: number;
    /**
     * List of downgrade items presented to customer service representatives
     * @type {Array<string>}
     * @memberof ItemAutoOrder
     */
    auto_order_downgrade_items?: Array<string>;
    /**
     * True if the rebill processing of this item is paused
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    auto_order_paused?: boolean;
    /**
     * Minimum number of months before expiration for the card.  Overrides the account level setting if higher.  Set to zero to disable.
     * @type {number}
     * @memberof ItemAutoOrder
     */
    auto_order_prohibit_expiring_cards?: number;
    /**
     * The user selectable schedules that are available
     * @type {Array<string>}
     * @memberof ItemAutoOrder
     */
    auto_order_schedules?: Array<string>;
    /**
     * List of upgrade items presented to customer service representatives
     * @type {Array<string>}
     * @memberof ItemAutoOrder
     */
    auto_order_upgrade_items?: Array<string>;
    /**
     * True if this item uses a fixed upsell step schedule
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    auto_order_upsell?: boolean;
    /**
     * Do not send the easy cancel email to the customer
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    auto_order_upsell_no_easy_cancel?: boolean;
    /**
     * Limit the purchase of this item to one per customer
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    auto_order_upsell_one_per_customer?: boolean;
    /**
     * True if this item can be automatically ordered by the customer
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    auto_orderable?: boolean;
    /**
     * True if other auto orders for this customer should be canceled when this item is ordered
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    cancel_other_auto_orders?: boolean;
    /**
     * True if the customer should be given free shipping
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    free_shipping_auto_order?: boolean;
    /**
     * True if other auto orders for this customer should refunded if this item is refunded.
     * @type {boolean}
     * @memberof ItemAutoOrder
     */
    refund_other_auto_orders?: boolean;
    /**
     * The rebill steps if this auto order is an upsell
     * @type {Array<ItemAutoOrderStep>}
     * @memberof ItemAutoOrder
     */
    steps?: Array<ItemAutoOrderStep>;
}

/**
 * 
 * @export
 * @interface ItemAutoOrderStep
 */
export interface ItemAutoOrderStep {
    /**
     * If the schedule is arbitrary, then this is the number of days
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    arbitrary_schedule_days?: number;
    /**
     * Arbitrary unit cost used to override the regular item cost
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    arbitrary_unit_cost?: number;
    /**
     * Arbitrary unit costs schedules for more advanced discounting by rebill attempt
     * @type {Array<ItemAutoOrderStepArbitraryUnitCostSchedule>}
     * @memberof ItemAutoOrderStep
     */
    arbitrary_unit_cost_schedules?: Array<ItemAutoOrderStepArbitraryUnitCostSchedule>;
    /**
     * Grand-father pricing configuration if the rebill schedule has changed over time
     * @type {Array<ItemAutoOrderStepGrandfatherPricing>}
     * @memberof ItemAutoOrderStep
     */
    grandfather_pricing?: Array<ItemAutoOrderStepGrandfatherPricing>;
    /**
     * Managed by (defaults to UltraCart)
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    managed_by?: string;
    /**
     * Number of days to pause
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    pause_days?: number;
    /**
     * Wait for this step to happen until the specified date
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    pause_until_date?: string;
    /**
     * If set, a pre-shipment notice is sent to the customer this many days in advance
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    preshipment_notice_days?: number;
    /**
     * Item id to rebill
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    recurring_merchant_item_id?: string;
    /**
     * Item object identifier to rebill
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    recurring_merchant_item_oid?: number;
    /**
     * Number of times to rebill.  Last step can be null for infinite
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    repeat_count?: number;
    /**
     * Frequency of the rebill
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    schedule?: string;
    /**
     * Email list name to subscribe the customer to when the rebill occurs
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    subscribe_email_list_name?: string;
    /**
     * Email list identifier to subscribe the customer to when this rebill occurs
     * @type {number}
     * @memberof ItemAutoOrderStep
     */
    subscribe_email_list_oid?: number;
    /**
     * Type of step (item, kit only, loop or pause)
     * @type {string}
     * @memberof ItemAutoOrderStep
     */
    type?: ItemAutoOrderStep.TypeEnum;
}

/**
 * @export
 * @namespace ItemAutoOrderStep
 */
export namespace ItemAutoOrderStep {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Item = <any> 'item',
        Pause = <any> 'pause',
        Loop = <any> 'loop',
        KitOnly = <any> 'kit only'
    }
}

/**
 * 
 * @export
 * @interface ItemAutoOrderStepArbitraryUnitCostSchedule
 */
export interface ItemAutoOrderStepArbitraryUnitCostSchedule {
    /**
     * Arbitrary unit cost
     * @type {number}
     * @memberof ItemAutoOrderStepArbitraryUnitCostSchedule
     */
    arbitrary_unit_cost?: number;
    /**
     * Retry days
     * @type {number}
     * @memberof ItemAutoOrderStepArbitraryUnitCostSchedule
     */
    retry_days?: number;
}

/**
 * 
 * @export
 * @interface ItemAutoOrderStepGrandfatherPricing
 */
export interface ItemAutoOrderStepGrandfatherPricing {
    /**
     * On or before date
     * @type {string}
     * @memberof ItemAutoOrderStepGrandfatherPricing
     */
    on_or_before_date?: string;
    /**
     * Unit cost
     * @type {number}
     * @memberof ItemAutoOrderStepGrandfatherPricing
     */
    unit_cost?: number;
}

/**
 * 
 * @export
 * @interface ItemCCBill
 */
export interface ItemCCBill {
    /**
     * Allowed currencies
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbill_allowed_currencies?: string;
    /**
     * Allowed types
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbill_allowed_types?: string;
    /**
     * Currency code
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbill_currency_code?: string;
    /**
     * Form name
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbill_form_name?: string;
    /**
     * Sub-account id
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbill_subaccount_id?: string;
    /**
     * Subscription type id
     * @type {string}
     * @memberof ItemCCBill
     */
    ccbill_subscription_type_id?: string;
}

/**
 * 
 * @export
 * @interface ItemChannelPartnerMapping
 */
export interface ItemChannelPartnerMapping {
    /**
     * Barcode UA (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcode_ua?: string;
    /**
     * Barcode UC (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcode_uc?: string;
    /**
     * Barcode UI (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcode_ui?: string;
    /**
     * Barcode UK (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    barcode_uk?: string;
    /**
     * Buyer catalog number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    buyer_catalog_number?: string;
    /**
     * Buyer DPCI (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    buyer_dpci?: string;
    /**
     * Buyer item number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    buyer_item_number?: string;
    /**
     * Channel partner code
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    channel_partner_code?: string;
    /**
     * Channel partner object identifier
     * @type {number}
     * @memberof ItemChannelPartnerMapping
     */
    channel_partner_oid?: number;
    /**
     * Cost given to this channel partner
     * @type {number}
     * @memberof ItemChannelPartnerMapping
     */
    cost?: number;
    /**
     * From Item ID
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    from_item_id?: string;
    /**
     * From SKU
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    from_sku?: string;
    /**
     * Mutually defined number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    mutually_defined_number?: string;
    /**
     * Ratio (Channel Partner)
     * @type {number}
     * @memberof ItemChannelPartnerMapping
     */
    quantity_ratio_cp?: number;
    /**
     * Ratio (UltraCart)
     * @type {number}
     * @memberof ItemChannelPartnerMapping
     */
    quantity_ratio_uc?: number;
    /**
     * SKU
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    sku?: string;
    /**
     * Unit of measure
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    unit_of_measure?: string;
    /**
     * Vendor number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    vendor_number?: string;
    /**
     * Vendor style number (EDI only)
     * @type {string}
     * @memberof ItemChannelPartnerMapping
     */
    vendor_style_number?: string;
}

/**
 * 
 * @export
 * @interface ItemChargeback
 */
export interface ItemChargeback {
    /**
     * Addendums
     * @type {Array<ItemChargebackAddendum>}
     * @memberof ItemChargeback
     */
    addendums?: Array<ItemChargebackAddendum>;
    /**
     * Adjustment requests
     * @type {Array<ItemChargebackAdjustmentRequest>}
     * @memberof ItemChargeback
     */
    adjustment_requests?: Array<ItemChargebackAdjustmentRequest>;
}

/**
 * 
 * @export
 * @interface ItemChargebackAddendum
 */
export interface ItemChargebackAddendum {
    /**
     * Chargeback addendum object identifier
     * @type {number}
     * @memberof ItemChargebackAddendum
     */
    chargeback_addendum_oid?: number;
    /**
     * Description
     * @type {string}
     * @memberof ItemChargebackAddendum
     */
    description?: string;
    /**
     * Size of the file
     * @type {number}
     * @memberof ItemChargebackAddendum
     */
    file_size?: number;
    /**
     * Number of pages
     * @type {number}
     * @memberof ItemChargebackAddendum
     */
    pages?: number;
}

/**
 * 
 * @export
 * @interface ItemChargebackAdjustmentRequest
 */
export interface ItemChargebackAdjustmentRequest {
    /**
     * Chargeback adjustment request object identifier
     * @type {number}
     * @memberof ItemChargebackAdjustmentRequest
     */
    chargeback_adjustment_request_oid?: number;
    /**
     * Description
     * @type {string}
     * @memberof ItemChargebackAdjustmentRequest
     */
    description?: string;
    /**
     * Reason code
     * @type {string}
     * @memberof ItemChargebackAdjustmentRequest
     */
    reason_code?: string;
}

/**
 * 
 * @export
 * @interface ItemCheckout
 */
export interface ItemCheckout {
    /**
     * True to suppress buySAFE (deprecated)
     * @type {boolean}
     * @memberof ItemCheckout
     */
    suppress_buysafe?: boolean;
    /**
     * Terms for purchasing this item
     * @type {string}
     * @memberof ItemCheckout
     */
    terms?: string;
    /**
     * Terms only apply if the item is on auto order
     * @type {boolean}
     * @memberof ItemCheckout
     */
    terms_if_auto_order?: boolean;
    /**
     * Terms translated text instance identifier
     * @type {number}
     * @memberof ItemCheckout
     */
    terms_translated_text_instance_oid?: number;
}

/**
 * 
 * @export
 * @interface ItemContent
 */
export interface ItemContent {
    /**
     * StoreFront assignments
     * @type {Array<ItemContentAssignment>}
     * @memberof ItemContent
     */
    assignments?: Array<ItemContentAssignment>;
    /**
     * StoreFront attributes
     * @type {Array<ItemContentAttribute>}
     * @memberof ItemContent
     */
    attributes?: Array<ItemContentAttribute>;
    /**
     * Custom Thank You URL
     * @type {string}
     * @memberof ItemContent
     */
    custom_thank_you_url?: string;
    /**
     * Exclude from search
     * @type {boolean}
     * @memberof ItemContent
     */
    exclude_from_search?: boolean;
    /**
     * Exclude from the sitemap for the StoreFront
     * @type {boolean}
     * @memberof ItemContent
     */
    exclude_from_sitemap?: boolean;
    /**
     * Exclude from the top sellers list in the StoreFront
     * @type {boolean}
     * @memberof ItemContent
     */
    exclude_from_top_sellers?: boolean;
    /**
     * Extended description (max 10000 characters)
     * @type {string}
     * @memberof ItemContent
     */
    extended_description?: string;
    /**
     * Extneded description text translation instance identifier
     * @type {number}
     * @memberof ItemContent
     */
    extended_description_translated_text_instance_oid?: number;
    /**
     * Multimedia
     * @type {Array<ItemContentMultimedia>}
     * @memberof ItemContent
     */
    multimedia?: Array<ItemContentMultimedia>;
    /**
     * True if the item is new
     * @type {boolean}
     * @memberof ItemContent
     */
    new_item?: boolean;
    /**
     * The date the item should no longer be considered new
     * @type {string}
     * @memberof ItemContent
     */
    new_item_end?: string;
    /**
     * The date the item should start being considered new
     * @type {string}
     * @memberof ItemContent
     */
    new_item_start?: string;
    /**
     * Legacy view URL (not used by StoreFronts)
     * @type {string}
     * @memberof ItemContent
     */
    view_url?: string;
}

/**
 * 
 * @export
 * @interface ItemContentAssignment
 */
export interface ItemContentAssignment {
    /**
     * True if this group is the default assignment for this item
     * @type {boolean}
     * @memberof ItemContentAssignment
     */
    default_assignment?: boolean;
    /**
     * Page (group) object identifier
     * @type {number}
     * @memberof ItemContentAssignment
     */
    group_oid?: number;
    /**
     * Page (group) path
     * @type {string}
     * @memberof ItemContentAssignment
     */
    group_path?: string;
    /**
     * StoreFront host name
     * @type {string}
     * @memberof ItemContentAssignment
     */
    host?: string;
    /**
     * Sort order (optional)
     * @type {number}
     * @memberof ItemContentAssignment
     */
    sort_order?: number;
    /**
     * URL part if the item id is not used
     * @type {string}
     * @memberof ItemContentAssignment
     */
    url_part?: string;
}

/**
 * 
 * @export
 * @interface ItemContentAttribute
 */
export interface ItemContentAttribute {
    /**
     * Attribute name
     * @type {string}
     * @memberof ItemContentAttribute
     */
    name?: string;
    /**
     * Attribute translated text instance identifier
     * @type {number}
     * @memberof ItemContentAttribute
     */
    translated_text_instance_oid?: number;
    /**
     * Attribute type
     * @type {string}
     * @memberof ItemContentAttribute
     */
    type?: string;
    /**
     * Attribute value
     * @type {string}
     * @memberof ItemContentAttribute
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemContentMultimedia
 */
export interface ItemContentMultimedia {
    /**
     * URL where the image can be downloaded from the cloud
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    cloud_url?: string;
    /**
     * Expiration date of the cloud URL
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    cloud_url_expiration?: string;
    /**
     * Code assigned to the file
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    code?: string;
    /**
     * Description
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    description?: string;
    /**
     * True to exclude from multimedia gallery
     * @type {boolean}
     * @memberof ItemContentMultimedia
     */
    exclude_from_gallery?: boolean;
    /**
     * File name
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    file_name?: string;
    /**
     * Height of the image
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    height?: number;
    /**
     * Item multimedia object identifier
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    merchant_item_multimedia_oid?: number;
    /**
     * True if the multimedia is an orphan of the active StoreFront themes
     * @type {boolean}
     * @memberof ItemContentMultimedia
     */
    orphan?: boolean;
    /**
     * True if the object is a place holder that can be populated
     * @type {boolean}
     * @memberof ItemContentMultimedia
     */
    placeholder?: boolean;
    /**
     * Temporary multimedia object identifier assigned if uploading new multimedia
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    temp_multimedia_oid?: number;
    /**
     * Thumbnails of this image
     * @type {Array<ItemContentMultimediaThumbnail>}
     * @memberof ItemContentMultimedia
     */
    thumbnails?: Array<ItemContentMultimediaThumbnail>;
    /**
     * Type of file
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    type?: ItemContentMultimedia.TypeEnum;
    /**
     * URL to download file (on new multimedia record this can be a URL for UltraCart to fetch)
     * @type {string}
     * @memberof ItemContentMultimedia
     */
    url?: string;
    /**
     * Width of the image
     * @type {number}
     * @memberof ItemContentMultimedia
     */
    width?: number;
}

/**
 * @export
 * @namespace ItemContentMultimedia
 */
export namespace ItemContentMultimedia {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}

/**
 * 
 * @export
 * @interface ItemContentMultimediaThumbnail
 */
export interface ItemContentMultimediaThumbnail {
    /**
     * Height of the thumbnail
     * @type {number}
     * @memberof ItemContentMultimediaThumbnail
     */
    height?: number;
    /**
     * HTTP URL to view the thumbnail
     * @type {string}
     * @memberof ItemContentMultimediaThumbnail
     */
    http_url?: string;
    /**
     * HTTPS URL to view the thumbnail
     * @type {string}
     * @memberof ItemContentMultimediaThumbnail
     */
    https_url?: string;
    /**
     * True if PNG, false if JPEG
     * @type {boolean}
     * @memberof ItemContentMultimediaThumbnail
     */
    png_format?: boolean;
    /**
     * True if the thumbnail is square
     * @type {boolean}
     * @memberof ItemContentMultimediaThumbnail
     */
    square?: boolean;
    /**
     * Width of the thumbnail
     * @type {number}
     * @memberof ItemContentMultimediaThumbnail
     */
    width?: number;
}

/**
 * 
 * @export
 * @interface ItemDigitalDelivery
 */
export interface ItemDigitalDelivery {
    /**
     * Description of the activation code
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activation_code_description?: string;
    /**
     * The number of activation codes whcih should generate a warning email
     * @type {number}
     * @memberof ItemDigitalDelivery
     */
    activation_code_low_warning?: number;
    /**
     * The URL to retrieve activation codes from in real-time
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activation_code_realtime_url?: string;
    /**
     * Shared secret used when communicating with the real-time URL
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activation_code_shared_secret?: string;
    /**
     * Type of activation code
     * @type {string}
     * @memberof ItemDigitalDelivery
     */
    activation_code_type?: string;
    /**
     * Digital items that customer can download when this item is purchased
     * @type {Array<ItemDigitalItem>}
     * @memberof ItemDigitalDelivery
     */
    digital_items?: Array<ItemDigitalItem>;
}

/**
 * 
 * @export
 * @interface ItemDigitalItem
 */
export interface ItemDigitalItem {
    /**
     * File creation date
     * @type {string}
     * @memberof ItemDigitalItem
     */
    creation_dts?: string;
    /**
     * Description of the digital item
     * @type {string}
     * @memberof ItemDigitalItem
     */
    description?: string;
    /**
     * File size
     * @type {number}
     * @memberof ItemDigitalItem
     */
    file_size?: number;
    /**
     * Mime type associated with the file
     * @type {string}
     * @memberof ItemDigitalItem
     */
    mime_type?: string;
    /**
     * Original filename
     * @type {string}
     * @memberof ItemDigitalItem
     */
    original_filename?: string;
}

/**
 * 
 * @export
 * @interface ItemEbay
 */
export interface ItemEbay {
    /**
     * True if the item is active for listing
     * @type {boolean}
     * @memberof ItemEbay
     */
    active?: boolean;
    /**
     * e-Bay category ID
     * @type {number}
     * @memberof ItemEbay
     */
    category_id?: number;
    /**
     * Answers to category specific questions
     * @type {Array<ItemEbayCategorySpecific>}
     * @memberof ItemEbay
     */
    category_specifics?: Array<ItemEbayCategorySpecific>;
    /**
     * Description of the condition (e-Bay constant)
     * @type {string}
     * @memberof ItemEbay
     */
    condition_description?: string;
    /**
     * Numerical ID of the condition (e-Bay constant)
     * @type {number}
     * @memberof ItemEbay
     */
    condition_id?: number;
    /**
     * Number of consecutive failures trying to list this item
     * @type {number}
     * @memberof ItemEbay
     */
    consecutive_failures?: number;
    /**
     * e-Bay Store category 1
     * @type {number}
     * @memberof ItemEbay
     */
    custom_category1?: number;
    /**
     * e-Bay Store category 2
     * @type {number}
     * @memberof ItemEbay
     */
    custom_category2?: number;
    /**
     * Maximum number of days it will take to ship the item
     * @type {number}
     * @memberof ItemEbay
     */
    dispatch_time_max?: number;
    /**
     * Domestic 1 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_1_additional_cost?: number;
    /**
     * Domestic 1 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_1_first_cost?: number;
    /**
     * Domestic 2 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_2_additional_cost?: number;
    /**
     * Domestic 2 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_2_first_cost?: number;
    /**
     * Domestic 3 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_3_additional_cost?: number;
    /**
     * Domestic 3 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_3_first_cost?: number;
    /**
     * Domestic 4 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_4_additional_cost?: number;
    /**
     * Domestic 4 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    domestic_4_first_cost?: number;
    /**
     * If listed, this is the e-Bay auction id
     * @type {string}
     * @memberof ItemEbay
     */
    ebay_auction_id?: string;
    /**
     * e-Bay specific inventory
     * @type {number}
     * @memberof ItemEbay
     */
    ebay_specific_inventory?: number;
    /**
     * The template name to use hwen rendering the e-Bay listing
     * @type {string}
     * @memberof ItemEbay
     */
    ebay_template_name?: string;
    /**
     * The template object identifier to use when rendering the e-Bay listing
     * @type {number}
     * @memberof ItemEbay
     */
    ebay_template_oid?: number;
    /**
     * Date/time of the auction end
     * @type {string}
     * @memberof ItemEbay
     */
    end_time?: string;
    /**
     * True if item receives free shipping
     * @type {boolean}
     * @memberof ItemEbay
     */
    free_shipping?: boolean;
    /**
     * The method that is free for free shipping
     * @type {string}
     * @memberof ItemEbay
     */
    free_shipping_method?: string;
    /**
     * International 1 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_1_additional_cost?: number;
    /**
     * International 1 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_1_first_cost?: number;
    /**
     * International 2 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_2_additional_cost?: number;
    /**
     * International 2 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_2_first_cost?: number;
    /**
     * International 3 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_3_additional_cost?: number;
    /**
     * International 3 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_3_first_cost?: number;
    /**
     * International 4 method additional item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_4_additional_cost?: number;
    /**
     * International 4 method first item cost
     * @type {number}
     * @memberof ItemEbay
     */
    international_4_first_cost?: number;
    /**
     * Date/time of the last status check
     * @type {string}
     * @memberof ItemEbay
     */
    last_status_dts?: string;
    /**
     * Current listing dispatch time maximum
     * @type {number}
     * @memberof ItemEbay
     */
    listed_dispatch_time_max?: number;
    /**
     * The template object identifier used for the listing
     * @type {number}
     * @memberof ItemEbay
     */
    listed_ebay_template_oid?: number;
    /**
     * Date/time of the listing
     * @type {string}
     * @memberof ItemEbay
     */
    listing_dts?: string;
    /**
     * The duration of the listing
     * @type {string}
     * @memberof ItemEbay
     */
    listing_duration?: string;
    /**
     * Price to list the item at
     * @type {number}
     * @memberof ItemEbay
     */
    listing_price?: number;
    /**
     * The price to list the item at if different than the regular UltraCart item price
     * @type {number}
     * @memberof ItemEbay
     */
    listing_price_override?: number;
    /**
     * The type of e-Bay listing
     * @type {string}
     * @memberof ItemEbay
     */
    listing_type?: string;
    /**
     * 
     * @type {ItemEbayMarketPlaceAnalysis}
     * @memberof ItemEbay
     */
    marketplace_analysis?: ItemEbayMarketPlaceAnalysis;
    /**
     * True if marketplace analysis should be performed
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplace_analysis_perform?: boolean;
    /**
     * Marketplace FVF percentage
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_final_value_fee_percentage?: number;
    /**
     * Date/time of the marketplace analysis last check
     * @type {string}
     * @memberof ItemEbay
     */
    marketplace_last_check_dts?: string;
    /**
     * True if we are the lowest offer in the marketplace
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplace_lowest?: boolean;
    /**
     * True if another seller is violating MAP
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplace_map_violation?: boolean;
    /**
     * Marketplace multiplier
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_multiplier?: number;
    /**
     * Marketplace other price
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_other_price?: number;
    /**
     * Marketplace other seller
     * @type {string}
     * @memberof ItemEbay
     */
    marketplace_other_seller?: string;
    /**
     * Marketplace other shipping
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_other_shipping?: number;
    /**
     * Marketplace other total
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_other_total?: number;
    /**
     * Marketplace our additional profit potential
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_our_additional_profit_potential?: number;
    /**
     * Marketplace our price
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_our_price?: number;
    /**
     * Marketplace our profit
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_our_profit?: number;
    /**
     * Marketplace our shipping
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_our_shipping?: number;
    /**
     * Marketplace our total
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_our_total?: number;
    /**
     * Marketplace overhead
     * @type {number}
     * @memberof ItemEbay
     */
    marketplace_overhead?: number;
    /**
     * True if our listing is profitable to sell
     * @type {boolean}
     * @memberof ItemEbay
     */
    marketplace_profitable?: boolean;
    /**
     * Date/time for the next attempt to list
     * @type {string}
     * @memberof ItemEbay
     */
    next_attempt_dts?: string;
    /**
     * The next listing duration to use when the current listing ends.
     * @type {string}
     * @memberof ItemEbay
     */
    next_listing_duration?: string;
    /**
     * True if the item should not qualify for promotional shipping
     * @type {boolean}
     * @memberof ItemEbay
     */
    no_promotional_shipping?: boolean;
    /**
     * Packaging and handling costs
     * @type {number}
     * @memberof ItemEbay
     */
    packaging_handling_costs?: number;
    /**
     * Previous e-Bay auction id
     * @type {string}
     * @memberof ItemEbay
     */
    previous_ebay_auction_id?: string;
    /**
     * Quantity available of the item
     * @type {number}
     * @memberof ItemEbay
     */
    quantity?: number;
    /**
     * Reserve price
     * @type {number}
     * @memberof ItemEbay
     */
    reserve_price?: number;
    /**
     * How to send the item dimensions and weights to e-Bay
     * @type {string}
     * @memberof ItemEbay
     */
    send_dimensions_and_weight?: string;
    /**
     * Date/time of the auction start
     * @type {string}
     * @memberof ItemEbay
     */
    start_time?: string;
    /**
     * Status of the item's listing
     * @type {string}
     * @memberof ItemEbay
     */
    status?: string;
    /**
     * Typical number of days it will take to ship the item
     * @type {number}
     * @memberof ItemEbay
     */
    target_dispatch_time_max?: number;
}

/**
 * 
 * @export
 * @interface ItemEbayCategorySpecific
 */
export interface ItemEbayCategorySpecific {
    /**
     * Name of the category specification field
     * @type {string}
     * @memberof ItemEbayCategorySpecific
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof ItemEbayCategorySpecific
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemEbayMarketListing
 */
export interface ItemEbayMarketListing {
    /**
     * Auction ID
     * @type {string}
     * @memberof ItemEbayMarketListing
     */
    auction_id?: string;
    /**
     * Price
     * @type {number}
     * @memberof ItemEbayMarketListing
     */
    price?: number;
    /**
     * Seller
     * @type {string}
     * @memberof ItemEbayMarketListing
     */
    seller?: string;
    /**
     * Shipping
     * @type {number}
     * @memberof ItemEbayMarketListing
     */
    shipping?: number;
    /**
     * Total
     * @type {number}
     * @memberof ItemEbayMarketListing
     */
    total?: number;
}

/**
 * 
 * @export
 * @interface ItemEbayMarketPlaceAnalysis
 */
export interface ItemEbayMarketPlaceAnalysis {
    /**
     * Adjusted price
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    adjusted_price?: number;
    /**
     * Adjusted shipping
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    adjusted_shipping?: number;
    /**
     * Adjusted total
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    adjusted_total?: number;
    /**
     * Cost of goods sold
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    cogs?: number;
    /**
     * Final value fee
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    final_value_fee?: number;
    /**
     * Minimum advertised price
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    minimum_advertised_price?: number;
    /**
     * Other listings
     * @type {Array<ItemEbayMarketListing>}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    other_listings?: Array<ItemEbayMarketListing>;
    /**
     * 
     * @type {ItemEbayMarketListing}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    our_listing?: ItemEbayMarketListing;
    /**
     * Overhead
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    overhead?: number;
    /**
     * Profit potential
     * @type {number}
     * @memberof ItemEbayMarketPlaceAnalysis
     */
    profit_potential?: number;
}

/**
 * 
 * @export
 * @interface ItemEmailNotifications
 */
export interface ItemEmailNotifications {
    /**
     * Skip receipt email to customer
     * @type {boolean}
     * @memberof ItemEmailNotifications
     */
    skip_receipt?: boolean;
    /**
     * Skip shipment notification to customer
     * @type {boolean}
     * @memberof ItemEmailNotifications
     */
    skip_shipment_notification?: boolean;
}

/**
 * 
 * @export
 * @interface ItemEnrollment123
 */
export interface ItemEnrollment123 {
    /**
     * Enrolment 123 product code
     * @type {string}
     * @memberof ItemEnrollment123
     */
    enrollment123_product_code?: string;
}

/**
 * 
 * @export
 * @interface ItemFulfillmentAddon
 */
export interface ItemFulfillmentAddon {
    /**
     * Add Item Id
     * @type {string}
     * @memberof ItemFulfillmentAddon
     */
    add_item_id?: string;
    /**
     * Add Item object identifier
     * @type {number}
     * @memberof ItemFulfillmentAddon
     */
    add_item_oid?: number;
    /**
     * Quantity
     * @type {boolean}
     * @memberof ItemFulfillmentAddon
     */
    once_per_order?: boolean;
    /**
     * Quantity
     * @type {number}
     * @memberof ItemFulfillmentAddon
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemGiftCertificate
 */
export interface ItemGiftCertificate {
    /**
     * True if the purchase of this item generates a gift certificate
     * @type {boolean}
     * @memberof ItemGiftCertificate
     */
    gift_certificate?: boolean;
    /**
     * The number of days that the gift certificate is good for (optional)
     * @type {number}
     * @memberof ItemGiftCertificate
     */
    gift_certificate_expiration_days?: number;
}

/**
 * 
 * @export
 * @interface ItemGoogleProductSearch
 */
export interface ItemGoogleProductSearch {
    /**
     * Adwords grouping
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwords_grouping?: string;
    /**
     * Adwords label 1
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwords_label1?: string;
    /**
     * Adwords label 2
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwords_label2?: string;
    /**
     * Adwords label 3
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwords_label3?: string;
    /**
     * Adwords label 4
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwords_label4?: string;
    /**
     * Adwords label 5
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    adwords_label5?: string;
    /**
     * Age group
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    age_group?: string;
    /**
     * Available at physical store
     * @type {boolean}
     * @memberof ItemGoogleProductSearch
     */
    available_at_physical_store?: boolean;
    /**
     * Book - author
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    book_author?: string;
    /**
     * Book - format
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    book_format?: string;
    /**
     * Bood - ISBN
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    book_isbn?: string;
    /**
     * Book - publisher
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    book_publisher?: string;
    /**
     * Category description
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    category_description?: string;
    /**
     * Color
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    color?: string;
    /**
     * Condition
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    condition?: string;
    /**
     * Custom label 0
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    custom_label0?: string;
    /**
     * Custom label 1
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    custom_label1?: string;
    /**
     * Custom label 2
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    custom_label2?: string;
    /**
     * Custom label 3
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    custom_label3?: string;
    /**
     * Custom label 4
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    custom_label4?: string;
    /**
     * Gender
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    gender?: string;
    /**
     * Google product category
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    google_product_category?: string;
    /**
     * Music - artist
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    music_artist?: string;
    /**
     * Music - format
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    music_format?: string;
    /**
     * Music - release date
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    music_release_date?: string;
    /**
     * Omit from feed
     * @type {boolean}
     * @memberof ItemGoogleProductSearch
     */
    omit_from_feed?: boolean;
    /**
     * Product type
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    product_type?: string;
    /**
     * Promotion ID 1
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id1?: string;
    /**
     * Promotion ID 10
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id10?: string;
    /**
     * Promotion ID 2
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id2?: string;
    /**
     * Promotion ID 3
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id3?: string;
    /**
     * Promotion ID 4
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id4?: string;
    /**
     * Promotion ID 5
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id5?: string;
    /**
     * Promotion ID 6
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id6?: string;
    /**
     * Promotion ID 7
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id7?: string;
    /**
     * Promotion ID 8
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id8?: string;
    /**
     * Promotion ID 9
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    promotion_id9?: string;
    /**
     * Search date/time
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    search_dts?: string;
    /**
     * Search lowest price
     * @type {number}
     * @memberof ItemGoogleProductSearch
     */
    search_lowest_price?: number;
    /**
     * Search lowest URL
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    search_lowest_url?: string;
    /**
     * Search position
     * @type {number}
     * @memberof ItemGoogleProductSearch
     */
    search_position?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    shippingLabel?: string;
    /**
     * Size
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    size?: string;
    /**
     * Video - director
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    video_director?: string;
    /**
     * Video - format
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    video_format?: string;
    /**
     * Video - rating
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    video_rating?: string;
    /**
     * Video - release date
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    video_release_date?: string;
    /**
     * Video - starring
     * @type {string}
     * @memberof ItemGoogleProductSearch
     */
    video_starring?: string;
}

/**
 * 
 * @export
 * @interface ItemIdentifiers
 */
export interface ItemIdentifiers {
    /**
     * Barcode
     * @type {string}
     * @memberof ItemIdentifiers
     */
    barcode?: string;
    /**
     * Manufacturer Name
     * @type {string}
     * @memberof ItemIdentifiers
     */
    manufacturer_name?: string;
    /**
     * Manufacturer SKU
     * @type {string}
     * @memberof ItemIdentifiers
     */
    manufacturer_sku?: string;
    /**
     * UNSPSC
     * @type {string}
     * @memberof ItemIdentifiers
     */
    unspsc?: string;
}

/**
 * 
 * @export
 * @interface ItemInstantPaymentNotification
 */
export interface ItemInstantPaymentNotification {
    /**
     * True for HTTP POST instead of GET
     * @type {boolean}
     * @memberof ItemInstantPaymentNotification
     */
    post_operation?: boolean;
    /**
     * Successful response text
     * @type {string}
     * @memberof ItemInstantPaymentNotification
     */
    successful_response_text?: string;
    /**
     * URL
     * @type {string}
     * @memberof ItemInstantPaymentNotification
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ItemInstantPaymentNotifications
 */
export interface ItemInstantPaymentNotifications {
    /**
     * Notifications
     * @type {Array<ItemInstantPaymentNotification>}
     * @memberof ItemInstantPaymentNotifications
     */
    notifications?: Array<ItemInstantPaymentNotification>;
}

/**
 * 
 * @export
 * @interface ItemInternal
 */
export interface ItemInternal {
    /**
     * Memo
     * @type {string}
     * @memberof ItemInternal
     */
    memo?: string;
}

/**
 * 
 * @export
 * @interface ItemKitComponent
 */
export interface ItemKitComponent {
    /**
     * Component item cost
     * @type {number}
     * @memberof ItemKitComponent
     */
    component_cost?: number;
    /**
     * Component item description
     * @type {string}
     * @memberof ItemKitComponent
     */
    component_description?: string;
    /**
     * Component item ID
     * @type {string}
     * @memberof ItemKitComponent
     */
    component_merchant_item_id?: string;
    /**
     * Component item object identifier
     * @type {number}
     * @memberof ItemKitComponent
     */
    component_merchant_item_oid?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof ItemKitComponent
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemKitDefinition
 */
export interface ItemKitDefinition {
    /**
     * Components
     * @type {Array<ItemKitComponent>}
     * @memberof ItemKitDefinition
     */
    components?: Array<ItemKitComponent>;
}

/**
 * 
 * @export
 * @interface ItemOption
 */
export interface ItemOption {
    /**
     * Cost if specified
     * @type {number}
     * @memberof ItemOption
     */
    cost_if_specified?: number;
    /**
     * Cost per letter
     * @type {number}
     * @memberof ItemOption
     */
    cost_per_letter?: number;
    /**
     * Cost per line
     * @type {number}
     * @memberof ItemOption
     */
    cost_per_line?: number;
    /**
     * Ignore this option on the order if the default value is selected
     * @type {boolean}
     * @memberof ItemOption
     */
    ignore_if_default?: boolean;
    /**
     * Label
     * @type {string}
     * @memberof ItemOption
     */
    label?: string;
    /**
     * Label translated text instance ID
     * @type {number}
     * @memberof ItemOption
     */
    label_translated_text_instance_oid?: number;
    /**
     * Name
     * @type {string}
     * @memberof ItemOption
     */
    name?: string;
    /**
     * Name translated text instance ID
     * @type {number}
     * @memberof ItemOption
     */
    name_translated_text_instance_oid?: number;
    /**
     * One time fee
     * @type {boolean}
     * @memberof ItemOption
     */
    one_time_fee?: boolean;
    /**
     * Option object identifier
     * @type {number}
     * @memberof ItemOption
     */
    option_oid?: number;
    /**
     * True if the customer is required to specify an answer
     * @type {boolean}
     * @memberof ItemOption
     */
    required?: boolean;
    /**
     * True if this is a system option
     * @type {boolean}
     * @memberof ItemOption
     */
    system_option?: boolean;
    /**
     * Type of option
     * @type {string}
     * @memberof ItemOption
     */
    type?: ItemOption.TypeEnum;
    /**
     * Values
     * @type {Array<ItemOptionValue>}
     * @memberof ItemOption
     */
    values?: Array<ItemOptionValue>;
}

/**
 * @export
 * @namespace ItemOption
 */
export namespace ItemOption {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Dropdown = <any> 'dropdown',
        FileAttachment = <any> 'file attachment',
        Fixed = <any> 'fixed',
        Hidden = <any> 'hidden',
        Multiline = <any> 'multiline',
        Radio = <any> 'radio',
        Single = <any> 'single'
    }
}

/**
 * 
 * @export
 * @interface ItemOptionValue
 */
export interface ItemOptionValue {
    /**
     * Additional dimensions application
     * @type {string}
     * @memberof ItemOptionValue
     */
    additional_dimension_application?: ItemOptionValue.AdditionalDimensionApplicationEnum;
    /**
     * Additional items to add to the order if this value is selected
     * @type {Array<ItemOptionValueAdditionalItem>}
     * @memberof ItemOptionValue
     */
    additional_items?: Array<ItemOptionValueAdditionalItem>;
    /**
     * Cost change
     * @type {number}
     * @memberof ItemOptionValue
     */
    cost_change?: number;
    /**
     * True if default value
     * @type {boolean}
     * @memberof ItemOptionValue
     */
    default_value?: boolean;
    /**
     * Digital items to allow the customer to download if this option value is selected
     * @type {Array<ItemOptionValueDigitalItem>}
     * @memberof ItemOptionValue
     */
    digital_items?: Array<ItemOptionValueDigitalItem>;
    /**
     * 
     * @type {Distance}
     * @memberof ItemOptionValue
     */
    height?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof ItemOptionValue
     */
    length?: Distance;
    /**
     * Multimedia object identifier associated with this option value
     * @type {number}
     * @memberof ItemOptionValue
     */
    merchant_item_multimedia_oid?: number;
    /**
     * Option value object identifier
     * @type {number}
     * @memberof ItemOptionValue
     */
    option_value_oid?: number;
    /**
     * Percentage cost change
     * @type {number}
     * @memberof ItemOptionValue
     */
    percent_cost_change?: number;
    /**
     * Translated text instance id
     * @type {number}
     * @memberof ItemOptionValue
     */
    translated_text_instance_oid?: number;
    /**
     * Value
     * @type {string}
     * @memberof ItemOptionValue
     */
    value?: string;
    /**
     * 
     * @type {Weight}
     * @memberof ItemOptionValue
     */
    weight_change?: Weight;
    /**
     * Percentage weight change
     * @type {number}
     * @memberof ItemOptionValue
     */
    weight_change_percent?: number;
    /**
     * 
     * @type {Distance}
     * @memberof ItemOptionValue
     */
    width?: Distance;
}

/**
 * @export
 * @namespace ItemOptionValue
 */
export namespace ItemOptionValue {
    /**
     * @export
     * @enum {string}
     */
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}

/**
 * 
 * @export
 * @interface ItemOptionValueAdditionalItem
 */
export interface ItemOptionValueAdditionalItem {
    /**
     * Additional item id
     * @type {string}
     * @memberof ItemOptionValueAdditionalItem
     */
    additional_merchant_item_id?: string;
    /**
     * Additional item object identifier
     * @type {number}
     * @memberof ItemOptionValueAdditionalItem
     */
    additional_merchant_item_oid?: number;
}

/**
 * 
 * @export
 * @interface ItemOptionValueDigitalItem
 */
export interface ItemOptionValueDigitalItem {
    /**
     * Digital item object identifier
     * @type {number}
     * @memberof ItemOptionValueDigitalItem
     */
    digital_item_oid?: number;
    /**
     * Original filename
     * @type {string}
     * @memberof ItemOptionValueDigitalItem
     */
    original_filename?: string;
}

/**
 * 
 * @export
 * @interface ItemPaymentProcessing
 */
export interface ItemPaymentProcessing {
    /**
     * True if prepaid cards should be blocked from buying this item
     * @type {boolean}
     * @memberof ItemPaymentProcessing
     */
    block_prepaid?: boolean;
    /**
     * Credit card transaction type
     * @type {string}
     * @memberof ItemPaymentProcessing
     */
    credit_card_transaction_type?: string;
    /**
     * True if no real-time charge should be performed on this item.
     * @type {boolean}
     * @memberof ItemPaymentProcessing
     */
    no_realtime_charge?: boolean;
    /**
     * Payment method validity
     * @type {Array<string>}
     * @memberof ItemPaymentProcessing
     */
    payment_method_validity?: Array<string>;
    /**
     * Rotating transaction gateway codes
     * @type {Array<string>}
     * @memberof ItemPaymentProcessing
     */
    rotating_transaction_gateway_codes?: Array<string>;
}

/**
 * 
 * @export
 * @interface ItemPhysical
 */
export interface ItemPhysical {
    /**
     * 
     * @type {Distance}
     * @memberof ItemPhysical
     */
    height?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof ItemPhysical
     */
    length?: Distance;
    /**
     * 
     * @type {Weight}
     * @memberof ItemPhysical
     */
    weight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof ItemPhysical
     */
    width?: Distance;
}

/**
 * 
 * @export
 * @interface ItemPricing
 */
export interface ItemPricing {
    /**
     * Allow arbitrary cost
     * @type {boolean}
     * @memberof ItemPricing
     */
    allow_arbitrary_cost?: boolean;
    /**
     * Arbitrary cost velocity code
     * @type {string}
     * @memberof ItemPricing
     */
    arbitrary_cost_velocity_code?: string;
    /**
     * Cost if customer selects to receive item on auto order.  Set to zero to delete.
     * @type {number}
     * @memberof ItemPricing
     */
    auto_order_cost?: number;
    /**
     * Automatic pricing tier name
     * @type {string}
     * @memberof ItemPricing
     */
    automatic_pricing_tier_name?: string;
    /**
     * Automatic pricing tier object identifier
     * @type {number}
     * @memberof ItemPricing
     */
    automatic_pricing_tier_oid?: number;
    /**
     * Cost of goods sold
     * @type {number}
     * @memberof ItemPricing
     */
    cogs?: number;
    /**
     * Cost
     * @type {number}
     * @memberof ItemPricing
     */
    cost?: number;
    /**
     * Currency code
     * @type {string}
     * @memberof ItemPricing
     */
    currency_code?: string;
    /**
     * Manufacturer suggested retail price
     * @type {number}
     * @memberof ItemPricing
     */
    manufacturer_suggested_retail_price?: number;
    /**
     * Maximum arbitrary cost
     * @type {number}
     * @memberof ItemPricing
     */
    maximum_arbitrary_cost?: number;
    /**
     * Minimum advertised price
     * @type {number}
     * @memberof ItemPricing
     */
    minimum_advertised_price?: number;
    /**
     * Minimum arbitrary cost
     * @type {number}
     * @memberof ItemPricing
     */
    minimum_arbitrary_cost?: number;
    /**
     * Mix and match group
     * @type {string}
     * @memberof ItemPricing
     */
    mix_and_match_group?: string;
    /**
     * Mix and match group object identifier
     * @type {number}
     * @memberof ItemPricing
     */
    mix_and_match_group_oid?: number;
    /**
     * Sale cost
     * @type {number}
     * @memberof ItemPricing
     */
    sale_cost?: number;
    /**
     * Sale end
     * @type {string}
     * @memberof ItemPricing
     */
    sale_end?: string;
    /**
     * Sale start
     * @type {string}
     * @memberof ItemPricing
     */
    sale_start?: string;
    /**
     * Tiers
     * @type {Array<ItemPricingTier>}
     * @memberof ItemPricing
     */
    tiers?: Array<ItemPricingTier>;
}

/**
 * 
 * @export
 * @interface ItemPricingTier
 */
export interface ItemPricingTier {
    /**
     * True if this is the default tier
     * @type {boolean}
     * @memberof ItemPricingTier
     */
    default_tier?: boolean;
    /**
     * Discounts
     * @type {Array<ItemPricingTierDiscount>}
     * @memberof ItemPricingTier
     */
    discounts?: Array<ItemPricingTierDiscount>;
    /**
     * 
     * @type {ItemPricingTierLimit}
     * @memberof ItemPricingTier
     */
    limit?: ItemPricingTierLimit;
    /**
     * Pricing tier name
     * @type {string}
     * @memberof ItemPricingTier
     */
    name?: string;
    /**
     * Pricing tier object identifier
     * @type {number}
     * @memberof ItemPricingTier
     */
    pricing_tier_oid?: number;
}

/**
 * 
 * @export
 * @interface ItemPricingTierDiscount
 */
export interface ItemPricingTierDiscount {
    /**
     * Cost
     * @type {number}
     * @memberof ItemPricingTierDiscount
     */
    cost?: number;
    /**
     * Quantity
     * @type {number}
     * @memberof ItemPricingTierDiscount
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemPricingTierLimit
 */
export interface ItemPricingTierLimit {
    /**
     * Cumulative order limit
     * @type {number}
     * @memberof ItemPricingTierLimit
     */
    cumulative_order_limit?: number;
    /**
     * Individual order limit
     * @type {number}
     * @memberof ItemPricingTierLimit
     */
    individual_order_limit?: number;
    /**
     * Multiple quantity
     * @type {number}
     * @memberof ItemPricingTierLimit
     */
    multiple_quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemProperty
 */
export interface ItemProperty {
    /**
     * Expiration of the property
     * @type {string}
     * @memberof ItemProperty
     */
    expirationDts?: string;
    /**
     * Property name
     * @type {string}
     * @memberof ItemProperty
     */
    name?: string;
    /**
     * Property value
     * @type {string}
     * @memberof ItemProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemRealtimePricing
 */
export interface ItemRealtimePricing {
    /**
     * Real-time pricing provider parameters
     * @type {string}
     * @memberof ItemRealtimePricing
     */
    realtime_pricing_parameter?: string;
    /**
     * Real-time pricing provider name
     * @type {string}
     * @memberof ItemRealtimePricing
     */
    realtime_pricing_provider?: string;
    /**
     * Real-time pricing provide object identifier
     * @type {number}
     * @memberof ItemRealtimePricing
     */
    realtime_pricing_provider_oid?: number;
}

/**
 * 
 * @export
 * @interface ItemRelated
 */
export interface ItemRelated {
    /**
     * True to suppress system calculated relationships
     * @type {boolean}
     * @memberof ItemRelated
     */
    no_system_calculated_related_items?: boolean;
    /**
     * Not relatable
     * @type {boolean}
     * @memberof ItemRelated
     */
    not_relatable?: boolean;
    /**
     * Related items
     * @type {Array<ItemRelatedItem>}
     * @memberof ItemRelated
     */
    related_items?: Array<ItemRelatedItem>;
}

/**
 * 
 * @export
 * @interface ItemRelatedItem
 */
export interface ItemRelatedItem {
    /**
     * Related item id
     * @type {string}
     * @memberof ItemRelatedItem
     */
    related_merchant_item_id?: string;
    /**
     * Related item object identifier
     * @type {number}
     * @memberof ItemRelatedItem
     */
    related_merchant_item_oid?: number;
    /**
     * Relationship type
     * @type {string}
     * @memberof ItemRelatedItem
     */
    type?: ItemRelatedItem.TypeEnum;
}

/**
 * @export
 * @namespace ItemRelatedItem
 */
export namespace ItemRelatedItem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        System = <any> 'System',
        UserDefined = <any> 'UserDefined'
    }
}

/**
 * 
 * @export
 * @interface ItemReporting
 */
export interface ItemReporting {
    /**
     * Report as an upsell
     * @type {boolean}
     * @memberof ItemReporting
     */
    report_as_upsell?: boolean;
    /**
     * Report pickable quantities
     * @type {Array<number>}
     * @memberof ItemReporting
     */
    report_pickable_quantities?: Array<number>;
}

/**
 * 
 * @export
 * @interface ItemResponse
 */
export interface ItemResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ItemResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Item}
     * @memberof ItemResponse
     */
    item?: Item;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ItemResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ItemResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ItemResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ItemRestriction
 */
export interface ItemRestriction {
    /**
     * Exclude coupons
     * @type {boolean}
     * @memberof ItemRestriction
     */
    exclude_coupon?: boolean;
    /**
     * Exclude from free promotion
     * @type {boolean}
     * @memberof ItemRestriction
     */
    exclude_from_free_promotion?: boolean;
    /**
     * Items
     * @type {Array<ItemRestrictionItem>}
     * @memberof ItemRestriction
     */
    items?: Array<ItemRestrictionItem>;
    /**
     * Maximum quantity
     * @type {number}
     * @memberof ItemRestriction
     */
    maximum_quantity?: number;
    /**
     * Minimum quantity (defaults to 1)
     * @type {number}
     * @memberof ItemRestriction
     */
    minimum_quantity?: number;
    /**
     * Multiple of quantity
     * @type {number}
     * @memberof ItemRestriction
     */
    multiple_quantity?: number;
    /**
     * One per customer
     * @type {boolean}
     * @memberof ItemRestriction
     */
    one_per_customer?: boolean;
    /**
     * Purchase separately
     * @type {boolean}
     * @memberof ItemRestriction
     */
    purchase_separately?: boolean;
}

/**
 * 
 * @export
 * @interface ItemRestrictionItem
 */
export interface ItemRestrictionItem {
    /**
     * Restrict item id
     * @type {string}
     * @memberof ItemRestrictionItem
     */
    restrict_merchant_item_id?: string;
    /**
     * Restrict item object identifier
     * @type {number}
     * @memberof ItemRestrictionItem
     */
    restrict_merchant_item_oid?: number;
    /**
     * Restriction type
     * @type {string}
     * @memberof ItemRestrictionItem
     */
    type?: ItemRestrictionItem.TypeEnum;
}

/**
 * @export
 * @namespace ItemRestrictionItem
 */
export namespace ItemRestrictionItem {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CanNotBePurchasedWith = <any> 'can not be purchased with',
        CanOnlyBePurchasedWith = <any> 'can only be purchased with',
        MustBePurchasedWith = <any> 'must be purchased with'
    }
}

/**
 * 
 * @export
 * @interface ItemRevguard
 */
export interface ItemRevguard {
    /**
     * Canceled CSR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguard_canceled_csr_prompt_group?: number;
    /**
     * IVR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguard_canceled_ivr_prompt_group?: number;
    /**
     * Canceled web prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguard_canceled_web_prompt_group?: number;
    /**
     * Client brand
     * @type {number}
     * @memberof ItemRevguard
     */
    revguard_client_brand?: number;
    /**
     * CSR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguard_csr_prompt_group?: number;
    /**
     * IVR prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguard_ivr_prompt_group?: number;
    /**
     * Web prompt group
     * @type {number}
     * @memberof ItemRevguard
     */
    revguard_web_prompt_group?: number;
}

/**
 * 
 * @export
 * @interface ItemReviews
 */
export interface ItemReviews {
    /**
     * True if the item has an approved review
     * @type {boolean}
     * @memberof ItemReviews
     */
    has_approved_review?: boolean;
    /**
     * True if the item has a review
     * @type {boolean}
     * @memberof ItemReviews
     */
    has_review?: boolean;
    /**
     * Number of approved reviews
     * @type {number}
     * @memberof ItemReviews
     */
    review_count?: number;
    /**
     * Overall score of reviews
     * @type {number}
     * @memberof ItemReviews
     */
    review_overall?: number;
    /**
     * Review template name
     * @type {string}
     * @memberof ItemReviews
     */
    review_template_name?: string;
    /**
     * Review template object identifier
     * @type {number}
     * @memberof ItemReviews
     */
    review_template_oid?: number;
    /**
     * True if the item is reviewable
     * @type {boolean}
     * @memberof ItemReviews
     */
    reviewable?: boolean;
    /**
     * Share reviews with item id.  To set, use the share_reviews_with_merchant_item_oid field.
     * @type {string}
     * @memberof ItemReviews
     */
    share_reviews_with_merchant_item_id?: string;
    /**
     * Share reviews with item oid.  To null out this field, set teh value to zero.
     * @type {number}
     * @memberof ItemReviews
     */
    share_reviews_with_merchant_item_oid?: number;
}

/**
 * 
 * @export
 * @interface ItemSalesforce
 */
export interface ItemSalesforce {
    /**
     * Salesforce.com pricebook id
     * @type {string}
     * @memberof ItemSalesforce
     */
    sfdc_pricebook_id?: string;
    /**
     * Salesforce.com product id
     * @type {string}
     * @memberof ItemSalesforce
     */
    sfdc_product_id?: string;
}

/**
 * 
 * @export
 * @interface ItemShipping
 */
export interface ItemShipping {
    /**
     * Allow back order
     * @type {boolean}
     * @memberof ItemShipping
     */
    allow_back_order?: boolean;
    /**
     * Fulfillment by Amazon.com
     * @type {boolean}
     * @memberof ItemShipping
     */
    amazon_fba?: boolean;
    /**
     * Case inner packs
     * @type {number}
     * @memberof ItemShipping
     */
    case_inner_packs?: number;
    /**
     * Case units
     * @type {number}
     * @memberof ItemShipping
     */
    case_units?: number;
    /**
     * Cases
     * @type {Array<ItemShippingCase>}
     * @memberof ItemShipping
     */
    cases?: Array<ItemShippingCase>;
    /**
     * This item is on pre-order
     * @type {boolean}
     * @memberof ItemShipping
     */
    collect_serial_numbers?: boolean;
    /**
     * Country code of origin for customs forms.  (ISO-3166 two letter code)
     * @type {string}
     * @memberof ItemShipping
     */
    country_code_of_origin?: string;
    /**
     * Customs description
     * @type {string}
     * @memberof ItemShipping
     */
    customs_description?: string;
    /**
     * Customs value
     * @type {number}
     * @memberof ItemShipping
     */
    customs_value?: number;
    /**
     * Delivery on Friday
     * @type {boolean}
     * @memberof ItemShipping
     */
    delivery_on_friday?: boolean;
    /**
     * Delivery on Monday
     * @type {boolean}
     * @memberof ItemShipping
     */
    delivery_on_monday?: boolean;
    /**
     * Delivery on Saturday
     * @type {boolean}
     * @memberof ItemShipping
     */
    delivery_on_saturday?: boolean;
    /**
     * Delivery on Sunday
     * @type {boolean}
     * @memberof ItemShipping
     */
    delivery_on_sunday?: boolean;
    /**
     * Delivery on Thursday
     * @type {boolean}
     * @memberof ItemShipping
     */
    delivery_on_thursday?: boolean;
    /**
     * Delivery on Tuesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    delivery_on_tuesday?: boolean;
    /**
     * Delivery on Wednesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    delivery_on_wednesday?: boolean;
    /**
     * Destination markups
     * @type {Array<ItemShippingDestinationMarkup>}
     * @memberof ItemShipping
     */
    destination_markups?: Array<ItemShippingDestinationMarkup>;
    /**
     * Destination restrictions
     * @type {Array<ItemShippingDestinationRestriction>}
     * @memberof ItemShipping
     */
    destination_restrictions?: Array<ItemShippingDestinationRestriction>;
    /**
     * Distribution centers
     * @type {Array<ItemShippingDistributionCenter>}
     * @memberof ItemShipping
     */
    distribution_centers?: Array<ItemShippingDistributionCenter>;
    /**
     * Estimated time of arrival
     * @type {string}
     * @memberof ItemShipping
     */
    eta?: string;
    /**
     * Qualifies for free shipping
     * @type {boolean}
     * @memberof ItemShipping
     */
    free_shipping?: boolean;
    /**
     * Freight class
     * @type {string}
     * @memberof ItemShipping
     */
    freight_class?: string;
    /**
     * Hazardous material
     * @type {boolean}
     * @memberof ItemShipping
     */
    hazmat?: boolean;
    /**
     * True if this item is made to order
     * @type {boolean}
     * @memberof ItemShipping
     */
    made_to_order?: boolean;
    /**
     * Number of days lead time it takes to make the item before ite can ship
     * @type {number}
     * @memberof ItemShipping
     */
    made_to_order_lead_time?: number;
    /**
     * Maximum days allowed in transit
     * @type {number}
     * @memberof ItemShipping
     */
    max_days_time_in_transit?: number;
    /**
     * Methods
     * @type {Array<ItemShippingMethod>}
     * @memberof ItemShipping
     */
    methods?: Array<ItemShippingMethod>;
    /**
     * No shipping discounts
     * @type {boolean}
     * @memberof ItemShipping
     */
    no_shipping_discount?: boolean;
    /**
     * Package requirements
     * @type {Array<ItemShippingPackageRequirement>}
     * @memberof ItemShipping
     */
    package_requirements?: Array<ItemShippingPackageRequirement>;
    /**
     * Perishable class name
     * @type {string}
     * @memberof ItemShipping
     */
    perishable_class_name?: string;
    /**
     * Perishable class object identifier
     * @type {number}
     * @memberof ItemShipping
     */
    perishable_class_oid?: number;
    /**
     * This item is on pre-order
     * @type {boolean}
     * @memberof ItemShipping
     */
    preorder?: boolean;
    /**
     * True to require customer to select a delivery date
     * @type {boolean}
     * @memberof ItemShipping
     */
    require_delivery_date?: boolean;
    /**
     * Restrict shipment on Friday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrict_shipment_on_friday?: boolean;
    /**
     * Restrict shipment on Monday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrict_shipment_on_monday?: boolean;
    /**
     * Restrict shipment on Saturday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrict_shipment_on_saturday?: boolean;
    /**
     * Restrict shipment on Sunday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrict_shipment_on_sunday?: boolean;
    /**
     * Restrict shipment on Thursday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrict_shipment_on_thursday?: boolean;
    /**
     * Restrict shipment on Tuesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrict_shipment_on_tuesday?: boolean;
    /**
     * Restrict shipment on Wednesday
     * @type {boolean}
     * @memberof ItemShipping
     */
    restrict_shipment_on_wednesday?: boolean;
    /**
     * Ship this item in a separate box
     * @type {boolean}
     * @memberof ItemShipping
     */
    ship_separately?: boolean;
    /**
     * 
     * @type {Weight}
     * @memberof ItemShipping
     */
    ship_separately_additional_weight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof ItemShipping
     */
    ship_separately_height?: Distance;
    /**
     * 
     * @type {Distance}
     * @memberof ItemShipping
     */
    ship_separately_length?: Distance;
    /**
     * Ship separately package special type
     * @type {string}
     * @memberof ItemShipping
     */
    ship_separately_package_special_type?: string;
    /**
     * 
     * @type {Distance}
     * @memberof ItemShipping
     */
    ship_separately_width?: Distance;
    /**
     * Special product type (USPS Media Mail)
     * @type {string}
     * @memberof ItemShipping
     */
    special_product_type?: string;
    /**
     * Track inventory
     * @type {boolean}
     * @memberof ItemShipping
     */
    track_inventory?: boolean;
}

/**
 * 
 * @export
 * @interface ItemShippingCase
 */
export interface ItemShippingCase {
    /**
     * Case label
     * @type {string}
     * @memberof ItemShippingCase
     */
    case_label?: string;
    /**
     * Case item id
     * @type {string}
     * @memberof ItemShippingCase
     */
    case_merchant_item_id?: string;
    /**
     * Case item object identifier
     * @type {number}
     * @memberof ItemShippingCase
     */
    case_merchant_item_oid?: number;
    /**
     * Case quantity
     * @type {number}
     * @memberof ItemShippingCase
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface ItemShippingDestinationMarkup
 */
export interface ItemShippingDestinationMarkup {
    /**
     * Country code (ISO-3166 two letter)
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    country_code?: string;
    /**
     * Flat fee
     * @type {number}
     * @memberof ItemShippingDestinationMarkup
     */
    flat_fee?: number;
    /**
     * Per item
     * @type {number}
     * @memberof ItemShippingDestinationMarkup
     */
    per_item?: number;
    /**
     * Postal code
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    postal_code?: string;
    /**
     * Shipping method
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    shipping_method?: string;
    /**
     * State
     * @type {string}
     * @memberof ItemShippingDestinationMarkup
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface ItemShippingDestinationRestriction
 */
export interface ItemShippingDestinationRestriction {
    /**
     * Country code (ISO-3166 two letter)
     * @type {string}
     * @memberof ItemShippingDestinationRestriction
     */
    country_code?: string;
    /**
     * State
     * @type {string}
     * @memberof ItemShippingDestinationRestriction
     */
    state?: string;
    /**
     * Validity
     * @type {string}
     * @memberof ItemShippingDestinationRestriction
     */
    validity?: ItemShippingDestinationRestriction.ValidityEnum;
}

/**
 * @export
 * @namespace ItemShippingDestinationRestriction
 */
export namespace ItemShippingDestinationRestriction {
    /**
     * @export
     * @enum {string}
     */
    export enum ValidityEnum {
        ValidOnlyFor = <any> 'valid only for',
        InvalidFor = <any> 'invalid for'
    }
}

/**
 * 
 * @export
 * @interface ItemShippingDistributionCenter
 */
export interface ItemShippingDistributionCenter {
    /**
     * Allocated to placed orders
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    allocated_to_placed_orders?: number;
    /**
     * Allocated to shopping carts
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    allocated_to_shopping_carts?: number;
    /**
     * Available to allocate
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    available_to_allocate?: number;
    /**
     * Cost of goods sold override at the distribution center level
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    cogs?: number;
    /**
     * Desired inventory level
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    desired_inventory_level?: number;
    /**
     * Distribution center code
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    distribution_center_code?: string;
    /**
     * Distribution center object identifier
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    distribution_center_oid?: number;
    /**
     * Estimated time of arrival
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    eta?: string;
    /**
     * True if this distribution center handles this item
     * @type {boolean}
     * @memberof ItemShippingDistributionCenter
     */
    handles?: boolean;
    /**
     * Inventory level
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    inventory_level?: number;
    /**
     * Maximum back-order
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    maximum_backorder?: number;
    /**
     * Reorder inventory level (triggers notification)
     * @type {number}
     * @memberof ItemShippingDistributionCenter
     */
    reorder_inventory_level?: number;
    /**
     * SKU
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    sku?: string;
    /**
     * Stock picking location
     * @type {string}
     * @memberof ItemShippingDistributionCenter
     */
    stock_picking_location?: string;
}

/**
 * 
 * @export
 * @interface ItemShippingMethod
 */
export interface ItemShippingMethod {
    /**
     * Cost
     * @type {number}
     * @memberof ItemShippingMethod
     */
    cost?: number;
    /**
     * Each additional item markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    each_additional_item_markup?: number;
    /**
     * Filter to this method if available
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    filter_to_if_available?: boolean;
    /**
     * First item markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    first_item_markup?: number;
    /**
     * Fixed shipping cost
     * @type {number}
     * @memberof ItemShippingMethod
     */
    fixed_shipping_cost?: number;
    /**
     * Flat fee markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    flat_fee_markup?: number;
    /**
     * Free shipping
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    free_shipping?: boolean;
    /**
     * Per item fee markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    per_item_fee_markup?: number;
    /**
     * Percentage markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    percentage_markup?: number;
    /**
     * Percentage of item markup
     * @type {number}
     * @memberof ItemShippingMethod
     */
    percentage_of_item_markup?: number;
    /**
     * Relax restrictions on upsell
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    relax_restrictions_on_upsell?: boolean;
    /**
     * Shipping method name
     * @type {string}
     * @memberof ItemShippingMethod
     */
    shipping_method?: string;
    /**
     * Shipping method object identifier
     * @type {number}
     * @memberof ItemShippingMethod
     */
    shipping_method_oid?: number;
    /**
     * Shipping method validity
     * @type {string}
     * @memberof ItemShippingMethod
     */
    shipping_method_validity?: ItemShippingMethod.ShippingMethodValidityEnum;
    /**
     * Signature required
     * @type {boolean}
     * @memberof ItemShippingMethod
     */
    signature_required?: boolean;
}

/**
 * @export
 * @namespace ItemShippingMethod
 */
export namespace ItemShippingMethod {
    /**
     * @export
     * @enum {string}
     */
    export enum ShippingMethodValidityEnum {
        InvalidFor = <any> 'invalid for',
        ValidFor = <any> 'valid for',
        ValidOnlyFor = <any> 'valid only for'
    }
}

/**
 * 
 * @export
 * @interface ItemShippingPackageRequirement
 */
export interface ItemShippingPackageRequirement {
    /**
     * Package name
     * @type {string}
     * @memberof ItemShippingPackageRequirement
     */
    package_name?: string;
    /**
     * Package object identifier
     * @type {number}
     * @memberof ItemShippingPackageRequirement
     */
    package_oid?: number;
}

/**
 * 
 * @export
 * @interface ItemTag
 */
export interface ItemTag {
    /**
     * tag_tpe
     * @type {string}
     * @memberof ItemTag
     */
    tagType?: ItemTag.TagTypeEnum;
    /**
     * tag_value
     * @type {string}
     * @memberof ItemTag
     */
    tagValue?: string;
}

/**
 * @export
 * @namespace ItemTag
 */
export namespace ItemTag {
    /**
     * @export
     * @enum {string}
     */
    export enum TagTypeEnum {
        Item = <any> 'item',
        Order = <any> 'order',
        Customer = <any> 'customer'
    }
}

/**
 * 
 * @export
 * @interface ItemTags
 */
export interface ItemTags {
    /**
     * tags
     * @type {Array<ItemTag>}
     * @memberof ItemTags
     */
    tags?: Array<ItemTag>;
}

/**
 * 
 * @export
 * @interface ItemTax
 */
export interface ItemTax {
    /**
     * Exemptions
     * @type {Array<ItemTaxExemption>}
     * @memberof ItemTax
     */
    exemptions?: Array<ItemTaxExemption>;
    /**
     * True if tax free
     * @type {boolean}
     * @memberof ItemTax
     */
    tax_free?: boolean;
    /**
     * Taxable cost if different than regular cost
     * @type {number}
     * @memberof ItemTax
     */
    taxable_cost?: number;
}

/**
 * 
 * @export
 * @interface ItemTaxExemption
 */
export interface ItemTaxExemption {
    /**
     * City
     * @type {string}
     * @memberof ItemTaxExemption
     */
    city?: string;
    /**
     * Country code (ISO-3166 two letter)
     * @type {string}
     * @memberof ItemTaxExemption
     */
    country_code?: string;
    /**
     * County
     * @type {string}
     * @memberof ItemTaxExemption
     */
    county?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof ItemTaxExemption
     */
    postal_code?: string;
    /**
     * State code
     * @type {string}
     * @memberof ItemTaxExemption
     */
    state_code?: string;
}

/**
 * 
 * @export
 * @interface ItemThirdPartyEmailMarketing
 */
export interface ItemThirdPartyEmailMarketing {
    /**
     * Add tags
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    add_tags?: Array<string>;
    /**
     * Provider name
     * @type {string}
     * @memberof ItemThirdPartyEmailMarketing
     */
    provider_name?: ItemThirdPartyEmailMarketing.ProviderNameEnum;
    /**
     * Remove tags
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    remove_tags?: Array<string>;
    /**
     * Subscribe to lists
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    subscribe_lists?: Array<string>;
    /**
     * Unsubscribe from lists
     * @type {Array<string>}
     * @memberof ItemThirdPartyEmailMarketing
     */
    unsubscribe_lists?: Array<string>;
}

/**
 * @export
 * @namespace ItemThirdPartyEmailMarketing
 */
export namespace ItemThirdPartyEmailMarketing {
    /**
     * @export
     * @enum {string}
     */
    export enum ProviderNameEnum {
        ActiveCampaign = <any> 'ActiveCampaign',
        AWeber = <any> 'AWeber',
        CampaignMonitor = <any> 'Campaign Monitor',
        ConstantContact = <any> 'ConstantContact',
        Emma = <any> 'Emma',
        GetResponse = <any> 'GetResponse',
        IContact = <any> 'iContact',
        Klaviyo = <any> 'Klaviyo',
        Lyris = <any> 'Lyris',
        LyrisHQ = <any> 'LyrisHQ',
        MailChimp = <any> 'MailChimp',
        SilverPop = <any> 'SilverPop'
    }
}

/**
 * 
 * @export
 * @interface ItemVariantItem
 */
export interface ItemVariantItem {
    /**
     * Description
     * @type {string}
     * @memberof ItemVariantItem
     */
    description?: string;
    /**
     * Multimedia object identifier
     * @type {number}
     * @memberof ItemVariantItem
     */
    merchant_item_multimedia_oid?: number;
    /**
     * Variant item id
     * @type {string}
     * @memberof ItemVariantItem
     */
    variant_merchant_item_id?: string;
    /**
     * Variant item object identifier
     * @type {number}
     * @memberof ItemVariantItem
     */
    variant_merchant_item_oid?: number;
    /**
     * Variation options
     * @type {Array<string>}
     * @memberof ItemVariantItem
     */
    variation_options?: Array<string>;
    /**
     * Variations
     * @type {Array<string>}
     * @memberof ItemVariantItem
     */
    variations?: Array<string>;
}

/**
 * 
 * @export
 * @interface ItemVariation
 */
export interface ItemVariation {
    /**
     * Default text
     * @type {string}
     * @memberof ItemVariation
     */
    default_text?: string;
    /**
     * Default text translated text instance id
     * @type {number}
     * @memberof ItemVariation
     */
    default_text_translated_text_instance_oid?: number;
    /**
     * Name
     * @type {string}
     * @memberof ItemVariation
     */
    name?: string;
    /**
     * Name translated text instance id
     * @type {number}
     * @memberof ItemVariation
     */
    name_translated_text_instance_oid?: number;
    /**
     * Options
     * @type {Array<ItemVariationOption>}
     * @memberof ItemVariation
     */
    options?: Array<ItemVariationOption>;
}

/**
 * 
 * @export
 * @interface ItemVariationOption
 */
export interface ItemVariationOption {
    /**
     * True if default option
     * @type {boolean}
     * @memberof ItemVariationOption
     */
    default_option?: boolean;
    /**
     * Multimedia object identifier
     * @type {number}
     * @memberof ItemVariationOption
     */
    merchant_item_multimedia_oid?: number;
    /**
     * Translated text instance id
     * @type {number}
     * @memberof ItemVariationOption
     */
    translated_text_instance_oid?: number;
    /**
     * Value
     * @type {string}
     * @memberof ItemVariationOption
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ItemWishlistMember
 */
export interface ItemWishlistMember {
    /**
     * WishList Member instance description
     * @type {string}
     * @memberof ItemWishlistMember
     */
    wishlist_member_instance_description?: string;
    /**
     * WishList Member instance object identifier
     * @type {number}
     * @memberof ItemWishlistMember
     */
    wishlist_member_instance_oid?: number;
    /**
     * WishList Member SKU
     * @type {string}
     * @memberof ItemWishlistMember
     */
    wishlist_member_sku?: string;
}

/**
 * 
 * @export
 * @interface ItemsRequest
 */
export interface ItemsRequest {
    /**
     * items
     * @type {Array<Item>}
     * @memberof ItemsRequest
     */
    items?: Array<Item>;
}

/**
 * 
 * @export
 * @interface ItemsResponse
 */
export interface ItemsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ItemsResponse
     */
    error?: ModelError;
    /**
     * items
     * @type {Array<Item>}
     * @memberof ItemsResponse
     */
    items?: Array<Item>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ItemsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ItemsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ItemsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface KeyValue
 */
export interface KeyValue {
    /**
     * Optional description of the lookup value
     * @type {string}
     * @memberof KeyValue
     */
    description?: string;
    /**
     * The key or id of this lookup value
     * @type {string}
     * @memberof KeyValue
     */
    key?: string;
    /**
     * The value of this lookup value
     * @type {string}
     * @memberof KeyValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface LibraryFilterValues
 */
export interface LibraryFilterValues {
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    categories?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    industries?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    styles?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryFilterValues
     */
    types?: Array<string>;
}

/**
 * 
 * @export
 * @interface LibraryFilterValuesResponse
 */
export interface LibraryFilterValuesResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof LibraryFilterValuesResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {LibraryFilterValues}
     * @memberof LibraryFilterValuesResponse
     */
    filter_values?: LibraryFilterValues;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LibraryFilterValuesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LibraryFilterValuesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof LibraryFilterValuesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface LibraryItem
 */
export interface LibraryItem {
    /**
     * 
     * @type {Array<LibraryItemAsset>}
     * @memberof LibraryItem
     */
    assets?: Array<LibraryItemAsset>;
    /**
     * 
     * @type {Array<LibraryItemAttribute>}
     * @memberof LibraryItem
     */
    attributes?: Array<LibraryItemAttribute>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryItem
     */
    categories?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    content_type?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryItem
     */
    industries?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof LibraryItem
     */
    library_item_oid?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    merchant_id?: string;
    /**
     * If this is a public item and the merchant has already purchased it, this is their version.  If not yet purchased, this will be zero.  This value will only be populated during a searchPublicItems() call.
     * @type {number}
     * @memberof LibraryItem
     */
    my_purchased_version?: number;
    /**
     * This id points to the original object that was added to the library. For flows and campaigns, this is a uuid string.  For upsells, it is an oid integer.  For transactional_emails, it is an email name.
     * @type {string}
     * @memberof LibraryItem
     */
    original_object_id?: string;
    /**
     * The price of the published item.  Null for any private library items.
     * @type {number}
     * @memberof LibraryItem
     */
    price?: number;
    /**
     * The formatted price of the published item.  Null for any private library items.
     * @type {string}
     * @memberof LibraryItem
     */
    price_formatted?: string;
    /**
     * True if this library item is a published item (not source)
     * @type {boolean}
     * @memberof LibraryItem
     */
    published?: boolean;
    /**
     * The timestamp of the last published version
     * @type {any}
     * @memberof LibraryItem
     */
    published_dts?: any;
    /**
     * The source item used to publish this item.  This allows for comparisons between source and published
     * @type {number}
     * @memberof LibraryItem
     */
    published_from_library_item_oid?: number;
    /**
     * 
     * @type {LibraryItemPublishedMeta}
     * @memberof LibraryItem
     */
    published_meta?: LibraryItemPublishedMeta;
    /**
     * The source version when this item was published.  This allows for out-of-date alerts to be shown when there is a difference between source and published
     * @type {number}
     * @memberof LibraryItem
     */
    published_version?: number;
    /**
     * True if this library item has been purchased
     * @type {boolean}
     * @memberof LibraryItem
     */
    purchased?: boolean;
    /**
     * The published item that was purchased to make this item.  This allows for comparisons between published and purchased
     * @type {number}
     * @memberof LibraryItem
     */
    purchased_from_library_item_oid?: number;
    /**
     * 
     * @type {LibraryItemPurchasedMeta}
     * @memberof LibraryItem
     */
    purchased_meta?: LibraryItemPurchasedMeta;
    /**
     * The published version when this item was purchased.  This allows for out-of-date alerts to be shown when there is a difference between published and purchased
     * @type {number}
     * @memberof LibraryItem
     */
    purchased_version?: number;
    /**
     * Any published library reviewed by UltraCart staff for malicious or inappropriate content will have this flag set to true.  This is always false for non-published items
     * @type {boolean}
     * @memberof LibraryItem
     */
    rejected?: boolean;
    /**
     * Any rejected published item will have this field populated with the reason.
     * @type {string}
     * @memberof LibraryItem
     */
    rejected_reason?: string;
    /**
     * Release notes specific to each published version and only appearing on public items.
     * @type {string}
     * @memberof LibraryItem
     */
    release_notes?: string;
    /**
     * This counter records how many times a library item has been published.  This is used to show version history.
     * @type {number}
     * @memberof LibraryItem
     */
    release_version?: number;
    /**
     * Any published library items must be reviewed by UltraCart staff for malicious content.  This flag shows the status of that review.  This is always false for non-published items
     * @type {boolean}
     * @memberof LibraryItem
     */
    reviewed?: boolean;
    /**
     * This is the timestamp for a published items formal review by UltraCart staff for malicious content.
     * @type {any}
     * @memberof LibraryItem
     */
    reviewed_dts?: any;
    /**
     * 
     * @type {Array<LibraryItemScreenshot>}
     * @memberof LibraryItem
     */
    screenshots?: Array<LibraryItemScreenshot>;
    /**
     * 
     * @type {Array<LibraryItemAccount>}
     * @memberof LibraryItem
     */
    share_with_accounts?: Array<LibraryItemAccount>;
    /**
     * 
     * @type {Array<LibraryItemEmail>}
     * @memberof LibraryItem
     */
    share_with_other_emails?: Array<LibraryItemEmail>;
    /**
     * True if this item is shared from another merchant account
     * @type {boolean}
     * @memberof LibraryItem
     */
    shared?: boolean;
    /**
     * True if this library item has been published
     * @type {boolean}
     * @memberof LibraryItem
     */
    source?: boolean;
    /**
     * This oid points to the published library item, if there is one.
     * @type {number}
     * @memberof LibraryItem
     */
    source_to_library_item_oid?: number;
    /**
     * The version of this item.  Increment every time the item is saved.
     * @type {number}
     * @memberof LibraryItem
     */
    source_version?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    style?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryItem
     */
    times_purchased?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItem
     */
    type?: string;
    /**
     * True if this library item was published but is awaiting review from UltraCart staff.
     * @type {boolean}
     * @memberof LibraryItem
     */
    under_review?: boolean;
}

/**
 * 
 * @export
 * @interface LibraryItemAccount
 */
export interface LibraryItemAccount {
    /**
     * 
     * @type {number}
     * @memberof LibraryItemAccount
     */
    library_item_account_oid?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryItemAccount
     */
    library_item_oid?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAccount
     */
    other_merchant_id?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemAsset
 */
export interface LibraryItemAsset {
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAsset
     */
    mime_type?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAsset
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemAttribute
 */
export interface LibraryItemAttribute {
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAttribute
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryItemAttribute
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemEmail
 */
export interface LibraryItemEmail {
    /**
     * 
     * @type {string}
     * @memberof LibraryItemEmail
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryItemEmail
     */
    library_item_email_oid?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryItemEmail
     */
    library_item_oid?: number;
}

/**
 * 
 * @export
 * @interface LibraryItemPublishedMeta
 */
export interface LibraryItemPublishedMeta {
    /**
     * The number of published versions a source item has, or zero if this item is not a source or is private
     * @type {number}
     * @memberof LibraryItemPublishedMeta
     */
    count_of_versions?: number;
    /**
     * The oid pointing to the most recent published version, or zero if this is not a published source item.
     * @type {number}
     * @memberof LibraryItemPublishedMeta
     */
    library_item_published_oid?: number;
    /**
     * The oid pointing to the review data if this is a source library item and currently under review
     * @type {number}
     * @memberof LibraryItemPublishedMeta
     */
    library_item_review_oid?: number;
    /**
     * True if this is a source item and is under review and was rejected.
     * @type {boolean}
     * @memberof LibraryItemPublishedMeta
     */
    rejected?: boolean;
    /**
     * The reason for rejection if this item is a source item, is under review, and was rejected.  For all other cases, this value will be null or missing.
     * @type {string}
     * @memberof LibraryItemPublishedMeta
     */
    rejected_reason?: string;
    /**
     * If this library item is a source item and it is published, this is the most recent release version number
     * @type {number}
     * @memberof LibraryItemPublishedMeta
     */
    release_version?: number;
    /**
     * If this library item is a source item and has a published item currently under review, this is that version number
     * @type {number}
     * @memberof LibraryItemPublishedMeta
     */
    review_version?: number;
    /**
     * True if this library item is a source item and is currently under review
     * @type {boolean}
     * @memberof LibraryItemPublishedMeta
     */
    under_review?: boolean;
}

/**
 * 
 * @export
 * @interface LibraryItemPurchasedMeta
 */
export interface LibraryItemPurchasedMeta {
    /**
     * The most recent version of the item purchased
     * @type {number}
     * @memberof LibraryItemPurchasedMeta
     */
    most_recent_version?: number;
    /**
     * If this is a public item and the merchant has already purchased it, this is their version.  If not yet purchased, this will be zero.  This value will only be populated during a searchPublicItems() call.
     * @type {number}
     * @memberof LibraryItemPurchasedMeta
     */
    my_purchased_version?: number;
    /**
     * True if the most recent version of this purchase it greater than what was purchased
     * @type {boolean}
     * @memberof LibraryItemPurchasedMeta
     */
    upgrade_available?: boolean;
}

/**
 * 
 * @export
 * @interface LibraryItemQuery
 */
export interface LibraryItemQuery {
    /**
     * Category
     * @type {string}
     * @memberof LibraryItemQuery
     */
    category?: string;
    /**
     * Library item content type such as flow, campaign, cjson, email, or transactional_email
     * @type {string}
     * @memberof LibraryItemQuery
     */
    content_type?: string;
    /**
     * Description of library item
     * @type {string}
     * @memberof LibraryItemQuery
     */
    description?: string;
    /**
     * Industry
     * @type {string}
     * @memberof LibraryItemQuery
     */
    industry?: string;
    /**
     * Maximum price
     * @type {number}
     * @memberof LibraryItemQuery
     */
    price_high?: number;
    /**
     * Minimum price
     * @type {number}
     * @memberof LibraryItemQuery
     */
    price_low?: number;
    /**
     * Minimum published date/time
     * @type {string}
     * @memberof LibraryItemQuery
     */
    published_dts_begin?: string;
    /**
     * Maximum published date/time
     * @type {string}
     * @memberof LibraryItemQuery
     */
    published_dts_end?: string;
    /**
     * Boolean, true if this library item has been published and is the master copy of that published work
     * @type {boolean}
     * @memberof LibraryItemQuery
     */
    source_of_published?: boolean;
    /**
     * Library item style
     * @type {string}
     * @memberof LibraryItemQuery
     */
    style?: string;
    /**
     * Title of the library item
     * @type {string}
     * @memberof LibraryItemQuery
     */
    title?: string;
    /**
     * Library item type such as header, footer, shipping block, etc
     * @type {string}
     * @memberof LibraryItemQuery
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemResponse
 */
export interface LibraryItemResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof LibraryItemResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {LibraryItem}
     * @memberof LibraryItemResponse
     */
    library_item?: LibraryItem;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LibraryItemResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LibraryItemResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof LibraryItemResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface LibraryItemScreenshot
 */
export interface LibraryItemScreenshot {
    /**
     * 
     * @type {boolean}
     * @memberof LibraryItemScreenshot
     */
    default_url?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LibraryItemScreenshot
     */
    screenshot_url?: string;
}

/**
 * 
 * @export
 * @interface LibraryItemsResponse
 */
export interface LibraryItemsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof LibraryItemsResponse
     */
    error?: ModelError;
    /**
     * Library items
     * @type {Array<LibraryItem>}
     * @memberof LibraryItemsResponse
     */
    items?: Array<LibraryItem>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LibraryItemsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LibraryItemsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof LibraryItemsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface LinkedAccount
 */
export interface LinkedAccount {
    /**
     * The company name of this linked account.
     * @type {string}
     * @memberof LinkedAccount
     */
    company?: string;
    /**
     * A merchant id that is linked to this account.
     * @type {string}
     * @memberof LinkedAccount
     */
    merchant_id?: string;
    /**
     * If true, this user configuration (permissions, notifications, everything) is cascaded to this linked account.
     * @type {boolean}
     * @memberof LinkedAccount
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface ListSegmentMembership
 */
export interface ListSegmentMembership {
    /**
     * 
     * @type {string}
     * @memberof ListSegmentMembership
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSegmentMembership
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSegmentMembership
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface LookupRequest
 */
export interface LookupRequest {
    /**
     * 
     * @type {string}
     * @memberof LookupRequest
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof LookupRequest
     */
    matches?: string;
    /**
     * 
     * @type {number}
     * @memberof LookupRequest
     */
    max_hits?: number;
    /**
     * 
     * @type {number}
     * @memberof LookupRequest
     */
    storefront_oid?: number;
    /**
     * 
     * @type {string}
     * @memberof LookupRequest
     */
    subcategory?: string;
}

/**
 * 
 * @export
 * @interface LookupResponse
 */
export interface LookupResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof LookupResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof LookupResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof LookupResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof LookupResponse
     */
    values?: Array<KeyValue>;
    /**
     * 
     * @type {Warning}
     * @memberof LookupResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    all_time?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    all_time_formatted?: string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    last_30?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    last_30_formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    prior_30?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    prior_30_formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A technical message meant to be read by a developer
     * @type {string}
     * @memberof ModelError
     */
    developer_message?: string;
    /**
     * HTTP status code
     * @type {string}
     * @memberof ModelError
     */
    error_code?: string;
    /**
     * Additional information often a link to additional documentation
     * @type {string}
     * @memberof ModelError
     */
    more_info?: string;
    /**
     * Object id that the error is associated with
     * @type {string}
     * @memberof ModelError
     */
    object_id?: string;
    /**
     * An end-user friendly message suitable for display to the customer
     * @type {string}
     * @memberof ModelError
     */
    user_message?: string;
}

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * True if this notification can be filtered to only send for one or more distribution centers.
     * @type {boolean}
     * @memberof Notification
     */
    can_filter_by_distribution_centers?: boolean;
    /**
     * True if this notification can include an affiliate information.
     * @type {boolean}
     * @memberof Notification
     */
    can_include_affiliate?: boolean;
    /**
     * True if this notification can include an order attachment.
     * @type {boolean}
     * @memberof Notification
     */
    can_include_order?: boolean;
    /**
     * True if this notification can include a plain text rendering of an order directly within an email.  Some desire this over an attachment
     * @type {boolean}
     * @memberof Notification
     */
    can_include_order_plain_text?: boolean;
    /**
     * If this notification supports it, this list of distribution center CODES will filter the notification to just those distribution centers.
     * @type {Array<string>}
     * @memberof Notification
     */
    distribution_center_filters?: Array<string>;
    /**
     * If true, and this notification supports it, affiliate information will be attached to all notifications of this type
     * @type {boolean}
     * @memberof Notification
     */
    include_affiliate?: boolean;
    /**
     * If true, and this notification supports it, the order will be attached to all notifications of this type
     * @type {boolean}
     * @memberof Notification
     */
    include_order?: boolean;
    /**
     * If true, and this notification supports it, a plain text order will be directly inserted into all notifications of this type
     * @type {boolean}
     * @memberof Notification
     */
    include_order_plain_text?: boolean;
    /**
     * The name of this notification.
     * @type {string}
     * @memberof Notification
     */
    name?: string;
    /**
     * A group for this notification.  This name is only used for visual grouping within interfaces.
     * @type {string}
     * @memberof Notification
     */
    notification_group?: string;
    /**
     * True if this user wishes to receive this email notification.
     * @type {boolean}
     * @memberof Notification
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface OauthRevokeSuccessResponse
 */
export interface OauthRevokeSuccessResponse {
    /**
     * Message confirming revocation of credentials
     * @type {string}
     * @memberof OauthRevokeSuccessResponse
     */
    message?: string;
    /**
     * True if revoke was successful
     * @type {boolean}
     * @memberof OauthRevokeSuccessResponse
     */
    successful?: boolean;
}

/**
 * 
 * @export
 * @interface OauthTokenResponse
 */
export interface OauthTokenResponse {
    /**
     * Access token to use in OAuth authenticated API call
     * @type {string}
     * @memberof OauthTokenResponse
     */
    access_token?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthTokenResponse
     */
    error?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthTokenResponse
     */
    error_description?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthTokenResponse
     */
    error_uri?: string;
    /**
     * The number of seconds since issuance when the access token will expire and need to be refreshed using the refresh token
     * @type {string}
     * @memberof OauthTokenResponse
     */
    expires_in?: string;
    /**
     * The refresh token that should be used to fetch a new access token when the expiration occurs
     * @type {string}
     * @memberof OauthTokenResponse
     */
    refresh_token?: string;
    /**
     * The scope of permissions associated with teh access token
     * @type {string}
     * @memberof OauthTokenResponse
     */
    scope?: string;
    /**
     * Type of token
     * @type {string}
     * @memberof OauthTokenResponse
     */
    token_type?: OauthTokenResponse.TokenTypeEnum;
}

/**
 * @export
 * @namespace OauthTokenResponse
 */
export namespace OauthTokenResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TokenTypeEnum {
        Bearer = <any> 'bearer'
    }
}

/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Affiliates if any were associated with the order.  The first one in the array sent the order and each subsequent affiliate is the recruiter that earns a downline commission.
     * @type {Array<OrderAffiliate>}
     * @memberof Order
     */
    affiliates?: Array<OrderAffiliate>;
    /**
     * 
     * @type {OrderAutoOrder}
     * @memberof Order
     */
    auto_order?: OrderAutoOrder;
    /**
     * 
     * @type {OrderBilling}
     * @memberof Order
     */
    billing?: OrderBilling;
    /**
     * 
     * @type {OrderBuysafe}
     * @memberof Order
     */
    buysafe?: OrderBuysafe;
    /**
     * 
     * @type {OrderChannelPartner}
     * @memberof Order
     */
    channel_partner?: OrderChannelPartner;
    /**
     * 
     * @type {OrderCheckout}
     * @memberof Order
     */
    checkout?: OrderCheckout;
    /**
     * Coupons
     * @type {Array<OrderCoupon>}
     * @memberof Order
     */
    coupons?: Array<OrderCoupon>;
    /**
     * Date/time that the order was created
     * @type {string}
     * @memberof Order
     */
    creation_dts?: string;
    /**
     * Currency code that the customer used if different than the merchant's base currency code
     * @type {string}
     * @memberof Order
     */
    currency_code?: string;
    /**
     * Current stage that the order is in.
     * @type {string}
     * @memberof Order
     */
    current_stage?: Order.CurrentStageEnum;
    /**
     * 
     * @type {Customer}
     * @memberof Order
     */
    customer_profile?: Customer;
    /**
     * 
     * @type {OrderDigitalOrder}
     * @memberof Order
     */
    digital_order?: OrderDigitalOrder;
    /**
     * 
     * @type {OrderEdi}
     * @memberof Order
     */
    edi?: OrderEdi;
    /**
     * Exchange rate at the time the order was placed if currency code is different than the base currency
     * @type {number}
     * @memberof Order
     */
    exchange_rate?: number;
    /**
     * 
     * @type {OrderFraudScore}
     * @memberof Order
     */
    fraud_score?: OrderFraudScore;
    /**
     * 
     * @type {OrderGift}
     * @memberof Order
     */
    gift?: OrderGift;
    /**
     * 
     * @type {OrderGiftCertificate}
     * @memberof Order
     */
    gift_certificate?: OrderGiftCertificate;
    /**
     * 
     * @type {OrderInternal}
     * @memberof Order
     */
    internal?: OrderInternal;
    /**
     * Items
     * @type {Array<OrderItem>}
     * @memberof Order
     */
    items?: Array<OrderItem>;
    /**
     * Three letter ISO-639 language code used by the customer during the checkout if different than the default language
     * @type {string}
     * @memberof Order
     */
    language_iso_code?: string;
    /**
     * 
     * @type {OrderLinkedShipment}
     * @memberof Order
     */
    linked_shipment?: OrderLinkedShipment;
    /**
     * 
     * @type {OrderMarketing}
     * @memberof Order
     */
    marketing?: OrderMarketing;
    /**
     * UltraCart merchant ID owning this order
     * @type {string}
     * @memberof Order
     */
    merchant_id?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof Order
     */
    order_id?: string;
    /**
     * 
     * @type {OrderPayment}
     * @memberof Order
     */
    payment?: OrderPayment;
    /**
     * Properties, available only through update, not through insert due to the nature of how properties are handled internally
     * @type {Array<OrderProperty>}
     * @memberof Order
     */
    properties?: Array<OrderProperty>;
    /**
     * 
     * @type {OrderQuote}
     * @memberof Order
     */
    quote?: OrderQuote;
    /**
     * If the order was refunded, the date/time that the last refund occurred
     * @type {string}
     * @memberof Order
     */
    refund_dts?: string;
    /**
     * If the order was rejected, the date/time that the rejection occurred
     * @type {string}
     * @memberof Order
     */
    reject_dts?: string;
    /**
     * 
     * @type {OrderSalesforce}
     * @memberof Order
     */
    salesforce?: OrderSalesforce;
    /**
     * 
     * @type {OrderShipping}
     * @memberof Order
     */
    shipping?: OrderShipping;
    /**
     * 
     * @type {OrderSummary}
     * @memberof Order
     */
    summary?: OrderSummary;
    /**
     * tags, available only through update, not through insert due to the nature of how tags are handled internally
     * @type {Array<OrderTag>}
     * @memberof Order
     */
    Tags?: Array<OrderTag>;
    /**
     * 
     * @type {OrderTaxes}
     * @memberof Order
     */
    taxes?: OrderTaxes;
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown',
        PreOrdered = <any> 'Pre-ordered'
    }
}

/**
 * 
 * @export
 * @interface OrderAffiliate
 */
export interface OrderAffiliate {
    /**
     * Affiliate ID
     * @type {number}
     * @memberof OrderAffiliate
     */
    affiliate_oid?: number;
    /**
     * Ledger entries associated with all the commissions earned on this order
     * @type {Array<OrderAffiliateLedger>}
     * @memberof OrderAffiliate
     */
    ledger_entries?: Array<OrderAffiliateLedger>;
    /**
     * Sub identifier provided by the affiliate on the click that generated this order
     * @type {string}
     * @memberof OrderAffiliate
     */
    sub_id?: string;
}

/**
 * 
 * @export
 * @interface OrderAffiliateLedger
 */
export interface OrderAffiliateLedger {
    /**
     * UltraCart user name that assigned this commission if manually assigned
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    assigned_by_user?: string;
    /**
     * Item ID that this ledger record is associated with
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    item_id?: string;
    /**
     * Tier number of this affiliate in the commission calculation
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    tier_number?: number;
    /**
     * Amount of the transaction
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    transaction_amount?: number;
    /**
     * The amount that has been paid so far on the transaction
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    transaction_amount_paid?: number;
    /**
     * The date/time that the affiliate ledger was generated for the transaction
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    transaction_dts?: string;
    /**
     * Details of the transaction suitable for display to the affiliate
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    transaction_memo?: string;
    /**
     * The percentage earned on the transaction
     * @type {number}
     * @memberof OrderAffiliateLedger
     */
    transaction_percentage?: number;
    /**
     * The state of the transaction
     * @type {string}
     * @memberof OrderAffiliateLedger
     */
    transaction_state?: OrderAffiliateLedger.TransactionStateEnum;
}

/**
 * @export
 * @namespace OrderAffiliateLedger
 */
export namespace OrderAffiliateLedger {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}

/**
 * 
 * @export
 * @interface OrderAutoOrder
 */
export interface OrderAutoOrder {
    /**
     * Unique code assigned to this auto order
     * @type {string}
     * @memberof OrderAutoOrder
     */
    auto_order_code?: string;
    /**
     * Auto order object identifier
     * @type {number}
     * @memberof OrderAutoOrder
     */
    auto_order_oid?: number;
    /**
     * Cancel this auto order after X additional rebills
     * @type {number}
     * @memberof OrderAutoOrder
     */
    cancel_after_next_x_orders?: number;
    /**
     * True if the auto order was canceled because the customer purchased a downgrade item
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    cancel_downgrade?: boolean;
    /**
     * True if the auto order was canceled because the customer purchased an upgrade item
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    cancel_upgrade?: boolean;
    /**
     * The user that canceled the auto order
     * @type {string}
     * @memberof OrderAutoOrder
     */
    canceled_by_user?: string;
    /**
     * The date/time that the auto order was canceled
     * @type {string}
     * @memberof OrderAutoOrder
     */
    canceled_dts?: string;
    /**
     * True if the auto order ran successfully to completion
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    completed?: boolean;
    /**
     * The number of credit card attempts that have taken place
     * @type {number}
     * @memberof OrderAutoOrder
     */
    credit_card_attempt?: number;
    /**
     * The date/time the auto order was disabled due to failed rebills
     * @type {string}
     * @memberof OrderAutoOrder
     */
    disabled_dts?: string;
    /**
     * True if this auto order is enabled
     * @type {boolean}
     * @memberof OrderAutoOrder
     */
    enabled?: boolean;
    /**
     * The reason this auto order failed during the last rebill attempt
     * @type {string}
     * @memberof OrderAutoOrder
     */
    failure_reason?: string;
    /**
     * The items that are setup to rebill
     * @type {Array<AutoOrderItem>}
     * @memberof OrderAutoOrder
     */
    items?: Array<AutoOrderItem>;
    /**
     * The next time that the auto order will be attempted for processing
     * @type {string}
     * @memberof OrderAutoOrder
     */
    next_attempt?: string;
    /**
     * The original order id that this auto order is associated with.
     * @type {string}
     * @memberof OrderAutoOrder
     */
    original_order_id?: string;
    /**
     * Override the affiliate id given credit for rebills of this auto order
     * @type {number}
     * @memberof OrderAutoOrder
     */
    override_affiliate_id?: number;
    /**
     * Rebill orders that have taken place on this auto order
     * @type {Array<Order>}
     * @memberof OrderAutoOrder
     */
    rebill_orders?: Array<Order>;
    /**
     * The RTG code associated with this order for future rebills
     * @type {string}
     * @memberof OrderAutoOrder
     */
    rotating_transaction_gateway_code?: string;
    /**
     * The status of the auto order
     * @type {string}
     * @memberof OrderAutoOrder
     */
    status?: OrderAutoOrder.StatusEnum;
}

/**
 * @export
 * @namespace OrderAutoOrder
 */
export namespace OrderAutoOrder {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}

/**
 * 
 * @export
 * @interface OrderBilling
 */
export interface OrderBilling {
    /**
     * Address line 1
     * @type {string}
     * @memberof OrderBilling
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof OrderBilling
     */
    address2?: string;
    /**
     * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
     * @type {Array<string>}
     * @memberof OrderBilling
     */
    cc_emails?: Array<string>;
    /**
     * City
     * @type {string}
     * @memberof OrderBilling
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof OrderBilling
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof OrderBilling
     */
    country_code?: string;
    /**
     * Day time phone
     * @type {string}
     * @memberof OrderBilling
     */
    day_phone?: string;
    /**
     * Day time phone (E164 format)
     * @type {string}
     * @memberof OrderBilling
     */
    day_phone_e164?: string;
    /**
     * Email
     * @type {string}
     * @memberof OrderBilling
     */
    email?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof OrderBilling
     */
    evening_phone?: string;
    /**
     * First name
     * @type {string}
     * @memberof OrderBilling
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof OrderBilling
     */
    last_name?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof OrderBilling
     */
    postal_code?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof OrderBilling
     */
    state_region?: string;
    /**
     * Title
     * @type {string}
     * @memberof OrderBilling
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface OrderBuysafe
 */
export interface OrderBuysafe {
    /**
     * True if a buySAFE bond was available for purchase on this order
     * @type {boolean}
     * @memberof OrderBuysafe
     */
    buysafe_bond_available?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderBuysafe
     */
    buysafe_bond_cost?: Currency;
    /**
     * True if the buySAFE bond was free for this order
     * @type {boolean}
     * @memberof OrderBuysafe
     */
    buysafe_bond_free?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderBuysafe
     */
    buysafe_bond_refunded?: Currency;
    /**
     * True if the buySAFE bond was wanted by the customer
     * @type {boolean}
     * @memberof OrderBuysafe
     */
    buysafe_bond_wanted?: boolean;
    /**
     * Shopping cart ID associated with the buySAFE bond
     * @type {string}
     * @memberof OrderBuysafe
     */
    buysafe_shopping_cart_id?: string;
}

/**
 * 
 * @export
 * @interface OrderByTokenQuery
 */
export interface OrderByTokenQuery {
    /**
     * Order Token
     * @type {string}
     * @memberof OrderByTokenQuery
     */
    order_token?: string;
}

/**
 * 
 * @export
 * @interface OrderChannelPartner
 */
export interface OrderChannelPartner {
    /**
     * If true, any purchase order submitted is automatically approved
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    auto_approve_purchase_order?: boolean;
    /**
     * The code of the channel partner
     * @type {string}
     * @memberof OrderChannelPartner
     */
    channel_partner_code?: string;
    /**
     * Additional data provided by the channel partner, read-only
     * @type {string}
     * @memberof OrderChannelPartner
     */
    channel_partner_data?: string;
    /**
     * Channel partner object identifier, read-only and available on existing channel orders only.
     * @type {number}
     * @memberof OrderChannelPartner
     */
    channel_partner_oid?: number;
    /**
     * The order ID assigned by the channel partner for this order.
     * @type {string}
     * @memberof OrderChannelPartner
     */
    channel_partner_order_id?: string;
    /**
     * Set to true to ignore invalid shipping method being specified.  Only applicable on inserting orders.
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    ignore_invalid_shipping_method?: boolean;
    /**
     * Indicates this order should be placed in Account Receivable for later payment processing
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    no_realtime_payment_processing?: boolean;
    /**
     * Indicates this order was already paid for via a channel purchase and no payment collection should be attempted
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    skip_payment_processing?: boolean;
    /**
     * Instructs UltraCart to skip shipping department and mark this order as fully complete.  This flag defaults to true.  Set this flag to false to shipped product for this order.
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    store_completed?: boolean;
    /**
     * If true, any failed payment will place the order in Accounts Receivable rather than rejecting it.
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    store_if_payment_declines?: boolean;
    /**
     * Any warnings are raised as errors and halt the import of the order
     * @type {boolean}
     * @memberof OrderChannelPartner
     */
    treat_warnings_as_errors?: boolean;
}

/**
 * 
 * @export
 * @interface OrderCheckout
 */
export interface OrderCheckout {
    /**
     * Comments from the customer.  Rarely used on the single page checkout.
     * @type {string}
     * @memberof OrderCheckout
     */
    comments?: string;
    /**
     * Custom field 1
     * @type {string}
     * @memberof OrderCheckout
     */
    custom_field1?: string;
    /**
     * Custom field 2
     * @type {string}
     * @memberof OrderCheckout
     */
    custom_field2?: string;
    /**
     * Custom field 3
     * @type {string}
     * @memberof OrderCheckout
     */
    custom_field3?: string;
    /**
     * Custom field 4
     * @type {string}
     * @memberof OrderCheckout
     */
    custom_field4?: string;
    /**
     * Custom field 5
     * @type {string}
     * @memberof OrderCheckout
     */
    custom_field5?: string;
    /**
     * Custom field 6
     * @type {string}
     * @memberof OrderCheckout
     */
    custom_field6?: string;
    /**
     * Custom field 7
     * @type {string}
     * @memberof OrderCheckout
     */
    custom_field7?: string;
    /**
     * IP address of the customer when placing the order
     * @type {string}
     * @memberof OrderCheckout
     */
    customer_ip_address?: string;
    /**
     * Screen branding theme code associated with the order (legacy checkout)
     * @type {string}
     * @memberof OrderCheckout
     */
    screen_branding_theme_code?: string;
    /**
     * StoreFront host name associated with the order
     * @type {string}
     * @memberof OrderCheckout
     */
    storefront_host_name?: string;
    /**
     * Upsell path code assigned during the checkout that the customer went through
     * @type {string}
     * @memberof OrderCheckout
     */
    upsell_path_code?: string;
}

/**
 * 
 * @export
 * @interface OrderCoupon
 */
export interface OrderCoupon {
    /**
     * QuickBooks accounting code for this coupon
     * @type {string}
     * @memberof OrderCoupon
     */
    accounting_code?: string;
    /**
     * Whether or not the coupon was automatically applied to the order
     * @type {boolean}
     * @memberof OrderCoupon
     */
    automatically_applied?: boolean;
    /**
     * Coupon code configured by the merchant.  Will differ if the customer used a one time coupon code generated off this base coupon
     * @type {string}
     * @memberof OrderCoupon
     */
    base_coupon_code?: string;
    /**
     * Coupon code entered by the customer
     * @type {string}
     * @memberof OrderCoupon
     */
    coupon_code?: string;
    /**
     * True if this coupon is hidde from the customer
     * @type {boolean}
     * @memberof OrderCoupon
     */
    hdie_from_customer?: boolean;
}

/**
 * 
 * @export
 * @interface OrderDigitalItem
 */
export interface OrderDigitalItem {
    /**
     * File size
     * @type {number}
     * @memberof OrderDigitalItem
     */
    file_size?: number;
    /**
     * Last download
     * @type {string}
     * @memberof OrderDigitalItem
     */
    last_download?: string;
    /**
     * IP address that performed the last download
     * @type {string}
     * @memberof OrderDigitalItem
     */
    last_download_ip_address?: string;
    /**
     * Original file name
     * @type {string}
     * @memberof OrderDigitalItem
     */
    original_filename?: string;
    /**
     * Item id associated with this item
     * @type {string}
     * @memberof OrderDigitalItem
     */
    product_code?: string;
    /**
     * Item description associated with this item
     * @type {string}
     * @memberof OrderDigitalItem
     */
    product_description?: string;
    /**
     * Remaining number of downloads
     * @type {number}
     * @memberof OrderDigitalItem
     */
    remaining_downloads?: number;
    /**
     * URL that the customer can click to download the specific digital item
     * @type {string}
     * @memberof OrderDigitalItem
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface OrderDigitalOrder
 */
export interface OrderDigitalOrder {
    /**
     * Date/time that the digital order was created
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    creation_dts?: string;
    /**
     * Expiration date/time of the digital order
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    expiration_dts?: string;
    /**
     * Digital items associated with the digital order
     * @type {Array<OrderDigitalItem>}
     * @memberof OrderDigitalOrder
     */
    items?: Array<OrderDigitalItem>;
    /**
     * URL where the customer can go to and download their digital order content
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    url?: string;
    /**
     * URL ID is a unique code that is part of the URLs
     * @type {string}
     * @memberof OrderDigitalOrder
     */
    url_id?: string;
}

/**
 * 
 * @export
 * @interface OrderEdi
 */
export interface OrderEdi {
    /**
     * Billing address identification code from the EDI order.  Typically DUNS or DUNS+4
     * @type {string}
     * @memberof OrderEdi
     */
    bill_to_edi_code?: string;
    /**
     * Department number associated with this EDI order
     * @type {string}
     * @memberof OrderEdi
     */
    edi_department?: string;
    /**
     * Internal vendor number associated with this EDI order
     * @type {string}
     * @memberof OrderEdi
     */
    edi_internal_vendor_number?: string;
    /**
     * Shipping address identification code from the EDI order.  Typically DUNS or DUNS+4
     * @type {string}
     * @memberof OrderEdi
     */
    ship_to_edi_code?: string;
}

/**
 * 
 * @export
 * @interface OrderFormat
 */
export interface OrderFormat {
    /**
     * The context to generate the order view for.
     * @type {string}
     * @memberof OrderFormat
     */
    context?: string;
    /**
     * True to not link the email address to the order search
     * @type {boolean}
     * @memberof OrderFormat
     */
    dont_link_email_to_search?: boolean;
    /**
     * True to make the email address a clickable mailto link
     * @type {boolean}
     * @memberof OrderFormat
     */
    email_as_link?: boolean;
    /**
     * Specify a distribution center oid to filter the items displayed to that particular distribution center.
     * @type {number}
     * @memberof OrderFormat
     */
    filter_distribution_center_oid?: number;
    /**
     * The container oid to filter items to.
     * @type {number}
     * @memberof OrderFormat
     */
    filter_to_items_in_contact_oid?: number;
    /**
     * The desired format.
     * @type {string}
     * @memberof OrderFormat
     */
    format?: OrderFormat.FormatEnum;
    /**
     * True to ide the bill to address
     * @type {boolean}
     * @memberof OrderFormat
     */
    hide_bill_to_address?: boolean;
    /**
     * True to hide price information
     * @type {boolean}
     * @memberof OrderFormat
     */
    hide_price_information?: boolean;
    /**
     * True to link file attachments for download
     * @type {boolean}
     * @memberof OrderFormat
     */
    link_file_attachments?: boolean;
    /**
     * True to show contact information
     * @type {boolean}
     * @memberof OrderFormat
     */
    show_contact_info?: boolean;
    /**
     * True to show the order in the merchant currency
     * @type {boolean}
     * @memberof OrderFormat
     */
    show_in_merchant_currency?: boolean;
    /**
     * True to show internal information about the order
     * @type {boolean}
     * @memberof OrderFormat
     */
    show_internal_information?: boolean;
    /**
     * True to show merchant notes
     * @type {boolean}
     * @memberof OrderFormat
     */
    show_merchant_notes?: boolean;
    /**
     * True to show non-sensitive payment information
     * @type {boolean}
     * @memberof OrderFormat
     */
    show_non_sensitive_payment_info?: boolean;
    /**
     * True to show payment information
     * @type {boolean}
     * @memberof OrderFormat
     */
    show_payment_info?: boolean;
    /**
     * True to translate the order into the native language of the customer
     * @type {boolean}
     * @memberof OrderFormat
     */
    translate?: boolean;
}

/**
 * @export
 * @namespace OrderFormat
 */
export namespace OrderFormat {
    /**
     * @export
     * @enum {string}
     */
    export enum FormatEnum {
        Text = <any> 'text',
        Div = <any> 'div',
        Table = <any> 'table',
        Email = <any> 'email'
    }
}

/**
 * 
 * @export
 * @interface OrderFormatResponse
 */
export interface OrderFormatResponse {
    /**
     * The URLs to any stylesheets that need to be included to properly view the markup.
     * @type {Array<string>}
     * @memberof OrderFormatResponse
     */
    css_links?: Array<string>;
    /**
     * The formatted result of the order.  This will be HTML or text depending upon the requested format.
     * @type {string}
     * @memberof OrderFormatResponse
     */
    formatted_result?: string;
}

/**
 * 
 * @export
 * @interface OrderFraudScore
 */
export interface OrderFraudScore {
    /**
     * True if the IP address is a known anonymous proxy server
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    anonymous_proxy?: boolean;
    /**
     * Whether the BIN (first six digits) matched the country
     * @type {string}
     * @memberof OrderFraudScore
     */
    bin_match?: OrderFraudScore.BinMatchEnum;
    /**
     * True if the email address belongs to a known credit card fraudster
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    carder_email?: boolean;
    /**
     * Country code
     * @type {string}
     * @memberof OrderFraudScore
     */
    country_code?: string;
    /**
     * Country code matches BIN country
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    country_match?: boolean;
    /**
     * Whether the customer's phone number is located in the area of the billing address
     * @type {string}
     * @memberof OrderFraudScore
     */
    customer_phone_in_billing_location?: string;
    /**
     * Distance in kilometers between the IP address and the BIN
     * @type {number}
     * @memberof OrderFraudScore
     */
    distance_km?: number;
    /**
     * True if the email address is for a free service like gmail.com
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    free_email?: boolean;
    /**
     * True if the customer is in a high risk country known for internet fraud
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    high_risk_country?: boolean;
    /**
     * City associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ip_city?: string;
    /**
     * ISP that owns the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ip_isp?: string;
    /**
     * Approximate latitude associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ip_latitude?: string;
    /**
     * Approximate longitude associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ip_longitude?: string;
    /**
     * Organization that owns the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ip_org?: string;
    /**
     * State/region associated with the IP address
     * @type {string}
     * @memberof OrderFraudScore
     */
    ip_region?: string;
    /**
     * Likelihood of the IP address being a proxy server
     * @type {number}
     * @memberof OrderFraudScore
     */
    proxy_score?: number;
    /**
     * Overall score.  This is the score that is compared to see if the order is rejected or held for review by the fraud filter rules.
     * @type {number}
     * @memberof OrderFraudScore
     */
    score?: number;
    /**
     * True if the address is a known ship forwarding company
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    ship_forwarder?: boolean;
    /**
     * Likelihood of the email address being associated with a spammer
     * @type {number}
     * @memberof OrderFraudScore
     */
    spam_score?: number;
    /**
     * True if the IP address that placed the order is a transparent proxy server
     * @type {boolean}
     * @memberof OrderFraudScore
     */
    transparent_proxy?: boolean;
}

/**
 * @export
 * @namespace OrderFraudScore
 */
export namespace OrderFraudScore {
    /**
     * @export
     * @enum {string}
     */
    export enum BinMatchEnum {
        NA = <any> 'NA',
        No = <any> 'No',
        NotFound = <any> 'NotFound',
        Yes = <any> 'Yes'
    }
}

/**
 * 
 * @export
 * @interface OrderGift
 */
export interface OrderGift {
    /**
     * True if the order is a gift
     * @type {boolean}
     * @memberof OrderGift
     */
    gift?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    gift_charge?: Currency;
    /**
     * QuickBooks code for the gift charge
     * @type {string}
     * @memberof OrderGift
     */
    gift_charge_accounting_code?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    gift_charge_refunded?: Currency;
    /**
     * Email address of the gift recipient
     * @type {string}
     * @memberof OrderGift
     */
    gift_email?: string;
    /**
     * Message to the gift recipient
     * @type {string}
     * @memberof OrderGift
     */
    gift_message?: string;
    /**
     * QuickBooks code for the gift wrap charge
     * @type {string}
     * @memberof OrderGift
     */
    gift_wrap_accounting_code?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    gift_wrap_cost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderGift
     */
    gift_wrap_refunded?: Currency;
    /**
     * Title of the gift wrap that the customer wants used
     * @type {string}
     * @memberof OrderGift
     */
    gift_wrap_title?: string;
}

/**
 * 
 * @export
 * @interface OrderGiftCertificate
 */
export interface OrderGiftCertificate {
    /**
     * 
     * @type {Currency}
     * @memberof OrderGiftCertificate
     */
    gift_certificate_amount?: Currency;
    /**
     * Gift certificate code used on the order
     * @type {string}
     * @memberof OrderGiftCertificate
     */
    gift_certificate_code?: string;
    /**
     * Gift certificate object identifier
     * @type {number}
     * @memberof OrderGiftCertificate
     */
    gift_certificate_oid?: number;
}

/**
 * 
 * @export
 * @interface OrderInternal
 */
export interface OrderInternal {
    /**
     * True if the order has been exported to QuickBooks. If QuickBooks is not configured, then this will already be true
     * @type {boolean}
     * @memberof OrderInternal
     */
    exported_to_accounting?: boolean;
    /**
     * Merchant notes
     * @type {string}
     * @memberof OrderInternal
     */
    merchant_notes?: string;
    /**
     * If placed via the BEOE, this is the user that placed the order
     * @type {string}
     * @memberof OrderInternal
     */
    placed_by_user?: string;
    /**
     * User that issued the refund
     * @type {string}
     * @memberof OrderInternal
     */
    refund_by_user?: string;
    /**
     * Sales rep code associated with the order
     * @type {string}
     * @memberof OrderInternal
     */
    sales_rep_code?: string;
}

/**
 * 
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
    /**
     * QuickBooks code
     * @type {string}
     * @memberof OrderItem
     */
    accounting_code?: string;
    /**
     * Activation codes assigned to this item
     * @type {Array<string>}
     * @memberof OrderItem
     */
    activation_codes?: Array<string>;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    arbitrary_unit_cost?: Currency;
    /**
     * Date/time of the last rebill, used only during order insert to help project future rebills
     * @type {string}
     * @memberof OrderItem
     */
    auto_order_last_rebill_dts?: string;
    /**
     * Auto order schedule, used only during inserts supplying the recurring schedule
     * @type {string}
     * @memberof OrderItem
     */
    auto_order_schedule?: string;
    /**
     * Barcode
     * @type {string}
     * @memberof OrderItem
     */
    barcode?: string;
    /**
     * Channel partner item id if this order came through a channel partner and the channel partner item id was mapped to an internal item id
     * @type {string}
     * @memberof OrderItem
     */
    channel_partner_item_id?: string;
    /**
     * Cost of goods sold
     * @type {number}
     * @memberof OrderItem
     */
    cogs?: number;
    /**
     * Value of the kit component item
     * @type {number}
     * @memberof OrderItem
     */
    component_unit_value?: number;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    cost?: Currency;
    /**
     * Country of origin (ISO-3166 two letter code)
     * @type {string}
     * @memberof OrderItem
     */
    country_code_of_origin?: string;
    /**
     * Customs description
     * @type {string}
     * @memberof OrderItem
     */
    customs_description?: string;
    /**
     * Description
     * @type {string}
     * @memberof OrderItem
     */
    description?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    discount?: Currency;
    /**
     * Discount quantity
     * @type {number}
     * @memberof OrderItem
     */
    discount_quantity?: number;
    /**
     * 
     * @type {Weight}
     * @memberof OrderItem
     */
    discount_shipping_weight?: Weight;
    /**
     * Distribution center code responsible for shipping this item
     * @type {string}
     * @memberof OrderItem
     */
    distribution_center_code?: string;
    /**
     * 
     * @type {OrderItemEdi}
     * @memberof OrderItem
     */
    edi?: OrderItemEdi;
    /**
     * True if this item is excluded from coupons
     * @type {boolean}
     * @memberof OrderItem
     */
    exclude_coupon?: boolean;
    /**
     * True if the item receives free shipping
     * @type {boolean}
     * @memberof OrderItem
     */
    free_shipping?: boolean;
    /**
     * Hazardous materials indicator
     * @type {boolean}
     * @memberof OrderItem
     */
    hazmat?: boolean;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItem
     */
    height?: Distance;
    /**
     * Item reference object identifier used to linked to auto order item record
     * @type {number}
     * @memberof OrderItem
     */
    item_reference_oid?: number;
    /**
     * True if this item is a kit
     * @type {boolean}
     * @memberof OrderItem
     */
    kit?: boolean;
    /**
     * True if this item is a kit component
     * @type {boolean}
     * @memberof OrderItem
     */
    kit_component?: boolean;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItem
     */
    length?: Distance;
    /**
     * Manufacturer SKU
     * @type {string}
     * @memberof OrderItem
     */
    manufacturer_sku?: string;
    /**
     * Maximum days that the item can be in transit before spoilage (perishable products)
     * @type {number}
     * @memberof OrderItem
     */
    max_days_time_in_transit?: number;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderItem
     */
    merchant_item_id?: string;
    /**
     * Mix and match group name
     * @type {string}
     * @memberof OrderItem
     */
    mix_and_match_group_name?: string;
    /**
     * Mix and match group object identifier
     * @type {number}
     * @memberof OrderItem
     */
    mix_and_match_group_oid?: number;
    /**
     * True if this item is excluded from shipping discounts
     * @type {boolean}
     * @memberof OrderItem
     */
    no_shipping_discount?: boolean;
    /**
     * Options
     * @type {Array<OrderItemOption>}
     * @memberof OrderItem
     */
    options?: Array<OrderItemOption>;
    /**
     * Packed by user
     * @type {string}
     * @memberof OrderItem
     */
    packed_by_user?: string;
    /**
     * Perishable class of the item
     * @type {string}
     * @memberof OrderItem
     */
    perishable_class?: string;
    /**
     * Pricing tier that granted the particular price for this item if the customer profile had pricing tiers assigned
     * @type {string}
     * @memberof OrderItem
     */
    pricing_tier_name?: string;
    /**
     * Properties
     * @type {Array<OrderItemProperty>}
     * @memberof OrderItem
     */
    properties?: Array<OrderItemProperty>;
    /**
     * Quantity
     * @type {number}
     * @memberof OrderItem
     */
    quantity?: number;
    /**
     * Quantity refunded on this item (read only except refund operation)
     * @type {number}
     * @memberof OrderItem
     */
    quantity_refunded?: number;
    /**
     * QuickBooks class
     * @type {string}
     * @memberof OrderItem
     */
    quickbooks_class?: string;
    /**
     * True if this item ships in a separate box
     * @type {boolean}
     * @memberof OrderItem
     */
    ship_separately?: boolean;
    /**
     * Shipped by user
     * @type {string}
     * @memberof OrderItem
     */
    shipped_by_user?: string;
    /**
     * Date/time that this item was marked shipped
     * @type {string}
     * @memberof OrderItem
     */
    shipped_dts?: string;
    /**
     * Special product type (USPS Media Mail)
     * @type {string}
     * @memberof OrderItem
     */
    special_product_type?: string;
    /**
     * Tags
     * @type {Array<OrderItemTag>}
     * @memberof OrderItem
     */
    tags?: Array<OrderItemTag>;
    /**
     * True if the item is tax free
     * @type {boolean}
     * @memberof OrderItem
     */
    tax_free?: boolean;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    taxable_cost?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    total_cost_with_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    total_refunded?: Currency;
    /**
     * Date/time that this item was transmitted to the distribution center
     * @type {string}
     * @memberof OrderItem
     */
    transmitted_to_distribution_center_dts?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItem
     */
    unit_cost_with_discount?: Currency;
    /**
     * True if this item was added to the order as part of an upsell
     * @type {boolean}
     * @memberof OrderItem
     */
    upsell?: boolean;
    /**
     * 
     * @type {Weight}
     * @memberof OrderItem
     */
    weight?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItem
     */
    width?: Distance;
}

/**
 * 
 * @export
 * @interface OrderItemEdi
 */
export interface OrderItemEdi {
    /**
     * Identification information receives on the EDI purchase order
     * @type {Array<OrderItemEdiIdentification>}
     * @memberof OrderItemEdi
     */
    identifications?: Array<OrderItemEdiIdentification>;
    /**
     * Lot information
     * @type {Array<OrderItemEdiLot>}
     * @memberof OrderItemEdi
     */
    lots?: Array<OrderItemEdiLot>;
}

/**
 * 
 * @export
 * @interface OrderItemEdiIdentification
 */
export interface OrderItemEdiIdentification {
    /**
     * Identification value
     * @type {string}
     * @memberof OrderItemEdiIdentification
     */
    identification?: string;
    /**
     * Quantity associated with this identifier
     * @type {number}
     * @memberof OrderItemEdiIdentification
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface OrderItemEdiLot
 */
export interface OrderItemEdiLot {
    /**
     * Log expiration
     * @type {string}
     * @memberof OrderItemEdiLot
     */
    lot_expiration?: string;
    /**
     * Lot number
     * @type {string}
     * @memberof OrderItemEdiLot
     */
    lot_number?: string;
    /**
     * Lot quantity
     * @type {number}
     * @memberof OrderItemEdiLot
     */
    lot_quantity?: number;
}

/**
 * 
 * @export
 * @interface OrderItemOption
 */
export interface OrderItemOption {
    /**
     * How the additional dimensions are applied to the item.
     * @type {string}
     * @memberof OrderItemOption
     */
    additional_dimension_application?: OrderItemOption.AdditionalDimensionApplicationEnum;
    /**
     * 
     * @type {Currency}
     * @memberof OrderItemOption
     */
    cost_change?: Currency;
    /**
     * 
     * @type {OrderItemOptionFileAttachment}
     * @memberof OrderItemOption
     */
    file_attachment?: OrderItemOptionFileAttachment;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItemOption
     */
    height?: Distance;
    /**
     * True if this option is hidden from display on the order
     * @type {boolean}
     * @memberof OrderItemOption
     */
    hidden?: boolean;
    /**
     * Label
     * @type {string}
     * @memberof OrderItemOption
     */
    label?: string;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItemOption
     */
    length?: Distance;
    /**
     * True if the cost associated with this option is a one time fee or multiplied by the quantity of the item
     * @type {boolean}
     * @memberof OrderItemOption
     */
    one_time_fee?: boolean;
    /**
     * Value
     * @type {string}
     * @memberof OrderItemOption
     */
    value?: string;
    /**
     * 
     * @type {Weight}
     * @memberof OrderItemOption
     */
    weight_change?: Weight;
    /**
     * 
     * @type {Distance}
     * @memberof OrderItemOption
     */
    width?: Distance;
}

/**
 * @export
 * @namespace OrderItemOption
 */
export namespace OrderItemOption {
    /**
     * @export
     * @enum {string}
     */
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}

/**
 * 
 * @export
 * @interface OrderItemOptionFileAttachment
 */
export interface OrderItemOptionFileAttachment {
    /**
     * Expiration date/time
     * @type {string}
     * @memberof OrderItemOptionFileAttachment
     */
    expiration_dts?: string;
    /**
     * File name
     * @type {string}
     * @memberof OrderItemOptionFileAttachment
     */
    file_name?: string;
    /**
     * Mime type
     * @type {string}
     * @memberof OrderItemOptionFileAttachment
     */
    mime_type?: string;
    /**
     * Size
     * @type {number}
     * @memberof OrderItemOptionFileAttachment
     */
    size?: number;
}

/**
 * 
 * @export
 * @interface OrderItemProperty
 */
export interface OrderItemProperty {
    /**
     * True if this property is displayed to the customer
     * @type {boolean}
     * @memberof OrderItemProperty
     */
    display?: boolean;
    /**
     * The date/time that the property expires and is deleted
     * @type {string}
     * @memberof OrderItemProperty
     */
    expiration_dts?: string;
    /**
     * Name
     * @type {string}
     * @memberof OrderItemProperty
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof OrderItemProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface OrderItemTag
 */
export interface OrderItemTag {
    /**
     * Tag Value
     * @type {string}
     * @memberof OrderItemTag
     */
    tag_value?: string;
}

/**
 * 
 * @export
 * @interface OrderLinkedShipment
 */
export interface OrderLinkedShipment {
    /**
     * True if this order has child linked shipments
     * @type {boolean}
     * @memberof OrderLinkedShipment
     */
    has_linked_shipment?: boolean;
    /**
     * True if this order is linked to another parent order
     * @type {boolean}
     * @memberof OrderLinkedShipment
     */
    linked_shipment?: boolean;
    /**
     * The child linked shipment channel partner order ids
     * @type {Array<string>}
     * @memberof OrderLinkedShipment
     */
    linked_shipment_channel_partner_order_ids?: Array<string>;
    /**
     * The child linked shipment order ids
     * @type {Array<string>}
     * @memberof OrderLinkedShipment
     */
    linked_shipment_order_ids?: Array<string>;
    /**
     * The parent order id that this one is linked to
     * @type {string}
     * @memberof OrderLinkedShipment
     */
    linked_shipment_to_order_id?: string;
}

/**
 * 
 * @export
 * @interface OrderMarketing
 */
export interface OrderMarketing {
    /**
     * Advertising source
     * @type {string}
     * @memberof OrderMarketing
     */
    advertising_source?: string;
    /**
     * True if the customer has opted into mailing list subscription
     * @type {boolean}
     * @memberof OrderMarketing
     */
    mailing_list?: boolean;
    /**
     * Referral code
     * @type {string}
     * @memberof OrderMarketing
     */
    referral_code?: string;
}

/**
 * 
 * @export
 * @interface OrderPayment
 */
export interface OrderPayment {
    /**
     * 
     * @type {OrderPaymentCheck}
     * @memberof OrderPayment
     */
    check?: OrderPaymentCheck;
    /**
     * 
     * @type {OrderPaymentCreditCard}
     * @memberof OrderPayment
     */
    credit_card?: OrderPaymentCreditCard;
    /**
     * 
     * @type {OrderPaymentECheck}
     * @memberof OrderPayment
     */
    echeck?: OrderPaymentECheck;
    /**
     * True if order has been held for fraud review
     * @type {boolean}
     * @memberof OrderPayment
     */
    hold_for_fraud_review?: boolean;
    /**
     * 
     * @type {OrderPaymentInsurance}
     * @memberof OrderPayment
     */
    insurance?: OrderPaymentInsurance;
    /**
     * Date/time that the payment was successfully processed, for new orders, this field is only considered if channel_partner.skip_payment_processing is true
     * @type {string}
     * @memberof OrderPayment
     */
    payment_dts?: string;
    /**
     * Payment method
     * @type {string}
     * @memberof OrderPayment
     */
    payment_method?: OrderPayment.PaymentMethodEnum;
    /**
     * Payment method QuickBooks code
     * @type {string}
     * @memberof OrderPayment
     */
    payment_method_accounting_code?: string;
    /**
     * Payment method QuickBooks deposit account
     * @type {string}
     * @memberof OrderPayment
     */
    payment_method_deposit_to_account?: string;
    /**
     * Payment status
     * @type {string}
     * @memberof OrderPayment
     */
    payment_status?: OrderPayment.PaymentStatusEnum;
    /**
     * 
     * @type {OrderPaymentPurchaseOrder}
     * @memberof OrderPayment
     */
    purchase_order?: OrderPaymentPurchaseOrder;
    /**
     * Rotating transaction gateway code used to process this order
     * @type {string}
     * @memberof OrderPayment
     */
    rotating_transaction_gateway_code?: string;
    /**
     * 
     * @type {Currency}
     * @memberof OrderPayment
     */
    surcharge?: Currency;
    /**
     * Surcharge accounting code
     * @type {string}
     * @memberof OrderPayment
     */
    surcharge_accounting_code?: string;
    /**
     * Surcharge transaction fee
     * @type {number}
     * @memberof OrderPayment
     */
    surcharge_transaction_fee?: number;
    /**
     * Surcharge transaction percentage
     * @type {number}
     * @memberof OrderPayment
     */
    surcharge_transaction_percentage?: number;
    /**
     * True if this is a test order
     * @type {boolean}
     * @memberof OrderPayment
     */
    test_order?: boolean;
    /**
     * Transactions associated with processing this payment
     * @type {Array<OrderPaymentTransaction>}
     * @memberof OrderPayment
     */
    transactions?: Array<OrderPaymentTransaction>;
}

/**
 * @export
 * @namespace OrderPayment
 */
export namespace OrderPayment {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        EBay = <any> 'eBay',
        ECheck = <any> 'eCheck',
        GoogleShopping = <any> 'Google Shopping',
        Insurance = <any> 'Insurance',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer',
        Walmart = <any> 'Walmart'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentStatusEnum {
        Unprocessed = <any> 'Unprocessed',
        Authorized = <any> 'Authorized',
        CaptureFailed = <any> 'Capture Failed',
        Processed = <any> 'Processed',
        Declined = <any> 'Declined',
        Voided = <any> 'Voided',
        Refunded = <any> 'Refunded',
        Skipped = <any> 'Skipped'
    }
}

/**
 * 
 * @export
 * @interface OrderPaymentCheck
 */
export interface OrderPaymentCheck {
    /**
     * Check number
     * @type {string}
     * @memberof OrderPaymentCheck
     */
    check_number?: string;
}

/**
 * 
 * @export
 * @interface OrderPaymentCreditCard
 */
export interface OrderPaymentCreditCard {
    /**
     * Card authorization ticket
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    card_auth_ticket?: string;
    /**
     * Card authorization amount
     * @type {number}
     * @memberof OrderPaymentCreditCard
     */
    card_authorization_amount?: number;
    /**
     * Card authorization date/time
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    card_authorization_dts?: string;
    /**
     * Card authorization reference number
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    card_authorization_reference_number?: string;
    /**
     * Card expiration month (1-12)
     * @type {number}
     * @memberof OrderPaymentCreditCard
     */
    card_expiration_month?: number;
    /**
     * Card expiration year (Four digit year)
     * @type {number}
     * @memberof OrderPaymentCreditCard
     */
    card_expiration_year?: number;
    /**
     * Card number (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    card_number?: string;
    /**
     * Card number token from hosted fields used to update the card number
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    card_number_token?: string;
    /**
     * True if the card has been truncated
     * @type {boolean}
     * @memberof OrderPaymentCreditCard
     */
    card_number_truncated?: boolean;
    /**
     * Card type
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    card_type?: OrderPaymentCreditCard.CardTypeEnum;
    /**
     * Card verification number token from hosted fields, only for import/insert of new orders, completely ignored for updates, and always null/empty for queries
     * @type {string}
     * @memberof OrderPaymentCreditCard
     */
    card_verification_number_token?: string;
}

/**
 * @export
 * @namespace OrderPaymentCreditCard
 */
export namespace OrderPaymentCreditCard {
    /**
     * @export
     * @enum {string}
     */
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        JCB = <any> 'JCB',
        MasterCard = <any> 'MasterCard',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface OrderPaymentECheck
 */
export interface OrderPaymentECheck {
    /**
     * Bank routing code
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bank_aba_code?: string;
    /**
     * Bank account name
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bank_account_name?: string;
    /**
     * Bank account number (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bank_account_number?: string;
    /**
     * Bank account type
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bank_account_type?: OrderPaymentECheck.BankAccountTypeEnum;
    /**
     * Bank name
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bank_name?: string;
    /**
     * Bank owner type
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    bank_owner_type?: OrderPaymentECheck.BankOwnerTypeEnum;
    /**
     * Customer tax id (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    customer_tax_id?: string;
    /**
     * Driver license date of birth
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    drivers_license_dob?: string;
    /**
     * Driver license number (masked to last 4)
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    drivers_license_number?: string;
    /**
     * Driver license state
     * @type {string}
     * @memberof OrderPaymentECheck
     */
    drivers_license_state?: string;
}

/**
 * @export
 * @namespace OrderPaymentECheck
 */
export namespace OrderPaymentECheck {
    /**
     * @export
     * @enum {string}
     */
    export enum BankAccountTypeEnum {
        Checking = <any> 'Checking',
        Savings = <any> 'Savings'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum BankOwnerTypeEnum {
        Personal = <any> 'Personal',
        Business = <any> 'Business'
    }
}

/**
 * 
 * @export
 * @interface OrderPaymentInsurance
 */
export interface OrderPaymentInsurance {
    /**
     * application id
     * @type {string}
     * @memberof OrderPaymentInsurance
     */
    application_id?: string;
    /**
     * claim id
     * @type {string}
     * @memberof OrderPaymentInsurance
     */
    claim_id?: string;
    /**
     * refund claim id
     * @type {string}
     * @memberof OrderPaymentInsurance
     */
    refund_claim_id?: string;
}

/**
 * 
 * @export
 * @interface OrderPaymentPurchaseOrder
 */
export interface OrderPaymentPurchaseOrder {
    /**
     * Purchase order number
     * @type {string}
     * @memberof OrderPaymentPurchaseOrder
     */
    purchase_order_number?: string;
}

/**
 * 
 * @export
 * @interface OrderPaymentTransaction
 */
export interface OrderPaymentTransaction {
    /**
     * Details
     * @type {Array<OrderPaymentTransactionDetail>}
     * @memberof OrderPaymentTransaction
     */
    details?: Array<OrderPaymentTransactionDetail>;
    /**
     * True if the transaction was successful
     * @type {boolean}
     * @memberof OrderPaymentTransaction
     */
    successful?: boolean;
    /**
     * Transaction gateway
     * @type {string}
     * @memberof OrderPaymentTransaction
     */
    transaction_gateway?: string;
    /**
     * Transaction date/time
     * @type {string}
     * @memberof OrderPaymentTransaction
     */
    transaction_timestamp?: string;
}

/**
 * 
 * @export
 * @interface OrderPaymentTransactionDetail
 */
export interface OrderPaymentTransactionDetail {
    /**
     * Name
     * @type {string}
     * @memberof OrderPaymentTransactionDetail
     */
    name?: string;
    /**
     * Type
     * @type {string}
     * @memberof OrderPaymentTransactionDetail
     */
    type?: string;
    /**
     * Value
     * @type {string}
     * @memberof OrderPaymentTransactionDetail
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface OrderProcessPaymentRequest
 */
export interface OrderProcessPaymentRequest {
    /**
     * Specific amount to bill (optional).  If not specified the total of the order is billed.
     * @type {number}
     * @memberof OrderProcessPaymentRequest
     */
    amount?: number;
    /**
     * Card verification number token from hosted fields used during credit card transaction processing (optional)
     * @type {string}
     * @memberof OrderProcessPaymentRequest
     */
    card_verification_number_token?: string;
}

/**
 * 
 * @export
 * @interface OrderProcessPaymentResponse
 */
export interface OrderProcessPaymentResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof OrderProcessPaymentResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrderProcessPaymentResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {OrderPaymentTransaction}
     * @memberof OrderProcessPaymentResponse
     */
    payment_transaction?: OrderPaymentTransaction;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrderProcessPaymentResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrderProcessPaymentResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface OrderProperty
 */
export interface OrderProperty {
    /**
     * True if this property is displayed to the customer
     * @type {boolean}
     * @memberof OrderProperty
     */
    display?: boolean;
    /**
     * The date/time that the property expires and is deleted
     * @type {string}
     * @memberof OrderProperty
     */
    expiration_dts?: string;
    /**
     * Name
     * @type {string}
     * @memberof OrderProperty
     */
    name?: string;
    /**
     * Value
     * @type {string}
     * @memberof OrderProperty
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface OrderQuery
 */
export interface OrderQuery {
    /**
     * CC Email
     * @type {string}
     * @memberof OrderQuery
     */
    cc_email?: string;
    /**
     * The code of the channel partner
     * @type {string}
     * @memberof OrderQuery
     */
    channel_partner_code?: string;
    /**
     * The order ID assigned by the channel partner for this order
     * @type {string}
     * @memberof OrderQuery
     */
    channel_partner_order_id?: string;
    /**
     * City
     * @type {string}
     * @memberof OrderQuery
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof OrderQuery
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof OrderQuery
     */
    country_code?: string;
    /**
     * Date/time that the order was created
     * @type {string}
     * @memberof OrderQuery
     */
    creation_date_begin?: string;
    /**
     * Date/time that the order was created
     * @type {string}
     * @memberof OrderQuery
     */
    creation_date_end?: string;
    /**
     * Current stage that the order is in.
     * @type {string}
     * @memberof OrderQuery
     */
    current_stage?: OrderQuery.CurrentStageEnum;
    /**
     * Custom field 1
     * @type {string}
     * @memberof OrderQuery
     */
    custom_field_1?: string;
    /**
     * Custom field 2
     * @type {string}
     * @memberof OrderQuery
     */
    custom_field_2?: string;
    /**
     * Custom field 3
     * @type {string}
     * @memberof OrderQuery
     */
    custom_field_3?: string;
    /**
     * Custom field 4
     * @type {string}
     * @memberof OrderQuery
     */
    custom_field_4?: string;
    /**
     * Custom field 5
     * @type {string}
     * @memberof OrderQuery
     */
    custom_field_5?: string;
    /**
     * Custom field 6
     * @type {string}
     * @memberof OrderQuery
     */
    custom_field_6?: string;
    /**
     * Custom field 7
     * @type {string}
     * @memberof OrderQuery
     */
    custom_field_7?: string;
    /**
     * The customer profile to find associated orders for
     * @type {number}
     * @memberof OrderQuery
     */
    customer_profile_oid?: number;
    /**
     * Email
     * @type {string}
     * @memberof OrderQuery
     */
    email?: string;
    /**
     * First name
     * @type {string}
     * @memberof OrderQuery
     */
    first_name?: string;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderQuery
     */
    item_id?: string;
    /**
     * Last name
     * @type {string}
     * @memberof OrderQuery
     */
    last_name?: string;
    /**
     * Order ID
     * @type {string}
     * @memberof OrderQuery
     */
    order_id?: string;
    /**
     * Date/time that the order was successfully processed
     * @type {string}
     * @memberof OrderQuery
     */
    payment_date_begin?: string;
    /**
     * Date/time that the order was successfully processed
     * @type {string}
     * @memberof OrderQuery
     */
    payment_date_end?: string;
    /**
     * Payment method
     * @type {string}
     * @memberof OrderQuery
     */
    payment_method?: OrderQuery.PaymentMethodEnum;
    /**
     * Phone
     * @type {string}
     * @memberof OrderQuery
     */
    phone?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof OrderQuery
     */
    postal_code?: string;
    /**
     * Purchase order number
     * @type {string}
     * @memberof OrderQuery
     */
    purchase_order_number?: string;
    /**
     * Date/time that the order was refunded
     * @type {string}
     * @memberof OrderQuery
     */
    refund_date_begin?: string;
    /**
     * Date/time that the order was refunded
     * @type {string}
     * @memberof OrderQuery
     */
    refund_date_end?: string;
    /**
     * RMA number
     * @type {string}
     * @memberof OrderQuery
     */
    rma?: string;
    /**
     * Screen branding theme code associated with the order (legacy checkout)
     * @type {string}
     * @memberof OrderQuery
     */
    screen_branding_theme_code?: string;
    /**
     * Date/time that the order was shipped
     * @type {string}
     * @memberof OrderQuery
     */
    shipment_date_begin?: string;
    /**
     * Date/time that the order was shipped
     * @type {string}
     * @memberof OrderQuery
     */
    shipment_date_end?: string;
    /**
     * Date/time that the order should ship on
     * @type {string}
     * @memberof OrderQuery
     */
    shipped_on_date_begin?: string;
    /**
     * Date/time that the order should ship on
     * @type {string}
     * @memberof OrderQuery
     */
    shipped_on_date_end?: string;
    /**
     * State for United States otherwise region or province for other countries
     * @type {string}
     * @memberof OrderQuery
     */
    state_region?: string;
    /**
     * StoreFront host name associated with the order
     * @type {string}
     * @memberof OrderQuery
     */
    storefront_host_name?: string;
    /**
     * Total
     * @type {number}
     * @memberof OrderQuery
     */
    total?: number;
}

/**
 * @export
 * @namespace OrderQuery
 */
export namespace OrderQuery {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        ECheck = <any> 'eCheck',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer'
    }
}

/**
 * 
 * @export
 * @interface OrderQueryBatch
 */
export interface OrderQueryBatch {
    /**
     * Order IDs
     * @type {Array<string>}
     * @memberof OrderQueryBatch
     */
    order_ids?: Array<string>;
}

/**
 * 
 * @export
 * @interface OrderQuote
 */
export interface OrderQuote {
    /**
     * Expiration of quote at date/time
     * @type {string}
     * @memberof OrderQuote
     */
    quote_expiration_dts?: string;
    /**
     * Quoted by user
     * @type {string}
     * @memberof OrderQuote
     */
    quoted_by?: string;
    /**
     * Quoted on date/time
     * @type {string}
     * @memberof OrderQuote
     */
    quoted_dts?: string;
}

/**
 * 
 * @export
 * @interface OrderReplacement
 */
export interface OrderReplacement {
    /**
     * Additional merchant notes to append to the new order
     * @type {string}
     * @memberof OrderReplacement
     */
    additional_merchant_notes_new_order?: string;
    /**
     * Additional merchant notes to append to the original order
     * @type {string}
     * @memberof OrderReplacement
     */
    additional_merchant_notes_original_order?: string;
    /**
     * Custom field 1
     * @type {string}
     * @memberof OrderReplacement
     */
    custom_field1?: string;
    /**
     * Custom field 2
     * @type {string}
     * @memberof OrderReplacement
     */
    custom_field2?: string;
    /**
     * Custom field 3
     * @type {string}
     * @memberof OrderReplacement
     */
    custom_field3?: string;
    /**
     * Custom field 4
     * @type {string}
     * @memberof OrderReplacement
     */
    custom_field4?: string;
    /**
     * Custom field 5
     * @type {string}
     * @memberof OrderReplacement
     */
    custom_field5?: string;
    /**
     * Custom field 6
     * @type {string}
     * @memberof OrderReplacement
     */
    custom_field6?: string;
    /**
     * Custom field 7
     * @type {string}
     * @memberof OrderReplacement
     */
    custom_field7?: string;
    /**
     * Set to true if this replacement shipment should be free for the customer.
     * @type {boolean}
     * @memberof OrderReplacement
     */
    free?: boolean;
    /**
     * Set to true if you want to immediately charge the payment on this order, otherwise it will go to Accounts Receivable.
     * @type {boolean}
     * @memberof OrderReplacement
     */
    immediate_charge?: boolean;
    /**
     * Items to include in the replacement order
     * @type {Array<OrderReplacementItem>}
     * @memberof OrderReplacement
     */
    items?: Array<OrderReplacementItem>;
    /**
     * Original order id
     * @type {string}
     * @memberof OrderReplacement
     */
    original_order_id?: string;
    /**
     * Shipping method to use.  If not specified or invalid then least cost shipping will take place.
     * @type {string}
     * @memberof OrderReplacement
     */
    shipping_method?: string;
    /**
     * Set to true if you want to skip the payment as if it was successful.
     * @type {boolean}
     * @memberof OrderReplacement
     */
    skip_payment?: boolean;
}

/**
 * 
 * @export
 * @interface OrderReplacementItem
 */
export interface OrderReplacementItem {
    /**
     * Cost to charge the customer if specified.  If not specified then the default item cost is used.
     * @type {number}
     * @memberof OrderReplacementItem
     */
    arbitrary_unit_cost?: number;
    /**
     * Item ID
     * @type {string}
     * @memberof OrderReplacementItem
     */
    merchant_item_id?: string;
    /**
     * Quantity
     * @type {number}
     * @memberof OrderReplacementItem
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface OrderReplacementResponse
 */
export interface OrderReplacementResponse {
    /**
     * 
     * @type {boolean}
     * @memberof OrderReplacementResponse
     */
    chargeSuccessful?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderReplacementResponse
     */
    errorMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReplacementResponse
     */
    feedback?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderReplacementResponse
     */
    free?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderReplacementResponse
     */
    orderId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderReplacementResponse
     */
    successful?: boolean;
}

/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof OrderResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrderResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Order}
     * @memberof OrderResponse
     */
    order?: Order;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrderResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrderResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface OrderSalesforce
 */
export interface OrderSalesforce {
    /**
     * Salesforce.com opportunity id
     * @type {string}
     * @memberof OrderSalesforce
     */
    salesforce_opportunity_id?: string;
}

/**
 * 
 * @export
 * @interface OrderShipping
 */
export interface OrderShipping {
    /**
     * Address line 1
     * @type {string}
     * @memberof OrderShipping
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof OrderShipping
     */
    address2?: string;
    /**
     * City
     * @type {string}
     * @memberof OrderShipping
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof OrderShipping
     */
    company?: string;
    /**
     * ISO-3166 two letter country code
     * @type {string}
     * @memberof OrderShipping
     */
    country_code?: string;
    /**
     * Day time phone
     * @type {string}
     * @memberof OrderShipping
     */
    day_phone?: string;
    /**
     * Day time phone (E164 format)
     * @type {string}
     * @memberof OrderShipping
     */
    day_phone_e164?: string;
    /**
     * Date the customer is requesting delivery on.  Typically used for perishable product delivery.
     * @type {string}
     * @memberof OrderShipping
     */
    delivery_date?: string;
    /**
     * Evening phone
     * @type {string}
     * @memberof OrderShipping
     */
    evening_phone?: string;
    /**
     * First name
     * @type {string}
     * @memberof OrderShipping
     */
    first_name?: string;
    /**
     * Last name
     * @type {string}
     * @memberof OrderShipping
     */
    last_name?: string;
    /**
     * If true, instructs UltraCart to apply the cheapest shipping method to this order.  Used only for channel partner order inserts.
     * @type {boolean}
     * @memberof OrderShipping
     */
    least_cost_route?: boolean;
    /**
     * List of shipping methods to consider if least_code_route is true. Used only for channel parter order inserts.
     * @type {Array<string>}
     * @memberof OrderShipping
     */
    least_cost_route_shipping_methods?: Array<string>;
    /**
     * Lift gate requested (LTL shipping methods only)
     * @type {boolean}
     * @memberof OrderShipping
     */
    lift_gate?: boolean;
    /**
     * Postal code
     * @type {string}
     * @memberof OrderShipping
     */
    postal_code?: string;
    /**
     * RMA number
     * @type {string}
     * @memberof OrderShipping
     */
    rma?: string;
    /**
     * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
     * @type {string}
     * @memberof OrderShipping
     */
    ship_on_date?: string;
    /**
     * True if the shipping address is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
     * @type {boolean}
     * @memberof OrderShipping
     */
    ship_to_residential?: boolean;
    /**
     * Shipping 3rd party account number
     * @type {string}
     * @memberof OrderShipping
     */
    shipping_3rd_party_account_number?: string;
    /**
     * Date/time the order shipped on.  This date is set once the first shipment is sent to the customer.
     * @type {string}
     * @memberof OrderShipping
     */
    shipping_date?: string;
    /**
     * Shipping department status
     * @type {string}
     * @memberof OrderShipping
     */
    shipping_department_status?: string;
    /**
     * Shipping method
     * @type {string}
     * @memberof OrderShipping
     */
    shipping_method?: string;
    /**
     * Shipping method accounting code
     * @type {string}
     * @memberof OrderShipping
     */
    shipping_method_accounting_code?: string;
    /**
     * Special instructions from the customer regarding shipping
     * @type {string}
     * @memberof OrderShipping
     */
    special_instructions?: string;
    /**
     * State
     * @type {string}
     * @memberof OrderShipping
     */
    state_region?: string;
    /**
     * Title
     * @type {string}
     * @memberof OrderShipping
     */
    title?: string;
    /**
     * Tracking number details
     * @type {Array<OrderTrackingNumberDetails>}
     * @memberof OrderShipping
     */
    tracking_number_details?: Array<OrderTrackingNumberDetails>;
    /**
     * Tracking numbers
     * @type {Array<string>}
     * @memberof OrderShipping
     */
    tracking_numbers?: Array<string>;
    /**
     * 
     * @type {Weight}
     * @memberof OrderShipping
     */
    weight?: Weight;
}

/**
 * 
 * @export
 * @interface OrderSummary
 */
export interface OrderSummary {
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    actual_fulfillment?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    actual_payment_processing?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    actual_shipping?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    arbitrary_shipping_handling_total?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    other_refunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    shipping_handling_refunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    shipping_handling_total?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    shipping_handling_total_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotal_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotal_discount_refunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    subtotal_refunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    tax?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    tax_refunded?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    taxable_subtotal?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    taxable_subtotal_discount?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    total?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof OrderSummary
     */
    total_refunded?: Currency;
}

/**
 * 
 * @export
 * @interface OrderTag
 */
export interface OrderTag {
    /**
     * Tag Value
     * @type {string}
     * @memberof OrderTag
     */
    tag_value?: string;
}

/**
 * 
 * @export
 * @interface OrderTaxes
 */
export interface OrderTaxes {
    /**
     * Arbitrary Tax, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
     * @type {number}
     * @memberof OrderTaxes
     */
    arbitrary_tax?: number;
    /**
     * Arbitrary tax rate, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
     * @type {number}
     * @memberof OrderTaxes
     */
    arbitrary_tax_rate?: number;
    /**
     * Arbitrary taxable subtotal, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
     * @type {number}
     * @memberof OrderTaxes
     */
    arbitrary_taxable_subtotal?: number;
    /**
     * QuickBooks tax city code
     * @type {string}
     * @memberof OrderTaxes
     */
    tax_city_accounting_code?: string;
    /**
     * QuickBooks tax country code
     * @type {string}
     * @memberof OrderTaxes
     */
    tax_country_accounting_code?: string;
    /**
     * County used for tax calculation purposes (only in the United States)
     * @type {string}
     * @memberof OrderTaxes
     */
    tax_county?: string;
    /**
     * QuickBooks tax county code
     * @type {string}
     * @memberof OrderTaxes
     */
    tax_county_accounting_code?: string;
    /**
     * True if gift charge is taxed
     * @type {boolean}
     * @memberof OrderTaxes
     */
    tax_gift_charge?: boolean;
    /**
     * QuickBooks tax postal code code
     * @type {string}
     * @memberof OrderTaxes
     */
    tax_postal_code_accounting_code?: string;
    /**
     * Tax rate, this is meaningless for updating an order.  For inserting a new order, if you need to override internal tax calculations, use the arbitrary fields.
     * @type {number}
     * @memberof OrderTaxes
     */
    tax_rate?: number;
    /**
     * Tax rate at the city level
     * @type {number}
     * @memberof OrderTaxes
     */
    tax_rate_city?: number;
    /**
     * Tax rate at the country level
     * @type {number}
     * @memberof OrderTaxes
     */
    tax_rate_country?: number;
    /**
     * Tax rate at the county level
     * @type {number}
     * @memberof OrderTaxes
     */
    tax_rate_county?: number;
    /**
     * Tax rate at the postal code level
     * @type {number}
     * @memberof OrderTaxes
     */
    tax_rate_postal_code?: number;
    /**
     * Tax rate at the state level
     * @type {number}
     * @memberof OrderTaxes
     */
    tax_rate_state?: number;
    /**
     * True if shipping is taxed
     * @type {boolean}
     * @memberof OrderTaxes
     */
    tax_shipping?: boolean;
    /**
     * QuickBooks tax state code
     * @type {string}
     * @memberof OrderTaxes
     */
    tax_state_accounting_code?: string;
}

/**
 * 
 * @export
 * @interface OrderTokenResponse
 */
export interface OrderTokenResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof OrderTokenResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrderTokenResponse
     */
    metadata?: ResponseMetadata;
    /**
     * An order token that securely represents an order id
     * @type {string}
     * @memberof OrderTokenResponse
     */
    order_token?: string;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrderTokenResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrderTokenResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface OrderTrackingNumberDetail
 */
export interface OrderTrackingNumberDetail {
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    city?: string;
    /**
     * ISO 8601 timestamp that the event occurred
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    event_dts?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    event_local_date?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    event_local_time?: string;
    /**
     * Timezone the event occurred in.  Use this in conjunction with event_dts to format a local date/time.
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    event_timezone_id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    subtag?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    subtag_message?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    tag_description?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    tag_icon?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetail
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface OrderTrackingNumberDetails
 */
export interface OrderTrackingNumberDetails {
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    actual_delivery_date?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    actual_delivery_date_formatted?: string;
    /**
     * 
     * @type {Array<OrderTrackingNumberDetail>}
     * @memberof OrderTrackingNumberDetails
     */
    details?: Array<OrderTrackingNumberDetail>;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    easypost_tracker_id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    expected_delivery_date?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    expected_delivery_date_formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    map_url?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    order_placed_date?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    order_placed_date_formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    payment_processed_date?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    payment_processed_date_formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    shipped_date?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    shipped_date_formatted?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    shipping_method?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    status_description?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    tracking_number?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderTrackingNumberDetails
     */
    tracking_url?: string;
}

/**
 * 
 * @export
 * @interface OrdersResponse
 */
export interface OrdersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof OrdersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof OrdersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * orders
     * @type {Array<Order>}
     * @memberof OrdersResponse
     */
    orders?: Array<Order>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof OrdersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof OrdersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface PaymentsConfiguration
 */
export interface PaymentsConfiguration {
    /**
     * 
     * @type {PaymentsConfigurationAffirm}
     * @memberof PaymentsConfiguration
     */
    affirm?: PaymentsConfigurationAffirm;
    /**
     * 
     * @type {PaymentsConfigurationAmazon}
     * @memberof PaymentsConfiguration
     */
    amazon?: PaymentsConfigurationAmazon;
    /**
     * 
     * @type {PaymentsConfigurationCash}
     * @memberof PaymentsConfiguration
     */
    cash?: PaymentsConfigurationCash;
    /**
     * 
     * @type {PaymentsConfigurationCheck}
     * @memberof PaymentsConfiguration
     */
    check?: PaymentsConfigurationCheck;
    /**
     * 
     * @type {PaymentsConfigurationCOD}
     * @memberof PaymentsConfiguration
     */
    cod?: PaymentsConfigurationCOD;
    /**
     * 
     * @type {PaymentsConfigurationCreditCard}
     * @memberof PaymentsConfiguration
     */
    credit_card?: PaymentsConfigurationCreditCard;
    /**
     * 
     * @type {PaymentsConfigurationEcheck}
     * @memberof PaymentsConfiguration
     */
    echeck?: PaymentsConfigurationEcheck;
    /**
     * 
     * @type {PaymentsConfigurationInsurance}
     * @memberof PaymentsConfiguration
     */
    insurance?: PaymentsConfigurationInsurance;
    /**
     * 
     * @type {PaymentsConfigurationLoanHero}
     * @memberof PaymentsConfiguration
     */
    loan_hero?: PaymentsConfigurationLoanHero;
    /**
     * 
     * @type {PaymentsConfigurationMoneyOrder}
     * @memberof PaymentsConfiguration
     */
    money_order?: PaymentsConfigurationMoneyOrder;
    /**
     * 
     * @type {PaymentsConfigurationPayPal}
     * @memberof PaymentsConfiguration
     */
    paypal?: PaymentsConfigurationPayPal;
    /**
     * 
     * @type {PaymentsConfigurationPurchaseOrder}
     * @memberof PaymentsConfiguration
     */
    purchase_order?: PaymentsConfigurationPurchaseOrder;
    /**
     * 
     * @type {PaymentsConfigurationQuoteRequest}
     * @memberof PaymentsConfiguration
     */
    quote_request?: PaymentsConfigurationQuoteRequest;
    /**
     * 
     * @type {PaymentsConfigurationSezzle}
     * @memberof PaymentsConfiguration
     */
    sezzle?: PaymentsConfigurationSezzle;
    /**
     * Internal flag used to determine if accounting codes should be shown on the screen or not.  This flag is true if the merchant has a Quickbooks integration configured.
     * @type {boolean}
     * @memberof PaymentsConfiguration
     */
    show_accounting_code?: boolean;
    /**
     * 
     * @type {PaymentsConfigurationWePay}
     * @memberof PaymentsConfiguration
     */
    ultracart_payments_wepay?: PaymentsConfigurationWePay;
    /**
     * 
     * @type {PaymentsConfigurationWireTransfer}
     * @memberof PaymentsConfiguration
     */
    wire_transfer?: PaymentsConfigurationWireTransfer;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationAffirm
 */
export interface PaymentsConfigurationAffirm {
    /**
     * Master flag indicating this merchant accepts Affirm payments
     * @type {boolean}
     * @memberof PaymentsConfigurationAffirm
     */
    accept_affirm?: boolean;
    /**
     * Optional Quickbooks code for this payment method
     * @type {string}
     * @memberof PaymentsConfigurationAffirm
     */
    accounting_code?: string;
    /**
     * Optional Quickbooks Deposit to Account value
     * @type {string}
     * @memberof PaymentsConfigurationAffirm
     */
    deposit_to_account?: string;
    /**
     * Environment
     * @type {string}
     * @memberof PaymentsConfigurationAffirm
     */
    environment?: PaymentsConfigurationAffirm.EnvironmentEnum;
    /**
     * Financial product key
     * @type {string}
     * @memberof PaymentsConfigurationAffirm
     */
    financial_product_key?: string;
    /**
     * Private API key
     * @type {string}
     * @memberof PaymentsConfigurationAffirm
     */
    private_api_key?: string;
    /**
     * Public API key
     * @type {string}
     * @memberof PaymentsConfigurationAffirm
     */
    public_api_key?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationAffirm
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * @export
 * @namespace PaymentsConfigurationAffirm
 */
export namespace PaymentsConfigurationAffirm {
    /**
     * @export
     * @enum {string}
     */
    export enum EnvironmentEnum {
        Live = <any> 'Live',
        Sandbox = <any> 'Sandbox'
    }
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationAmazon
 */
export interface PaymentsConfigurationAmazon {
    /**
     * Master flag to determine if this merchant accepts Pay by Amazon
     * @type {boolean}
     * @memberof PaymentsConfigurationAmazon
     */
    accept_amazon?: boolean;
    /**
     * Amazon access key ID
     * @type {string}
     * @memberof PaymentsConfigurationAmazon
     */
    access_key_id?: string;
    /**
     * Optional accounting code for use with Quickbooks integrations
     * @type {string}
     * @memberof PaymentsConfigurationAmazon
     */
    accounting_code?: string;
    /**
     * Amazon merchant ID
     * @type {string}
     * @memberof PaymentsConfigurationAmazon
     */
    amazon_merchant_id?: string;
    /**
     * Optional deposit to account field for use with Quickbooks integrations
     * @type {string}
     * @memberof PaymentsConfigurationAmazon
     */
    deposit_to_account?: string;
    /**
     * Environment
     * @type {string}
     * @memberof PaymentsConfigurationAmazon
     */
    environment?: PaymentsConfigurationAmazon.EnvironmentEnum;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationAmazon
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * Amazon secret access key
     * @type {string}
     * @memberof PaymentsConfigurationAmazon
     */
    secret_access_key?: string;
}

/**
 * @export
 * @namespace PaymentsConfigurationAmazon
 */
export namespace PaymentsConfigurationAmazon {
    /**
     * @export
     * @enum {string}
     */
    export enum EnvironmentEnum {
        Live = <any> 'Live',
        Sandbox = <any> 'Sandbox'
    }
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationCOD
 */
export interface PaymentsConfigurationCOD {
    /**
     * Master flag indicating this merchant accepts COD
     * @type {boolean}
     * @memberof PaymentsConfigurationCOD
     */
    accept_cod?: boolean;
    /**
     * If true, only approved customers may pay with COD
     * @type {boolean}
     * @memberof PaymentsConfigurationCOD
     */
    approved_customers_only?: boolean;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationCOD
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * Optional field, if surcharge is set, this is the accounting code the surcharge is tagged with when sent to Quickbooks
     * @type {string}
     * @memberof PaymentsConfigurationCOD
     */
    surcharge_accounting_code?: string;
    /**
     * Additional cost for using COD
     * @type {number}
     * @memberof PaymentsConfigurationCOD
     */
    surcharge_fee?: number;
    /**
     * Additional percentage cost for using COD
     * @type {number}
     * @memberof PaymentsConfigurationCOD
     */
    surcharge_percentage?: number;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationCash
 */
export interface PaymentsConfigurationCash {
    /**
     * Master flag indicating this merchant accepts cash
     * @type {boolean}
     * @memberof PaymentsConfigurationCash
     */
    accept_cash?: boolean;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationCash
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationCheck
 */
export interface PaymentsConfigurationCheck {
    /**
     * Master flag indicating this merchant accepts paper checks
     * @type {boolean}
     * @memberof PaymentsConfigurationCheck
     */
    accept_check_orders?: boolean;
    /**
     * Optional Quickbooks accounting code
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    accounting_code?: string;
    /**
     * This is who the customer makes the check out to
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    checks_payable_to?: string;
    /**
     * Optional Quickbooks deposit to account
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    deposit_to_account?: string;
    /**
     * MailTo address line 1
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    mail_to_address1?: string;
    /**
     * MailTo address line 2
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    mail_to_address2?: string;
    /**
     * MailTo city
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    mail_to_city?: string;
    /**
     * MailTo country
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    mail_to_country?: string;
    /**
     * MailTo name
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    mail_to_name?: string;
    /**
     * MailTo postal code
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    mail_to_postal_code?: string;
    /**
     * MailTo store
     * @type {string}
     * @memberof PaymentsConfigurationCheck
     */
    mail_to_store?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationCheck
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationCreditCard
 */
export interface PaymentsConfigurationCreditCard {
    /**
     * Master flag indicating whether this merchant accepts credit card payments
     * @type {boolean}
     * @memberof PaymentsConfigurationCreditCard
     */
    accept_credit_card?: boolean;
    /**
     * Description that appears on customer statements
     * @type {string}
     * @memberof PaymentsConfigurationCreditCard
     */
    billed_by?: string;
    /**
     * If false, order will be accepted and placed into Accounts Receivable without charging card first
     * @type {boolean}
     * @memberof PaymentsConfigurationCreditCard
     */
    charge_during_checkout?: boolean;
    /**
     * UltraCart will require customer to enter cvv if this is true
     * @type {boolean}
     * @memberof PaymentsConfigurationCreditCard
     */
    collect_cvv2?: boolean;
    /**
     * Human readable description of the credit card gateway currently configured
     * @type {string}
     * @memberof PaymentsConfigurationCreditCard
     */
    configured_gateway_details?: string;
    /**
     * The number of failed attempts before the order is placed into Accounts Receivable for manual intervention
     * @type {number}
     * @memberof PaymentsConfigurationCreditCard
     */
    failed_attempts?: number;
    /**
     * This internal flag aids the UI in determining which buttons to show.
     * @type {boolean}
     * @memberof PaymentsConfigurationCreditCard
     */
    hide_connect_single_gateway?: boolean;
    /**
     * UltraCart will send customers emails to update their credit card if the card is declined
     * @type {boolean}
     * @memberof PaymentsConfigurationCreditCard
     */
    send_customer_billing_update_on_decline?: boolean;
    /**
     * A list of credit cards the merchant wishes to accept.
     * @type {Array<PaymentsConfigurationCreditCardType>}
     * @memberof PaymentsConfigurationCreditCard
     */
    supported_cards?: Array<PaymentsConfigurationCreditCardType>;
    /**
     * An array of test methods for placing test orders.  The cards defined here may be real or fake, but any order placed with them will be marked as Test orders
     * @type {Array<PaymentsConfigurationTestMethod>}
     * @memberof PaymentsConfigurationCreditCard
     */
    test_methods?: Array<PaymentsConfigurationTestMethod>;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationCreditCardType
 */
export interface PaymentsConfigurationCreditCardType {
    /**
     * Optional field used for Quickbooks integrations to match this credit card with the corresponding payment type in Quickbooks
     * @type {string}
     * @memberof PaymentsConfigurationCreditCardType
     */
    accounting_code?: string;
    /**
     * Internally used icon information for this card type
     * @type {string}
     * @memberof PaymentsConfigurationCreditCardType
     */
    card_type_icon?: string;
    /**
     * Credit card type
     * @type {string}
     * @memberof PaymentsConfigurationCreditCardType
     */
    credit_card?: PaymentsConfigurationCreditCardType.CreditCardEnum;
    /**
     * The name of the account to deposit funds
     * @type {string}
     * @memberof PaymentsConfigurationCreditCardType
     */
    deposit_to_account?: string;
    /**
     * If true, this card type will be accepted during checkout
     * @type {boolean}
     * @memberof PaymentsConfigurationCreditCardType
     */
    enabled?: boolean;
    /**
     * Optional additional fee applied to order for this card
     * @type {number}
     * @memberof PaymentsConfigurationCreditCardType
     */
    processing_fee?: number;
    /**
     * Optional additional fee applied to order for this card
     * @type {number}
     * @memberof PaymentsConfigurationCreditCardType
     */
    processing_percentage?: number;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationCreditCardType
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * Optional field. If integrated with Quickbooks, this code will be used when informing Quickbooks about any surcharges applied to orders
     * @type {string}
     * @memberof PaymentsConfigurationCreditCardType
     */
    surcharge_accounting_code?: string;
    /**
     * An optional additional fee to charge the customer for using this card.
     * @type {number}
     * @memberof PaymentsConfigurationCreditCardType
     */
    transaction_fee?: number;
    /**
     * An optional transaction percentage to charge the customer for using this card
     * @type {number}
     * @memberof PaymentsConfigurationCreditCardType
     */
    transaction_percentage?: number;
}

/**
 * @export
 * @namespace PaymentsConfigurationCreditCardType
 */
export namespace PaymentsConfigurationCreditCardType {
    /**
     * @export
     * @enum {string}
     */
    export enum CreditCardEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        MasterCard = <any> 'MasterCard',
        JCB = <any> 'JCB',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationEcheck
 */
export interface PaymentsConfigurationEcheck {
    /**
     * Master flag indicating this merchant accepts eChecks
     * @type {boolean}
     * @memberof PaymentsConfigurationEcheck
     */
    accept_echeck?: boolean;
    /**
     * Optional Quickbooks accounting code
     * @type {string}
     * @memberof PaymentsConfigurationEcheck
     */
    accounting_code?: string;
    /**
     * Optional Quickbooks deposit to account
     * @type {string}
     * @memberof PaymentsConfigurationEcheck
     */
    deposit_to_account?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationEcheck
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * Test methods for this payment method
     * @type {Array<PaymentsConfigurationTestMethod>}
     * @memberof PaymentsConfigurationEcheck
     */
    test_methods?: Array<PaymentsConfigurationTestMethod>;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationInsurance
 */
export interface PaymentsConfigurationInsurance {
    /**
     * Master flag indicating this merchant accepts insurance
     * @type {boolean}
     * @memberof PaymentsConfigurationInsurance
     */
    accept_insurance?: boolean;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationInsurance
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationLoanHero
 */
export interface PaymentsConfigurationLoanHero {
    /**
     * Master flag indicating this merchant accepts Loan Hero
     * @type {boolean}
     * @memberof PaymentsConfigurationLoanHero
     */
    accept_loan_hero?: boolean;
    /**
     * Optional Quickbooks accounting code
     * @type {string}
     * @memberof PaymentsConfigurationLoanHero
     */
    accounting_code?: string;
    /**
     * Optional Quickbooks deposit to account
     * @type {string}
     * @memberof PaymentsConfigurationLoanHero
     */
    deposit_to_account?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationLoanHero
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * Internal field to aid UI
     * @type {boolean}
     * @memberof PaymentsConfigurationLoanHero
     */
    show_loan_hero?: boolean;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationMoneyOrder
 */
export interface PaymentsConfigurationMoneyOrder {
    /**
     * Master flag for this merchant accepting money orders
     * @type {boolean}
     * @memberof PaymentsConfigurationMoneyOrder
     */
    accept_money_orders?: boolean;
    /**
     * Optional Quickbooks accounting code
     * @type {string}
     * @memberof PaymentsConfigurationMoneyOrder
     */
    accounting_code?: string;
    /**
     * Optional Quickbooks deposit to account
     * @type {string}
     * @memberof PaymentsConfigurationMoneyOrder
     */
    deposit_to_account?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationMoneyOrder
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationPayPal
 */
export interface PaymentsConfigurationPayPal {
    /**
     * Master flag that determine if PayPal is an active payment for this account
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    accept_paypal?: boolean;
    /**
     * Optional accounting code that is set to Quickbooks when an order uses this payment method.
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    accounting_code?: string;
    /**
     * PayPal API password
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    api_password?: string;
    /**
     * PayPal API username
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    api_username?: string;
    /**
     * (Legacy) true if there is a PayPal certificate already on file. Used to manage the internal UI
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    certificate_on_file?: boolean;
    /**
     * The account to deposit funds
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    deposit_to_account?: string;
    /**
     * The main PayPal email address
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    email?: string;
    /**
     * PayPal configuration, live or sandbox
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    environment?: PaymentsConfigurationPayPal.EnvironmentEnum;
    /**
     * The URL for the PayPal header
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    header_image_url?: string;
    /**
     * True if the Bill Me Later button should be hidden during checkout
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    hide_bill_me_later?: boolean;
    /**
     * True if the PayPal express checkout button should be hidden on the view cart page.  This will force the customer to enter address information before being able to checkout with PayPal
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    hide_express_checkout_on_view_cart?: boolean;
    /**
     * True if PayPal should be hidden for orders with no shippable product, such as digital orders
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    hide_for_unshipped_orders?: boolean;
    /**
     * If true, PayPal orders are held in Accounts Receivable for review
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    hold_in_ar?: boolean;
    /**
     * PayPal landing page
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    landing_page?: PaymentsConfigurationPayPal.LandingPageEnum;
    /**
     * The PayPal mode
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    mode?: PaymentsConfigurationPayPal.ModeEnum;
    /**
     * PayPal API private key password
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    private_key_password?: string;
    /**
     * Optional additional fee to charge if PayPal is used.  It is rare for this to be used.
     * @type {number}
     * @memberof PaymentsConfigurationPayPal
     */
    processing_fee?: number;
    /**
     * The processing percentage charged by PayPal
     * @type {number}
     * @memberof PaymentsConfigurationPayPal
     */
    processing_percentage?: number;
    /**
     * True if the internal UI should recommend opening a PayPal account
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    push_paypal?: boolean;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationPayPal
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * True if UltraCart should send recurring orders to PayPal.  There are restrictions to what PayPal will accept for recurring orders.  Be careful.
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    send_recurring?: boolean;
    /**
     * Short marketing text
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    short_paypal_marketing_text?: boolean;
    /**
     * internal ui flag
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    show_card_logos_not_directly_supported?: boolean;
    /**
     * Internal flag used to manage UI
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    show_signature?: boolean;
    /**
     * PayPal signature
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    signature?: string;
    /**
     * PayPal solution type
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    solution_type?: PaymentsConfigurationPayPal.SolutionTypeEnum;
    /**
     * The email where PayPal summaries should be sent
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    summary_email?: string;
    /**
     * Description of what mode PayPal is operating
     * @type {string}
     * @memberof PaymentsConfigurationPayPal
     */
    summary_mode?: string;
    /**
     * Send free items to PayPal as one cent items and subtract this penny from shipping.  PayPal does not allow the sale of free items.
     * @type {boolean}
     * @memberof PaymentsConfigurationPayPal
     */
    zero_dollar_penny?: boolean;
}

/**
 * @export
 * @namespace PaymentsConfigurationPayPal
 */
export namespace PaymentsConfigurationPayPal {
    /**
     * @export
     * @enum {string}
     */
    export enum EnvironmentEnum {
        Live = <any> 'Live',
        Sandbox = <any> 'Sandbox'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LandingPageEnum {
        Billing = <any> 'Billing',
        Login = <any> 'Login'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ModeEnum {
        WPPECO = <any> 'WPPECO',
        WPPECDP = <any> 'WPPECDP'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SolutionTypeEnum {
        Sole = <any> 'Sole',
        Mark = <any> 'Mark'
    }
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationPurchaseOrder
 */
export interface PaymentsConfigurationPurchaseOrder {
    /**
     * Master flag indicating this merchant accepts purchase orders
     * @type {boolean}
     * @memberof PaymentsConfigurationPurchaseOrder
     */
    accept_purchase_orders?: boolean;
    /**
     * If true, only approved customers may pay with a purchase order
     * @type {boolean}
     * @memberof PaymentsConfigurationPurchaseOrder
     */
    approved_customers_only?: boolean;
    /**
     * If true, customers may not use duplicate PO numbers for any order
     * @type {boolean}
     * @memberof PaymentsConfigurationPurchaseOrder
     */
    prevent_duplicate_number?: boolean;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationPurchaseOrder
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationQuoteRequest
 */
export interface PaymentsConfigurationQuoteRequest {
    /**
     * Master flag indicating this merchant accepts quote requests
     * @type {boolean}
     * @memberof PaymentsConfigurationQuoteRequest
     */
    accept_quote_requests?: boolean;
    /**
     * If true, only approved customers may use quote requests
     * @type {boolean}
     * @memberof PaymentsConfigurationQuoteRequest
     */
    approved_customers_only?: boolean;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationQuoteRequest
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationResponse
 */
export interface PaymentsConfigurationResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof PaymentsConfigurationResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof PaymentsConfigurationResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {PaymentsConfiguration}
     * @memberof PaymentsConfigurationResponse
     */
    payments_configuration?: PaymentsConfiguration;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof PaymentsConfigurationResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof PaymentsConfigurationResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationRestrictions
 */
export interface PaymentsConfigurationRestrictions {
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentsConfigurationRestrictions
     */
    descriptions?: Array<string>;
    /**
     * Maximum subtotal
     * @type {number}
     * @memberof PaymentsConfigurationRestrictions
     */
    maximum_subtotal?: number;
    /**
     * Minimum subtotal
     * @type {number}
     * @memberof PaymentsConfigurationRestrictions
     */
    minimum_subtotal?: number;
    /**
     * Payment method
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    payment_method?: string;
    /**
     * Alaska and Hawaii restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_alaska_hawaii?: PaymentsConfigurationRestrictions.RestrictionAlaskaHawaiiEnum;
    /**
     * APO/FPO restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_apo_fpo?: PaymentsConfigurationRestrictions.RestrictionApoFpoEnum;
    /**
     * Canada restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_canada?: PaymentsConfigurationRestrictions.RestrictionCanadaEnum;
    /**
     * Continental US restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_continental_us?: PaymentsConfigurationRestrictions.RestrictionContinentalUsEnum;
    /**
     * Domestic only restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_domestic_only?: PaymentsConfigurationRestrictions.RestrictionDomesticOnlyEnum;
    /**
     * International only restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_international_only?: PaymentsConfigurationRestrictions.RestrictionInternationalOnlyEnum;
    /**
     * PO Box restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_po_box?: PaymentsConfigurationRestrictions.RestrictionPoBoxEnum;
    /**
     * Puerto Rico restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_puerto_rico?: PaymentsConfigurationRestrictions.RestrictionPuertoRicoEnum;
    /**
     * US Territories restriction
     * @type {string}
     * @memberof PaymentsConfigurationRestrictions
     */
    restriction_us_territories?: PaymentsConfigurationRestrictions.RestrictionUsTerritoriesEnum;
    /**
     * 
     * @type {Array<PaymentsConfigurationRestrictionsTheme>}
     * @memberof PaymentsConfigurationRestrictions
     */
    themes?: Array<PaymentsConfigurationRestrictionsTheme>;
}

/**
 * @export
 * @namespace PaymentsConfigurationRestrictions
 */
export namespace PaymentsConfigurationRestrictions {
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionAlaskaHawaiiEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionApoFpoEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionCanadaEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionContinentalUsEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionDomesticOnlyEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionInternationalOnlyEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionPoBoxEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionPuertoRicoEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionUsTerritoriesEnum {
        Invalid = <any> 'invalid',
        InvalidOnly = <any> 'invalidOnly',
        Valid = <any> 'valid'
    }
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationRestrictionsTheme
 */
export interface PaymentsConfigurationRestrictionsTheme {
    /**
     * 
     * @type {string}
     * @memberof PaymentsConfigurationRestrictionsTheme
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsConfigurationRestrictionsTheme
     */
    restriction?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsConfigurationRestrictionsTheme
     */
    storeFrontHostName?: string;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationSezzle
 */
export interface PaymentsConfigurationSezzle {
    /**
     * Master flag for this merchant accepting Sezzle payments
     * @type {boolean}
     * @memberof PaymentsConfigurationSezzle
     */
    accept_sezzle?: boolean;
    /**
     * Optional Quickbooks code for this payment method
     * @type {string}
     * @memberof PaymentsConfigurationSezzle
     */
    accounting_code?: string;
    /**
     * Business ID
     * @type {string}
     * @memberof PaymentsConfigurationSezzle
     */
    business_id?: string;
    /**
     * Optional Quickbooks Deposit to Account value
     * @type {string}
     * @memberof PaymentsConfigurationSezzle
     */
    deposit_to_account?: string;
    /**
     * Sezzle environment
     * @type {string}
     * @memberof PaymentsConfigurationSezzle
     */
    environment?: PaymentsConfigurationSezzle.EnvironmentEnum;
    /**
     * Private API key
     * @type {string}
     * @memberof PaymentsConfigurationSezzle
     */
    private_api_key?: string;
    /**
     * Public API key
     * @type {string}
     * @memberof PaymentsConfigurationSezzle
     */
    public_api_key?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationSezzle
     */
    restrictions?: PaymentsConfigurationRestrictions;
}

/**
 * @export
 * @namespace PaymentsConfigurationSezzle
 */
export namespace PaymentsConfigurationSezzle {
    /**
     * @export
     * @enum {string}
     */
    export enum EnvironmentEnum {
        Live = <any> 'Live',
        Sandbox = <any> 'Sandbox'
    }
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationTestMethod
 */
export interface PaymentsConfigurationTestMethod {
    /**
     * Bank account number
     * @type {string}
     * @memberof PaymentsConfigurationTestMethod
     */
    bank_account_number?: string;
    /**
     * Bank routing number
     * @type {string}
     * @memberof PaymentsConfigurationTestMethod
     */
    bank_routing_number?: string;
    /**
     * Credit card number
     * @type {string}
     * @memberof PaymentsConfigurationTestMethod
     */
    credit_card_number?: string;
    /**
     * The existing credit card number
     * @type {string}
     * @memberof PaymentsConfigurationTestMethod
     */
    credit_card_number_existing?: string;
    /**
     * Description
     * @type {string}
     * @memberof PaymentsConfigurationTestMethod
     */
    description?: string;
    /**
     * Payment action
     * @type {string}
     * @memberof PaymentsConfigurationTestMethod
     */
    payment_action?: PaymentsConfigurationTestMethod.PaymentActionEnum;
    /**
     * Payment method
     * @type {string}
     * @memberof PaymentsConfigurationTestMethod
     */
    payment_method?: string;
    /**
     * Payment method test oid
     * @type {number}
     * @memberof PaymentsConfigurationTestMethod
     */
    payment_method_test_oid?: number;
    /**
     * Skip affiliate transaction
     * @type {boolean}
     * @memberof PaymentsConfigurationTestMethod
     */
    skip_affiliate_transaction?: boolean;
    /**
     * If true, skips recording any conversion pixels to avoid sending test orders to your analysis sites
     * @type {boolean}
     * @memberof PaymentsConfigurationTestMethod
     */
    skip_conversion_pixels?: boolean;
    /**
     * Skip fraud filter
     * @type {boolean}
     * @memberof PaymentsConfigurationTestMethod
     */
    skip_fraud_filter?: boolean;
}

/**
 * @export
 * @namespace PaymentsConfigurationTestMethod
 */
export namespace PaymentsConfigurationTestMethod {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentActionEnum {
        SkipPayment = <any> 'skip payment',
        SkipPmtRej = <any> 'skip pmt rej',
        SkipPmtCo = <any> 'skip pmt co',
        HoldInAr = <any> 'hold in ar'
    }
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationWePay
 */
export interface PaymentsConfigurationWePay {
    /**
     * Master flag indicating this merchant accepts UltraCart Payments WePay
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    accept_wepay?: boolean;
    /**
     * URI for updating the WePay account
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    account_update_uri?: string;
    /**
     * Address line 1
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    address1?: string;
    /**
     * Address line 2
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    address2?: string;
    /**
     * For Canadian merchants, true if they wish to accept debit cards
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    canada_accept_debit_cards?: boolean;
    /**
     * City
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    city?: string;
    /**
     * Company
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    company?: string;
    /**
     * Company description
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    company_description?: string;
    /**
     * Console hostname
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    console_hostname?: string;
    /**
     * Country
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    country?: string;
    /**
     * WePay credit card rate
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    credit_card_rate?: string;
    /**
     * Base currency for transactions
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    currency?: string;
    /**
     * Expected Revenue
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    expected_revenue?: string;
    /**
     * Internal flag to aid UI
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    hide_credit_card_non_ultracart_payments?: boolean;
    /**
     * Internal flag to aid UI
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    hide_surcharge_amount?: boolean;
    /**
     * Industry
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    industry?: string;
    /**
     * Owner email
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    owner_email?: string;
    /**
     * Owner name
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    owner_name?: string;
    /**
     * Owner phone
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    owner_phone?: string;
    /**
     * Postal code
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    postal_code?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationWePay
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * Internal UI aid
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    short_paypal_marketing_text?: boolean;
    /**
     * Internal flag to aid UI
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    show_ultracart_payments_disabled?: boolean;
    /**
     * Internal flag to aid UI
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    show_ultracart_payments_intro?: boolean;
    /**
     * Internal flag to aid UI
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    show_ultracart_payments_verification?: boolean;
    /**
     * Internal flag to aid UI
     * @type {boolean}
     * @memberof PaymentsConfigurationWePay
     */
    show_ultracart_payments_verified?: boolean;
    /**
     * State
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    state?: string;
    /**
     * Website URL
     * @type {string}
     * @memberof PaymentsConfigurationWePay
     */
    website_url?: string;
}

/**
 * 
 * @export
 * @interface PaymentsConfigurationWireTransfer
 */
export interface PaymentsConfigurationWireTransfer {
    /**
     * Master flag indicating this merchant accepts wire transfers
     * @type {boolean}
     * @memberof PaymentsConfigurationWireTransfer
     */
    accept_wire_transfer?: boolean;
    /**
     * account_number
     * @type {string}
     * @memberof PaymentsConfigurationWireTransfer
     */
    account_number?: string;
    /**
     * Optional Quickbooks accounting code
     * @type {string}
     * @memberof PaymentsConfigurationWireTransfer
     */
    accounting_code?: string;
    /**
     * Bank address
     * @type {string}
     * @memberof PaymentsConfigurationWireTransfer
     */
    bank_address?: string;
    /**
     * Optional Quickbooks deposit to account
     * @type {string}
     * @memberof PaymentsConfigurationWireTransfer
     */
    deposit_to_account?: string;
    /**
     * Intermediate routing number
     * @type {string}
     * @memberof PaymentsConfigurationWireTransfer
     */
    intermediate_routing_number?: string;
    /**
     * 
     * @type {PaymentsConfigurationRestrictions}
     * @memberof PaymentsConfigurationWireTransfer
     */
    restrictions?: PaymentsConfigurationRestrictions;
    /**
     * Routing number
     * @type {string}
     * @memberof PaymentsConfigurationWireTransfer
     */
    routing_number?: string;
    /**
     * If a surcharge is present and this merchant is integrated with Quickbooks, this is the accounting code for the surcharge amount
     * @type {string}
     * @memberof PaymentsConfigurationWireTransfer
     */
    surcharge_accounting_code?: string;
    /**
     * surcharge_fee
     * @type {number}
     * @memberof PaymentsConfigurationWireTransfer
     */
    surcharge_fee?: number;
    /**
     * surcharge_percentage
     * @type {number}
     * @memberof PaymentsConfigurationWireTransfer
     */
    surcharge_percentage?: number;
}

/**
 * 
 * @export
 * @interface PaymentsThemeTransactionType
 */
export interface PaymentsThemeTransactionType {
    /**
     * External human readable identifier for a theme
     * @type {string}
     * @memberof PaymentsThemeTransactionType
     */
    code?: string;
    /**
     * The credit card transaction type for this theme
     * @type {string}
     * @memberof PaymentsThemeTransactionType
     */
    credit_card_transaction_type?: PaymentsThemeTransactionType.CreditCardTransactionTypeEnum;
    /**
     * Internal identifier for a theme
     * @type {number}
     * @memberof PaymentsThemeTransactionType
     */
    screen_branding_theme_oid?: number;
}

/**
 * @export
 * @namespace PaymentsThemeTransactionType
 */
export namespace PaymentsThemeTransactionType {
    /**
     * @export
     * @enum {string}
     */
    export enum CreditCardTransactionTypeEnum {
        AndCapture = <any> 'auth and capture',
        ThenCapture = <any> 'auth then capture',
        Only = <any> 'auth only'
    }
}

/**
 * 
 * @export
 * @interface PaymentsWepayEnroll
 */
export interface PaymentsWepayEnroll {
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    address2?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentsWepayEnroll
     */
    canada_accept_debit_cards?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    company_description?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    expected_revenue?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    industry?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    owner_email?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    owner_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    owner_phone?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    webiste_url?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsWepayEnroll
     */
    zip?: string;
}

/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * A group for this permission.  This name is only used for visual grouping within interfaces.
     * @type {string}
     * @memberof Permission
     */
    permission_group?: string;
    /**
     * The name of this permission.
     * @type {string}
     * @memberof Permission
     */
    permission_Name?: string;
    /**
     * True if this user has this permission.
     * @type {boolean}
     * @memberof Permission
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface PricingTier
 */
export interface PricingTier {
    /**
     * Allow 3rd party billing
     * @type {boolean}
     * @memberof PricingTier
     */
    allow_3rd_party_billing?: boolean;
    /**
     * Allow COD
     * @type {boolean}
     * @memberof PricingTier
     */
    allow_cod?: boolean;
    /**
     * Allow purchase order
     * @type {boolean}
     * @memberof PricingTier
     */
    allow_purchase_order?: boolean;
    /**
     * Allow quote request
     * @type {boolean}
     * @memberof PricingTier
     */
    allow_quote_request?: boolean;
    /**
     * 
     * @type {PricingTierNotification}
     * @memberof PricingTier
     */
    approval_notification?: PricingTierNotification;
    /**
     * Auto approve COD
     * @type {boolean}
     * @memberof PricingTier
     */
    auto_approve_cod?: boolean;
    /**
     * Auto approve purchase order
     * @type {boolean}
     * @memberof PricingTier
     */
    auto_approve_purchase_order?: boolean;
    /**
     * Default on wholesale signup
     * @type {boolean}
     * @memberof PricingTier
     */
    default_on_wholesale_signup?: boolean;
    /**
     * Default percentage discount
     * @type {number}
     * @memberof PricingTier
     */
    default_percentage_discount?: number;
    /**
     * Default shipping method oid
     * @type {number}
     * @memberof PricingTier
     */
    default_shipping_method_oid?: number;
    /**
     * Default tier
     * @type {boolean}
     * @memberof PricingTier
     */
    default_tier?: boolean;
    /**
     * Display on wholesale signup
     * @type {boolean}
     * @memberof PricingTier
     */
    display_on_wholesale_signup?: boolean;
    /**
     * Exclude from free promotion
     * @type {boolean}
     * @memberof PricingTier
     */
    exclude_from_free_promotion?: boolean;
    /**
     * Exempt shipping handling charge
     * @type {boolean}
     * @memberof PricingTier
     */
    exempt_shipping_handling_charge?: boolean;
    /**
     * Free shipping
     * @type {boolean}
     * @memberof PricingTier
     */
    free_shipping?: boolean;
    /**
     * Free shipping minimum
     * @type {number}
     * @memberof PricingTier
     */
    free_shipping_minimum?: number;
    /**
     * Maximum item count
     * @type {number}
     * @memberof PricingTier
     */
    maximum_item_count?: number;
    /**
     * Minimum item count
     * @type {number}
     * @memberof PricingTier
     */
    minimum_item_count?: number;
    /**
     * Minimum subtotal
     * @type {number}
     * @memberof PricingTier
     */
    minimum_subtotal?: number;
    /**
     * Name
     * @type {string}
     * @memberof PricingTier
     */
    name?: string;
    /**
     * No coupons
     * @type {boolean}
     * @memberof PricingTier
     */
    no_coupons?: boolean;
    /**
     * No free shipping
     * @type {boolean}
     * @memberof PricingTier
     */
    no_free_shipping?: boolean;
    /**
     * No realtime charge
     * @type {boolean}
     * @memberof PricingTier
     */
    no_realtime_charge?: boolean;
    /**
     * Not valid when coupon present
     * @type {boolean}
     * @memberof PricingTier
     */
    not_valid_when_coupon_present?: boolean;
    /**
     * Pricing Tier Oid
     * @type {number}
     * @memberof PricingTier
     */
    pricing_tier_oid?: number;
    /**
     * Realtime percentage discount
     * @type {number}
     * @memberof PricingTier
     */
    realtime_percentage_discount?: number;
    /**
     * 
     * @type {PricingTierNotification}
     * @memberof PricingTier
     */
    signup_notification?: PricingTierNotification;
    /**
     * Suppress buySAFE (deprecated)
     * @type {boolean}
     * @memberof PricingTier
     */
    suppress_buysafe?: boolean;
    /**
     * Suppress mailing list
     * @type {boolean}
     * @memberof PricingTier
     */
    suppress_mailing_list?: boolean;
    /**
     * Tax Exempt
     * @type {boolean}
     * @memberof PricingTier
     */
    tax_exempt?: boolean;
    /**
     * Track separately
     * @type {boolean}
     * @memberof PricingTier
     */
    track_separately?: boolean;
}

/**
 * 
 * @export
 * @interface PricingTierNotification
 */
export interface PricingTierNotification {
    /**
     * Notification format
     * @type {string}
     * @memberof PricingTierNotification
     */
    format?: string;
    /**
     * Notification subject
     * @type {string}
     * @memberof PricingTierNotification
     */
    subject?: string;
    /**
     * Notification text
     * @type {string}
     * @memberof PricingTierNotification
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface PricingTiersResponse
 */
export interface PricingTiersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof PricingTiersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof PricingTiersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * pricing_tiers
     * @type {Array<PricingTier>}
     * @memberof PricingTiersResponse
     */
    pricingTiers?: Array<PricingTier>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof PricingTiersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof PricingTiersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface PublishLibraryItemRequest
 */
export interface PublishLibraryItemRequest {
    /**
     * Release notes for this release version.
     * @type {string}
     * @memberof PublishLibraryItemRequest
     */
    release_notes?: string;
}

/**
 * 
 * @export
 * @interface RegisterAffiliateClickRequest
 */
export interface RegisterAffiliateClickRequest {
    /**
     * Affiliate Id (must be specified if landing_page_url is not)
     * @type {number}
     * @memberof RegisterAffiliateClickRequest
     */
    affid?: number;
    /**
     * IP Address (must be specified for non-browser key authenticated)
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    ip_address?: string;
    /**
     * Landing Page URL
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    landing_page_url?: string;
    /**
     * Referrer URL (used for detecting invisible linking)
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    referrer_url?: string;
    /**
     * Sub Id (optional value if affid is specified.
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    subid?: string;
    /**
     * User agent of the browser (must be specified for non-browser key authenticated)
     * @type {string}
     * @memberof RegisterAffiliateClickRequest
     */
    user_agent?: string;
}

/**
 * 
 * @export
 * @interface RegisterAffiliateClickResponse
 */
export interface RegisterAffiliateClickResponse {
    /**
     * The cookie max age to use
     * @type {number}
     * @memberof RegisterAffiliateClickResponse
     */
    cookie_max_age?: number;
    /**
     * The names of all the cookies to set on the browser
     * @type {Array<string>}
     * @memberof RegisterAffiliateClickResponse
     */
    cookie_names?: Array<string>;
    /**
     * The values of all the cookies to set on the browser
     * @type {Array<string>}
     * @memberof RegisterAffiliateClickResponse
     */
    cookie_values?: Array<string>;
    /**
     * True if a click was registered
     * @type {boolean}
     * @memberof RegisterAffiliateClickResponse
     */
    registered?: boolean;
}

/**
 * 
 * @export
 * @interface ResponseMetadata
 */
export interface ResponseMetadata {
    /**
     * Payload name
     * @type {string}
     * @memberof ResponseMetadata
     */
    payload_name?: string;
    /**
     * 
     * @type {ResultSet}
     * @memberof ResponseMetadata
     */
    result_set?: ResultSet;
}

/**
 * 
 * @export
 * @interface ResultSet
 */
export interface ResultSet {
    /**
     * Number of results in this set
     * @type {number}
     * @memberof ResultSet
     */
    count?: number;
    /**
     * Maximum number of results that can be returned in a set
     * @type {number}
     * @memberof ResultSet
     */
    limit?: number;
    /**
     * True if there are more results to query
     * @type {boolean}
     * @memberof ResultSet
     */
    more?: boolean;
    /**
     * The next offset that you should query to retrieve more results
     * @type {number}
     * @memberof ResultSet
     */
    next_offset?: number;
    /**
     * Offset of this result set (zero based)
     * @type {number}
     * @memberof ResultSet
     */
    offset?: number;
    /**
     * The total number of records in the result set.  May be null if the number is not known and the client should continue iterating as long as more is true.
     * @type {number}
     * @memberof ResultSet
     */
    total_records?: number;
}

/**
 * 
 * @export
 * @interface RotatingTransactionGateway
 */
export interface RotatingTransactionGateway {
    /**
     * An array of all currencies known to the UltraCart system and a boolean indicating whether this gateway supports that currency.
     * @type {Array<RtgCurrency>}
     * @memberof RotatingTransactionGateway
     */
    additional_native_currency_codes?: Array<RtgCurrency>;
    /**
     * Advanced feature for canceling an auto order unless the transaction gateway response contains a field with this name.  If specified, this field must exist and the value must equal a value in the auto_order_cancel_unless_response_values array
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    auto_order_cancel_unless_response_name?: string;
    /**
     * Advanced feature for canceling an auto order unless the transaction gateway response contains a field with the name specified in auto_order_cancel_unless_response_name.  If specified, this field must exist and the value must equal a value in this array.  If nothing matches, the auto order is canceled.
     * @type {Array<string>}
     * @memberof RotatingTransactionGateway
     */
    auto_order_cancel_unless_response_values?: Array<string>;
    /**
     * The base currency code for your gateway.  For example, USD.
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    base_currency_code?: string;
    /**
     * Optional field specifying a different rotating gateway to use if this gateway fails to process the transaction.
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    cascade_code?: string;
    /**
     * A list of other rotating transaction gateways that can be used as a lookup to assign actions based on failures of this gateway
     * @type {Array<string>}
     * @memberof RotatingTransactionGateway
     */
    cascade_codes?: Array<string>;
    /**
     * The code for the next rotating gateway that should be used when this gateway reaches a daily limit
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    cascade_daily_auto_order_code?: string;
    /**
     * Optional field providing an alternate Charge Appears As value for this rotating gateway
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    charge_appears_on_statement_as?: string;
    /**
     * A human friendly short code used to recognize and differentiate this rotating gateway with other rotating gateways
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    code?: string;
    /**
     * The current daily dollar amount this gateway has processed.  Providing this will allow UltraCart to track the monthly amount going forward.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    current_daily?: number;
    /**
     * The current daily dollar amount of auto orders (recurring) this gateway has processed.  Providing this will allow UltraCart to track the monthly amount going forward.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    current_daily_auto_order?: number;
    /**
     * The current monthly dollar amount this gateway has processed.  Providing this will allow UltraCart to track the monthly amount going forward.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    current_monthly?: number;
    /**
     * The customer service email address for this gateway
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    customer_service_email?: string;
    /**
     * The customer service phone number for this gateway
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    customer_service_phone?: string;
    /**
     * Array containing all 31 (possible) days and any optional restrictions for one or more days.
     * @type {Array<RtgDayOfMonthRestriction>}
     * @memberof RotatingTransactionGateway
     */
    day_of_month_restrictions?: Array<RtgDayOfMonthRestriction>;
    /**
     * Array containing all seven days of the week and any optional restrictions for one or more days
     * @type {Array<RtgDayOfWeekRestriction>}
     * @memberof RotatingTransactionGateway
     */
    day_of_week_restrictions?: Array<RtgDayOfWeekRestriction>;
    /**
     * If non-zero, this gateway will be deactivated after reaching this amount of consecutive failures.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    deactivate_after_failures?: number;
    /**
     * Optional field to specify an absolute date when this gateway should stop accepting transactions
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    end_date?: string;
    /**
     * An array of all transaction gateways, not just the one currently configured for this rotating gateway. This allows for easy switching to another gateway.  The enabled property on the transaction gateway indicates which one is actually being used.
     * @type {Array<TransactionGateway>}
     * @memberof RotatingTransactionGateway
     */
    gateways?: Array<TransactionGateway>;
    /**
     * The maximum daily dollar amount this gateway may process
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    maximum_daily?: number;
    /**
     * The maximum daily dollar amount of auto orders (recurring) this gateway may process
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    maximum_daily_auto_order?: number;
    /**
     * The maximum monthly dollar amount this gateway may process.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    maximum_monthly?: number;
    /**
     * The date and time when this gateway daily limit for auto orders will reset
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    next_daily_auto_order_reset?: string;
    /**
     * The date and time when this gateway daily limit will reset
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    next_daily_reset?: string;
    /**
     * The date and time when this gateway monthly limit will reset
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    next_monthly_reset?: string;
    /**
     * This optional field is combined with order_total_comparison to determine if an order should be processed thorugh this gateway.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    order_total?: number;
    /**
     * The math operator used to determine if the order total is allowed to process through this gateway.
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    order_total_comparison?: RotatingTransactionGateway.OrderTotalComparisonEnum;
    /**
     * If specified auto orders (rebills) are routed to this rotating gateway.  This may be needed because rebills lack a credit card cvv.
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    rebill_auto_orders_against_this_rtg_code?: string;
    /**
     * The number of days that your gateway holds any reserves.  This aids in profitability reporting.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    reserve_days?: number;
    /**
     * The percentage of an order which your gateway is holding in reserve.  This aids in profitability reporting.
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    reserve_percentage?: number;
    /**
     * If true, reserves are refunded when an order is refunded.  This aids in profitability reporting.
     * @type {boolean}
     * @memberof RotatingTransactionGateway
     */
    reserve_refunded?: boolean;
    /**
     * An optional date specifying the date up to which your gateway has released all reserve funds.  This aids in profitability reporting.
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    reserves_released_through?: string;
    /**
     * Internal identifier used to store and retrieve this gateway information
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    rotating_transaction_gateway_oid?: number;
    /**
     * The name of the currently selected transaction gateway used by this rotating gateway
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    selected_gateway_name?: string;
    /**
     * A boolean used by the builtin UltraCart UI to determine if cascading rtg codes should be shown
     * @type {boolean}
     * @memberof RotatingTransactionGateway
     */
    show_cascade_codes?: boolean;
    /**
     * A flag to help the UltraCart UI to know whether to show merchant account profiles or not.
     * @type {boolean}
     * @memberof RotatingTransactionGateway
     */
    show_merchant_account_profiles?: boolean;
    /**
     * Optional field to specify an absolute date when this gateway should begin accepting transactions
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    start_date?: string;
    /**
     * A field used to take a gateway offline without removing/deleting the configuration. Inactive marks the gateway as completely unusable.  Standby takes the gateway offline and will not be used unless all other active gateways fail.
     * @type {string}
     * @memberof RotatingTransactionGateway
     */
    status?: RotatingTransactionGateway.StatusEnum;
    /**
     * Optional restrictions by theme/storefront
     * @type {Array<RtgThemeRestriction>}
     * @memberof RotatingTransactionGateway
     */
    theme_restrictions?: Array<RtgThemeRestriction>;
    /**
     * Required field between 0 and 1 that dictates the percentage of traffic that should flow through this gateway
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    traffic_percentage?: number;
    /**
     * If specified, limits the total daily count of trial orders
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    trial_daily_amount?: number;
    /**
     * If specified, limits the total daily dollar amount of trial orders
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    trial_daily_limit?: number;
    /**
     * If specified, limits the total month dollar amount of trial orders
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    trial_monthly_amount?: number;
    /**
     * If specified, limits the total month count of trial orders
     * @type {number}
     * @memberof RotatingTransactionGateway
     */
    trial_monthly_limit?: number;
}

/**
 * @export
 * @namespace RotatingTransactionGateway
 */
export namespace RotatingTransactionGateway {
    /**
     * @export
     * @enum {string}
     */
    export enum OrderTotalComparisonEnum {
        LessThan = <any> '<',
        LessThanOrEqualTo = <any> '<=',
        Equal = <any> '=',
        GreaterThan = <any> '>',
        GreaterThanOrEqualTo = <any> '>='
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Active = <any> 'active',
        Inactive = <any> 'inactive',
        Standby = <any> 'standby'
    }
}

/**
 * 
 * @export
 * @interface RotatingTransactionGatewayResponse
 */
export interface RotatingTransactionGatewayResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof RotatingTransactionGatewayResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof RotatingTransactionGatewayResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {RotatingTransactionGateway}
     * @memberof RotatingTransactionGatewayResponse
     */
    rotating_gateway?: RotatingTransactionGateway;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof RotatingTransactionGatewayResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof RotatingTransactionGatewayResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface RotatingTransactionGatewaysResponse
 */
export interface RotatingTransactionGatewaysResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof RotatingTransactionGatewaysResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof RotatingTransactionGatewaysResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<RotatingTransactionGateway>}
     * @memberof RotatingTransactionGatewaysResponse
     */
    rotating_gateways?: Array<RotatingTransactionGateway>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof RotatingTransactionGatewaysResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof RotatingTransactionGatewaysResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface RtgCurrency
 */
export interface RtgCurrency {
    /**
     * Standard three letter currency code, for example USD
     * @type {string}
     * @memberof RtgCurrency
     */
    currency_code?: string;
    /**
     * Human friendly description of currency
     * @type {string}
     * @memberof RtgCurrency
     */
    description?: string;
    /**
     * true if this rotating gateway supports this currency
     * @type {boolean}
     * @memberof RtgCurrency
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface RtgDayOfMonthRestriction
 */
export interface RtgDayOfMonthRestriction {
    /**
     * The day of the month. 1 equals the first day of the month, 31 is the last possible value.
     * @type {number}
     * @memberof RtgDayOfMonthRestriction
     */
    day_of_month?: number;
    /**
     * True if this rotating gateway is allowed to operate on this day of month.  If no days are selected, all days are allowed.
     * @type {boolean}
     * @memberof RtgDayOfMonthRestriction
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface RtgDayOfWeekRestriction
 */
export interface RtgDayOfWeekRestriction {
    /**
     * Human readable day of week abbreviation
     * @type {string}
     * @memberof RtgDayOfWeekRestriction
     */
    abbreviation?: string;
    /**
     * 1=Sun,2=Mon,3=Tue,4=Wed,5=Thu,6=Fri,7=Sat
     * @type {number}
     * @memberof RtgDayOfWeekRestriction
     */
    day_of_week?: number;
    /**
     * True if this rotating gateway is allowed to operate on this day of week.  If no days are selected, all days are allowed.
     * @type {boolean}
     * @memberof RtgDayOfWeekRestriction
     */
    selected?: boolean;
}

/**
 * 
 * @export
 * @interface RtgSummaryGateway
 */
export interface RtgSummaryGateway {
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    cascade_code?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    delay_auto_orders?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof RtgSummaryGateway
     */
    reserve_percentage?: number;
    /**
     * An optional date specifying the date up to which your gateway has released all reserve funds.  This aids in profitability reporting.
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    reserves_released_through?: string;
    /**
     * 
     * @type {number}
     * @memberof RtgSummaryGateway
     */
    rotating_transaction_gateway_oid?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RtgSummaryGateway
     */
    show_ultracart_payments_verification?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RtgSummaryGateway
     */
    show_ultracart_payments_verified?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    supports_auth?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    supports_refund?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    third_party?: string;
    /**
     * 
     * @type {number}
     * @memberof RtgSummaryGateway
     */
    traffic_percentage?: number;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    warning?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    wepay_account_update_uri?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryGateway
     */
    wepay_console_hostname?: string;
}

/**
 * 
 * @export
 * @interface RtgSummaryResponse
 */
export interface RtgSummaryResponse {
    /**
     * 
     * @type {Array<RtgSummaryGateway>}
     * @memberof RtgSummaryResponse
     */
    gateways?: Array<RtgSummaryGateway>;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryResponse
     */
    info_message?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryResponse
     */
    migration_rtg_code?: string;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryResponse
     */
    migration_single_gateway_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RtgSummaryResponse
     */
    show_delay_auto_orders?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RtgSummaryResponse
     */
    show_migration?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RtgSummaryResponse
     */
    warning?: string;
}

/**
 * 
 * @export
 * @interface RtgThemeRestriction
 */
export interface RtgThemeRestriction {
    /**
     * Any restriction for this theme
     * @type {string}
     * @memberof RtgThemeRestriction
     */
    restriction?: RtgThemeRestriction.RestrictionEnum;
    /**
     * The server name for this theme.  This will not be populated for legacy (ancient) themes
     * @type {string}
     * @memberof RtgThemeRestriction
     */
    storefront_host_name?: string;
    /**
     * Human friendly short code for this theme
     * @type {string}
     * @memberof RtgThemeRestriction
     */
    theme_code?: string;
}

/**
 * @export
 * @namespace RtgThemeRestriction
 */
export namespace RtgThemeRestriction {
    /**
     * @export
     * @enum {string}
     */
    export enum RestrictionEnum {
        Invalid = <any> 'invalid',
        Valid = <any> 'valid',
        ValidOnly = <any> 'validOnly'
    }
}

/**
 * 
 * @export
 * @interface ScreenRecording
 */
export interface ScreenRecording {
    /**
     * 
     * @type {ScreenRecordingAdPlatform}
     * @memberof ScreenRecording
     */
    ad_platform?: ScreenRecordingAdPlatform;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    analytics_client_oid?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    analytics_session_dts?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    analytics_session_oid?: number;
    /**
     * Campaign Name
     * @type {string}
     * @memberof ScreenRecording
     */
    communications_campaign_name?: string;
    /**
     * Campaign UUID
     * @type {string}
     * @memberof ScreenRecording
     */
    communications_campaign_uuid?: string;
    /**
     * Email subject
     * @type {string}
     * @memberof ScreenRecording
     */
    communications_email_subject?: string;
    /**
     * Email UUID
     * @type {string}
     * @memberof ScreenRecording
     */
    communications_email_uuid?: string;
    /**
     * Flow Name
     * @type {string}
     * @memberof ScreenRecording
     */
    communications_flow_name?: string;
    /**
     * Flow UUID
     * @type {string}
     * @memberof ScreenRecording
     */
    communications_flow_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    email_domain?: string;
    /**
     * Ending timestamp
     * @type {string}
     * @memberof ScreenRecording
     */
    end_timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    esp_customer_uuid?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    events_gz_size?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    events_json_key?: string;
    /**
     * True if the user calling the API has favorited this particular screen recording.
     * @type {boolean}
     * @memberof ScreenRecording
     */
    favorite?: boolean;
    /**
     * Array of user ids that favorited this particular screen recording.
     * @type {Array<number>}
     * @memberof ScreenRecording
     */
    favorites?: Array<number>;
    /**
     * 
     * @type {GeoPoint}
     * @memberof ScreenRecording
     */
    geolocation?: GeoPoint;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    geolocation_country?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    geolocation_state?: string;
    /**
     * Language ISO code
     * @type {string}
     * @memberof ScreenRecording
     */
    language_iso_code?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    merchant_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    merchant_notes?: string;
    /**
     * True if external page view was not tracked
     * @type {boolean}
     * @memberof ScreenRecording
     */
    missing_external_tracking?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    order_id?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    page_view_count?: number;
    /**
     * 
     * @type {Array<ScreenRecordingPageView>}
     * @memberof ScreenRecording
     */
    page_views?: Array<ScreenRecordingPageView>;
    /**
     * ISO 3 Letter language code that the customer would prefer
     * @type {string}
     * @memberof ScreenRecording
     */
    preferred_language?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    referrer_domain?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    rrweb_version?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    screen_recording_uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    signed_download_url?: string;
    /**
     * Starting timestamp
     * @type {string}
     * @memberof ScreenRecording
     */
    start_timestamp?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenRecording
     */
    storefront_oids?: Array<number>;
    /**
     * 
     * @type {Array<ScreenRecordingStoreFront>}
     * @memberof ScreenRecording
     */
    storefronts?: Array<ScreenRecordingStoreFront>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecording
     */
    tags?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    time_on_site?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    ucacid?: string;
    /**
     * 
     * @type {ScreenRecordingUserAgent}
     * @memberof ScreenRecording
     */
    user_agent?: ScreenRecordingUserAgent;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    user_agent_raw?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecording
     */
    user_ip?: string;
    /**
     * 
     * @type {Array<ScreenRecordingUserProperty>}
     * @memberof ScreenRecording
     */
    user_properties?: Array<ScreenRecordingUserProperty>;
    /**
     * UTM Campaign
     * @type {string}
     * @memberof ScreenRecording
     */
    utm_campaign?: string;
    /**
     * UTM Source
     * @type {string}
     * @memberof ScreenRecording
     */
    utm_source?: string;
    /**
     * Timestamp this visitor was first seen
     * @type {string}
     * @memberof ScreenRecording
     */
    visitor_first_seen?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    visitor_number?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecording
     */
    watched?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    window_height?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecording
     */
    window_width?: number;
}

/**
 * 
 * @export
 * @interface ScreenRecordingAdPlatform
 */
export interface ScreenRecordingAdPlatform {
    /**
     * Facebook Click Id (Cookie)
     * @type {string}
     * @memberof ScreenRecordingAdPlatform
     */
    fbc?: string;
    /**
     * Facebook Click Id Parameter (Parameter)
     * @type {string}
     * @memberof ScreenRecordingAdPlatform
     */
    fbclid?: string;
    /**
     * Facebook Browser Id (Cookie)
     * @type {string}
     * @memberof ScreenRecordingAdPlatform
     */
    fbp?: string;
    /**
     * Google Analytics CID (Cookie)
     * @type {string}
     * @memberof ScreenRecordingAdPlatform
     */
    gacid?: string;
    /**
     * Google Adwords Click Id (Parameter)
     * @type {string}
     * @memberof ScreenRecordingAdPlatform
     */
    glcid?: string;
    /**
     * Bing Click Id (Parameter
     * @type {string}
     * @memberof ScreenRecordingAdPlatform
     */
    msclkid?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilter
 */
export interface ScreenRecordingFilter {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    affiliate_email?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilter
     */
    affiliate_id?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    communications_campaign_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    communications_campaign_name_filter?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    communications_email_subject?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    communications_email_subject_filter?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    communications_flow_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    communications_flow_name_filter?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilter
     */
    email?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    email_domain?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    email_domain_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    email_identified?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterRangeDate}
     * @memberof ScreenRecordingFilter
     */
    end_timestamp?: ScreenRecordingFilterRangeDate;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    esp_customer_uuid?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    favorite?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterGeoDistance}
     * @memberof ScreenRecordingFilter
     */
    geolocation?: ScreenRecordingFilterGeoDistance;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilter
     */
    geolocation_country?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    geolocation_country_filter?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilter
     */
    geolocation_state?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    geolocation_state_filter?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilter
     */
    language_iso_code?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    language_iso_code_filter?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilter
     */
    last_x_days?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilter
     */
    max_filter_values?: number;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilter
     */
    order_id?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {ScreenRecordingFilterRangeInteger}
     * @memberof ScreenRecordingFilter
     */
    page_view_count?: ScreenRecordingFilterRangeInteger;
    /**
     * 
     * @type {Array<ScreenRecordingFilterPageView>}
     * @memberof ScreenRecordingFilter
     */
    page_views?: Array<ScreenRecordingFilterPageView>;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    placed_order?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilter
     */
    preferred_language?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    preferred_language_filter?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    referrer_domain?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    referrer_domain_filter?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilter
     */
    screen_recording_uuids?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilter
     */
    screen_sizes?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    skip_filter_values?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    skip_histogram?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    skip_hits?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterRangeDate}
     * @memberof ScreenRecordingFilter
     */
    start_timestamp?: ScreenRecordingFilterRangeDate;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilter
     */
    tags?: Array<string>;
    /**
     * 
     * @type {ScreenRecordingFilterRangeInteger}
     * @memberof ScreenRecordingFilter
     */
    time_on_site?: ScreenRecordingFilterRangeInteger;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    time_on_site_max_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    time_on_site_min_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    url_filter?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    user_agent_device_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    user_agent_device_name_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    user_agent_device_os_name_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    user_agent_device_os_version_filter?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    user_agent_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    user_agent_name_filter?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilter
     */
    user_agent_original?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    user_agent_original_filter?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    user_agent_os_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    user_agent_os_version?: string;
    /**
     * 
     * @type {ScreenRecordingFilterIpSearch}
     * @memberof ScreenRecordingFilter
     */
    user_ip?: ScreenRecordingFilterIpSearch;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    utm_campaign?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    utm_campaign_filter?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilter
     */
    utm_source?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    utm_source_filter?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilter
     */
    visitor_number?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilter
     */
    watched?: boolean;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterGeoDistance
 */
export interface ScreenRecordingFilterGeoDistance {
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterGeoDistance
     */
    distance?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterGeoDistance
     */
    distance_uom?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterGeoDistance
     */
    from_address?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterGeoDistance
     */
    lat?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterGeoDistance
     */
    lon?: number;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterIpSearch
 */
export interface ScreenRecordingFilterIpSearch {
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterIpSearch
     */
    does_not_exist?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterIpSearch
     */
    exists?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterIpSearch
     */
    is?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterIpSearch
     */
    is_not?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterPageView
 */
export interface ScreenRecordingFilterPageView {
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilterPageView
     */
    domain?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    domain_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    event_name_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    event_param_name_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    event_param_value_filter?: boolean;
    /**
     * 
     * @type {Array<ScreenRecordingFilterPageViewEvent>}
     * @memberof ScreenRecordingFilterPageView
     */
    events?: Array<ScreenRecordingFilterPageViewEvent>;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    param_name_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    param_value_filter?: boolean;
    /**
     * 
     * @type {Array<ScreenRecordingFilterPageViewParam>}
     * @memberof ScreenRecordingFilterPageView
     */
    params?: Array<ScreenRecordingFilterPageViewParam>;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilterPageView
     */
    referrer?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {Array<ScreenRecordingFilterPageViewReferrerParam>}
     * @memberof ScreenRecordingFilterPageView
     */
    referrer_params?: Array<ScreenRecordingFilterPageViewReferrerParam>;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilterPageView
     */
    referrer_raw?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {ScreenRecordingFilterRangeInteger}
     * @memberof ScreenRecordingFilterPageView
     */
    time_on_page?: ScreenRecordingFilterRangeInteger;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    time_on_page_max_filter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    time_on_page_min_filter?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilterPageView
     */
    url?: ScreenRecordingFilterStringSearch;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageView
     */
    url_filter?: boolean;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterPageViewEvent
 */
export interface ScreenRecordingFilterPageViewEvent {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterPageViewEvent
     */
    event_name?: string;
    /**
     * 
     * @type {Array<ScreenRecordingFilterPageViewEventParam>}
     * @memberof ScreenRecordingFilterPageViewEvent
     */
    event_params?: Array<ScreenRecordingFilterPageViewEventParam>;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterPageViewEventParam
 */
export interface ScreenRecordingFilterPageViewEventParam {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterPageViewEventParam
     */
    name?: string;
    /**
     * 
     * @type {ScreenRecordingFilterRangeBigDecimal}
     * @memberof ScreenRecordingFilterPageViewEventParam
     */
    value_bd?: ScreenRecordingFilterRangeBigDecimal;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterPageViewEventParam
     */
    value_bool?: boolean;
    /**
     * 
     * @type {ScreenRecordingFilterRangeInteger}
     * @memberof ScreenRecordingFilterPageViewEventParam
     */
    value_num?: ScreenRecordingFilterRangeInteger;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilterPageViewEventParam
     */
    value_text?: ScreenRecordingFilterStringSearch;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterPageViewParam
 */
export interface ScreenRecordingFilterPageViewParam {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterPageViewParam
     */
    name?: string;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilterPageViewParam
     */
    value?: ScreenRecordingFilterStringSearch;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterPageViewReferrerParam
 */
export interface ScreenRecordingFilterPageViewReferrerParam {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterPageViewReferrerParam
     */
    name?: string;
    /**
     * 
     * @type {ScreenRecordingFilterStringSearch}
     * @memberof ScreenRecordingFilterPageViewReferrerParam
     */
    value?: ScreenRecordingFilterStringSearch;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterRangeBigDecimal
 */
export interface ScreenRecordingFilterRangeBigDecimal {
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeBigDecimal
     */
    eq?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeBigDecimal
     */
    gt?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeBigDecimal
     */
    gte?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeBigDecimal
     */
    lt?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeBigDecimal
     */
    lte?: number;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterRangeDate
 */
export interface ScreenRecordingFilterRangeDate {
    /**
     * End of the range
     * @type {string}
     * @memberof ScreenRecordingFilterRangeDate
     */
    end?: string;
    /**
     * Start of the range
     * @type {string}
     * @memberof ScreenRecordingFilterRangeDate
     */
    start?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterRangeInteger
 */
export interface ScreenRecordingFilterRangeInteger {
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeInteger
     */
    eq?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeInteger
     */
    gt?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeInteger
     */
    gte?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeInteger
     */
    lt?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterRangeInteger
     */
    lte?: number;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterStringSearch
 */
export interface ScreenRecordingFilterStringSearch {
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterStringSearch
     */
    does_not_exist?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingFilterStringSearch
     */
    exists?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterStringSearch
     */
    is?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterStringSearch
     */
    is_not?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterStringSearch
     */
    starts_with?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterValues
 */
export interface ScreenRecordingFilterValues {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    communications_campaign_names?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    communications_email_subjects?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    communications_flow_names?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    email_domains?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    geolocation_countries?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    geolocation_states?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    language_iso_codes?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterValues
     */
    max_values?: number;
    /**
     * 
     * @type {Array<ScreenRecordingFilterValuesPageView>}
     * @memberof ScreenRecordingFilterValues
     */
    page_views?: Array<ScreenRecordingFilterValuesPageView>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    preferred_languages?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    referrer_domains?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterValues
     */
    time_on_site_max?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterValues
     */
    time_on_site_min?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    urls?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    user_agent_device_names?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    user_agent_device_os_names?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    user_agent_device_os_versions?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    user_agent_names?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    user_agent_originals?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    utm_campaigns?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValues
     */
    utm_sources?: Array<string>;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterValuesEvent
 */
export interface ScreenRecordingFilterValuesEvent {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterValuesEvent
     */
    name?: string;
    /**
     * 
     * @type {Array<ScreenRecordingFilterValuesEventParams>}
     * @memberof ScreenRecordingFilterValuesEvent
     */
    params?: Array<ScreenRecordingFilterValuesEventParams>;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterValuesEventParams
 */
export interface ScreenRecordingFilterValuesEventParams {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterValuesEventParams
     */
    name?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenRecordingFilterValuesEventParams
     */
    values_bd?: Array<number>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof ScreenRecordingFilterValuesEventParams
     */
    values_bool?: Array<boolean>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenRecordingFilterValuesEventParams
     */
    values_num?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValuesEventParams
     */
    values_text?: Array<string>;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterValuesPageParam
 */
export interface ScreenRecordingFilterValuesPageParam {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingFilterValuesPageParam
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValuesPageParam
     */
    values?: Array<string>;
}

/**
 * 
 * @export
 * @interface ScreenRecordingFilterValuesPageView
 */
export interface ScreenRecordingFilterValuesPageView {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValuesPageView
     */
    domains?: Array<string>;
    /**
     * 
     * @type {Array<ScreenRecordingFilterValuesEvent>}
     * @memberof ScreenRecordingFilterValuesPageView
     */
    events?: Array<ScreenRecordingFilterValuesEvent>;
    /**
     * 
     * @type {Array<ScreenRecordingFilterValuesPageParam>}
     * @memberof ScreenRecordingFilterValuesPageView
     */
    page_params?: Array<ScreenRecordingFilterValuesPageParam>;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterValuesPageView
     */
    time_on_page_max?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingFilterValuesPageView
     */
    time_on_page_min?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingFilterValuesPageView
     */
    urls?: Array<string>;
}

/**
 * 
 * @export
 * @interface ScreenRecordingHeatmap
 */
export interface ScreenRecordingHeatmap {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_click_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_click_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_movement_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_movement_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_regular_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_regular_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_scroll_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    large_scroll_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_click_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_click_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_movement_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_movement_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_regular_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_regular_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_scroll_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    medium_scroll_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_click_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_click_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_movement_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_movement_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_regular_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_regular_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_scroll_thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmap
     */
    small_scroll_url?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingHeatmapIndexRequest
 */
export interface ScreenRecordingHeatmapIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmapIndexRequest
     */
    url_contains?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingHeatmapIndexResponse
 */
export interface ScreenRecordingHeatmapIndexResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingHeatmapIndexResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<ScreenRecordingHeatmapUrl>}
     * @memberof ScreenRecordingHeatmapIndexResponse
     */
    heatmap_urls?: Array<ScreenRecordingHeatmapUrl>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingHeatmapIndexResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingHeatmapIndexResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingHeatmapIndexResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingHeatmapRequest
 */
export interface ScreenRecordingHeatmapRequest {
    /**
     * 
     * @type {ScreenRecordingFilterRangeDate}
     * @memberof ScreenRecordingHeatmapRequest
     */
    range?: ScreenRecordingFilterRangeDate;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingHeatmapRequest
     */
    screen_sizes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmapRequest
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingHeatmapReset
 */
export interface ScreenRecordingHeatmapReset {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmapReset
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingHeatmapResponse
 */
export interface ScreenRecordingHeatmapResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingHeatmapResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ScreenRecordingHeatmap}
     * @memberof ScreenRecordingHeatmapResponse
     */
    heatmap?: ScreenRecordingHeatmap;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingHeatmapResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingHeatmapResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingHeatmapResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingHeatmapUrl
 */
export interface ScreenRecordingHeatmapUrl {
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenRecordingHeatmapUrl
     */
    histogram_data?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmapUrl
     */
    histogram_interval?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmapUrl
     */
    histogram_start_dts?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingHeatmapUrl
     */
    page_rank?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingHeatmapUrl
     */
    session_count?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingHeatmapUrl
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingMerchantNotesRequest
 */
export interface ScreenRecordingMerchantNotesRequest {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingMerchantNotesRequest
     */
    merchant_notes?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingMultifield
 */
export interface ScreenRecordingMultifield {
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingMultifield
     */
    bd?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingMultifield
     */
    bool?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingMultifield
     */
    json?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingMultifield
     */
    num?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingMultifield
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingPageView
 */
export interface ScreenRecordingPageView {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    domain?: string;
    /**
     * 
     * @type {Array<ScreenRecordingPageViewEvent>}
     * @memberof ScreenRecordingPageView
     */
    events?: Array<ScreenRecordingPageViewEvent>;
    /**
     * First event timestamp
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    first_event_timestamp?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingPageView
     */
    http_post?: boolean;
    /**
     * Last event timestamp
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    last_event_timestamp?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingPageView
     */
    missing_events?: boolean;
    /**
     * 
     * @type {Array<ScreenRecordingPageViewParameter>}
     * @memberof ScreenRecordingPageView
     */
    params?: Array<ScreenRecordingPageViewParameter>;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingPageView
     */
    range_end?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingPageView
     */
    range_start?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    referrer?: string;
    /**
     * 
     * @type {Array<ScreenRecordingPageViewParameter>}
     * @memberof ScreenRecordingPageView
     */
    referrer_params?: Array<ScreenRecordingPageViewParameter>;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    referrer_raw?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    screen_recording_page_view_uuid?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingPageView
     */
    time_on_page?: number;
    /**
     * Amount of time for DOMContentLoaded event to fire (milliseconds)
     * @type {number}
     * @memberof ScreenRecordingPageView
     */
    timing_dom_content_loaded?: number;
    /**
     * Amount of time for loaded event to fire (milliseconds)
     * @type {number}
     * @memberof ScreenRecordingPageView
     */
    timing_loaded?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingPageView
     */
    truncated_events?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    ucapv?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageView
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingPageViewDataResponse
 */
export interface ScreenRecordingPageViewDataResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingPageViewDataResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageViewDataResponse
     */
    events_json?: string;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingPageViewDataResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingPageViewDataResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingPageViewDataResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingPageViewEvent
 */
export interface ScreenRecordingPageViewEvent {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageViewEvent
     */
    name?: string;
    /**
     * 
     * @type {Array<ScreenRecordingPageViewEventParameter>}
     * @memberof ScreenRecordingPageViewEvent
     */
    params?: Array<ScreenRecordingPageViewEventParameter>;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingPageViewEvent
     */
    prior_page_view?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageViewEvent
     */
    sub_text?: string;
    /**
     * Timestamp of the event
     * @type {string}
     * @memberof ScreenRecordingPageViewEvent
     */
    timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingPageViewEvent
     */
    ts?: number;
}

/**
 * 
 * @export
 * @interface ScreenRecordingPageViewEventParameter
 */
export interface ScreenRecordingPageViewEventParameter {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageViewEventParameter
     */
    name?: string;
    /**
     * 
     * @type {ScreenRecordingMultifield}
     * @memberof ScreenRecordingPageViewEventParameter
     */
    value?: ScreenRecordingMultifield;
}

/**
 * 
 * @export
 * @interface ScreenRecordingPageViewParameter
 */
export interface ScreenRecordingPageViewParameter {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageViewParameter
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingPageViewParameter
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingQueryRequest
 */
export interface ScreenRecordingQueryRequest {
    /**
     * 
     * @type {ScreenRecordingFilter}
     * @memberof ScreenRecordingQueryRequest
     */
    filter?: ScreenRecordingFilter;
}

/**
 * 
 * @export
 * @interface ScreenRecordingQueryResponse
 */
export interface ScreenRecordingQueryResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingQueryResponse
     */
    checkout_only?: boolean;
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingQueryResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ScreenRecordingFilter}
     * @memberof ScreenRecordingQueryResponse
     */
    filter?: ScreenRecordingFilter;
    /**
     * 
     * @type {ScreenRecordingFilterValues}
     * @memberof ScreenRecordingQueryResponse
     */
    filter_values?: ScreenRecordingFilterValues;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenRecordingQueryResponse
     */
    histogram_data?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingQueryResponse
     */
    histogram_interval?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingQueryResponse
     */
    histogram_start_dts?: string;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingQueryResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<ScreenRecording>}
     * @memberof ScreenRecordingQueryResponse
     */
    screen_recordings?: Array<ScreenRecording>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingQueryResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingQueryResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingResponse
 */
export interface ScreenRecordingResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingResponse
     */
    checkout_only?: boolean;
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {ScreenRecording}
     * @memberof ScreenRecordingResponse
     */
    screen_recording?: ScreenRecording;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingSegment
 */
export interface ScreenRecordingSegment {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingSegment
     */
    create_dts?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingSegment
     */
    description?: string;
    /**
     * 
     * @type {ScreenRecordingFilter}
     * @memberof ScreenRecordingSegment
     */
    filter?: ScreenRecordingFilter;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScreenRecordingSegment
     */
    histogram_data?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingSegment
     */
    histogram_interval?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingSegment
     */
    histogram_start_dts?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingSegment
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingSegment
     */
    screen_recording_segment_oid?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingSegment
     */
    session_count?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingSegment
     */
    session_count_last_update_dts?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingSegmentResponse
 */
export interface ScreenRecordingSegmentResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingSegmentResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingSegmentResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {ScreenRecordingSegment}
     * @memberof ScreenRecordingSegmentResponse
     */
    segment?: ScreenRecordingSegment;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingSegmentResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingSegmentResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingSegmentsResponse
 */
export interface ScreenRecordingSegmentsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingSegmentsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingSegmentsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {Array<ScreenRecordingSegment>}
     * @memberof ScreenRecordingSegmentsResponse
     */
    segments?: Array<ScreenRecordingSegment>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingSegmentsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingSegmentsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingSettings
 */
export interface ScreenRecordingSettings {
    /**
     * Cost per one thousand sessions
     * @type {number}
     * @memberof ScreenRecordingSettings
     */
    cost_per_thousand?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingSettings
     */
    enabled?: boolean;
    /**
     * How long screen recording data is retained
     * @type {string}
     * @memberof ScreenRecordingSettings
     */
    retention_interval?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingSettings
     */
    sessions_current_billing_period?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingSettings
     */
    sessions_last_billing_period?: number;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingSettings
     */
    sessions_trial_billing_period?: number;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingSettings
     */
    trial_expiration?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScreenRecordingSettings
     */
    trial_expired?: boolean;
}

/**
 * 
 * @export
 * @interface ScreenRecordingSettingsResponse
 */
export interface ScreenRecordingSettingsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingSettingsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingSettingsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {ScreenRecordingSettings}
     * @memberof ScreenRecordingSettingsResponse
     */
    settings?: ScreenRecordingSettings;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingSettingsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingSettingsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingStoreFront
 */
export interface ScreenRecordingStoreFront {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingStoreFront
     */
    storefront_host_name?: string;
    /**
     * 
     * @type {number}
     * @memberof ScreenRecordingStoreFront
     */
    storefront_oid?: number;
}

/**
 * 
 * @export
 * @interface ScreenRecordingTagsRequest
 */
export interface ScreenRecordingTagsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingTagsRequest
     */
    tags?: Array<string>;
}

/**
 * 
 * @export
 * @interface ScreenRecordingTagsResponse
 */
export interface ScreenRecordingTagsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenRecordingTagsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenRecordingTagsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenRecordingTagsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ScreenRecordingTagsResponse
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenRecordingTagsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ScreenRecordingUserAgent
 */
export interface ScreenRecordingUserAgent {
    /**
     * 
     * @type {ScreenRecordingUserAgentDevice}
     * @memberof ScreenRecordingUserAgent
     */
    device?: ScreenRecordingUserAgentDevice;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserAgent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserAgent
     */
    original?: string;
    /**
     * 
     * @type {ScreenRecordingUserAgentOS}
     * @memberof ScreenRecordingUserAgent
     */
    os?: ScreenRecordingUserAgentOS;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserAgent
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingUserAgentDevice
 */
export interface ScreenRecordingUserAgentDevice {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserAgentDevice
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingUserAgentOS
 */
export interface ScreenRecordingUserAgentOS {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserAgentOS
     */
    full?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserAgentOS
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserAgentOS
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface ScreenRecordingUserProperty
 */
export interface ScreenRecordingUserProperty {
    /**
     * 
     * @type {string}
     * @memberof ScreenRecordingUserProperty
     */
    name?: string;
    /**
     * 
     * @type {ScreenRecordingMultifield}
     * @memberof ScreenRecordingUserProperty
     */
    value?: ScreenRecordingMultifield;
}

/**
 * 
 * @export
 * @interface ScreenshotsResponse
 */
export interface ScreenshotsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ScreenshotsResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ScreenshotsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * List of screenshot urls related to the object (depends on which method was called).
     * @type {Array<string>}
     * @memberof ScreenshotsResponse
     */
    screenshots?: Array<string>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ScreenshotsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof ScreenshotsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface SelfConfig
 */
export interface SelfConfig {
    /**
     * True if sales tax should be collected based on billing address instead of shipping address
     * @type {boolean}
     * @memberof SelfConfig
     */
    tax_billing?: boolean;
}

/**
 * 
 * @export
 * @interface SimpleValue
 */
export interface SimpleValue {
    /**
     * A friendly display of this value suitable for human reading
     * @type {string}
     * @memberof SimpleValue
     */
    display?: string;
    /**
     * The actual value
     * @type {string}
     * @memberof SimpleValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface SingleSignOnAuthorizeRequest
 */
export interface SingleSignOnAuthorizeRequest {
    /**
     * The URL that the customer should be redirected to after they have approved a single sign on session.
     * @type {string}
     * @memberof SingleSignOnAuthorizeRequest
     */
    redirect_uri?: string;
    /**
     * An optional state variable that you provide.  It will be returned to you on the redirect.  You can inspect the state to validate the request is legitimate.  We recommend using this field.
     * @type {string}
     * @memberof SingleSignOnAuthorizeRequest
     */
    state?: string;
}

/**
 * 
 * @export
 * @interface SingleSignOnAuthorizeResponse
 */
export interface SingleSignOnAuthorizeResponse {
    /**
     * Expiration date/time after which the single sign-on login operation will have timed out
     * @type {string}
     * @memberof SingleSignOnAuthorizeResponse
     */
    expiration_dts?: string;
    /**
     * The URL that you should redirect the customer's browser to.  This URL will begin the login process.
     * @type {string}
     * @memberof SingleSignOnAuthorizeResponse
     */
    login_url?: string;
}

/**
 * 
 * @export
 * @interface SingleSignOnTokenRequest
 */
export interface SingleSignOnTokenRequest {
    /**
     * The code received on the redirect URI after the customer approved the single sign on request.
     * @type {string}
     * @memberof SingleSignOnTokenRequest
     */
    code?: string;
    /**
     * Grant type.  The value should be simple_key.
     * @type {string}
     * @memberof SingleSignOnTokenRequest
     */
    grant_type?: string;
}

/**
 * 
 * @export
 * @interface SingleSignOnTokenResponse
 */
export interface SingleSignOnTokenResponse {
    /**
     * Expiration date/time after which time the key is no longer valid
     * @type {string}
     * @memberof SingleSignOnTokenResponse
     */
    expiration_dts?: string;
    /**
     * IP address of the user which we recommend you lock the simple key's usage to.
     * @type {string}
     * @memberof SingleSignOnTokenResponse
     */
    ip_address?: string;
    /**
     * The simple key that can then be used to make SDK calls on the users behalf.
     * @type {string}
     * @memberof SingleSignOnTokenResponse
     */
    simple_key?: string;
}

/**
 * 
 * @export
 * @interface SovosConfig
 */
export interface SovosConfig {
    /**
     * Sovos access key
     * @type {string}
     * @memberof SovosConfig
     */
    access_key?: string;
    /**
     * True if this Sovos configuration is to estimate taxes only and not report placed orders to Sovos
     * @type {boolean}
     * @memberof SovosConfig
     */
    estimate_only?: boolean;
    /**
     * Date/time of the connection test to Sovos
     * @type {string}
     * @memberof SovosConfig
     */
    last_test_dts?: string;
    /**
     * Sovos secret key
     * @type {string}
     * @memberof SovosConfig
     */
    secret_key?: string;
    /**
     * Send test orders through to Sovos.  The default is to not transmit test orders to Sovos.
     * @type {boolean}
     * @memberof SovosConfig
     */
    send_test_orders?: boolean;
    /**
     * Test results of the last connection test to Sovos
     * @type {string}
     * @memberof SovosConfig
     */
    test_results?: string;
    /**
     * True if this Sovos configuration is currently undergoing user acceptance testing
     * @type {boolean}
     * @memberof SovosConfig
     */
    uat?: boolean;
}

/**
 * 
 * @export
 * @interface StateProvince
 */
export interface StateProvince {
    /**
     * abbreviation
     * @type {string}
     * @memberof StateProvince
     */
    abbreviation?: string;
    /**
     * name
     * @type {string}
     * @memberof StateProvince
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface StepWaiting
 */
export interface StepWaiting {
    /**
     * 
     * @type {string}
     * @memberof StepWaiting
     */
    commseq_step_uuid?: string;
    /**
     * 
     * @type {number}
     * @memberof StepWaiting
     */
    number_waiting?: number;
}

/**
 * 
 * @export
 * @interface StripeConnectResponse
 */
export interface StripeConnectResponse {
    /**
     * 
     * @type {string}
     * @memberof StripeConnectResponse
     */
    connect_url?: string;
    /**
     * 
     * @type {ModelError}
     * @memberof StripeConnectResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof StripeConnectResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof StripeConnectResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof StripeConnectResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TaxCity
 */
export interface TaxCity {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCity
     */
    accounting_code?: string;
    /**
     * City
     * @type {string}
     * @memberof TaxCity
     */
    city?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCity
     */
    city_oid?: number;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCity
     */
    county_oid?: number;
    /**
     * Flag instructing engine to not collect city tax for this city
     * @type {boolean}
     * @memberof TaxCity
     */
    dont_collect_city?: boolean;
    /**
     * Flag instructing engine to not collect postal code tax for this city
     * @type {boolean}
     * @memberof TaxCity
     */
    dont_collect_postal_code?: boolean;
    /**
     * Postal Codes within this city
     * @type {Array<TaxPostalCode>}
     * @memberof TaxCity
     */
    postal_codes?: Array<TaxPostalCode>;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCity
     */
    tax_rate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCity
     */
    tax_rate_formatted?: string;
}

/**
 * 
 * @export
 * @interface TaxCountry
 */
export interface TaxCountry {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCountry
     */
    accounting_code?: string;
    /**
     * Country code (2 characters
     * @type {string}
     * @memberof TaxCountry
     */
    country_code?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCountry
     */
    country_oid?: number;
    /**
     * States (or regions or territories) within this country
     * @type {Array<TaxState>}
     * @memberof TaxCountry
     */
    states?: Array<TaxState>;
    /**
     * True if taxation within this jurisdiction should charge tax on gift charge
     * @type {boolean}
     * @memberof TaxCountry
     */
    tax_gift_charge?: boolean;
    /**
     * True if taxation within this jurisdiction should charge tax on gift wrap
     * @type {boolean}
     * @memberof TaxCountry
     */
    tax_gift_wrap?: boolean;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCountry
     */
    tax_rate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCountry
     */
    tax_rate_formatted?: string;
    /**
     * True if taxation within this jurisdiction should charge tax on shipping
     * @type {boolean}
     * @memberof TaxCountry
     */
    tax_shipping?: boolean;
}

/**
 * 
 * @export
 * @interface TaxCountryCode
 */
export interface TaxCountryCode {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCountryCode
     */
    accounting_code?: string;
    /**
     * Country code (2 characters
     * @type {string}
     * @memberof TaxCountryCode
     */
    country_code?: string;
    /**
     * Country name
     * @type {string}
     * @memberof TaxCountryCode
     */
    country_name?: string;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCountryCode
     */
    tax_rate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCountryCode
     */
    tax_rate_formatted?: string;
}

/**
 * 
 * @export
 * @interface TaxCounty
 */
export interface TaxCounty {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxCounty
     */
    accounting_code?: string;
    /**
     * Cities within this city
     * @type {Array<TaxCity>}
     * @memberof TaxCounty
     */
    cities?: Array<TaxCity>;
    /**
     * County
     * @type {string}
     * @memberof TaxCounty
     */
    county?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCounty
     */
    county_oid?: number;
    /**
     * Flag instructing engine to not collect city tax for this county
     * @type {boolean}
     * @memberof TaxCounty
     */
    dont_collect_city?: boolean;
    /**
     * Flag instructing engine to not collect county tax for this county
     * @type {boolean}
     * @memberof TaxCounty
     */
    dont_collect_county?: boolean;
    /**
     * Flag instructing engine to not collect postal code tax for this county
     * @type {boolean}
     * @memberof TaxCounty
     */
    dont_collect_postal_code?: boolean;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxCounty
     */
    state_oid?: number;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxCounty
     */
    tax_rate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxCounty
     */
    tax_rate_formatted?: string;
}

/**
 * 
 * @export
 * @interface TaxJarConfig
 */
export interface TaxJarConfig {
    /**
     * True if TaxJar is active for this merchant
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    active?: boolean;
    /**
     * TaxJar API key
     * @type {string}
     * @memberof TaxJarConfig
     */
    api_key?: string;
    /**
     * True if this TaxJar configuration is to estimate taxes only and not report placed orders to TaxJar
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    estimate_only?: boolean;
    /**
     * Send orders outside your nexus TaxJar.  The default is to not transmit outside orders to TaxJar to reduce API calls.  However, this will prevent TaxJar from dynamically creating new Nexus when thresholds are exceeded for a state.
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    send_outside_nexus?: boolean;
    /**
     * Send test orders through to TaxJar.  The default is to not transmit test orders to TaxJar.
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    send_test_orders?: boolean;
    /**
     * Do not send channel partner orders to TaxJar.  Set this to true if your channel partner reports tax on their own.
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    skip_channel_orders?: boolean;
    /**
     * Use distribution center from address
     * @type {boolean}
     * @memberof TaxJarConfig
     */
    use_distribution_center_from?: boolean;
}

/**
 * 
 * @export
 * @interface TaxPostalCode
 */
export interface TaxPostalCode {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxPostalCode
     */
    accounting_code?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxPostalCode
     */
    city_oid?: number;
    /**
     * Flag instructing engine to not collect postal code tax for this postal code
     * @type {boolean}
     * @memberof TaxPostalCode
     */
    dont_collect_postal_code?: boolean;
    /**
     * Postal Code (5 digits)
     * @type {string}
     * @memberof TaxPostalCode
     */
    postal_code?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxPostalCode
     */
    postal_code_oid?: number;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxPostalCode
     */
    tax_rate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxPostalCode
     */
    tax_rate_formatted?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderActivateResult
 */
export interface TaxProviderActivateResult {
    /**
     * 
     * @type {string}
     * @memberof TaxProviderActivateResult
     */
    details?: string;
    /**
     * True if the connection was successful
     * @type {boolean}
     * @memberof TaxProviderActivateResult
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface TaxProviderAvalara
 */
export interface TaxProviderAvalara {
    /**
     * 
     * @type {AvalaraConfig}
     * @memberof TaxProviderAvalara
     */
    configuration?: AvalaraConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderAvalara
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderAvalara
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderAvalara
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderAvalaraCompaniesResult
 */
export interface TaxProviderAvalaraCompaniesResult {
    /**
     * Tax companies configured by the merchant
     * @type {Array<TaxProviderAvalaraCompany>}
     * @memberof TaxProviderAvalaraCompaniesResult
     */
    companies?: Array<TaxProviderAvalaraCompany>;
}

/**
 * 
 * @export
 * @interface TaxProviderAvalaraCompany
 */
export interface TaxProviderAvalaraCompany {
    /**
     * Company code
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    company_code?: string;
    /**
     * Company name
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    company_name?: string;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderAvalaraCompany
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderAvalaraCompany
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderSelf
 */
export interface TaxProviderSelf {
    /**
     * 
     * @type {SelfConfig}
     * @memberof TaxProviderSelf
     */
    configuration?: SelfConfig;
    /**
     * Countries that collect sales tax
     * @type {Array<TaxCountry>}
     * @memberof TaxProviderSelf
     */
    countries?: Array<TaxCountry>;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderSelf
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderSelf
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderSelf
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderSelfCountriesResponse
 */
export interface TaxProviderSelfCountriesResponse {
    /**
     * countries
     * @type {Array<TaxCountryCode>}
     * @memberof TaxProviderSelfCountriesResponse
     */
    countries?: Array<TaxCountryCode>;
}

/**
 * 
 * @export
 * @interface TaxProviderSelfRegionsResponse
 */
export interface TaxProviderSelfRegionsResponse {
    /**
     * regions
     * @type {Array<TaxStateCode>}
     * @memberof TaxProviderSelfRegionsResponse
     */
    regions?: Array<TaxStateCode>;
}

/**
 * 
 * @export
 * @interface TaxProviderSovos
 */
export interface TaxProviderSovos {
    /**
     * 
     * @type {SovosConfig}
     * @memberof TaxProviderSovos
     */
    configuration?: SovosConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderSovos
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderSovos
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderSovos
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderTaxJar
 */
export interface TaxProviderTaxJar {
    /**
     * 
     * @type {TaxJarConfig}
     * @memberof TaxProviderTaxJar
     */
    configuration?: TaxJarConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderTaxJar
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderTaxJar
     */
    selected?: boolean;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderTaxJar
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderTestResult
 */
export interface TaxProviderTestResult {
    /**
     * 
     * @type {string}
     * @memberof TaxProviderTestResult
     */
    details?: string;
    /**
     * True if the connection was successful
     * @type {boolean}
     * @memberof TaxProviderTestResult
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface TaxProviderUltraCart
 */
export interface TaxProviderUltraCart {
    /**
     * 
     * @type {UltraCartConfig}
     * @memberof TaxProviderUltraCart
     */
    configuration?: UltraCartConfig;
    /**
     * Description
     * @type {string}
     * @memberof TaxProviderUltraCart
     */
    description?: string;
    /**
     * Selected
     * @type {boolean}
     * @memberof TaxProviderUltraCart
     */
    selected?: boolean;
    /**
     * States in the union showing their management status
     * @type {Array<TaxProviderUltraCartState>}
     * @memberof TaxProviderUltraCart
     */
    states?: Array<TaxProviderUltraCartState>;
    /**
     * Title
     * @type {string}
     * @memberof TaxProviderUltraCart
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface TaxProviderUltraCartState
 */
export interface TaxProviderUltraCartState {
    /**
     * True if this state taxes are managed by UltraCart
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    enabled?: boolean;
    /**
     * State Code (2 digits)
     * @type {string}
     * @memberof TaxProviderUltraCartState
     */
    state_code?: string;
    /**
     * Fully spelled out state name
     * @type {string}
     * @memberof TaxProviderUltraCartState
     */
    state_name?: string;
    /**
     * True if gift charges should be taxed in this state.
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    tax_gift_charge?: boolean;
    /**
     * True if gift wrap should be taxed in this state.
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    tax_gift_wrap?: boolean;
    /**
     * State tax rate formatted for display
     * @type {string}
     * @memberof TaxProviderUltraCartState
     */
    tax_rate_formatted?: string;
    /**
     * True if shipping should be taxed in this state.
     * @type {boolean}
     * @memberof TaxProviderUltraCartState
     */
    tax_shipping?: boolean;
}

/**
 * 
 * @export
 * @interface TaxProvidersResponse
 */
export interface TaxProvidersResponse {
    /**
     * 
     * @type {TaxProviderAvalara}
     * @memberof TaxProvidersResponse
     */
    avalara?: TaxProviderAvalara;
    /**
     * 
     * @type {ModelError}
     * @memberof TaxProvidersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TaxProvidersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * 
     * @type {TaxProviderSelf}
     * @memberof TaxProvidersResponse
     */
    self?: TaxProviderSelf;
    /**
     * 
     * @type {TaxProviderSovos}
     * @memberof TaxProvidersResponse
     */
    sovos?: TaxProviderSovos;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TaxProvidersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {TaxProviderTaxJar}
     * @memberof TaxProvidersResponse
     */
    taxjar?: TaxProviderTaxJar;
    /**
     * 
     * @type {TaxProviderUltraCart}
     * @memberof TaxProvidersResponse
     */
    ultracart?: TaxProviderUltraCart;
    /**
     * 
     * @type {Warning}
     * @memberof TaxProvidersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TaxState
 */
export interface TaxState {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxState
     */
    accounting_code?: string;
    /**
     * Counties within this state
     * @type {Array<TaxCounty>}
     * @memberof TaxState
     */
    counties?: Array<TaxCounty>;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxState
     */
    country_oid?: number;
    /**
     * Flag instructing engine to not collect city tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dont_collect_city?: boolean;
    /**
     * Flag instructing engine to not collect county tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dont_collect_county?: boolean;
    /**
     * Flag instructing engine to not collect postal code tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dont_collect_postal_code?: boolean;
    /**
     * Flag instructing engine to not collect state tax for this state
     * @type {boolean}
     * @memberof TaxState
     */
    dont_collect_state?: boolean;
    /**
     * State code
     * @type {string}
     * @memberof TaxState
     */
    state_code?: string;
    /**
     * Tax record object identifier used internally by database
     * @type {number}
     * @memberof TaxState
     */
    state_oid?: number;
    /**
     * True if taxation within this jurisdiction should charge tax on gift charge
     * @type {boolean}
     * @memberof TaxState
     */
    tax_gift_charge?: boolean;
    /**
     * True if taxation within this jurisdiction should charge tax on gift wrap
     * @type {boolean}
     * @memberof TaxState
     */
    tax_gift_wrap?: boolean;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxState
     */
    tax_rate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxState
     */
    tax_rate_formatted?: string;
    /**
     * True if taxation within this jurisdiction should charge tax on shipping
     * @type {boolean}
     * @memberof TaxState
     */
    tax_shipping?: boolean;
    /**
     * If true, use UltraCart managed rates for this state
     * @type {boolean}
     * @memberof TaxState
     */
    use_ultracart_managed_rates?: boolean;
}

/**
 * 
 * @export
 * @interface TaxStateCode
 */
export interface TaxStateCode {
    /**
     * Accounting code for programs such as QuickBooks
     * @type {string}
     * @memberof TaxStateCode
     */
    accounting_code?: string;
    /**
     * State code (2 characters
     * @type {string}
     * @memberof TaxStateCode
     */
    state_code?: string;
    /**
     * State name
     * @type {string}
     * @memberof TaxStateCode
     */
    state_name?: string;
    /**
     * Tax Rate
     * @type {number}
     * @memberof TaxStateCode
     */
    tax_rate?: number;
    /**
     * Tax rate formatted
     * @type {string}
     * @memberof TaxStateCode
     */
    tax_rate_formatted?: string;
}

/**
 * 
 * @export
 * @interface TempMultimedia
 */
export interface TempMultimedia {
    /**
     * Filename
     * @type {string}
     * @memberof TempMultimedia
     */
    filename?: string;
    /**
     * Height
     * @type {number}
     * @memberof TempMultimedia
     */
    height?: number;
    /**
     * Multimedia type
     * @type {string}
     * @memberof TempMultimedia
     */
    multimedia_type?: TempMultimedia.MultimediaTypeEnum;
    /**
     * Size
     * @type {number}
     * @memberof TempMultimedia
     */
    size?: number;
    /**
     * Temporary multimedia object identifier
     * @type {number}
     * @memberof TempMultimedia
     */
    temp_multimedia_oid?: number;
    /**
     * URL
     * @type {string}
     * @memberof TempMultimedia
     */
    url?: string;
    /**
     * Width
     * @type {number}
     * @memberof TempMultimedia
     */
    width?: number;
}

/**
 * @export
 * @namespace TempMultimedia
 */
export namespace TempMultimedia {
    /**
     * @export
     * @enum {string}
     */
    export enum MultimediaTypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Video = <any> 'Video'
    }
}

/**
 * 
 * @export
 * @interface TempMultimediaResponse
 */
export interface TempMultimediaResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof TempMultimediaResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TempMultimediaResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TempMultimediaResponse
     */
    success?: boolean;
    /**
     * 
     * @type {TempMultimedia}
     * @memberof TempMultimediaResponse
     */
    temp_multimedia?: TempMultimedia;
    /**
     * 
     * @type {Warning}
     * @memberof TempMultimediaResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface ThumbnailParametersRequest
 */
export interface ThumbnailParametersRequest {
    /**
     * 
     * @type {number}
     * @memberof ThumbnailParametersRequest
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailParametersRequest
     */
    pngFormat?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailParametersRequest
     */
    squareThumbnail?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ThumbnailParametersRequest
     */
    webp?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ThumbnailParametersRequest
     */
    width?: number;
}

/**
 * 
 * @export
 * @interface ThumbnailParametersResponse
 */
export interface ThumbnailParametersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof ThumbnailParametersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof ThumbnailParametersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof ThumbnailParametersResponse
     */
    success?: boolean;
    /**
     * Suffix to append to the larger image URL to obtain the thumbnail
     * @type {string}
     * @memberof ThumbnailParametersResponse
     */
    thumbnail_url_suffix?: string;
    /**
     * 
     * @type {Warning}
     * @memberof ThumbnailParametersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TransactionEmail
 */
export interface TransactionEmail {
    /**
     * Actual template contents
     * @type {string}
     * @memberof TransactionEmail
     */
    content?: string;
    /**
     * The uuid of the sending domain
     * @type {string}
     * @memberof TransactionEmail
     */
    esp_domain_uuid?: string;
    /**
     * Friendly from that will appear in customer email clients.
     * @type {string}
     * @memberof TransactionEmail
     */
    esp_friendly_name?: string;
    /**
     * The username of the sending email.  This is not the full email.  Only the username which is everything before the @ sign.
     * @type {string}
     * @memberof TransactionEmail
     */
    esp_user?: string;
    /**
     * An internal identifier used to aid in retrieving templates from the filesystem.
     * @type {boolean}
     * @memberof TransactionEmail
     */
    file_exists?: boolean;
    /**
     * File name
     * @type {string}
     * @memberof TransactionEmail
     */
    file_name?: string;
    /**
     * Group
     * @type {string}
     * @memberof TransactionEmail
     */
    group?: string;
    /**
     * Handlebar Variables available for email template
     * @type {Array<string>}
     * @memberof TransactionEmail
     */
    handlebar_variables?: Array<string>;
    /**
     * Invalid will be true if the template cannot compile
     * @type {boolean}
     * @memberof TransactionEmail
     */
    invalid?: boolean;
    /**
     * Last modified timestamp
     * @type {string}
     * @memberof TransactionEmail
     */
    last_modified?: string;
    /**
     * If this item was ever added to the Code Library, this is the oid for that library item, or 0 if never added before.  This value is used to determine if a library item should be inserted or updated.
     * @type {number}
     * @memberof TransactionEmail
     */
    library_item_oid?: number;
    /**
     * Options that help govern how and when this template is used
     * @type {Array<TransactionEmailOption>}
     * @memberof TransactionEmail
     */
    options?: Array<TransactionEmailOption>;
    /**
     * directory path where template is stored in file system
     * @type {string}
     * @memberof TransactionEmail
     */
    path?: string;
    /**
     * Size of file in friendly description
     * @type {string}
     * @memberof TransactionEmail
     */
    size?: string;
    /**
     * Internal identifier used to store and retrieve template from filesystem
     * @type {number}
     * @memberof TransactionEmail
     */
    store_front_fs_directory_oid?: number;
    /**
     * Internal identifier used to store and retrieve template from filesystem
     * @type {number}
     * @memberof TransactionEmail
     */
    store_front_fs_file_oid?: number;
    /**
     * Subject
     * @type {string}
     * @memberof TransactionEmail
     */
    subject?: string;
    /**
     * Any syntax errors contained within the tempalate
     * @type {string}
     * @memberof TransactionEmail
     */
    syntax_errors?: string;
    /**
     * Internal value used to locate the template in the filesystem
     * @type {string}
     * @memberof TransactionEmail
     */
    template_path_relative_path?: string;
    /**
     * Theme relative path in the filesystem.
     * @type {string}
     * @memberof TransactionEmail
     */
    theme_relative_path?: string;
}

/**
 * 
 * @export
 * @interface TransactionEmailListResponse
 */
export interface TransactionEmailListResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionEmailListResponse
     */
    email_names?: Array<string>;
    /**
     * 
     * @type {ModelError}
     * @memberof TransactionEmailListResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TransactionEmailListResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TransactionEmailListResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof TransactionEmailListResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TransactionEmailOption
 */
export interface TransactionEmailOption {
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionEmailOption
     */
    merchantEmailDeliveryOptionOid?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    merchantId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionEmailOption
     */
    selected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionEmailOption
     */
    storeFrontOid?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    templateDisplay?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionEmailOption
     */
    templateType?: string;
}

/**
 * 
 * @export
 * @interface TransactionEmailResponse
 */
export interface TransactionEmailResponse {
    /**
     * 
     * @type {TransactionEmail}
     * @memberof TransactionEmailResponse
     */
    email?: TransactionEmail;
    /**
     * 
     * @type {ModelError}
     * @memberof TransactionEmailResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TransactionEmailResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TransactionEmailResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof TransactionEmailResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TransactionGateway
 */
export interface TransactionGateway {
    /**
     * Additional html to display for this transaction gateway.  This html will include instructions and connection links
     * @type {string}
     * @memberof TransactionGateway
     */
    arbitrary_html?: string;
    /**
     * Additional comments
     * @type {string}
     * @memberof TransactionGateway
     */
    comment?: string;
    /**
     * True if this gateway supports credit cards
     * @type {boolean}
     * @memberof TransactionGateway
     */
    credit_card_capable?: boolean;
    /**
     * True if this gateway supports eChecks
     * @type {boolean}
     * @memberof TransactionGateway
     */
    echeck_capable?: boolean;
    /**
     * True if this gateway supports eChecks
     * @type {string}
     * @memberof TransactionGateway
     */
    echeck_supported?: string;
    /**
     * True if this transaction gateway is the currently active gateway.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    enabled?: boolean;
    /**
     * Cryptographic public certificate allowing UltraCart to communicate securely with this gateway.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_cert_pem?: string;
    /**
     * The label for the gateway certificate pem.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_cert_pem_label?: string;
    /**
     * Gateway Email
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_email?: string;
    /**
     * The label for the gateway email.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_email_label?: string;
    /**
     * Gateway Environment to indicate sandbox versus production environments
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_environment?: string;
    /**
     * The label for the gateway environment.  The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_environment_label?: string;
    /**
     * Used to populate drop down lists for the gateway environment.  Varies by gateway.
     * @type {Array<string>}
     * @memberof TransactionGateway
     */
    gateway_environments?: Array<string>;
    /**
     * Optional Look and feel setting for Verified-by-VISA.  Only needed if you are using 3DS
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_header_back_color?: string;
    /**
     * Optional Look and feel setting for Verified-by-VISA.  Only needed if you are using 3DS
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_header_border_color?: string;
    /**
     * Optional Look and feel setting for Verified-by-VISA.  Only needed if you are using 3DS
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_header_image_url?: string;
    /**
     * Gateway Key
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_key?: string;
    /**
     * The label for the gateway key.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_key_label?: string;
    /**
     * Cryptographic private key allowing UltraCart to communicate securely with this gateway.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_key_pem?: string;
    /**
     * The label for the gateway key pem.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_key_pem_label?: string;
    /**
     * Optional Look and feel setting for Verified-by-VISA.  Only needed if you are using 3DS
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_landing_page?: string;
    /**
     * Gateway Merchant ID
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_merchant_id?: string;
    /**
     * The label for the gateway merchant id.  The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_merchant_id_label?: string;
    /**
     * Gateway Mode
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_mode?: string;
    /**
     * The label for the gateway mode.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_mode_label?: string;
    /**
     * Used to populate drop down lists for gateway modes
     * @type {Array<string>}
     * @memberof TransactionGateway
     */
    gateway_modes?: Array<string>;
    /**
     * Gateway Page Style
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_page_style?: string;
    /**
     * Gateway page style label
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_page_style_label?: string;
    /**
     * Used to populate drop down lists for gateway page style
     * @type {Array<string>}
     * @memberof TransactionGateway
     */
    gateway_page_styles?: Array<string>;
    /**
     * Gateway Partner
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_partner?: string;
    /**
     * The label for the gateway partner.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_partner_label?: string;
    /**
     * Gateway Password
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_password?: string;
    /**
     * The label for the gateway password.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_password_label?: string;
    /**
     * Optional Look and feel setting for Verified-by-VISA.  Only needed if you are using 3DS
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_payflow_color?: string;
    /**
     * Gateway private key password
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_private_key_password?: string;
    /**
     * The label for the gateway private key password.  The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_private_key_password_label?: string;
    /**
     * Optional Look and feel setting for Verified-by-VISA.  Only needed if you are using 3DS
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_solution_type?: string;
    /**
     * The label for the gateway solution type.  The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_solution_type_label?: string;
    /**
     * Used to populate drop down lists for gateway solution types
     * @type {Array<string>}
     * @memberof TransactionGateway
     */
    gateway_solution_types?: Array<string>;
    /**
     * Gateway URL
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_url?: string;
    /**
     * The label for the gateway url.   The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_url_label?: string;
    /**
     * Gateway Username
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_username?: string;
    /**
     * The label for the gateway username.  The actual value stored may vary by gateway, so the label will vary too.
     * @type {string}
     * @memberof TransactionGateway
     */
    gateway_username_label?: string;
    /**
     * If a merchant has multiple card processing accounts, this is the one to use for American Express cards.
     * @type {string}
     * @memberof TransactionGateway
     */
    merchant_account_profile_amex?: string;
    /**
     * If a merchant has multiple card processing accounts, this is the one to use for Diners Club cards.
     * @type {string}
     * @memberof TransactionGateway
     */
    merchant_account_profile_diners_club?: string;
    /**
     * If a merchant has multiple card processing accounts, this is the one to use for Discover cards.
     * @type {string}
     * @memberof TransactionGateway
     */
    merchant_account_profile_discover?: string;
    /**
     * If a merchant has multiple card processing accounts, this is the one to use for JCB cards.
     * @type {string}
     * @memberof TransactionGateway
     */
    merchant_account_profile_jcb?: string;
    /**
     * If a merchant has multiple card processing accounts, this is the one to use for MasterCard cards.
     * @type {string}
     * @memberof TransactionGateway
     */
    merchant_account_profile_mastercard?: string;
    /**
     * If a merchant has multiple card processing accounts, this is the one to use for VISA cards.
     * @type {string}
     * @memberof TransactionGateway
     */
    merchant_account_profile_visa?: string;
    /**
     * UltraCart Merchant ID
     * @type {string}
     * @memberof TransactionGateway
     */
    merchant_id?: string;
    /**
     * True if this gateway provides details for multiple currency transactions
     * @type {boolean}
     * @memberof TransactionGateway
     */
    multi_currency_details?: boolean;
    /**
     * Name of this transaction gateway
     * @type {string}
     * @memberof TransactionGateway
     */
    name?: string;
    /**
     * True if this gateway supports refunds
     * @type {boolean}
     * @memberof TransactionGateway
     */
    refund_supported?: boolean;
    /**
     * If true, e-Check transaction will require either a Tax ID or a Driver License
     * @type {boolean}
     * @memberof TransactionGateway
     */
    require_echeck_tax_id_or_drivers_license?: boolean;
    /**
     * True if this gateway supported Verified-by-VISA 3D Secure
     * @type {boolean}
     * @memberof TransactionGateway
     */
    support_vbv_3ds?: boolean;
    /**
     * If true, this gateway will attempt to process American Express transactions.  If false, the customer will not be allowed to use this type of Credit Card.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_amex?: boolean;
    /**
     * If true, this gateway will attempt to process Diners Club transactions.  If false, the customer will not be allowed to use this type of Credit Card.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_diners_club?: boolean;
    /**
     * If true, this gateway will attempt to process Discover transactions.  If false, the customer will not be allowed to use this type of Credit Card.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_discover?: boolean;
    /**
     * If true, this gateway will attempt to process e-Check transactions.  If false, the customer will not be allowed to use e-Checks.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_echeck?: boolean;
    /**
     * if true, this gateway will attempt to process electronic gift cards.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_electronic_gift_card?: boolean;
    /**
     * If true, this gateway will attempt to process JCB transactions.  If false, the customer will not be allowed to use this type of Credit Card.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_jcb?: boolean;
    /**
     * If true, this gateway will attempt to process MasterCard transactions.  If false, the customer will not be allowed to use this type of Credit Card.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_mastercard?: boolean;
    /**
     * If true, this gateway will attempt to process VISA transactions.  If false, the customer will not be allowed to use this type of Credit Card.
     * @type {boolean}
     * @memberof TransactionGateway
     */
    supports_visa?: boolean;
    /**
     * True if this gateway supports third parties
     * @type {boolean}
     * @memberof TransactionGateway
     */
    third_party?: boolean;
}

/**
 * 
 * @export
 * @interface TransactionGatewaysRequest
 */
export interface TransactionGatewaysRequest {
    /**
     * The default transaction type for this merchant account
     * @type {string}
     * @memberof TransactionGatewaysRequest
     */
    default_credit_card_transaction_type?: TransactionGatewaysRequest.DefaultCreditCardTransactionTypeEnum;
    /**
     * 
     * @type {Array<TransactionGateway>}
     * @memberof TransactionGatewaysRequest
     */
    gateways?: Array<TransactionGateway>;
    /**
     * A list of the storefronts and themes for this merchant account and what type of transaction should be attempted
     * @type {Array<PaymentsThemeTransactionType>}
     * @memberof TransactionGatewaysRequest
     */
    theme_credit_card_transaction_types?: Array<PaymentsThemeTransactionType>;
}

/**
 * @export
 * @namespace TransactionGatewaysRequest
 */
export namespace TransactionGatewaysRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum DefaultCreditCardTransactionTypeEnum {
        AndCapture = <any> 'auth and capture',
        ThenCapture = <any> 'auth then capture',
        Only = <any> 'auth only'
    }
}

/**
 * 
 * @export
 * @interface TransactionGatewaysResponse
 */
export interface TransactionGatewaysResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof TransactionGatewaysResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {Array<TransactionGateway>}
     * @memberof TransactionGatewaysResponse
     */
    gateways?: Array<TransactionGateway>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TransactionGatewaysResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TransactionGatewaysResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof TransactionGatewaysResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface Twilio
 */
export interface Twilio {
    /**
     * 
     * @type {string}
     * @memberof Twilio
     */
    account_sid?: string;
    /**
     * 
     * @type {string}
     * @memberof Twilio
     */
    auth_token?: string;
    /**
     * 
     * @type {string}
     * @memberof Twilio
     */
    esp_twilio_uuid?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Twilio
     */
    phone_numbers?: Array<string>;
}

/**
 * 
 * @export
 * @interface TwilioResponse
 */
export interface TwilioResponse {
    /**
     * 
     * @type {string}
     * @memberof TwilioResponse
     */
    diagnostics?: string;
    /**
     * 
     * @type {ModelError}
     * @memberof TwilioResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TwilioResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TwilioResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Twilio}
     * @memberof TwilioResponse
     */
    twilio?: Twilio;
    /**
     * 
     * @type {Warning}
     * @memberof TwilioResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface TwiliosResponse
 */
export interface TwiliosResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof TwiliosResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof TwiliosResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof TwiliosResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<Twilio>}
     * @memberof TwiliosResponse
     */
    twilios?: Array<Twilio>;
    /**
     * 
     * @type {Warning}
     * @memberof TwiliosResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface UltraCartConfig
 */
export interface UltraCartConfig {
    /**
     * True if sales tax should be collected based on billing address instead of shipping address
     * @type {boolean}
     * @memberof UltraCartConfig
     */
    tax_billing?: boolean;
}

/**
 * 
 * @export
 * @interface UploadCouponCodesRequest
 */
export interface UploadCouponCodesRequest {
    /**
     * Coupon codes
     * @type {Array<string>}
     * @memberof UploadCouponCodesRequest
     */
    coupon_codes?: Array<string>;
    /**
     * 
     * @type {ModelError}
     * @memberof UploadCouponCodesRequest
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UploadCouponCodesRequest
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UploadCouponCodesRequest
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof UploadCouponCodesRequest
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface UploadCouponCodesResponse
 */
export interface UploadCouponCodesResponse {
    /**
     * Duplicate codes
     * @type {Array<string>}
     * @memberof UploadCouponCodesResponse
     */
    duplicate_codes?: Array<string>;
    /**
     * 
     * @type {ModelError}
     * @memberof UploadCouponCodesResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UploadCouponCodesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Rejected codes
     * @type {Array<string>}
     * @memberof UploadCouponCodesResponse
     */
    rejected_codes?: Array<string>;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UploadCouponCodesResponse
     */
    success?: boolean;
    /**
     * Uploaded codes
     * @type {Array<string>}
     * @memberof UploadCouponCodesResponse
     */
    uploaded_codes?: Array<string>;
    /**
     * 
     * @type {Warning}
     * @memberof UploadCouponCodesResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * A list of IP addresses whitelisted for any user with API Access permission.  Without this list, each ip address must be authenticated by a user, which can be a pain for some servers.
     * @type {Array<string>}
     * @memberof User
     */
    api_ip_address_masks?: Array<string>;
    /**
     * Supply a new FTP password using this field.  Password are stored using one-way encryption, so they are never available anywhere in the system.  The FTP password cannot be the same as the normal password.
     * @type {string}
     * @memberof User
     */
    change_ftp_password_to?: string;
    /**
     * Supply a new password using this field.  Password are stored using one-way encryption, so they are never available anywhere in the system.
     * @type {string}
     * @memberof User
     */
    change_password_to?: string;
    /**
     * Email address of user
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Full name of user.  This is used solely for human assistance and so the UltraCart staff knows who they are calling when there is a problem.
     * @type {string}
     * @memberof User
     */
    full_name?: string;
    /**
     * A list of groups for this merchant and whether or not this user is a member of those groups.
     * @type {Array<UserGroupMembership>}
     * @memberof User
     */
    groups?: Array<UserGroupMembership>;
    /**
     * A list of linked accounts and whether or not this user is mirrored to any of those accounts.
     * @type {Array<LinkedAccount>}
     * @memberof User
     */
    linked_accounts?: Array<LinkedAccount>;
    /**
     * User name of user.  Must be unique across a merchant account.
     * @type {string}
     * @memberof User
     */
    login?: string;
    /**
     * A list of user logins over the past 90 days
     * @type {Array<UserLogin>}
     * @memberof User
     */
    login_histories?: Array<UserLogin>;
    /**
     * A list of notifications the user receives.
     * @type {Array<Notification>}
     * @memberof User
     */
    notifications?: Array<Notification>;
    /**
     * OTP Serial Number such as Google Authenticator or Crypto Card.
     * @type {string}
     * @memberof User
     */
    otp_serial_number?: string;
    /**
     * A list of permissions the user enjoys for accessing the backend of UltraCart.
     * @type {Array<Permission>}
     * @memberof User
     */
    permissions?: Array<Permission>;
    /**
     * Phone number of user.  Please supply a valid phone number.  When something breaks on your account, we need to be able to reach you.
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * User id is a unique identifier for this user
     * @type {number}
     * @memberof User
     */
    user_id?: number;
}

/**
 * 
 * @export
 * @interface UserGroupMembership
 */
export interface UserGroupMembership {
    /**
     * The unique object identifier (oid for short) for this group
     * @type {number}
     * @memberof UserGroupMembership
     */
    group_oid?: number;
    /**
     * True if this user is a member of the group.
     * @type {boolean}
     * @memberof UserGroupMembership
     */
    member?: boolean;
    /**
     * The name of this group.
     * @type {string}
     * @memberof UserGroupMembership
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
    /**
     * IP Address
     * @type {string}
     * @memberof UserLogin
     */
    ip_address?: string;
    /**
     * login
     * @type {string}
     * @memberof UserLogin
     */
    login?: string;
    /**
     * Login date/time
     * @type {string}
     * @memberof UserLogin
     */
    login_dts?: string;
    /**
     * User Agent
     * @type {string}
     * @memberof UserLogin
     */
    user_agent?: string;
}

/**
 * 
 * @export
 * @interface UserLoginsResponse
 */
export interface UserLoginsResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof UserLoginsResponse
     */
    error?: ModelError;
    /**
     * Logins
     * @type {Array<UserLogin>}
     * @memberof UserLoginsResponse
     */
    logins?: Array<UserLogin>;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UserLoginsResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UserLoginsResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof UserLoginsResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof UserResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UserResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UserResponse
     */
    success?: boolean;
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    user?: User;
    /**
     * 
     * @type {Warning}
     * @memberof UserResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof UsersResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof UsersResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof UsersResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersResponse
     */
    users?: Array<User>;
    /**
     * 
     * @type {Warning}
     * @memberof UsersResponse
     */
    warning?: Warning;
}

/**
 * 
 * @export
 * @interface VerificationRecord
 */
export interface VerificationRecord {
    /**
     * 
     * @type {string}
     * @memberof VerificationRecord
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationRecord
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof VerificationRecord
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface Warning
 */
export interface Warning {
    /**
     * Additional information often a link to additional documentation
     * @type {string}
     * @memberof Warning
     */
    more_info?: string;
    /**
     * A technical message meant to be read by a developer
     * @type {string}
     * @memberof Warning
     */
    warning_message?: string;
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Populated if webhook associated with an API user
     * @type {number}
     * @memberof Webhook
     */
    api_user_oid?: number;
    /**
     * Version of the API objects that are sent in notifications
     * @type {string}
     * @memberof Webhook
     */
    api_version?: Webhook.ApiVersionEnum;
    /**
     * 
     * @type {ApiUserApplicationProfile}
     * @memberof Webhook
     */
    application_profile?: ApiUserApplicationProfile;
    /**
     * The type of authentication this webhook will use when communicating with your server
     * @type {string}
     * @memberof Webhook
     */
    authentication_type?: Webhook.AuthenticationTypeEnum;
    /**
     * Basic authentication password
     * @type {string}
     * @memberof Webhook
     */
    basic_password?: string;
    /**
     * Basic authentication user name
     * @type {string}
     * @memberof Webhook
     */
    basic_username?: string;
    /**
     * The number of consecutive failures that have occurred trying to deliver notifications to the target server
     * @type {number}
     * @memberof Webhook
     */
    consecutive_failures?: number;
    /**
     * True if the webhook has been disabled
     * @type {boolean}
     * @memberof Webhook
     */
    disabled?: boolean;
    /**
     * The categories of events.  Individual events and subscriptions are handled in the child objects.  _placeholders parameter effects the population of this on a retrieval.
     * @type {Array<WebhookEventCategory>}
     * @memberof Webhook
     */
    event_categories?: Array<WebhookEventCategory>;
    /**
     * IAM Access Key for AWS SQS Delivery
     * @type {string}
     * @memberof Webhook
     */
    iam_access_key?: string;
    /**
     * IAM Secret Key for AWS SQS Delivery
     * @type {string}
     * @memberof Webhook
     */
    iam_secret_key?: string;
    /**
     * The maximum number of events in the payload that UltraCart will deliver
     * @type {number}
     * @memberof Webhook
     */
    maximum_events?: number;
    /**
     * The maximum size of the payload that UltraCart will deliver
     * @type {number}
     * @memberof Webhook
     */
    maximum_size?: number;
    /**
     * The UltraCart merchant ID that owns this webhook
     * @type {string}
     * @memberof Webhook
     */
    merchant_id?: string;
    /**
     * The next time UltraCart will attempt delivery if failures have been occurring
     * @type {string}
     * @memberof Webhook
     */
    next_retry_after?: string;
    /**
     * The number of pending events for this webhook
     * @type {number}
     * @memberof Webhook
     */
    pending?: number;
    /**
     * The object identifier for this webhook
     * @type {number}
     * @memberof Webhook
     */
    webhook_oid?: number;
    /**
     * The URL to deliver events to.  Must be HTTPS for customer related information.
     * @type {string}
     * @memberof Webhook
     */
    webhook_url?: string;
}

/**
 * @export
 * @namespace Webhook
 */
export namespace Webhook {
    /**
     * @export
     * @enum {string}
     */
    export enum ApiVersionEnum {
        _20170301 = <any> '2017-03-01'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AuthenticationTypeEnum {
        None = <any> 'none',
        Basic = <any> 'basic'
    }
}

/**
 * 
 * @export
 * @interface WebhookEventCategory
 */
export interface WebhookEventCategory {
    /**
     * True if any events are subscribed to.
     * @type {boolean}
     * @memberof WebhookEventCategory
     */
    any_subscribed?: boolean;
    /**
     * Array of available expansion constants
     * @type {Array<string>}
     * @memberof WebhookEventCategory
     */
    available_expansions?: Array<string>;
    /**
     * Name of the event category
     * @type {string}
     * @memberof WebhookEventCategory
     */
    event_category?: string;
    /**
     * The events within the category.  Individual subscription flags contained within the child object.
     * @type {Array<WebhookEventSubscription>}
     * @memberof WebhookEventCategory
     */
    events?: Array<WebhookEventSubscription>;
    /**
     * True if all the events within this category are subscribed.  This is a convenience flag to make user interfaces easier.
     * @type {boolean}
     * @memberof WebhookEventCategory
     */
    subscribed?: boolean;
}

/**
 * 
 * @export
 * @interface WebhookEventSubscription
 */
export interface WebhookEventSubscription {
    /**
     * Comment about the event to provide further clarification to the end user
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    comments?: string;
    /**
     * True if the event is deprecated.  See the API change log for details on when it will be discontinued.
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    deprecated_flag?: boolean;
    /**
     * True if the event is discontinued.  See the API change log for details on migration details.
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    discontinued_flag?: boolean;
    /**
     * Description of the event
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    event_description?: string;
    /**
     * Event name
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    event_name?: string;
    /**
     * The expand string for the notification object.  See the individual resource _expand documentation for valid values.
     * @type {string}
     * @memberof WebhookEventSubscription
     */
    expansion?: string;
    /**
     * True if this is event is subscribed to
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    subscribed?: boolean;
    /**
     * True if the event can be triggered to reflow existing records
     * @type {boolean}
     * @memberof WebhookEventSubscription
     */
    supports_reflow?: boolean;
    /**
     * The webhook event object identifier
     * @type {number}
     * @memberof WebhookEventSubscription
     */
    webhook_event_oid?: number;
}

/**
 * 
 * @export
 * @interface WebhookLog
 */
export interface WebhookLog {
    /**
     * Date/time of delivery
     * @type {string}
     * @memberof WebhookLog
     */
    delivery_dts?: string;
    /**
     * Number of milliseconds to process the notification
     * @type {number}
     * @memberof WebhookLog
     */
    duration?: number;
    /**
     * Number of milliseconds of delay caused by queuing
     * @type {number}
     * @memberof WebhookLog
     */
    queue_delay?: number;
    /**
     * Request payload (first 100,000 characters)
     * @type {string}
     * @memberof WebhookLog
     */
    request?: string;
    /**
     * Request headers sent to the server
     * @type {Array<HTTPHeader>}
     * @memberof WebhookLog
     */
    request_headers?: Array<HTTPHeader>;
    /**
     * Request id is a unique string that you can look up in the logs
     * @type {string}
     * @memberof WebhookLog
     */
    request_id?: string;
    /**
     * Response payload (first 100,000 characters)
     * @type {string}
     * @memberof WebhookLog
     */
    response?: string;
    /**
     * Response headers received from the server
     * @type {Array<HTTPHeader>}
     * @memberof WebhookLog
     */
    response_headers?: Array<HTTPHeader>;
    /**
     * HTTP status code received from the server
     * @type {number}
     * @memberof WebhookLog
     */
    status_code?: number;
    /**
     * True if the delivery was successful
     * @type {boolean}
     * @memberof WebhookLog
     */
    success?: boolean;
    /**
     * URI of the webhook delivered to
     * @type {string}
     * @memberof WebhookLog
     */
    uri?: string;
}

/**
 * 
 * @export
 * @interface WebhookLogResponse
 */
export interface WebhookLogResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof WebhookLogResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookLogResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookLogResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookLogResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {WebhookLog}
     * @memberof WebhookLogResponse
     */
    webhook_log?: WebhookLog;
}

/**
 * 
 * @export
 * @interface WebhookLogSummariesResponse
 */
export interface WebhookLogSummariesResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof WebhookLogSummariesResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookLogSummariesResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookLogSummariesResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookLogSummariesResponse
     */
    warning?: Warning;
    /**
     * Webhook log summaries
     * @type {Array<WebhookLogSummary>}
     * @memberof WebhookLogSummariesResponse
     */
    webhook_log_summaries?: Array<WebhookLogSummary>;
}

/**
 * 
 * @export
 * @interface WebhookLogSummary
 */
export interface WebhookLogSummary {
    /**
     * Date/time of the delivery
     * @type {string}
     * @memberof WebhookLogSummary
     */
    delivery_dts?: string;
    /**
     * Request id
     * @type {string}
     * @memberof WebhookLogSummary
     */
    request_id?: string;
    /**
     * True if the notification was successful
     * @type {boolean}
     * @memberof WebhookLogSummary
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof WebhookResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookResponse
     */
    webhook?: Webhook;
}

/**
 * 
 * @export
 * @interface WebhookSampleRequest
 */
export interface WebhookSampleRequest {
    /**
     * Request
     * @type {string}
     * @memberof WebhookSampleRequest
     */
    request?: string;
    /**
     * Request headers
     * @type {Array<HTTPHeader>}
     * @memberof WebhookSampleRequest
     */
    request_headers?: Array<HTTPHeader>;
    /**
     * Request id
     * @type {string}
     * @memberof WebhookSampleRequest
     */
    request_id?: string;
    /**
     * URI to send request to
     * @type {string}
     * @memberof WebhookSampleRequest
     */
    uri?: string;
}

/**
 * 
 * @export
 * @interface WebhookSampleRequestResponse
 */
export interface WebhookSampleRequestResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof WebhookSampleRequestResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhookSampleRequestResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhookSampleRequestResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhookSampleRequestResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {WebhookSampleRequest}
     * @memberof WebhookSampleRequestResponse
     */
    webhook_sample_request?: WebhookSampleRequest;
}

/**
 * 
 * @export
 * @interface WebhooksResponse
 */
export interface WebhooksResponse {
    /**
     * 
     * @type {ModelError}
     * @memberof WebhooksResponse
     */
    error?: ModelError;
    /**
     * 
     * @type {ResponseMetadata}
     * @memberof WebhooksResponse
     */
    metadata?: ResponseMetadata;
    /**
     * Indicates if API call was successful
     * @type {boolean}
     * @memberof WebhooksResponse
     */
    success?: boolean;
    /**
     * 
     * @type {Warning}
     * @memberof WebhooksResponse
     */
    warning?: Warning;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhooksResponse
     */
    webhooks?: Array<Webhook>;
}

/**
 * 
 * @export
 * @interface Weight
 */
export interface Weight {
    /**
     * Unit of measure
     * @type {string}
     * @memberof Weight
     */
    uom?: Weight.UomEnum;
    /**
     * Weight
     * @type {number}
     * @memberof Weight
     */
    value?: number;
}

/**
 * @export
 * @namespace Weight
 */
export namespace Weight {
    /**
     * @export
     * @enum {string}
     */
    export enum UomEnum {
        KG = <any> 'KG',
        LB = <any> 'LB',
        OZ = <any> 'OZ'
    }
}


/**
 * AffiliateApi - fetch parameter creator
 * @export
 */
export const AffiliateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve clicks
         * @param {AffiliateClickQuery} click_query Click query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicksByQuery(click_query: AffiliateClickQuery, _limit?: number, _offset?: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'click_query' is not null or undefined
            if (click_query === null || click_query === undefined) {
                throw new RequiredError('click_query','Required parameter click_query was null or undefined when calling getClicksByQuery.');
            }
            const localVarPath = `/affiliate/clicks/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AffiliateClickQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(click_query || {}) : (click_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve ledger entries
         * @param {AffiliateLedgerQuery} ledger_query Ledger query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLedgersByQuery(ledger_query: AffiliateLedgerQuery, _limit?: number, _offset?: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'ledger_query' is not null or undefined
            if (ledger_query === null || ledger_query === undefined) {
                throw new RequiredError('ledger_query','Required parameter ledger_query was null or undefined when calling getLedgersByQuery.');
            }
            const localVarPath = `/affiliate/ledgers/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AffiliateLedgerQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ledger_query || {}) : (ledger_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AffiliateApi - functional programming interface
 * @export
 */
export const AffiliateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve clicks
         * @param {AffiliateClickQuery} click_query Click query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicksByQuery(click_query: AffiliateClickQuery, _limit?: number, _offset?: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AffiliateClicksResponse> {
            const localVarFetchArgs = AffiliateApiFetchParamCreator(configuration).getClicksByQuery(click_query, _limit, _offset, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve ledger entries
         * @param {AffiliateLedgerQuery} ledger_query Ledger query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLedgersByQuery(ledger_query: AffiliateLedgerQuery, _limit?: number, _offset?: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AffiliateLedgersResponse> {
            const localVarFetchArgs = AffiliateApiFetchParamCreator(configuration).getLedgersByQuery(ledger_query, _limit, _offset, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AffiliateApi - factory interface
 * @export
 */
export const AffiliateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve clicks
         * @param {AffiliateClickQuery} click_query Click query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicksByQuery(click_query: AffiliateClickQuery, _limit?: number, _offset?: number, _expand?: string, options?: any) {
            return AffiliateApiFp(configuration).getClicksByQuery(click_query, _limit, _offset, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve ledger entries
         * @param {AffiliateLedgerQuery} ledger_query Ledger query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLedgersByQuery(ledger_query: AffiliateLedgerQuery, _limit?: number, _offset?: number, _expand?: string, options?: any) {
            return AffiliateApiFp(configuration).getLedgersByQuery(ledger_query, _limit, _offset, _expand, options)(fetch, basePath);
        },
    };
};

/**
 * AffiliateApi - interface
 * @export
 * @interface AffiliateApi
 */
export interface AffiliateApiInterface {
    /**
     * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve clicks
     * @param {AffiliateClickQuery} click_query Click query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApiInterface
     */
    getClicksByQuery(click_query: AffiliateClickQuery, _limit?: number, _offset?: number, _expand?: string, options?: any): Promise<AffiliateClicksResponse>;

    /**
     * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve ledger entries
     * @param {AffiliateLedgerQuery} ledger_query Ledger query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApiInterface
     */
    getLedgersByQuery(ledger_query: AffiliateLedgerQuery, _limit?: number, _offset?: number, _expand?: string, options?: any): Promise<AffiliateLedgersResponse>;

}

/**
 * AffiliateApi - object-oriented interface
 * @export
 * @class AffiliateApi
 * @extends {BaseAPI}
 */
export class AffiliateApi extends BaseAPI implements AffiliateApiInterface {
    /**
     * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve clicks
     * @param {AffiliateClickQuery} click_query Click query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApi
     */
    public getClicksByQuery(click_query: AffiliateClickQuery, _limit?: number, _offset?: number, _expand?: string, options?: any) {
        return AffiliateApiFp(this.configuration).getClicksByQuery(click_query, _limit, _offset, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve ledger entries
     * @param {AffiliateLedgerQuery} ledger_query Ledger query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_expand] The object expansion to perform on the result.  Only option is link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliateApi
     */
    public getLedgersByQuery(ledger_query: AffiliateLedgerQuery, _limit?: number, _offset?: number, _expand?: string, options?: any) {
        return AffiliateApiFp(this.configuration).getLedgersByQuery(ledger_query, _limit, _offset, _expand, options)(this.fetch, this.basePath);
    }

}

/**
 * AutoOrderApi - fetch parameter creator
 * @export
 */
export const AutoOrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a single auto order using the specified auto order oid. 
         * @summary Retrieve an auto order by oid
         * @param {number} auto_order_oid The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrder(auto_order_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'auto_order_oid' is not null or undefined
            if (auto_order_oid === null || auto_order_oid === undefined) {
                throw new RequiredError('auto_order_oid','Required parameter auto_order_oid was null or undefined when calling getAutoOrder.');
            }
            const localVarPath = `/auto_order/auto_orders/{auto_order_oid}`
                .replace(`{${"auto_order_oid"}}`, encodeURIComponent(String(auto_order_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order by code
         * @param {string} auto_order_code The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByCode(auto_order_code: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'auto_order_code' is not null or undefined
            if (auto_order_code === null || auto_order_code === undefined) {
                throw new RequiredError('auto_order_code','Required parameter auto_order_code was null or undefined when calling getAutoOrderByCode.');
            }
            const localVarPath = `/auto_order/auto_orders/code/{auto_order_code}`
                .replace(`{${"auto_order_code"}}`, encodeURIComponent(String(auto_order_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order by order id
         * @param {string} reference_order_id The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByReferenceOrderId(reference_order_id: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'reference_order_id' is not null or undefined
            if (reference_order_id === null || reference_order_id === undefined) {
                throw new RequiredError('reference_order_id','Required parameter reference_order_id was null or undefined when calling getAutoOrderByReferenceOrderId.');
            }
            const localVarPath = `/auto_order/auto_orders/reference_order_id/{reference_order_id}`
                .replace(`{${"reference_order_id"}}`, encodeURIComponent(String(reference_order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {string} [auto_order_code] Auto order code
         * @param {string} [original_order_id] Original order id
         * @param {string} [first_name] First name
         * @param {string} [last_name] Last name
         * @param {string} [company] Company
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postal_code] Postal code
         * @param {string} [country_code] Country code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [original_order_date_begin] Original order date begin
         * @param {string} [original_order_date_end] Original order date end
         * @param {string} [next_shipment_date_begin] Next shipment date begin
         * @param {string} [next_shipment_date_end] Next shipment date end
         * @param {string} [card_type] Card type
         * @param {string} [item_id] Item ID
         * @param {string} [status] Status
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch auto orders that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrders(auto_order_code?: string, original_order_id?: string, first_name?: string, last_name?: string, company?: string, city?: string, state?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, original_order_date_begin?: string, original_order_date_end?: string, next_shipment_date_begin?: string, next_shipment_date_end?: string, card_type?: string, item_id?: string, status?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/auto_order/auto_orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (auto_order_code !== undefined) {
                localVarQueryParameter['auto_order_code'] = auto_order_code;
            }

            if (original_order_id !== undefined) {
                localVarQueryParameter['original_order_id'] = original_order_id;
            }

            if (first_name !== undefined) {
                localVarQueryParameter['first_name'] = first_name;
            }

            if (last_name !== undefined) {
                localVarQueryParameter['last_name'] = last_name;
            }

            if (company !== undefined) {
                localVarQueryParameter['company'] = company;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (postal_code !== undefined) {
                localVarQueryParameter['postal_code'] = postal_code;
            }

            if (country_code !== undefined) {
                localVarQueryParameter['country_code'] = country_code;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (original_order_date_begin !== undefined) {
                localVarQueryParameter['original_order_date_begin'] = original_order_date_begin;
            }

            if (original_order_date_end !== undefined) {
                localVarQueryParameter['original_order_date_end'] = original_order_date_end;
            }

            if (next_shipment_date_begin !== undefined) {
                localVarQueryParameter['next_shipment_date_begin'] = next_shipment_date_begin;
            }

            if (next_shipment_date_end !== undefined) {
                localVarQueryParameter['next_shipment_date_end'] = next_shipment_date_end;
            }

            if (card_type !== undefined) {
                localVarQueryParameter['card_type'] = card_type;
            }

            if (item_id !== undefined) {
                localVarQueryParameter['item_id'] = item_id;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_since !== undefined) {
                localVarQueryParameter['_since'] = _since;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve auto order batch
         * @param {AutoOrderQueryBatch} auto_order_batch Auto order batch
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersBatch(auto_order_batch: AutoOrderQueryBatch, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'auto_order_batch' is not null or undefined
            if (auto_order_batch === null || auto_order_batch === undefined) {
                throw new RequiredError('auto_order_batch','Required parameter auto_order_batch was null or undefined when calling getAutoOrdersBatch.');
            }
            const localVarPath = `/auto_order/auto_orders/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrderQueryBatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(auto_order_batch || {}) : (auto_order_batch || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders by query
         * @param {AutoOrderQuery} auto_order_query Auto order query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersByQuery(auto_order_query: AutoOrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'auto_order_query' is not null or undefined
            if (auto_order_query === null || auto_order_query === undefined) {
                throw new RequiredError('auto_order_query','Required parameter auto_order_query was null or undefined when calling getAutoOrdersByQuery.');
            }
            const localVarPath = `/auto_order/auto_orders/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrderQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(auto_order_query || {}) : (auto_order_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an auto order on the UltraCart account. 
         * @summary Update an auto order
         * @param {AutoOrder} auto_order Auto order to update
         * @param {number} auto_order_oid The auto order oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrder(auto_order: AutoOrder, auto_order_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'auto_order' is not null or undefined
            if (auto_order === null || auto_order === undefined) {
                throw new RequiredError('auto_order','Required parameter auto_order was null or undefined when calling updateAutoOrder.');
            }
            // verify required parameter 'auto_order_oid' is not null or undefined
            if (auto_order_oid === null || auto_order_oid === undefined) {
                throw new RequiredError('auto_order_oid','Required parameter auto_order_oid was null or undefined when calling updateAutoOrder.');
            }
            const localVarPath = `/auto_order/auto_orders/{auto_order_oid}`
                .replace(`{${"auto_order_oid"}}`, encodeURIComponent(String(auto_order_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(auto_order || {}) : (auto_order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple auto orders on the UltraCart account. 
         * @summary Update multiple auto orders
         * @param {AutoOrdersRequest} auto_orders_request Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrdersBatch(auto_orders_request: AutoOrdersRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'auto_orders_request' is not null or undefined
            if (auto_orders_request === null || auto_orders_request === undefined) {
                throw new RequiredError('auto_orders_request','Required parameter auto_orders_request was null or undefined when calling updateAutoOrdersBatch.');
            }
            const localVarPath = `/auto_order/auto_orders/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["auto_order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            if (_async !== undefined) {
                localVarQueryParameter['_async'] = _async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoOrdersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(auto_orders_request || {}) : (auto_orders_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoOrderApi - functional programming interface
 * @export
 */
export const AutoOrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves a single auto order using the specified auto order oid. 
         * @summary Retrieve an auto order by oid
         * @param {number} auto_order_oid The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrder(auto_order_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrder(auto_order_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order by code
         * @param {string} auto_order_code The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByCode(auto_order_code: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrderByCode(auto_order_code, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order by order id
         * @param {string} reference_order_id The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByReferenceOrderId(reference_order_id: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrderByReferenceOrderId(reference_order_id, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {string} [auto_order_code] Auto order code
         * @param {string} [original_order_id] Original order id
         * @param {string} [first_name] First name
         * @param {string} [last_name] Last name
         * @param {string} [company] Company
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postal_code] Postal code
         * @param {string} [country_code] Country code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [original_order_date_begin] Original order date begin
         * @param {string} [original_order_date_end] Original order date end
         * @param {string} [next_shipment_date_begin] Next shipment date begin
         * @param {string} [next_shipment_date_end] Next shipment date end
         * @param {string} [card_type] Card type
         * @param {string} [item_id] Item ID
         * @param {string} [status] Status
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch auto orders that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrders(auto_order_code?: string, original_order_id?: string, first_name?: string, last_name?: string, company?: string, city?: string, state?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, original_order_date_begin?: string, original_order_date_end?: string, next_shipment_date_begin?: string, next_shipment_date_end?: string, card_type?: string, item_id?: string, status?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrders(auto_order_code, original_order_id, first_name, last_name, company, city, state, postal_code, country_code, phone, email, original_order_date_begin, original_order_date_end, next_shipment_date_begin, next_shipment_date_end, card_type, item_id, status, _limit, _offset, _since, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve auto order batch
         * @param {AutoOrderQueryBatch} auto_order_batch Auto order batch
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersBatch(auto_order_batch: AutoOrderQueryBatch, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrdersBatch(auto_order_batch, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders by query
         * @param {AutoOrderQuery} auto_order_query Auto order query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersByQuery(auto_order_query: AutoOrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).getAutoOrdersByQuery(auto_order_query, _limit, _offset, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an auto order on the UltraCart account. 
         * @summary Update an auto order
         * @param {AutoOrder} auto_order Auto order to update
         * @param {number} auto_order_oid The auto order oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrder(auto_order: AutoOrder, auto_order_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrderResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).updateAutoOrder(auto_order, auto_order_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update multiple auto orders on the UltraCart account. 
         * @summary Update multiple auto orders
         * @param {AutoOrdersRequest} auto_orders_request Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrdersBatch(auto_orders_request: AutoOrdersRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoOrdersResponse> {
            const localVarFetchArgs = AutoOrderApiFetchParamCreator(configuration).updateAutoOrdersBatch(auto_orders_request, _expand, _placeholders, _async, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AutoOrderApi - factory interface
 * @export
 */
export const AutoOrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves a single auto order using the specified auto order oid. 
         * @summary Retrieve an auto order by oid
         * @param {number} auto_order_oid The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrder(auto_order_oid: number, _expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrder(auto_order_oid, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order by code
         * @param {string} auto_order_code The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByCode(auto_order_code: string, _expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrderByCode(auto_order_code, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single auto order using the specified reference (original) order id. 
         * @summary Retrieve an auto order by order id
         * @param {string} reference_order_id The auto order oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrderByReferenceOrderId(reference_order_id: string, _expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrderByReferenceOrderId(reference_order_id, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders
         * @param {string} [auto_order_code] Auto order code
         * @param {string} [original_order_id] Original order id
         * @param {string} [first_name] First name
         * @param {string} [last_name] Last name
         * @param {string} [company] Company
         * @param {string} [city] City
         * @param {string} [state] State
         * @param {string} [postal_code] Postal code
         * @param {string} [country_code] Country code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [original_order_date_begin] Original order date begin
         * @param {string} [original_order_date_end] Original order date end
         * @param {string} [next_shipment_date_begin] Next shipment date begin
         * @param {string} [next_shipment_date_end] Next shipment date end
         * @param {string} [card_type] Card type
         * @param {string} [item_id] Item ID
         * @param {string} [status] Status
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch auto orders that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrders(auto_order_code?: string, original_order_id?: string, first_name?: string, last_name?: string, company?: string, city?: string, state?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, original_order_date_begin?: string, original_order_date_end?: string, next_shipment_date_begin?: string, next_shipment_date_end?: string, card_type?: string, item_id?: string, status?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrders(auto_order_code, original_order_id, first_name, last_name, company, city, state, postal_code, country_code, phone, email, original_order_date_begin, original_order_date_end, next_shipment_date_begin, next_shipment_date_end, card_type, item_id, status, _limit, _offset, _since, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve auto order batch
         * @param {AutoOrderQueryBatch} auto_order_batch Auto order batch
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersBatch(auto_order_batch: AutoOrderQueryBatch, _expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrdersBatch(auto_order_batch, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve auto orders by query
         * @param {AutoOrderQuery} auto_order_query Auto order query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoOrdersByQuery(auto_order_query: AutoOrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).getAutoOrdersByQuery(auto_order_query, _limit, _offset, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Update an auto order on the UltraCart account. 
         * @summary Update an auto order
         * @param {AutoOrder} auto_order Auto order to update
         * @param {number} auto_order_oid The auto order oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrder(auto_order: AutoOrder, auto_order_oid: number, _expand?: string, options?: any) {
            return AutoOrderApiFp(configuration).updateAutoOrder(auto_order, auto_order_oid, _expand, options)(fetch, basePath);
        },
        /**
         * Update multiple auto orders on the UltraCart account. 
         * @summary Update multiple auto orders
         * @param {AutoOrdersRequest} auto_orders_request Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoOrdersBatch(auto_orders_request: AutoOrdersRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any) {
            return AutoOrderApiFp(configuration).updateAutoOrdersBatch(auto_orders_request, _expand, _placeholders, _async, options)(fetch, basePath);
        },
    };
};

/**
 * AutoOrderApi - interface
 * @export
 * @interface AutoOrderApi
 */
export interface AutoOrderApiInterface {
    /**
     * Retrieves a single auto order using the specified auto order oid. 
     * @summary Retrieve an auto order by oid
     * @param {number} auto_order_oid The auto order oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrder(auto_order_oid: number, _expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order by code
     * @param {string} auto_order_code The auto order oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrderByCode(auto_order_code: string, _expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order by order id
     * @param {string} reference_order_id The auto order oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrderByReferenceOrderId(reference_order_id: string, _expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param {string} [auto_order_code] Auto order code
     * @param {string} [original_order_id] Original order id
     * @param {string} [first_name] First name
     * @param {string} [last_name] Last name
     * @param {string} [company] Company
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postal_code] Postal code
     * @param {string} [country_code] Country code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [original_order_date_begin] Original order date begin
     * @param {string} [original_order_date_end] Original order date end
     * @param {string} [next_shipment_date_begin] Next shipment date begin
     * @param {string} [next_shipment_date_end] Next shipment date end
     * @param {string} [card_type] Card type
     * @param {string} [item_id] Item ID
     * @param {string} [status] Status
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch auto orders that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrders(auto_order_code?: string, original_order_id?: string, first_name?: string, last_name?: string, company?: string, city?: string, state?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, original_order_date_begin?: string, original_order_date_end?: string, next_shipment_date_begin?: string, next_shipment_date_end?: string, card_type?: string, item_id?: string, status?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): Promise<AutoOrdersResponse>;

    /**
     * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve auto order batch
     * @param {AutoOrderQueryBatch} auto_order_batch Auto order batch
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrdersBatch(auto_order_batch: AutoOrderQueryBatch, _expand?: string, options?: any): Promise<AutoOrdersResponse>;

    /**
     * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders by query
     * @param {AutoOrderQuery} auto_order_query Auto order query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    getAutoOrdersByQuery(auto_order_query: AutoOrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): Promise<AutoOrdersResponse>;

    /**
     * Update an auto order on the UltraCart account. 
     * @summary Update an auto order
     * @param {AutoOrder} auto_order Auto order to update
     * @param {number} auto_order_oid The auto order oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    updateAutoOrder(auto_order: AutoOrder, auto_order_oid: number, _expand?: string, options?: any): Promise<AutoOrderResponse>;

    /**
     * Update multiple auto orders on the UltraCart account. 
     * @summary Update multiple auto orders
     * @param {AutoOrdersRequest} auto_orders_request Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [_async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApiInterface
     */
    updateAutoOrdersBatch(auto_orders_request: AutoOrdersRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any): Promise<AutoOrdersResponse>;

}

/**
 * AutoOrderApi - object-oriented interface
 * @export
 * @class AutoOrderApi
 * @extends {BaseAPI}
 */
export class AutoOrderApi extends BaseAPI implements AutoOrderApiInterface {
    /**
     * Retrieves a single auto order using the specified auto order oid. 
     * @summary Retrieve an auto order by oid
     * @param {number} auto_order_oid The auto order oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrder(auto_order_oid: number, _expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrder(auto_order_oid, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order by code
     * @param {string} auto_order_code The auto order oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrderByCode(auto_order_code: string, _expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrderByCode(auto_order_code, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @summary Retrieve an auto order by order id
     * @param {string} reference_order_id The auto order oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrderByReferenceOrderId(reference_order_id: string, _expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrderByReferenceOrderId(reference_order_id, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders
     * @param {string} [auto_order_code] Auto order code
     * @param {string} [original_order_id] Original order id
     * @param {string} [first_name] First name
     * @param {string} [last_name] Last name
     * @param {string} [company] Company
     * @param {string} [city] City
     * @param {string} [state] State
     * @param {string} [postal_code] Postal code
     * @param {string} [country_code] Country code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [original_order_date_begin] Original order date begin
     * @param {string} [original_order_date_end] Original order date end
     * @param {string} [next_shipment_date_begin] Next shipment date begin
     * @param {string} [next_shipment_date_end] Next shipment date end
     * @param {string} [card_type] Card type
     * @param {string} [item_id] Item ID
     * @param {string} [status] Status
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch auto orders that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrders(auto_order_code?: string, original_order_id?: string, first_name?: string, last_name?: string, company?: string, city?: string, state?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, original_order_date_begin?: string, original_order_date_end?: string, next_shipment_date_begin?: string, next_shipment_date_end?: string, card_type?: string, item_id?: string, status?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrders(auto_order_code, original_order_id, first_name, last_name, company, city, state, postal_code, country_code, phone, email, original_order_date_begin, original_order_date_end, next_shipment_date_begin, next_shipment_date_end, card_type, item_id, status, _limit, _offset, _since, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of auto orders from the account based on an array of auto order oids.  If more than 200 auto order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve auto order batch
     * @param {AutoOrderQueryBatch} auto_order_batch Auto order batch
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrdersBatch(auto_order_batch: AutoOrderQueryBatch, _expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrdersBatch(auto_order_batch, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve auto orders by query
     * @param {AutoOrderQuery} auto_order_query Auto order query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public getAutoOrdersByQuery(auto_order_query: AutoOrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).getAutoOrdersByQuery(auto_order_query, _limit, _offset, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update an auto order on the UltraCart account. 
     * @summary Update an auto order
     * @param {AutoOrder} auto_order Auto order to update
     * @param {number} auto_order_oid The auto order oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public updateAutoOrder(auto_order: AutoOrder, auto_order_oid: number, _expand?: string, options?: any) {
        return AutoOrderApiFp(this.configuration).updateAutoOrder(auto_order, auto_order_oid, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update multiple auto orders on the UltraCart account. 
     * @summary Update multiple auto orders
     * @param {AutoOrdersRequest} auto_orders_request Auto orders to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [_async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoOrderApi
     */
    public updateAutoOrdersBatch(auto_orders_request: AutoOrdersRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any) {
        return AutoOrderApiFp(this.configuration).updateAutoOrdersBatch(auto_orders_request, _expand, _placeholders, _async, options)(this.fetch, this.basePath);
    }

}

/**
 * ChargebackApi - fetch parameter creator
 * @export
 */
export const ChargebackApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a chargeback on the UltraCart account. 
         * @summary Delete a chargeback
         * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChargeback(chargeback_dispute_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'chargeback_dispute_oid' is not null or undefined
            if (chargeback_dispute_oid === null || chargeback_dispute_oid === undefined) {
                throw new RequiredError('chargeback_dispute_oid','Required parameter chargeback_dispute_oid was null or undefined when calling deleteChargeback.');
            }
            const localVarPath = `/chargeback/chargebacks/{chargeback_dispute_oid}`
                .replace(`{${"chargeback_dispute_oid"}}`, encodeURIComponent(String(chargeback_dispute_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single chargeback using the specified chargeback dispute oid. 
         * @summary Retrieve a chargeback
         * @param {number} chargeback_dispute_oid The chargeback dispute oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDispute(chargeback_dispute_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'chargeback_dispute_oid' is not null or undefined
            if (chargeback_dispute_oid === null || chargeback_dispute_oid === undefined) {
                throw new RequiredError('chargeback_dispute_oid','Required parameter chargeback_dispute_oid was null or undefined when calling getChargebackDispute.');
            }
            const localVarPath = `/chargeback/chargebacks/{chargeback_dispute_oid}`
                .replace(`{${"chargeback_dispute_oid"}}`, encodeURIComponent(String(chargeback_dispute_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve chargebacks
         * @param {string} [order_id] Order Id
         * @param {string} [case_number] Case number
         * @param {string} [status] Status
         * @param {string} [expiration_dts_start] Expiration dts start
         * @param {string} [expiration_dts_end] Expiration dts end
         * @param {string} [chargeback_dts_start] Chargeback dts start
         * @param {string} [chargeback_dts_end] Chargeback dts end
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch chargebacks that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDisputes(order_id?: string, case_number?: string, status?: string, expiration_dts_start?: string, expiration_dts_end?: string, chargeback_dts_start?: string, chargeback_dts_end?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/chargeback/chargebacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (order_id !== undefined) {
                localVarQueryParameter['order_id'] = order_id;
            }

            if (case_number !== undefined) {
                localVarQueryParameter['case_number'] = case_number;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (expiration_dts_start !== undefined) {
                localVarQueryParameter['expiration_dts_start'] = expiration_dts_start;
            }

            if (expiration_dts_end !== undefined) {
                localVarQueryParameter['expiration_dts_end'] = expiration_dts_end;
            }

            if (chargeback_dts_start !== undefined) {
                localVarQueryParameter['chargeback_dts_start'] = chargeback_dts_start;
            }

            if (chargeback_dts_end !== undefined) {
                localVarQueryParameter['chargeback_dts_end'] = chargeback_dts_end;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_since !== undefined) {
                localVarQueryParameter['_since'] = _since;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a chargeback on the UltraCart account. 
         * @summary Insert a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertChargeback(chargeback: ChargebackDispute, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'chargeback' is not null or undefined
            if (chargeback === null || chargeback === undefined) {
                throw new RequiredError('chargeback','Required parameter chargeback was null or undefined when calling insertChargeback.');
            }
            const localVarPath = `/chargeback/chargebacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackDispute" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(chargeback || {}) : (chargeback || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a chargeback on the UltraCart account. 
         * @summary Update a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to update
         * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChargeback(chargeback: ChargebackDispute, chargeback_dispute_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'chargeback' is not null or undefined
            if (chargeback === null || chargeback === undefined) {
                throw new RequiredError('chargeback','Required parameter chargeback was null or undefined when calling updateChargeback.');
            }
            // verify required parameter 'chargeback_dispute_oid' is not null or undefined
            if (chargeback_dispute_oid === null || chargeback_dispute_oid === undefined) {
                throw new RequiredError('chargeback_dispute_oid','Required parameter chargeback_dispute_oid was null or undefined when calling updateChargeback.');
            }
            const localVarPath = `/chargeback/chargebacks/{chargeback_dispute_oid}`
                .replace(`{${"chargeback_dispute_oid"}}`, encodeURIComponent(String(chargeback_dispute_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["chargeback_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackDispute" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(chargeback || {}) : (chargeback || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargebackApi - functional programming interface
 * @export
 */
export const ChargebackApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a chargeback on the UltraCart account. 
         * @summary Delete a chargeback
         * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChargeback(chargeback_dispute_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).deleteChargeback(chargeback_dispute_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single chargeback using the specified chargeback dispute oid. 
         * @summary Retrieve a chargeback
         * @param {number} chargeback_dispute_oid The chargeback dispute oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDispute(chargeback_dispute_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).getChargebackDispute(chargeback_dispute_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve chargebacks
         * @param {string} [order_id] Order Id
         * @param {string} [case_number] Case number
         * @param {string} [status] Status
         * @param {string} [expiration_dts_start] Expiration dts start
         * @param {string} [expiration_dts_end] Expiration dts end
         * @param {string} [chargeback_dts_start] Chargeback dts start
         * @param {string} [chargeback_dts_end] Chargeback dts end
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch chargebacks that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDisputes(order_id?: string, case_number?: string, status?: string, expiration_dts_start?: string, expiration_dts_end?: string, chargeback_dts_start?: string, chargeback_dts_end?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputesResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).getChargebackDisputes(order_id, case_number, status, expiration_dts_start, expiration_dts_end, chargeback_dts_start, chargeback_dts_end, _limit, _offset, _since, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a chargeback on the UltraCart account. 
         * @summary Insert a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertChargeback(chargeback: ChargebackDispute, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).insertChargeback(chargeback, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a chargeback on the UltraCart account. 
         * @summary Update a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to update
         * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChargeback(chargeback: ChargebackDispute, chargeback_dispute_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackDisputeResponse> {
            const localVarFetchArgs = ChargebackApiFetchParamCreator(configuration).updateChargeback(chargeback, chargeback_dispute_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChargebackApi - factory interface
 * @export
 */
export const ChargebackApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a chargeback on the UltraCart account. 
         * @summary Delete a chargeback
         * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChargeback(chargeback_dispute_oid: number, options?: any) {
            return ChargebackApiFp(configuration).deleteChargeback(chargeback_dispute_oid, options)(fetch, basePath);
        },
        /**
         * Retrieves a single chargeback using the specified chargeback dispute oid. 
         * @summary Retrieve a chargeback
         * @param {number} chargeback_dispute_oid The chargeback dispute oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDispute(chargeback_dispute_oid: number, _expand?: string, options?: any) {
            return ChargebackApiFp(configuration).getChargebackDispute(chargeback_dispute_oid, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve chargebacks
         * @param {string} [order_id] Order Id
         * @param {string} [case_number] Case number
         * @param {string} [status] Status
         * @param {string} [expiration_dts_start] Expiration dts start
         * @param {string} [expiration_dts_end] Expiration dts end
         * @param {string} [chargeback_dts_start] Chargeback dts start
         * @param {string} [chargeback_dts_end] Chargeback dts end
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch chargebacks that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebackDisputes(order_id?: string, case_number?: string, status?: string, expiration_dts_start?: string, expiration_dts_end?: string, chargeback_dts_start?: string, chargeback_dts_end?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
            return ChargebackApiFp(configuration).getChargebackDisputes(order_id, case_number, status, expiration_dts_start, expiration_dts_end, chargeback_dts_start, chargeback_dts_end, _limit, _offset, _since, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Insert a chargeback on the UltraCart account. 
         * @summary Insert a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertChargeback(chargeback: ChargebackDispute, _expand?: string, options?: any) {
            return ChargebackApiFp(configuration).insertChargeback(chargeback, _expand, options)(fetch, basePath);
        },
        /**
         * Update a chargeback on the UltraCart account. 
         * @summary Update a chargeback
         * @param {ChargebackDispute} chargeback Chargeback to update
         * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChargeback(chargeback: ChargebackDispute, chargeback_dispute_oid: number, _expand?: string, options?: any) {
            return ChargebackApiFp(configuration).updateChargeback(chargeback, chargeback_dispute_oid, _expand, options)(fetch, basePath);
        },
    };
};

/**
 * ChargebackApi - interface
 * @export
 * @interface ChargebackApi
 */
export interface ChargebackApiInterface {
    /**
     * Delete a chargeback on the UltraCart account. 
     * @summary Delete a chargeback
     * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    deleteChargeback(chargeback_dispute_oid: number, options?: any): Promise<ChargebackDisputeResponse>;

    /**
     * Retrieves a single chargeback using the specified chargeback dispute oid. 
     * @summary Retrieve a chargeback
     * @param {number} chargeback_dispute_oid The chargeback dispute oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    getChargebackDispute(chargeback_dispute_oid: number, _expand?: string, options?: any): Promise<ChargebackDisputeResponse>;

    /**
     * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve chargebacks
     * @param {string} [order_id] Order Id
     * @param {string} [case_number] Case number
     * @param {string} [status] Status
     * @param {string} [expiration_dts_start] Expiration dts start
     * @param {string} [expiration_dts_end] Expiration dts end
     * @param {string} [chargeback_dts_start] Chargeback dts start
     * @param {string} [chargeback_dts_end] Chargeback dts end
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch chargebacks that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    getChargebackDisputes(order_id?: string, case_number?: string, status?: string, expiration_dts_start?: string, expiration_dts_end?: string, chargeback_dts_start?: string, chargeback_dts_end?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): Promise<ChargebackDisputesResponse>;

    /**
     * Insert a chargeback on the UltraCart account. 
     * @summary Insert a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    insertChargeback(chargeback: ChargebackDispute, _expand?: string, options?: any): Promise<ChargebackDisputeResponse>;

    /**
     * Update a chargeback on the UltraCart account. 
     * @summary Update a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to update
     * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApiInterface
     */
    updateChargeback(chargeback: ChargebackDispute, chargeback_dispute_oid: number, _expand?: string, options?: any): Promise<ChargebackDisputeResponse>;

}

/**
 * ChargebackApi - object-oriented interface
 * @export
 * @class ChargebackApi
 * @extends {BaseAPI}
 */
export class ChargebackApi extends BaseAPI implements ChargebackApiInterface {
    /**
     * Delete a chargeback on the UltraCart account. 
     * @summary Delete a chargeback
     * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public deleteChargeback(chargeback_dispute_oid: number, options?: any) {
        return ChargebackApiFp(this.configuration).deleteChargeback(chargeback_dispute_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single chargeback using the specified chargeback dispute oid. 
     * @summary Retrieve a chargeback
     * @param {number} chargeback_dispute_oid The chargeback dispute oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public getChargebackDispute(chargeback_dispute_oid: number, _expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).getChargebackDispute(chargeback_dispute_oid, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve chargebacks
     * @param {string} [order_id] Order Id
     * @param {string} [case_number] Case number
     * @param {string} [status] Status
     * @param {string} [expiration_dts_start] Expiration dts start
     * @param {string} [expiration_dts_end] Expiration dts end
     * @param {string} [chargeback_dts_start] Chargeback dts start
     * @param {string} [chargeback_dts_end] Chargeback dts end
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch chargebacks that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public getChargebackDisputes(order_id?: string, case_number?: string, status?: string, expiration_dts_start?: string, expiration_dts_end?: string, chargeback_dts_start?: string, chargeback_dts_end?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).getChargebackDisputes(order_id, case_number, status, expiration_dts_start, expiration_dts_end, chargeback_dts_start, chargeback_dts_end, _limit, _offset, _since, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Insert a chargeback on the UltraCart account. 
     * @summary Insert a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public insertChargeback(chargeback: ChargebackDispute, _expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).insertChargeback(chargeback, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update a chargeback on the UltraCart account. 
     * @summary Update a chargeback
     * @param {ChargebackDispute} chargeback Chargeback to update
     * @param {number} chargeback_dispute_oid The chargeback_dispute_oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebackApi
     */
    public updateChargeback(chargeback: ChargebackDispute, chargeback_dispute_oid: number, _expand?: string, options?: any) {
        return ChargebackApiFp(this.configuration).updateChargeback(chargeback, chargeback_dispute_oid, _expand, options)(this.fetch, this.basePath);
    }

}

/**
 * CheckoutApi - fetch parameter creator
 * @export
 */
export const CheckoutApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
         * @summary City/State for Zip
         * @param {Cart} cart Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityState(cart: Cart, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling cityState.');
            }
            const localVarPath = `/checkout/city_state`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
         * @summary Finalize Order
         * @param {CartFinalizeOrderRequest} finalize_request Finalize request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeOrder(finalize_request: CartFinalizeOrderRequest, options: any = {}): FetchArgs {
            // verify required parameter 'finalize_request' is not null or undefined
            if (finalize_request === null || finalize_request === undefined) {
                throw new RequiredError('finalize_request','Required parameter finalize_request was null or undefined when calling finalizeOrder.');
            }
            const localVarPath = `/checkout/cart/finalizeOrder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartFinalizeOrderRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(finalize_request || {}) : (finalize_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Affirm checkout object for the specified cart_id parameter. 
         * @summary Get affirm checkout (by cart id)
         * @param {string} cart_id Cart ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffirmCheckout(cart_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart_id' is not null or undefined
            if (cart_id === null || cart_id === undefined) {
                throw new RequiredError('cart_id','Required parameter cart_id was null or undefined when calling getAffirmCheckout.');
            }
            const localVarPath = `/checkout/cart/{cart_id}/affirmCheckout`
                .replace(`{${"cart_id"}}`, encodeURIComponent(String(cart_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup the allowed countries for this merchant id 
         * @summary Allowed countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedCountries(options: any = {}): FetchArgs {
            const localVarPath = `/checkout/allowedCountries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
         * @summary Get cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(_expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/checkout/cart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a cart specified by the cart_id parameter. 
         * @summary Get cart (by cart id)
         * @param {string} cart_id Cart ID to retrieve
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByCartId(cart_id: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart_id' is not null or undefined
            if (cart_id === null || cart_id === undefined) {
                throw new RequiredError('cart_id','Required parameter cart_id was null or undefined when calling getCartByCartId.');
            }
            const localVarPath = `/checkout/cart/{cart_id}`
                .replace(`{${"cart_id"}}`, encodeURIComponent(String(cart_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a cart specified by the return code parameter. 
         * @summary Get cart (by return code)
         * @param {string} return_code Return code to lookup cart ID by
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnCode(return_code: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'return_code' is not null or undefined
            if (return_code === null || return_code === undefined) {
                throw new RequiredError('return_code','Required parameter return_code was null or undefined when calling getCartByReturnCode.');
            }
            const localVarPath = `/checkout/return/{return_code}`
                .replace(`{${"return_code"}}`, encodeURIComponent(String(return_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a cart specified by the encrypted return token parameter. 
         * @summary Get cart (by return token)
         * @param {string} [return_token] Return token provided by StoreFront Communications
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnToken(return_token?: string, _expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/checkout/return_token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (return_token !== undefined) {
                localVarQueryParameter['return_token'] = return_token;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup a state/province list for a given country code 
         * @summary Get state/province list for a country code
         * @param {string} country_code Two letter ISO country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProvincesForCountry(country_code: string, options: any = {}): FetchArgs {
            // verify required parameter 'country_code' is not null or undefined
            if (country_code === null || country_code === undefined) {
                throw new RequiredError('country_code','Required parameter country_code was null or undefined when calling getStateProvincesForCountry.');
            }
            const localVarPath = `/checkout/stateProvincesForCountry/{country_code}`
                .replace(`{${"country_code"}}`, encodeURIComponent(String(country_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
         * @summary Handoff cart
         * @param {CheckoutHandoffRequest} handoff_request Handoff request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoffCart(handoff_request: CheckoutHandoffRequest, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'handoff_request' is not null or undefined
            if (handoff_request === null || handoff_request === undefined) {
                throw new RequiredError('handoff_request','Required parameter handoff_request was null or undefined when calling handoffCart.');
            }
            const localVarPath = `/checkout/cart/handoff`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutHandoffRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(handoff_request || {}) : (handoff_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login in to the customer profile specified by cart.billing.email and password 
         * @summary Profile login
         * @param {CartProfileLoginRequest} login_request Login request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(login_request: CartProfileLoginRequest, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'login_request' is not null or undefined
            if (login_request === null || login_request === undefined) {
                throw new RequiredError('login_request','Required parameter login_request was null or undefined when calling login.');
            }
            const localVarPath = `/checkout/cart/profile/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartProfileLoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(login_request || {}) : (login_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log the cart out of the current profile.  No error will occur if they are not logged in. 
         * @summary Profile logout
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(cart: Cart, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling logout.');
            }
            const localVarPath = `/checkout/cart/profile/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
         * @summary Profile registration
         * @param {CartProfileRegisterRequest} register_request Register request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(register_request: CartProfileRegisterRequest, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'register_request' is not null or undefined
            if (register_request === null || register_request === undefined) {
                throw new RequiredError('register_request','Required parameter register_request was null or undefined when calling register.');
            }
            const localVarPath = `/checkout/cart/profile/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartProfileRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(register_request || {}) : (register_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
         * @summary Register affiliate click
         * @param {RegisterAffiliateClickRequest} register_affiliate_click_request Register affiliate click request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAffiliateClick(register_affiliate_click_request: RegisterAffiliateClickRequest, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'register_affiliate_click_request' is not null or undefined
            if (register_affiliate_click_request === null || register_affiliate_click_request === undefined) {
                throw new RequiredError('register_affiliate_click_request','Required parameter register_affiliate_click_request was null or undefined when calling registerAffiliateClick.');
            }
            const localVarPath = `/checkout/affiliateClick/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterAffiliateClickRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(register_affiliate_click_request || {}) : (register_affiliate_click_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForCart(cart: Cart, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling relatedItemsForCart.');
            }
            const localVarPath = `/checkout/related_items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items (specific item)
         * @param {string} item_id Item ID to retrieve related items for
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForItem(item_id: string, cart: Cart, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'item_id' is not null or undefined
            if (item_id === null || item_id === undefined) {
                throw new RequiredError('item_id','Required parameter item_id was null or undefined when calling relatedItemsForItem.');
            }
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling relatedItemsForItem.');
            }
            const localVarPath = `/checkout/relatedItems/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(item_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
         * @summary Setup Browser Application
         * @param {CheckoutSetupBrowserKeyRequest} browser_key_request Setup browser key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupBrowserKey(browser_key_request: CheckoutSetupBrowserKeyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'browser_key_request' is not null or undefined
            if (browser_key_request === null || browser_key_request === undefined) {
                throw new RequiredError('browser_key_request','Required parameter browser_key_request was null or undefined when calling setupBrowserKey.');
            }
            const localVarPath = `/checkout/browser_key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CheckoutSetupBrowserKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(browser_key_request || {}) : (browser_key_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the cart. 
         * @summary Update cart
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(cart: Cart, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cart' is not null or undefined
            if (cart === null || cart === undefined) {
                throw new RequiredError('cart','Required parameter cart was null or undefined when calling updateCart.');
            }
            const localVarPath = `/checkout/cart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(cart || {}) : (cart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
         * @summary Validate
         * @param {CartValidationRequest} validation_request Validation request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCart(validation_request: CartValidationRequest, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'validation_request' is not null or undefined
            if (validation_request === null || validation_request === undefined) {
                throw new RequiredError('validation_request','Required parameter validation_request was null or undefined when calling validateCart.');
            }
            const localVarPath = `/checkout/cart/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["checkout_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartValidationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(validation_request || {}) : (validation_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutApi - functional programming interface
 * @export
 */
export const CheckoutApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
         * @summary City/State for Zip
         * @param {Cart} cart Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityState(cart: Cart, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CityStateZip> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).cityState(cart, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
         * @summary Finalize Order
         * @param {CartFinalizeOrderRequest} finalize_request Finalize request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeOrder(finalize_request: CartFinalizeOrderRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartFinalizeOrderResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).finalizeOrder(finalize_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a Affirm checkout object for the specified cart_id parameter. 
         * @summary Get affirm checkout (by cart id)
         * @param {string} cart_id Cart ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffirmCheckout(cart_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartAffirmCheckoutResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getAffirmCheckout(cart_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lookup the allowed countries for this merchant id 
         * @summary Allowed countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedCountries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutAllowedCountriesResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getAllowedCountries(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
         * @summary Get cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(_expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getCart(_expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a cart specified by the cart_id parameter. 
         * @summary Get cart (by cart id)
         * @param {string} cart_id Cart ID to retrieve
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByCartId(cart_id: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getCartByCartId(cart_id, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a cart specified by the return code parameter. 
         * @summary Get cart (by return code)
         * @param {string} return_code Return code to lookup cart ID by
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnCode(return_code: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getCartByReturnCode(return_code, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a cart specified by the encrypted return token parameter. 
         * @summary Get cart (by return token)
         * @param {string} [return_token] Return token provided by StoreFront Communications
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnToken(return_token?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getCartByReturnToken(return_token, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lookup a state/province list for a given country code 
         * @summary Get state/province list for a country code
         * @param {string} country_code Two letter ISO country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProvincesForCountry(country_code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutStateProvinceResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).getStateProvincesForCountry(country_code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
         * @summary Handoff cart
         * @param {CheckoutHandoffRequest} handoff_request Handoff request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoffCart(handoff_request: CheckoutHandoffRequest, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutHandoffResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).handoffCart(handoff_request, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Login in to the customer profile specified by cart.billing.email and password 
         * @summary Profile login
         * @param {CartProfileLoginRequest} login_request Login request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(login_request: CartProfileLoginRequest, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartProfileLoginResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).login(login_request, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Log the cart out of the current profile.  No error will occur if they are not logged in. 
         * @summary Profile logout
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(cart: Cart, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).logout(cart, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
         * @summary Profile registration
         * @param {CartProfileRegisterRequest} register_request Register request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(register_request: CartProfileRegisterRequest, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartProfileRegisterResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).register(register_request, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
         * @summary Register affiliate click
         * @param {RegisterAffiliateClickRequest} register_affiliate_click_request Register affiliate click request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAffiliateClick(register_affiliate_click_request: RegisterAffiliateClickRequest, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RegisterAffiliateClickResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).registerAffiliateClick(register_affiliate_click_request, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForCart(cart: Cart, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).relatedItemsForCart(cart, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items (specific item)
         * @param {string} item_id Item ID to retrieve related items for
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForItem(item_id: string, cart: Cart, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).relatedItemsForItem(item_id, cart, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
         * @summary Setup Browser Application
         * @param {CheckoutSetupBrowserKeyRequest} browser_key_request Setup browser key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupBrowserKey(browser_key_request: CheckoutSetupBrowserKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutSetupBrowserKeyResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).setupBrowserKey(browser_key_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the cart. 
         * @summary Update cart
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(cart: Cart, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).updateCart(cart, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
         * @summary Validate
         * @param {CartValidationRequest} validation_request Validation request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCart(validation_request: CartValidationRequest, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartValidationResponse> {
            const localVarFetchArgs = CheckoutApiFetchParamCreator(configuration).validateCart(validation_request, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckoutApi - factory interface
 * @export
 */
export const CheckoutApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
         * @summary City/State for Zip
         * @param {Cart} cart Cart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityState(cart: Cart, options?: any) {
            return CheckoutApiFp(configuration).cityState(cart, options)(fetch, basePath);
        },
        /**
         * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
         * @summary Finalize Order
         * @param {CartFinalizeOrderRequest} finalize_request Finalize request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeOrder(finalize_request: CartFinalizeOrderRequest, options?: any) {
            return CheckoutApiFp(configuration).finalizeOrder(finalize_request, options)(fetch, basePath);
        },
        /**
         * Get a Affirm checkout object for the specified cart_id parameter. 
         * @summary Get affirm checkout (by cart id)
         * @param {string} cart_id Cart ID to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffirmCheckout(cart_id: string, options?: any) {
            return CheckoutApiFp(configuration).getAffirmCheckout(cart_id, options)(fetch, basePath);
        },
        /**
         * Lookup the allowed countries for this merchant id 
         * @summary Allowed countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowedCountries(options?: any) {
            return CheckoutApiFp(configuration).getAllowedCountries(options)(fetch, basePath);
        },
        /**
         * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
         * @summary Get cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(_expand?: string, options?: any) {
            return CheckoutApiFp(configuration).getCart(_expand, options)(fetch, basePath);
        },
        /**
         * Get a cart specified by the cart_id parameter. 
         * @summary Get cart (by cart id)
         * @param {string} cart_id Cart ID to retrieve
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByCartId(cart_id: string, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).getCartByCartId(cart_id, _expand, options)(fetch, basePath);
        },
        /**
         * Get a cart specified by the return code parameter. 
         * @summary Get cart (by return code)
         * @param {string} return_code Return code to lookup cart ID by
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnCode(return_code: string, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).getCartByReturnCode(return_code, _expand, options)(fetch, basePath);
        },
        /**
         * Get a cart specified by the encrypted return token parameter. 
         * @summary Get cart (by return token)
         * @param {string} [return_token] Return token provided by StoreFront Communications
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartByReturnToken(return_token?: string, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).getCartByReturnToken(return_token, _expand, options)(fetch, basePath);
        },
        /**
         * Lookup a state/province list for a given country code 
         * @summary Get state/province list for a country code
         * @param {string} country_code Two letter ISO country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStateProvincesForCountry(country_code: string, options?: any) {
            return CheckoutApiFp(configuration).getStateProvincesForCountry(country_code, options)(fetch, basePath);
        },
        /**
         * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
         * @summary Handoff cart
         * @param {CheckoutHandoffRequest} handoff_request Handoff request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handoffCart(handoff_request: CheckoutHandoffRequest, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).handoffCart(handoff_request, _expand, options)(fetch, basePath);
        },
        /**
         * Login in to the customer profile specified by cart.billing.email and password 
         * @summary Profile login
         * @param {CartProfileLoginRequest} login_request Login request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(login_request: CartProfileLoginRequest, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).login(login_request, _expand, options)(fetch, basePath);
        },
        /**
         * Log the cart out of the current profile.  No error will occur if they are not logged in. 
         * @summary Profile logout
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(cart: Cart, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).logout(cart, _expand, options)(fetch, basePath);
        },
        /**
         * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
         * @summary Profile registration
         * @param {CartProfileRegisterRequest} register_request Register request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(register_request: CartProfileRegisterRequest, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).register(register_request, _expand, options)(fetch, basePath);
        },
        /**
         * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
         * @summary Register affiliate click
         * @param {RegisterAffiliateClickRequest} register_affiliate_click_request Register affiliate click request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAffiliateClick(register_affiliate_click_request: RegisterAffiliateClickRequest, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).registerAffiliateClick(register_affiliate_click_request, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForCart(cart: Cart, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).relatedItemsForCart(cart, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
         * @summary Related items (specific item)
         * @param {string} item_id Item ID to retrieve related items for
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedItemsForItem(item_id: string, cart: Cart, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).relatedItemsForItem(item_id, cart, _expand, options)(fetch, basePath);
        },
        /**
         * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
         * @summary Setup Browser Application
         * @param {CheckoutSetupBrowserKeyRequest} browser_key_request Setup browser key request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupBrowserKey(browser_key_request: CheckoutSetupBrowserKeyRequest, options?: any) {
            return CheckoutApiFp(configuration).setupBrowserKey(browser_key_request, options)(fetch, basePath);
        },
        /**
         * Update the cart. 
         * @summary Update cart
         * @param {Cart} cart Cart
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(cart: Cart, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).updateCart(cart, _expand, options)(fetch, basePath);
        },
        /**
         * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
         * @summary Validate
         * @param {CartValidationRequest} validation_request Validation request
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCart(validation_request: CartValidationRequest, _expand?: string, options?: any) {
            return CheckoutApiFp(configuration).validateCart(validation_request, _expand, options)(fetch, basePath);
        },
    };
};

/**
 * CheckoutApi - interface
 * @export
 * @interface CheckoutApi
 */
export interface CheckoutApiInterface {
    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @summary City/State for Zip
     * @param {Cart} cart Cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    cityState(cart: Cart, options?: any): Promise<CityStateZip>;

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @summary Finalize Order
     * @param {CartFinalizeOrderRequest} finalize_request Finalize request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    finalizeOrder(finalize_request: CartFinalizeOrderRequest, options?: any): Promise<CartFinalizeOrderResponse>;

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * @summary Get affirm checkout (by cart id)
     * @param {string} cart_id Cart ID to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getAffirmCheckout(cart_id: string, options?: any): Promise<CartAffirmCheckoutResponse>;

    /**
     * Lookup the allowed countries for this merchant id 
     * @summary Allowed countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getAllowedCountries(options?: any): Promise<CheckoutAllowedCountriesResponse>;

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @summary Get cart
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCart(_expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Get a cart specified by the cart_id parameter. 
     * @summary Get cart (by cart id)
     * @param {string} cart_id Cart ID to retrieve
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByCartId(cart_id: string, _expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Get a cart specified by the return code parameter. 
     * @summary Get cart (by return code)
     * @param {string} return_code Return code to lookup cart ID by
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByReturnCode(return_code: string, _expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Get a cart specified by the encrypted return token parameter. 
     * @summary Get cart (by return token)
     * @param {string} [return_token] Return token provided by StoreFront Communications
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByReturnToken(return_token?: string, _expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Lookup a state/province list for a given country code 
     * @summary Get state/province list for a country code
     * @param {string} country_code Two letter ISO country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getStateProvincesForCountry(country_code: string, options?: any): Promise<CheckoutStateProvinceResponse>;

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
     * @summary Handoff cart
     * @param {CheckoutHandoffRequest} handoff_request Handoff request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    handoffCart(handoff_request: CheckoutHandoffRequest, _expand?: string, options?: any): Promise<CheckoutHandoffResponse>;

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * @summary Profile login
     * @param {CartProfileLoginRequest} login_request Login request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    login(login_request: CartProfileLoginRequest, _expand?: string, options?: any): Promise<CartProfileLoginResponse>;

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @summary Profile logout
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    logout(cart: Cart, _expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @summary Profile registration
     * @param {CartProfileRegisterRequest} register_request Register request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    register(register_request: CartProfileRegisterRequest, _expand?: string, options?: any): Promise<CartProfileRegisterResponse>;

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * @summary Register affiliate click
     * @param {RegisterAffiliateClickRequest} register_affiliate_click_request Register affiliate click request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    registerAffiliateClick(register_affiliate_click_request: RegisterAffiliateClickRequest, _expand?: string, options?: any): Promise<RegisterAffiliateClickResponse>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    relatedItemsForCart(cart: Cart, _expand?: string, options?: any): Promise<ItemsResponse>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items (specific item)
     * @param {string} item_id Item ID to retrieve related items for
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    relatedItemsForItem(item_id: string, cart: Cart, _expand?: string, options?: any): Promise<ItemsResponse>;

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @summary Setup Browser Application
     * @param {CheckoutSetupBrowserKeyRequest} browser_key_request Setup browser key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    setupBrowserKey(browser_key_request: CheckoutSetupBrowserKeyRequest, options?: any): Promise<CheckoutSetupBrowserKeyResponse>;

    /**
     * Update the cart. 
     * @summary Update cart
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    updateCart(cart: Cart, _expand?: string, options?: any): Promise<CartResponse>;

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @summary Validate
     * @param {CartValidationRequest} validation_request Validation request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    validateCart(validation_request: CartValidationRequest, _expand?: string, options?: any): Promise<CartValidationResponse>;

}

/**
 * CheckoutApi - object-oriented interface
 * @export
 * @class CheckoutApi
 * @extends {BaseAPI}
 */
export class CheckoutApi extends BaseAPI implements CheckoutApiInterface {
    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @summary City/State for Zip
     * @param {Cart} cart Cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public cityState(cart: Cart, options?: any) {
        return CheckoutApiFp(this.configuration).cityState(cart, options)(this.fetch, this.basePath);
    }

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @summary Finalize Order
     * @param {CartFinalizeOrderRequest} finalize_request Finalize request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public finalizeOrder(finalize_request: CartFinalizeOrderRequest, options?: any) {
        return CheckoutApiFp(this.configuration).finalizeOrder(finalize_request, options)(this.fetch, this.basePath);
    }

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * @summary Get affirm checkout (by cart id)
     * @param {string} cart_id Cart ID to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getAffirmCheckout(cart_id: string, options?: any) {
        return CheckoutApiFp(this.configuration).getAffirmCheckout(cart_id, options)(this.fetch, this.basePath);
    }

    /**
     * Lookup the allowed countries for this merchant id 
     * @summary Allowed countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getAllowedCountries(options?: any) {
        return CheckoutApiFp(this.configuration).getAllowedCountries(options)(this.fetch, this.basePath);
    }

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @summary Get cart
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getCart(_expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).getCart(_expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get a cart specified by the cart_id parameter. 
     * @summary Get cart (by cart id)
     * @param {string} cart_id Cart ID to retrieve
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getCartByCartId(cart_id: string, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).getCartByCartId(cart_id, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get a cart specified by the return code parameter. 
     * @summary Get cart (by return code)
     * @param {string} return_code Return code to lookup cart ID by
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getCartByReturnCode(return_code: string, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).getCartByReturnCode(return_code, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Get a cart specified by the encrypted return token parameter. 
     * @summary Get cart (by return token)
     * @param {string} [return_token] Return token provided by StoreFront Communications
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getCartByReturnToken(return_token?: string, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).getCartByReturnToken(return_token, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Lookup a state/province list for a given country code 
     * @summary Get state/province list for a country code
     * @param {string} country_code Two letter ISO country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public getStateProvincesForCountry(country_code: string, options?: any) {
        return CheckoutApiFp(this.configuration).getStateProvincesForCountry(country_code, options)(this.fetch, this.basePath);
    }

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
     * @summary Handoff cart
     * @param {CheckoutHandoffRequest} handoff_request Handoff request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public handoffCart(handoff_request: CheckoutHandoffRequest, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).handoffCart(handoff_request, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * @summary Profile login
     * @param {CartProfileLoginRequest} login_request Login request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public login(login_request: CartProfileLoginRequest, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).login(login_request, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @summary Profile logout
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public logout(cart: Cart, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).logout(cart, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @summary Profile registration
     * @param {CartProfileRegisterRequest} register_request Register request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public register(register_request: CartProfileRegisterRequest, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).register(register_request, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * @summary Register affiliate click
     * @param {RegisterAffiliateClickRequest} register_affiliate_click_request Register affiliate click request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public registerAffiliateClick(register_affiliate_click_request: RegisterAffiliateClickRequest, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).registerAffiliateClick(register_affiliate_click_request, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public relatedItemsForCart(cart: Cart, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).relatedItemsForCart(cart, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items (specific item)
     * @param {string} item_id Item ID to retrieve related items for
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public relatedItemsForItem(item_id: string, cart: Cart, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).relatedItemsForItem(item_id, cart, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @summary Setup Browser Application
     * @param {CheckoutSetupBrowserKeyRequest} browser_key_request Setup browser key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public setupBrowserKey(browser_key_request: CheckoutSetupBrowserKeyRequest, options?: any) {
        return CheckoutApiFp(this.configuration).setupBrowserKey(browser_key_request, options)(this.fetch, this.basePath);
    }

    /**
     * Update the cart. 
     * @summary Update cart
     * @param {Cart} cart Cart
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public updateCart(cart: Cart, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).updateCart(cart, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @summary Validate
     * @param {CartValidationRequest} validation_request Validation request
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public validateCart(validation_request: CartValidationRequest, _expand?: string, options?: any) {
        return CheckoutApiFp(this.configuration).validateCart(validation_request, _expand, options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigurationApi - fetch parameter creator
 * @export
 */
export const ConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delay auto order processing for a day for this rotating transaction gateway 
         * @summary Delay auto order processing for a day for this rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to delay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delayAutoOrders(rtg_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'rtg_oid' is not null or undefined
            if (rtg_oid === null || rtg_oid === undefined) {
                throw new RequiredError('rtg_oid','Required parameter rtg_oid was null or undefined when calling delayAutoOrders.');
            }
            const localVarPath = `/configuration/checkout/payments/rtg/{rtg_oid}/delayAutoOrders`
                .replace(`{${"rtg_oid"}}`, encodeURIComponent(String(rtg_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a rotating transaction gateway 
         * @summary Delete a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRotatingTransactionGateway(rtg_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'rtg_oid' is not null or undefined
            if (rtg_oid === null || rtg_oid === undefined) {
                throw new RequiredError('rtg_oid','Required parameter rtg_oid was null or undefined when calling deleteRotatingTransactionGateway.');
            }
            const localVarPath = `/configuration/checkout/payments/rtg/{rtg_oid}`
                .replace(`{${"rtg_oid"}}`, encodeURIComponent(String(rtg_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves payments configuration for this account. 
         * @summary Retrieve payments configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsConfiguration(options: any = {}): FetchArgs {
            const localVarPath = `/configuration/checkout/payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a rotating transaction gateway 
         * @summary Retrieve a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid for the desired record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingGateway(rtg_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'rtg_oid' is not null or undefined
            if (rtg_oid === null || rtg_oid === undefined) {
                throw new RequiredError('rtg_oid','Required parameter rtg_oid was null or undefined when calling getPaymentsRotatingGateway.');
            }
            const localVarPath = `/configuration/checkout/payments/rtg/{rtg_oid}`
                .replace(`{${"rtg_oid"}}`, encodeURIComponent(String(rtg_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a rotating transaction gateway by code 
         * @summary Retrieve a rotating transaction gateway by code
         * @param {string} code The code for the desired rotating transaction gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingGatewayByCode(code: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling getPaymentsRotatingGatewayByCode.');
            }
            const localVarPath = `/configuration/checkout/payments/rtg/byCode/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of rotating transaction gateways 
         * @summary Retrieve a list of rotating transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingTransactionGateways(options: any = {}): FetchArgs {
            const localVarPath = `/configuration/checkout/payments/rtg`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a summary of rotating transaction gateways 
         * @summary Retrieve a summary of rotating transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRtgSummaries(options: any = {}): FetchArgs {
            const localVarPath = `/configuration/checkout/payments/rtg/summaries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of transaction gateways 
         * @summary Retrieve a list of transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTransactionGateways(options: any = {}): FetchArgs {
            const localVarPath = `/configuration/checkout/payments/tg`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a rotating transaction gateway 
         * @summary Insert a rotating transaction gateway
         * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertRotatingTransactionGateway(rotating_transaction_gateway: RotatingTransactionGateway, options: any = {}): FetchArgs {
            // verify required parameter 'rotating_transaction_gateway' is not null or undefined
            if (rotating_transaction_gateway === null || rotating_transaction_gateway === undefined) {
                throw new RequiredError('rotating_transaction_gateway','Required parameter rotating_transaction_gateway was null or undefined when calling insertRotatingTransactionGateway.');
            }
            const localVarPath = `/configuration/checkout/payments/rtg/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RotatingTransactionGateway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rotating_transaction_gateway || {}) : (rotating_transaction_gateway || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrate a normal transaction gateway to a rotating transaction gateway 
         * @summary Migrate a normal transaction gateway to a rotating transaction gateway
         * @param {string} code The short code for the new rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateToRotatingTransactionGateway(code: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling migrateToRotatingTransactionGateway.');
            }
            const localVarPath = `/configuration/checkout/payments/tg/migrateToRtgWithCodeOf/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Begin the processing of connecting with Stripe. 
         * @summary Begin the processing of connecting with Stripe
         * @param {number} rtg_oid The rtg_oid to be connected to stripe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeConnect(rtg_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'rtg_oid' is not null or undefined
            if (rtg_oid === null || rtg_oid === undefined) {
                throw new RequiredError('rtg_oid','Required parameter rtg_oid was null or undefined when calling stripeConnect.');
            }
            const localVarPath = `/configuration/checkout/payments/rtg/{rtg_oid}/stripeConnect`
                .replace(`{${"rtg_oid"}}`, encodeURIComponent(String(rtg_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates payments configuration on the UltraCart account. 
         * @summary Updates payments configuration
         * @param {PaymentsConfiguration} payments_configuration Payments configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentsConfiguration(payments_configuration: PaymentsConfiguration, options: any = {}): FetchArgs {
            // verify required parameter 'payments_configuration' is not null or undefined
            if (payments_configuration === null || payments_configuration === undefined) {
                throw new RequiredError('payments_configuration','Required parameter payments_configuration was null or undefined when calling updatePaymentsConfiguration.');
            }
            const localVarPath = `/configuration/checkout/payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentsConfiguration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payments_configuration || {}) : (payments_configuration || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates payments transaction gateway on the UltraCart account. 
         * @summary Updates payments transaction gateway
         * @param {TransactionGatewaysRequest} update_gateway_request Transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentsTransactionGateway(update_gateway_request: TransactionGatewaysRequest, options: any = {}): FetchArgs {
            // verify required parameter 'update_gateway_request' is not null or undefined
            if (update_gateway_request === null || update_gateway_request === undefined) {
                throw new RequiredError('update_gateway_request','Required parameter update_gateway_request was null or undefined when calling updatePaymentsTransactionGateway.');
            }
            const localVarPath = `/configuration/checkout/payments/tg`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionGatewaysRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(update_gateway_request || {}) : (update_gateway_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a rotating transaction gateway 
         * @summary Update a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to update.
         * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRotatingTransactionGateway(rtg_oid: number, rotating_transaction_gateway: RotatingTransactionGateway, options: any = {}): FetchArgs {
            // verify required parameter 'rtg_oid' is not null or undefined
            if (rtg_oid === null || rtg_oid === undefined) {
                throw new RequiredError('rtg_oid','Required parameter rtg_oid was null or undefined when calling updateRotatingTransactionGateway.');
            }
            // verify required parameter 'rotating_transaction_gateway' is not null or undefined
            if (rotating_transaction_gateway === null || rotating_transaction_gateway === undefined) {
                throw new RequiredError('rotating_transaction_gateway','Required parameter rotating_transaction_gateway was null or undefined when calling updateRotatingTransactionGateway.');
            }
            const localVarPath = `/configuration/checkout/payments/rtg/{rtg_oid}`
                .replace(`{${"rtg_oid"}}`, encodeURIComponent(String(rtg_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RotatingTransactionGateway" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(rotating_transaction_gateway || {}) : (rotating_transaction_gateway || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enroll with WePay on the UltraCart account. 
         * @summary Enroll with WePay
         * @param {PaymentsWepayEnroll} wepay_enroll Wepay enrollment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wepayEnroll(wepay_enroll: PaymentsWepayEnroll, options: any = {}): FetchArgs {
            // verify required parameter 'wepay_enroll' is not null or undefined
            if (wepay_enroll === null || wepay_enroll === undefined) {
                throw new RequiredError('wepay_enroll','Required parameter wepay_enroll was null or undefined when calling wepayEnroll.');
            }
            const localVarPath = `/configuration/checkout/wepayEnroll`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["configuration_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentsWepayEnroll" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(wepay_enroll || {}) : (wepay_enroll || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delay auto order processing for a day for this rotating transaction gateway 
         * @summary Delay auto order processing for a day for this rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to delay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delayAutoOrders(rtg_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DelayAutoOrdersResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).delayAutoOrders(rtg_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a rotating transaction gateway 
         * @summary Delete a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRotatingTransactionGateway(rtg_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).deleteRotatingTransactionGateway(rtg_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves payments configuration for this account. 
         * @summary Retrieve payments configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsConfiguration(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentsConfigurationResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).getPaymentsConfiguration(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a rotating transaction gateway 
         * @summary Retrieve a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid for the desired record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingGateway(rtg_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RotatingTransactionGatewayResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).getPaymentsRotatingGateway(rtg_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a rotating transaction gateway by code 
         * @summary Retrieve a rotating transaction gateway by code
         * @param {string} code The code for the desired rotating transaction gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingGatewayByCode(code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RotatingTransactionGatewayResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).getPaymentsRotatingGatewayByCode(code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of rotating transaction gateways 
         * @summary Retrieve a list of rotating transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingTransactionGateways(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RotatingTransactionGatewaysResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).getPaymentsRotatingTransactionGateways(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a summary of rotating transaction gateways 
         * @summary Retrieve a summary of rotating transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRtgSummaries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RtgSummaryResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).getPaymentsRtgSummaries(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of transaction gateways 
         * @summary Retrieve a list of transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTransactionGateways(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionGatewaysResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).getPaymentsTransactionGateways(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a rotating transaction gateway 
         * @summary Insert a rotating transaction gateway
         * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertRotatingTransactionGateway(rotating_transaction_gateway: RotatingTransactionGateway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RotatingTransactionGatewayResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).insertRotatingTransactionGateway(rotating_transaction_gateway, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Migrate a normal transaction gateway to a rotating transaction gateway 
         * @summary Migrate a normal transaction gateway to a rotating transaction gateway
         * @param {string} code The short code for the new rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateToRotatingTransactionGateway(code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RotatingTransactionGatewayResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).migrateToRotatingTransactionGateway(code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Begin the processing of connecting with Stripe. 
         * @summary Begin the processing of connecting with Stripe
         * @param {number} rtg_oid The rtg_oid to be connected to stripe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeConnect(rtg_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StripeConnectResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).stripeConnect(rtg_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates payments configuration on the UltraCart account. 
         * @summary Updates payments configuration
         * @param {PaymentsConfiguration} payments_configuration Payments configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentsConfiguration(payments_configuration: PaymentsConfiguration, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentsConfigurationResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).updatePaymentsConfiguration(payments_configuration, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates payments transaction gateway on the UltraCart account. 
         * @summary Updates payments transaction gateway
         * @param {TransactionGatewaysRequest} update_gateway_request Transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentsTransactionGateway(update_gateway_request: TransactionGatewaysRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionGatewaysResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).updatePaymentsTransactionGateway(update_gateway_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a rotating transaction gateway 
         * @summary Update a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to update.
         * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRotatingTransactionGateway(rtg_oid: number, rotating_transaction_gateway: RotatingTransactionGateway, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RotatingTransactionGatewayResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).updateRotatingTransactionGateway(rtg_oid, rotating_transaction_gateway, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enroll with WePay on the UltraCart account. 
         * @summary Enroll with WePay
         * @param {PaymentsWepayEnroll} wepay_enroll Wepay enrollment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wepayEnroll(wepay_enroll: PaymentsWepayEnroll, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentsConfigurationResponse> {
            const localVarFetchArgs = ConfigurationApiFetchParamCreator(configuration).wepayEnroll(wepay_enroll, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delay auto order processing for a day for this rotating transaction gateway 
         * @summary Delay auto order processing for a day for this rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to delay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delayAutoOrders(rtg_oid: number, options?: any) {
            return ConfigurationApiFp(configuration).delayAutoOrders(rtg_oid, options)(fetch, basePath);
        },
        /**
         * Delete a rotating transaction gateway 
         * @summary Delete a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRotatingTransactionGateway(rtg_oid: number, options?: any) {
            return ConfigurationApiFp(configuration).deleteRotatingTransactionGateway(rtg_oid, options)(fetch, basePath);
        },
        /**
         * Retrieves payments configuration for this account. 
         * @summary Retrieve payments configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsConfiguration(options?: any) {
            return ConfigurationApiFp(configuration).getPaymentsConfiguration(options)(fetch, basePath);
        },
        /**
         * Retrieve a rotating transaction gateway 
         * @summary Retrieve a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid for the desired record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingGateway(rtg_oid: number, options?: any) {
            return ConfigurationApiFp(configuration).getPaymentsRotatingGateway(rtg_oid, options)(fetch, basePath);
        },
        /**
         * Retrieve a rotating transaction gateway by code 
         * @summary Retrieve a rotating transaction gateway by code
         * @param {string} code The code for the desired rotating transaction gateway.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingGatewayByCode(code: string, options?: any) {
            return ConfigurationApiFp(configuration).getPaymentsRotatingGatewayByCode(code, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of rotating transaction gateways 
         * @summary Retrieve a list of rotating transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRotatingTransactionGateways(options?: any) {
            return ConfigurationApiFp(configuration).getPaymentsRotatingTransactionGateways(options)(fetch, basePath);
        },
        /**
         * Retrieve a summary of rotating transaction gateways 
         * @summary Retrieve a summary of rotating transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsRtgSummaries(options?: any) {
            return ConfigurationApiFp(configuration).getPaymentsRtgSummaries(options)(fetch, basePath);
        },
        /**
         * Retrieve a list of transaction gateways 
         * @summary Retrieve a list of transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTransactionGateways(options?: any) {
            return ConfigurationApiFp(configuration).getPaymentsTransactionGateways(options)(fetch, basePath);
        },
        /**
         * Insert a rotating transaction gateway 
         * @summary Insert a rotating transaction gateway
         * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertRotatingTransactionGateway(rotating_transaction_gateway: RotatingTransactionGateway, options?: any) {
            return ConfigurationApiFp(configuration).insertRotatingTransactionGateway(rotating_transaction_gateway, options)(fetch, basePath);
        },
        /**
         * Migrate a normal transaction gateway to a rotating transaction gateway 
         * @summary Migrate a normal transaction gateway to a rotating transaction gateway
         * @param {string} code The short code for the new rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateToRotatingTransactionGateway(code: string, options?: any) {
            return ConfigurationApiFp(configuration).migrateToRotatingTransactionGateway(code, options)(fetch, basePath);
        },
        /**
         * Begin the processing of connecting with Stripe. 
         * @summary Begin the processing of connecting with Stripe
         * @param {number} rtg_oid The rtg_oid to be connected to stripe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeConnect(rtg_oid: number, options?: any) {
            return ConfigurationApiFp(configuration).stripeConnect(rtg_oid, options)(fetch, basePath);
        },
        /**
         * Updates payments configuration on the UltraCart account. 
         * @summary Updates payments configuration
         * @param {PaymentsConfiguration} payments_configuration Payments configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentsConfiguration(payments_configuration: PaymentsConfiguration, options?: any) {
            return ConfigurationApiFp(configuration).updatePaymentsConfiguration(payments_configuration, options)(fetch, basePath);
        },
        /**
         * Updates payments transaction gateway on the UltraCart account. 
         * @summary Updates payments transaction gateway
         * @param {TransactionGatewaysRequest} update_gateway_request Transaction gateways
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentsTransactionGateway(update_gateway_request: TransactionGatewaysRequest, options?: any) {
            return ConfigurationApiFp(configuration).updatePaymentsTransactionGateway(update_gateway_request, options)(fetch, basePath);
        },
        /**
         * Update a rotating transaction gateway 
         * @summary Update a rotating transaction gateway
         * @param {number} rtg_oid The rtg_oid to update.
         * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRotatingTransactionGateway(rtg_oid: number, rotating_transaction_gateway: RotatingTransactionGateway, options?: any) {
            return ConfigurationApiFp(configuration).updateRotatingTransactionGateway(rtg_oid, rotating_transaction_gateway, options)(fetch, basePath);
        },
        /**
         * Enroll with WePay on the UltraCart account. 
         * @summary Enroll with WePay
         * @param {PaymentsWepayEnroll} wepay_enroll Wepay enrollment information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wepayEnroll(wepay_enroll: PaymentsWepayEnroll, options?: any) {
            return ConfigurationApiFp(configuration).wepayEnroll(wepay_enroll, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigurationApi - interface
 * @export
 * @interface ConfigurationApi
 */
export interface ConfigurationApiInterface {
    /**
     * Delay auto order processing for a day for this rotating transaction gateway 
     * @summary Delay auto order processing for a day for this rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid to delay.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    delayAutoOrders(rtg_oid: number, options?: any): Promise<DelayAutoOrdersResponse>;

    /**
     * Delete a rotating transaction gateway 
     * @summary Delete a rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    deleteRotatingTransactionGateway(rtg_oid: number, options?: any): Promise<BaseResponse>;

    /**
     * Retrieves payments configuration for this account. 
     * @summary Retrieve payments configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    getPaymentsConfiguration(options?: any): Promise<PaymentsConfigurationResponse>;

    /**
     * Retrieve a rotating transaction gateway 
     * @summary Retrieve a rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid for the desired record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    getPaymentsRotatingGateway(rtg_oid: number, options?: any): Promise<RotatingTransactionGatewayResponse>;

    /**
     * Retrieve a rotating transaction gateway by code 
     * @summary Retrieve a rotating transaction gateway by code
     * @param {string} code The code for the desired rotating transaction gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    getPaymentsRotatingGatewayByCode(code: string, options?: any): Promise<RotatingTransactionGatewayResponse>;

    /**
     * Retrieve a list of rotating transaction gateways 
     * @summary Retrieve a list of rotating transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    getPaymentsRotatingTransactionGateways(options?: any): Promise<RotatingTransactionGatewaysResponse>;

    /**
     * Retrieve a summary of rotating transaction gateways 
     * @summary Retrieve a summary of rotating transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    getPaymentsRtgSummaries(options?: any): Promise<RtgSummaryResponse>;

    /**
     * Retrieve a list of transaction gateways 
     * @summary Retrieve a list of transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    getPaymentsTransactionGateways(options?: any): Promise<TransactionGatewaysResponse>;

    /**
     * Insert a rotating transaction gateway 
     * @summary Insert a rotating transaction gateway
     * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    insertRotatingTransactionGateway(rotating_transaction_gateway: RotatingTransactionGateway, options?: any): Promise<RotatingTransactionGatewayResponse>;

    /**
     * Migrate a normal transaction gateway to a rotating transaction gateway 
     * @summary Migrate a normal transaction gateway to a rotating transaction gateway
     * @param {string} code The short code for the new rotating transaction gateway
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    migrateToRotatingTransactionGateway(code: string, options?: any): Promise<RotatingTransactionGatewayResponse>;

    /**
     * Begin the processing of connecting with Stripe. 
     * @summary Begin the processing of connecting with Stripe
     * @param {number} rtg_oid The rtg_oid to be connected to stripe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    stripeConnect(rtg_oid: number, options?: any): Promise<StripeConnectResponse>;

    /**
     * Updates payments configuration on the UltraCart account. 
     * @summary Updates payments configuration
     * @param {PaymentsConfiguration} payments_configuration Payments configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    updatePaymentsConfiguration(payments_configuration: PaymentsConfiguration, options?: any): Promise<PaymentsConfigurationResponse>;

    /**
     * Updates payments transaction gateway on the UltraCart account. 
     * @summary Updates payments transaction gateway
     * @param {TransactionGatewaysRequest} update_gateway_request Transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    updatePaymentsTransactionGateway(update_gateway_request: TransactionGatewaysRequest, options?: any): Promise<TransactionGatewaysResponse>;

    /**
     * Update a rotating transaction gateway 
     * @summary Update a rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid to update.
     * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    updateRotatingTransactionGateway(rtg_oid: number, rotating_transaction_gateway: RotatingTransactionGateway, options?: any): Promise<RotatingTransactionGatewayResponse>;

    /**
     * Enroll with WePay on the UltraCart account. 
     * @summary Enroll with WePay
     * @param {PaymentsWepayEnroll} wepay_enroll Wepay enrollment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApiInterface
     */
    wepayEnroll(wepay_enroll: PaymentsWepayEnroll, options?: any): Promise<PaymentsConfigurationResponse>;

}

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI implements ConfigurationApiInterface {
    /**
     * Delay auto order processing for a day for this rotating transaction gateway 
     * @summary Delay auto order processing for a day for this rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid to delay.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public delayAutoOrders(rtg_oid: number, options?: any) {
        return ConfigurationApiFp(this.configuration).delayAutoOrders(rtg_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a rotating transaction gateway 
     * @summary Delete a rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public deleteRotatingTransactionGateway(rtg_oid: number, options?: any) {
        return ConfigurationApiFp(this.configuration).deleteRotatingTransactionGateway(rtg_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves payments configuration for this account. 
     * @summary Retrieve payments configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getPaymentsConfiguration(options?: any) {
        return ConfigurationApiFp(this.configuration).getPaymentsConfiguration(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a rotating transaction gateway 
     * @summary Retrieve a rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid for the desired record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getPaymentsRotatingGateway(rtg_oid: number, options?: any) {
        return ConfigurationApiFp(this.configuration).getPaymentsRotatingGateway(rtg_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a rotating transaction gateway by code 
     * @summary Retrieve a rotating transaction gateway by code
     * @param {string} code The code for the desired rotating transaction gateway.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getPaymentsRotatingGatewayByCode(code: string, options?: any) {
        return ConfigurationApiFp(this.configuration).getPaymentsRotatingGatewayByCode(code, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of rotating transaction gateways 
     * @summary Retrieve a list of rotating transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getPaymentsRotatingTransactionGateways(options?: any) {
        return ConfigurationApiFp(this.configuration).getPaymentsRotatingTransactionGateways(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a summary of rotating transaction gateways 
     * @summary Retrieve a summary of rotating transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getPaymentsRtgSummaries(options?: any) {
        return ConfigurationApiFp(this.configuration).getPaymentsRtgSummaries(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of transaction gateways 
     * @summary Retrieve a list of transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getPaymentsTransactionGateways(options?: any) {
        return ConfigurationApiFp(this.configuration).getPaymentsTransactionGateways(options)(this.fetch, this.basePath);
    }

    /**
     * Insert a rotating transaction gateway 
     * @summary Insert a rotating transaction gateway
     * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public insertRotatingTransactionGateway(rotating_transaction_gateway: RotatingTransactionGateway, options?: any) {
        return ConfigurationApiFp(this.configuration).insertRotatingTransactionGateway(rotating_transaction_gateway, options)(this.fetch, this.basePath);
    }

    /**
     * Migrate a normal transaction gateway to a rotating transaction gateway 
     * @summary Migrate a normal transaction gateway to a rotating transaction gateway
     * @param {string} code The short code for the new rotating transaction gateway
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public migrateToRotatingTransactionGateway(code: string, options?: any) {
        return ConfigurationApiFp(this.configuration).migrateToRotatingTransactionGateway(code, options)(this.fetch, this.basePath);
    }

    /**
     * Begin the processing of connecting with Stripe. 
     * @summary Begin the processing of connecting with Stripe
     * @param {number} rtg_oid The rtg_oid to be connected to stripe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public stripeConnect(rtg_oid: number, options?: any) {
        return ConfigurationApiFp(this.configuration).stripeConnect(rtg_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Updates payments configuration on the UltraCart account. 
     * @summary Updates payments configuration
     * @param {PaymentsConfiguration} payments_configuration Payments configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updatePaymentsConfiguration(payments_configuration: PaymentsConfiguration, options?: any) {
        return ConfigurationApiFp(this.configuration).updatePaymentsConfiguration(payments_configuration, options)(this.fetch, this.basePath);
    }

    /**
     * Updates payments transaction gateway on the UltraCart account. 
     * @summary Updates payments transaction gateway
     * @param {TransactionGatewaysRequest} update_gateway_request Transaction gateways
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updatePaymentsTransactionGateway(update_gateway_request: TransactionGatewaysRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).updatePaymentsTransactionGateway(update_gateway_request, options)(this.fetch, this.basePath);
    }

    /**
     * Update a rotating transaction gateway 
     * @summary Update a rotating transaction gateway
     * @param {number} rtg_oid The rtg_oid to update.
     * @param {RotatingTransactionGateway} rotating_transaction_gateway Rotating transaction gateway
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateRotatingTransactionGateway(rtg_oid: number, rotating_transaction_gateway: RotatingTransactionGateway, options?: any) {
        return ConfigurationApiFp(this.configuration).updateRotatingTransactionGateway(rtg_oid, rotating_transaction_gateway, options)(this.fetch, this.basePath);
    }

    /**
     * Enroll with WePay on the UltraCart account. 
     * @summary Enroll with WePay
     * @param {PaymentsWepayEnroll} wepay_enroll Wepay enrollment information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public wepayEnroll(wepay_enroll: PaymentsWepayEnroll, options?: any) {
        return ConfigurationApiFp(this.configuration).wepayEnroll(wepay_enroll, options)(this.fetch, this.basePath);
    }

}

/**
 * CouponApi - fetch parameter creator
 * @export
 */
export const CouponApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a coupon on the UltraCart account. 
         * @summary Delete a coupon
         * @param {number} coupon_oid The coupon_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(coupon_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'coupon_oid' is not null or undefined
            if (coupon_oid === null || coupon_oid === undefined) {
                throw new RequiredError('coupon_oid','Required parameter coupon_oid was null or undefined when calling deleteCoupon.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(coupon_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete coupons on the UltraCart account. 
         * @summary Deletes multiple coupons
         * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCouponsByCode(coupon_delete_request: CouponDeletesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'coupon_delete_request' is not null or undefined
            if (coupon_delete_request === null || coupon_delete_request === undefined) {
                throw new RequiredError('coupon_delete_request','Required parameter coupon_delete_request was null or undefined when calling deleteCouponsByCode.');
            }
            const localVarPath = `/coupon/coupons/by_code`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponDeletesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon_delete_request || {}) : (coupon_delete_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete coupons on the UltraCart account. 
         * @summary Deletes multiple coupons
         * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCouponsByOid(coupon_delete_request: CouponDeletesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'coupon_delete_request' is not null or undefined
            if (coupon_delete_request === null || coupon_delete_request === undefined) {
                throw new RequiredError('coupon_delete_request','Required parameter coupon_delete_request was null or undefined when calling deleteCouponsByOid.');
            }
            const localVarPath = `/coupon/coupons/by_oid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponDeletesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon_delete_request || {}) : (coupon_delete_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Determines if a coupon merchant code already exists. 
         * @summary Determines if a coupon merchant code already exists
         * @param {string} merchant_code The coupon merchant code to examine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesCouponCodeExist(merchant_code: string, options: any = {}): FetchArgs {
            // verify required parameter 'merchant_code' is not null or undefined
            if (merchant_code === null || merchant_code === undefined) {
                throw new RequiredError('merchant_code','Required parameter merchant_code was null or undefined when calling doesCouponCodeExist.');
            }
            const localVarPath = `/coupon/coupons/merchant_code/{merchant_code}/exists`
                .replace(`{${"merchant_code"}}`, encodeURIComponent(String(merchant_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate one time codes for a coupon 
         * @summary Generates one time codes for a coupon
         * @param {number} coupon_oid The coupon oid to generate codes.
         * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCouponCodes(coupon_oid: number, coupon_codes_request: CouponCodesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'coupon_oid' is not null or undefined
            if (coupon_oid === null || coupon_oid === undefined) {
                throw new RequiredError('coupon_oid','Required parameter coupon_oid was null or undefined when calling generateCouponCodes.');
            }
            // verify required parameter 'coupon_codes_request' is not null or undefined
            if (coupon_codes_request === null || coupon_codes_request === undefined) {
                throw new RequiredError('coupon_codes_request','Required parameter coupon_codes_request was null or undefined when calling generateCouponCodes.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}/generate_codes`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(coupon_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponCodesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon_codes_request || {}) : (coupon_codes_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate one time codes by merchant code 
         * @summary Generates one time codes by merchant code
         * @param {string} merchant_code The merchant code to generate one time codes.
         * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOneTimeCodesByMerchantCode(merchant_code: string, coupon_codes_request: CouponCodesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'merchant_code' is not null or undefined
            if (merchant_code === null || merchant_code === undefined) {
                throw new RequiredError('merchant_code','Required parameter merchant_code was null or undefined when calling generateOneTimeCodesByMerchantCode.');
            }
            // verify required parameter 'coupon_codes_request' is not null or undefined
            if (coupon_codes_request === null || coupon_codes_request === undefined) {
                throw new RequiredError('coupon_codes_request','Required parameter coupon_codes_request was null or undefined when calling generateOneTimeCodesByMerchantCode.');
            }
            const localVarPath = `/coupon/coupons/merchant_code/{merchant_code}/generate_codes`
                .replace(`{${"merchant_code"}}`, encodeURIComponent(String(merchant_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponCodesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon_codes_request || {}) : (coupon_codes_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve auto apply rules and conditions 
         * @summary Retrieve auto apply rules and conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoApply(options: any = {}): FetchArgs {
            const localVarPath = `/coupon/auto_apply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single coupon using the specified coupon profile oid. 
         * @summary Retrieve a coupon
         * @param {number} coupon_oid The coupon oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(coupon_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'coupon_oid' is not null or undefined
            if (coupon_oid === null || coupon_oid === undefined) {
                throw new RequiredError('coupon_oid','Required parameter coupon_oid was null or undefined when calling getCoupon.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(coupon_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single coupon using the specified merchant code. 
         * @summary Retrieve a coupon by merchant code
         * @param {string} merchant_code The coupon merchant code to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponByMerchantCode(merchant_code: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'merchant_code' is not null or undefined
            if (merchant_code === null || merchant_code === undefined) {
                throw new RequiredError('merchant_code','Required parameter merchant_code was null or undefined when calling getCouponByMerchantCode.');
            }
            const localVarPath = `/coupon/coupons/merchant_code/{merchant_code}`
                .replace(`{${"merchant_code"}}`, encodeURIComponent(String(merchant_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons
         * @param {string} [merchant_code] Merchant code
         * @param {string} [description] Description
         * @param {string} [coupon_type] Coupon type
         * @param {string} [start_date_begin] Start date begin
         * @param {string} [start_date_end] Start date end
         * @param {string} [expiration_date_begin] Expiration date begin
         * @param {string} [expiration_date_end] Expiration date end
         * @param {number} [affiliate_oid] Affiliate oid
         * @param {boolean} [exclude_expired] Exclude expired
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupons(merchant_code?: string, description?: string, coupon_type?: string, start_date_begin?: string, start_date_end?: string, expiration_date_begin?: string, expiration_date_end?: string, affiliate_oid?: number, exclude_expired?: boolean, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/coupon/coupons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (merchant_code !== undefined) {
                localVarQueryParameter['merchant_code'] = merchant_code;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (coupon_type !== undefined) {
                localVarQueryParameter['coupon_type'] = coupon_type;
            }

            if (start_date_begin !== undefined) {
                localVarQueryParameter['start_date_begin'] = start_date_begin;
            }

            if (start_date_end !== undefined) {
                localVarQueryParameter['start_date_end'] = start_date_end;
            }

            if (expiration_date_begin !== undefined) {
                localVarQueryParameter['expiration_date_begin'] = expiration_date_begin;
            }

            if (expiration_date_end !== undefined) {
                localVarQueryParameter['expiration_date_end'] = expiration_date_end;
            }

            if (affiliate_oid !== undefined) {
                localVarQueryParameter['affiliate_oid'] = affiliate_oid;
            }

            if (exclude_expired !== undefined) {
                localVarQueryParameter['exclude_expired'] = exclude_expired;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons by query
         * @param {CouponQuery} coupon_query Coupon query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponsByQuery(coupon_query: CouponQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'coupon_query' is not null or undefined
            if (coupon_query === null || coupon_query === undefined) {
                throw new RequiredError('coupon_query','Required parameter coupon_query was null or undefined when calling getCouponsByQuery.');
            }
            const localVarPath = `/coupon/coupons/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon_query || {}) : (coupon_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve values needed for a coupon editor 
         * @summary Retrieve values needed for a coupon editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options: any = {}): FetchArgs {
            const localVarPath = `/coupon/editor_values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a coupon on the UltraCart account. 
         * @summary Insert a coupon
         * @param {Coupon} coupon Coupon to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupon(coupon: Coupon, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'coupon' is not null or undefined
            if (coupon === null || coupon === undefined) {
                throw new RequiredError('coupon','Required parameter coupon was null or undefined when calling insertCoupon.');
            }
            const localVarPath = `/coupon/coupons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Coupon" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon || {}) : (coupon || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert multiple coupon on the UltraCart account. 
         * @summary Insert multiple coupons
         * @param {CouponsRequest} coupons_request Coupons to insert (maximum 50)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'coupons_request' is not null or undefined
            if (coupons_request === null || coupons_request === undefined) {
                throw new RequiredError('coupons_request','Required parameter coupons_request was null or undefined when calling insertCoupons.');
            }
            const localVarPath = `/coupon/coupons/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupons_request || {}) : (coupons_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for items to display within a coupon editor and assign to coupons 
         * @summary Searches for items to display within a coupon editor and assign to coupons
         * @param {string} [s] 
         * @param {number} [m] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItems(s?: string, m?: number, options: any = {}): FetchArgs {
            const localVarPath = `/coupon/searchItems`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (s !== undefined) {
                localVarQueryParameter['s'] = s;
            }

            if (m !== undefined) {
                localVarQueryParameter['m'] = m;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update auto apply rules and conditions 
         * @summary Update auto apply rules and conditions
         * @param {CouponAutoApplyConditions} conditions Conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoApply(conditions: CouponAutoApplyConditions, options: any = {}): FetchArgs {
            // verify required parameter 'conditions' is not null or undefined
            if (conditions === null || conditions === undefined) {
                throw new RequiredError('conditions','Required parameter conditions was null or undefined when calling updateAutoApply.');
            }
            const localVarPath = `/coupon/auto_apply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponAutoApplyConditions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(conditions || {}) : (conditions || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a coupon on the UltraCart account. 
         * @summary Update a coupon
         * @param {Coupon} coupon Coupon to update
         * @param {number} coupon_oid The coupon_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(coupon: Coupon, coupon_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'coupon' is not null or undefined
            if (coupon === null || coupon === undefined) {
                throw new RequiredError('coupon','Required parameter coupon was null or undefined when calling updateCoupon.');
            }
            // verify required parameter 'coupon_oid' is not null or undefined
            if (coupon_oid === null || coupon_oid === undefined) {
                throw new RequiredError('coupon_oid','Required parameter coupon_oid was null or undefined when calling updateCoupon.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(coupon_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Coupon" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupon || {}) : (coupon || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple coupon on the UltraCart account. 
         * @summary Update multiple coupons
         * @param {CouponsRequest} coupons_request Coupons to update (synchronous maximum 50 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'coupons_request' is not null or undefined
            if (coupons_request === null || coupons_request === undefined) {
                throw new RequiredError('coupons_request','Required parameter coupons_request was null or undefined when calling updateCoupons.');
            }
            const localVarPath = `/coupon/coupons/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            if (_async !== undefined) {
                localVarQueryParameter['_async'] = _async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CouponsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(coupons_request || {}) : (coupons_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload one-time codes for a coupon 
         * @summary Upload one-time codes for a coupon
         * @param {number} coupon_oid The coupon oid to associate with the provided one-time codes.
         * @param {UploadCouponCodesRequest} upload_coupon_codes_request One-time coupon codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCouponCodes(coupon_oid: number, upload_coupon_codes_request: UploadCouponCodesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'coupon_oid' is not null or undefined
            if (coupon_oid === null || coupon_oid === undefined) {
                throw new RequiredError('coupon_oid','Required parameter coupon_oid was null or undefined when calling uploadCouponCodes.');
            }
            // verify required parameter 'upload_coupon_codes_request' is not null or undefined
            if (upload_coupon_codes_request === null || upload_coupon_codes_request === undefined) {
                throw new RequiredError('upload_coupon_codes_request','Required parameter upload_coupon_codes_request was null or undefined when calling uploadCouponCodes.');
            }
            const localVarPath = `/coupon/coupons/{coupon_oid}/upload_codes`
                .replace(`{${"coupon_oid"}}`, encodeURIComponent(String(coupon_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["coupon_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UploadCouponCodesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(upload_coupon_codes_request || {}) : (upload_coupon_codes_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponApi - functional programming interface
 * @export
 */
export const CouponApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a coupon on the UltraCart account. 
         * @summary Delete a coupon
         * @param {number} coupon_oid The coupon_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(coupon_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).deleteCoupon(coupon_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete coupons on the UltraCart account. 
         * @summary Deletes multiple coupons
         * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCouponsByCode(coupon_delete_request: CouponDeletesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).deleteCouponsByCode(coupon_delete_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete coupons on the UltraCart account. 
         * @summary Deletes multiple coupons
         * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCouponsByOid(coupon_delete_request: CouponDeletesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).deleteCouponsByOid(coupon_delete_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Determines if a coupon merchant code already exists. 
         * @summary Determines if a coupon merchant code already exists
         * @param {string} merchant_code The coupon merchant code to examine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesCouponCodeExist(merchant_code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponExistsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).doesCouponCodeExist(merchant_code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate one time codes for a coupon 
         * @summary Generates one time codes for a coupon
         * @param {number} coupon_oid The coupon oid to generate codes.
         * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCouponCodes(coupon_oid: number, coupon_codes_request: CouponCodesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponCodesResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).generateCouponCodes(coupon_oid, coupon_codes_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate one time codes by merchant code 
         * @summary Generates one time codes by merchant code
         * @param {string} merchant_code The merchant code to generate one time codes.
         * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOneTimeCodesByMerchantCode(merchant_code: string, coupon_codes_request: CouponCodesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponCodesResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).generateOneTimeCodesByMerchantCode(merchant_code, coupon_codes_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve auto apply rules and conditions 
         * @summary Retrieve auto apply rules and conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoApply(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponAutoApplyConditions> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getAutoApply(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single coupon using the specified coupon profile oid. 
         * @summary Retrieve a coupon
         * @param {number} coupon_oid The coupon oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(coupon_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCoupon(coupon_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single coupon using the specified merchant code. 
         * @summary Retrieve a coupon by merchant code
         * @param {string} merchant_code The coupon merchant code to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponByMerchantCode(merchant_code: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCouponByMerchantCode(merchant_code, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons
         * @param {string} [merchant_code] Merchant code
         * @param {string} [description] Description
         * @param {string} [coupon_type] Coupon type
         * @param {string} [start_date_begin] Start date begin
         * @param {string} [start_date_end] Start date end
         * @param {string} [expiration_date_begin] Expiration date begin
         * @param {string} [expiration_date_end] Expiration date end
         * @param {number} [affiliate_oid] Affiliate oid
         * @param {boolean} [exclude_expired] Exclude expired
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupons(merchant_code?: string, description?: string, coupon_type?: string, start_date_begin?: string, start_date_end?: string, expiration_date_begin?: string, expiration_date_end?: string, affiliate_oid?: number, exclude_expired?: boolean, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCoupons(merchant_code, description, coupon_type, start_date_begin, start_date_end, expiration_date_begin, expiration_date_end, affiliate_oid, exclude_expired, _limit, _offset, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons by query
         * @param {CouponQuery} coupon_query Coupon query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponsByQuery(coupon_query: CouponQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getCouponsByQuery(coupon_query, _limit, _offset, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve values needed for a coupon editor 
         * @summary Retrieve values needed for a coupon editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponEditorValues> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).getEditorValues(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a coupon on the UltraCart account. 
         * @summary Insert a coupon
         * @param {Coupon} coupon Coupon to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupon(coupon: Coupon, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).insertCoupon(coupon, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert multiple coupon on the UltraCart account. 
         * @summary Insert multiple coupons
         * @param {CouponsRequest} coupons_request Coupons to insert (maximum 50)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).insertCoupons(coupons_request, _expand, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Searches for items to display within a coupon editor and assign to coupons 
         * @summary Searches for items to display within a coupon editor and assign to coupons
         * @param {string} [s] 
         * @param {number} [m] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItems(s?: string, m?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponItemSearchResultsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).searchItems(s, m, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update auto apply rules and conditions 
         * @summary Update auto apply rules and conditions
         * @param {CouponAutoApplyConditions} conditions Conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoApply(conditions: CouponAutoApplyConditions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).updateAutoApply(conditions, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a coupon on the UltraCart account. 
         * @summary Update a coupon
         * @param {Coupon} coupon Coupon to update
         * @param {number} coupon_oid The coupon_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(coupon: Coupon, coupon_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).updateCoupon(coupon, coupon_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update multiple coupon on the UltraCart account. 
         * @summary Update multiple coupons
         * @param {CouponsRequest} coupons_request Coupons to update (synchronous maximum 50 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponsResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).updateCoupons(coupons_request, _expand, _placeholders, _async, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upload one-time codes for a coupon 
         * @summary Upload one-time codes for a coupon
         * @param {number} coupon_oid The coupon oid to associate with the provided one-time codes.
         * @param {UploadCouponCodesRequest} upload_coupon_codes_request One-time coupon codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCouponCodes(coupon_oid: number, upload_coupon_codes_request: UploadCouponCodesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadCouponCodesResponse> {
            const localVarFetchArgs = CouponApiFetchParamCreator(configuration).uploadCouponCodes(coupon_oid, upload_coupon_codes_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CouponApi - factory interface
 * @export
 */
export const CouponApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a coupon on the UltraCart account. 
         * @summary Delete a coupon
         * @param {number} coupon_oid The coupon_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(coupon_oid: number, options?: any) {
            return CouponApiFp(configuration).deleteCoupon(coupon_oid, options)(fetch, basePath);
        },
        /**
         * Delete coupons on the UltraCart account. 
         * @summary Deletes multiple coupons
         * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCouponsByCode(coupon_delete_request: CouponDeletesRequest, options?: any) {
            return CouponApiFp(configuration).deleteCouponsByCode(coupon_delete_request, options)(fetch, basePath);
        },
        /**
         * Delete coupons on the UltraCart account. 
         * @summary Deletes multiple coupons
         * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCouponsByOid(coupon_delete_request: CouponDeletesRequest, options?: any) {
            return CouponApiFp(configuration).deleteCouponsByOid(coupon_delete_request, options)(fetch, basePath);
        },
        /**
         * Determines if a coupon merchant code already exists. 
         * @summary Determines if a coupon merchant code already exists
         * @param {string} merchant_code The coupon merchant code to examine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesCouponCodeExist(merchant_code: string, options?: any) {
            return CouponApiFp(configuration).doesCouponCodeExist(merchant_code, options)(fetch, basePath);
        },
        /**
         * Generate one time codes for a coupon 
         * @summary Generates one time codes for a coupon
         * @param {number} coupon_oid The coupon oid to generate codes.
         * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCouponCodes(coupon_oid: number, coupon_codes_request: CouponCodesRequest, options?: any) {
            return CouponApiFp(configuration).generateCouponCodes(coupon_oid, coupon_codes_request, options)(fetch, basePath);
        },
        /**
         * Generate one time codes by merchant code 
         * @summary Generates one time codes by merchant code
         * @param {string} merchant_code The merchant code to generate one time codes.
         * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOneTimeCodesByMerchantCode(merchant_code: string, coupon_codes_request: CouponCodesRequest, options?: any) {
            return CouponApiFp(configuration).generateOneTimeCodesByMerchantCode(merchant_code, coupon_codes_request, options)(fetch, basePath);
        },
        /**
         * Retrieve auto apply rules and conditions 
         * @summary Retrieve auto apply rules and conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoApply(options?: any) {
            return CouponApiFp(configuration).getAutoApply(options)(fetch, basePath);
        },
        /**
         * Retrieves a single coupon using the specified coupon profile oid. 
         * @summary Retrieve a coupon
         * @param {number} coupon_oid The coupon oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(coupon_oid: number, _expand?: string, options?: any) {
            return CouponApiFp(configuration).getCoupon(coupon_oid, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single coupon using the specified merchant code. 
         * @summary Retrieve a coupon by merchant code
         * @param {string} merchant_code The coupon merchant code to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponByMerchantCode(merchant_code: string, _expand?: string, options?: any) {
            return CouponApiFp(configuration).getCouponByMerchantCode(merchant_code, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons
         * @param {string} [merchant_code] Merchant code
         * @param {string} [description] Description
         * @param {string} [coupon_type] Coupon type
         * @param {string} [start_date_begin] Start date begin
         * @param {string} [start_date_end] Start date end
         * @param {string} [expiration_date_begin] Expiration date begin
         * @param {string} [expiration_date_end] Expiration date end
         * @param {number} [affiliate_oid] Affiliate oid
         * @param {boolean} [exclude_expired] Exclude expired
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupons(merchant_code?: string, description?: string, coupon_type?: string, start_date_begin?: string, start_date_end?: string, expiration_date_begin?: string, expiration_date_end?: string, affiliate_oid?: number, exclude_expired?: boolean, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
            return CouponApiFp(configuration).getCoupons(merchant_code, description, coupon_type, start_date_begin, start_date_end, expiration_date_begin, expiration_date_end, affiliate_oid, exclude_expired, _limit, _offset, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve coupons by query
         * @param {CouponQuery} coupon_query Coupon query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCouponsByQuery(coupon_query: CouponQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
            return CouponApiFp(configuration).getCouponsByQuery(coupon_query, _limit, _offset, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieve values needed for a coupon editor 
         * @summary Retrieve values needed for a coupon editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorValues(options?: any) {
            return CouponApiFp(configuration).getEditorValues(options)(fetch, basePath);
        },
        /**
         * Insert a coupon on the UltraCart account. 
         * @summary Insert a coupon
         * @param {Coupon} coupon Coupon to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupon(coupon: Coupon, _expand?: string, options?: any) {
            return CouponApiFp(configuration).insertCoupon(coupon, _expand, options)(fetch, basePath);
        },
        /**
         * Insert multiple coupon on the UltraCart account. 
         * @summary Insert multiple coupons
         * @param {CouponsRequest} coupons_request Coupons to insert (maximum 50)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, options?: any) {
            return CouponApiFp(configuration).insertCoupons(coupons_request, _expand, _placeholders, options)(fetch, basePath);
        },
        /**
         * Searches for items to display within a coupon editor and assign to coupons 
         * @summary Searches for items to display within a coupon editor and assign to coupons
         * @param {string} [s] 
         * @param {number} [m] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchItems(s?: string, m?: number, options?: any) {
            return CouponApiFp(configuration).searchItems(s, m, options)(fetch, basePath);
        },
        /**
         * Update auto apply rules and conditions 
         * @summary Update auto apply rules and conditions
         * @param {CouponAutoApplyConditions} conditions Conditions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutoApply(conditions: CouponAutoApplyConditions, options?: any) {
            return CouponApiFp(configuration).updateAutoApply(conditions, options)(fetch, basePath);
        },
        /**
         * Update a coupon on the UltraCart account. 
         * @summary Update a coupon
         * @param {Coupon} coupon Coupon to update
         * @param {number} coupon_oid The coupon_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(coupon: Coupon, coupon_oid: number, _expand?: string, options?: any) {
            return CouponApiFp(configuration).updateCoupon(coupon, coupon_oid, _expand, options)(fetch, basePath);
        },
        /**
         * Update multiple coupon on the UltraCart account. 
         * @summary Update multiple coupons
         * @param {CouponsRequest} coupons_request Coupons to update (synchronous maximum 50 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any) {
            return CouponApiFp(configuration).updateCoupons(coupons_request, _expand, _placeholders, _async, options)(fetch, basePath);
        },
        /**
         * Upload one-time codes for a coupon 
         * @summary Upload one-time codes for a coupon
         * @param {number} coupon_oid The coupon oid to associate with the provided one-time codes.
         * @param {UploadCouponCodesRequest} upload_coupon_codes_request One-time coupon codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCouponCodes(coupon_oid: number, upload_coupon_codes_request: UploadCouponCodesRequest, options?: any) {
            return CouponApiFp(configuration).uploadCouponCodes(coupon_oid, upload_coupon_codes_request, options)(fetch, basePath);
        },
    };
};

/**
 * CouponApi - interface
 * @export
 * @interface CouponApi
 */
export interface CouponApiInterface {
    /**
     * Delete a coupon on the UltraCart account. 
     * @summary Delete a coupon
     * @param {number} coupon_oid The coupon_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    deleteCoupon(coupon_oid: number, options?: any): Promise<{}>;

    /**
     * Delete coupons on the UltraCart account. 
     * @summary Deletes multiple coupons
     * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    deleteCouponsByCode(coupon_delete_request: CouponDeletesRequest, options?: any): Promise<{}>;

    /**
     * Delete coupons on the UltraCart account. 
     * @summary Deletes multiple coupons
     * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    deleteCouponsByOid(coupon_delete_request: CouponDeletesRequest, options?: any): Promise<{}>;

    /**
     * Determines if a coupon merchant code already exists. 
     * @summary Determines if a coupon merchant code already exists
     * @param {string} merchant_code The coupon merchant code to examine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    doesCouponCodeExist(merchant_code: string, options?: any): Promise<CouponExistsResponse>;

    /**
     * Generate one time codes for a coupon 
     * @summary Generates one time codes for a coupon
     * @param {number} coupon_oid The coupon oid to generate codes.
     * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    generateCouponCodes(coupon_oid: number, coupon_codes_request: CouponCodesRequest, options?: any): Promise<CouponCodesResponse>;

    /**
     * Generate one time codes by merchant code 
     * @summary Generates one time codes by merchant code
     * @param {string} merchant_code The merchant code to generate one time codes.
     * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    generateOneTimeCodesByMerchantCode(merchant_code: string, coupon_codes_request: CouponCodesRequest, options?: any): Promise<CouponCodesResponse>;

    /**
     * Retrieve auto apply rules and conditions 
     * @summary Retrieve auto apply rules and conditions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getAutoApply(options?: any): Promise<CouponAutoApplyConditions>;

    /**
     * Retrieves a single coupon using the specified coupon profile oid. 
     * @summary Retrieve a coupon
     * @param {number} coupon_oid The coupon oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCoupon(coupon_oid: number, _expand?: string, options?: any): Promise<CouponResponse>;

    /**
     * Retrieves a single coupon using the specified merchant code. 
     * @summary Retrieve a coupon by merchant code
     * @param {string} merchant_code The coupon merchant code to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCouponByMerchantCode(merchant_code: string, _expand?: string, options?: any): Promise<CouponResponse>;

    /**
     * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons
     * @param {string} [merchant_code] Merchant code
     * @param {string} [description] Description
     * @param {string} [coupon_type] Coupon type
     * @param {string} [start_date_begin] Start date begin
     * @param {string} [start_date_end] Start date end
     * @param {string} [expiration_date_begin] Expiration date begin
     * @param {string} [expiration_date_end] Expiration date end
     * @param {number} [affiliate_oid] Affiliate oid
     * @param {boolean} [exclude_expired] Exclude expired
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCoupons(merchant_code?: string, description?: string, coupon_type?: string, start_date_begin?: string, start_date_end?: string, expiration_date_begin?: string, expiration_date_end?: string, affiliate_oid?: number, exclude_expired?: boolean, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): Promise<CouponsResponse>;

    /**
     * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons by query
     * @param {CouponQuery} coupon_query Coupon query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getCouponsByQuery(coupon_query: CouponQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): Promise<CouponsResponse>;

    /**
     * Retrieve values needed for a coupon editor 
     * @summary Retrieve values needed for a coupon editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    getEditorValues(options?: any): Promise<CouponEditorValues>;

    /**
     * Insert a coupon on the UltraCart account. 
     * @summary Insert a coupon
     * @param {Coupon} coupon Coupon to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    insertCoupon(coupon: Coupon, _expand?: string, options?: any): Promise<CouponResponse>;

    /**
     * Insert multiple coupon on the UltraCart account. 
     * @summary Insert multiple coupons
     * @param {CouponsRequest} coupons_request Coupons to insert (maximum 50)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    insertCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, options?: any): Promise<CouponsResponse>;

    /**
     * Searches for items to display within a coupon editor and assign to coupons 
     * @summary Searches for items to display within a coupon editor and assign to coupons
     * @param {string} [s] 
     * @param {number} [m] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    searchItems(s?: string, m?: number, options?: any): Promise<CouponItemSearchResultsResponse>;

    /**
     * Update auto apply rules and conditions 
     * @summary Update auto apply rules and conditions
     * @param {CouponAutoApplyConditions} conditions Conditions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    updateAutoApply(conditions: CouponAutoApplyConditions, options?: any): Promise<{}>;

    /**
     * Update a coupon on the UltraCart account. 
     * @summary Update a coupon
     * @param {Coupon} coupon Coupon to update
     * @param {number} coupon_oid The coupon_oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    updateCoupon(coupon: Coupon, coupon_oid: number, _expand?: string, options?: any): Promise<CouponResponse>;

    /**
     * Update multiple coupon on the UltraCart account. 
     * @summary Update multiple coupons
     * @param {CouponsRequest} coupons_request Coupons to update (synchronous maximum 50 / asynchronous maximum 100)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [_async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    updateCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any): Promise<CouponsResponse>;

    /**
     * Upload one-time codes for a coupon 
     * @summary Upload one-time codes for a coupon
     * @param {number} coupon_oid The coupon oid to associate with the provided one-time codes.
     * @param {UploadCouponCodesRequest} upload_coupon_codes_request One-time coupon codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApiInterface
     */
    uploadCouponCodes(coupon_oid: number, upload_coupon_codes_request: UploadCouponCodesRequest, options?: any): Promise<UploadCouponCodesResponse>;

}

/**
 * CouponApi - object-oriented interface
 * @export
 * @class CouponApi
 * @extends {BaseAPI}
 */
export class CouponApi extends BaseAPI implements CouponApiInterface {
    /**
     * Delete a coupon on the UltraCart account. 
     * @summary Delete a coupon
     * @param {number} coupon_oid The coupon_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public deleteCoupon(coupon_oid: number, options?: any) {
        return CouponApiFp(this.configuration).deleteCoupon(coupon_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete coupons on the UltraCart account. 
     * @summary Deletes multiple coupons
     * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public deleteCouponsByCode(coupon_delete_request: CouponDeletesRequest, options?: any) {
        return CouponApiFp(this.configuration).deleteCouponsByCode(coupon_delete_request, options)(this.fetch, this.basePath);
    }

    /**
     * Delete coupons on the UltraCart account. 
     * @summary Deletes multiple coupons
     * @param {CouponDeletesRequest} coupon_delete_request Coupon oids to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public deleteCouponsByOid(coupon_delete_request: CouponDeletesRequest, options?: any) {
        return CouponApiFp(this.configuration).deleteCouponsByOid(coupon_delete_request, options)(this.fetch, this.basePath);
    }

    /**
     * Determines if a coupon merchant code already exists. 
     * @summary Determines if a coupon merchant code already exists
     * @param {string} merchant_code The coupon merchant code to examine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public doesCouponCodeExist(merchant_code: string, options?: any) {
        return CouponApiFp(this.configuration).doesCouponCodeExist(merchant_code, options)(this.fetch, this.basePath);
    }

    /**
     * Generate one time codes for a coupon 
     * @summary Generates one time codes for a coupon
     * @param {number} coupon_oid The coupon oid to generate codes.
     * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public generateCouponCodes(coupon_oid: number, coupon_codes_request: CouponCodesRequest, options?: any) {
        return CouponApiFp(this.configuration).generateCouponCodes(coupon_oid, coupon_codes_request, options)(this.fetch, this.basePath);
    }

    /**
     * Generate one time codes by merchant code 
     * @summary Generates one time codes by merchant code
     * @param {string} merchant_code The merchant code to generate one time codes.
     * @param {CouponCodesRequest} coupon_codes_request Coupon code generation parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public generateOneTimeCodesByMerchantCode(merchant_code: string, coupon_codes_request: CouponCodesRequest, options?: any) {
        return CouponApiFp(this.configuration).generateOneTimeCodesByMerchantCode(merchant_code, coupon_codes_request, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve auto apply rules and conditions 
     * @summary Retrieve auto apply rules and conditions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getAutoApply(options?: any) {
        return CouponApiFp(this.configuration).getAutoApply(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single coupon using the specified coupon profile oid. 
     * @summary Retrieve a coupon
     * @param {number} coupon_oid The coupon oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCoupon(coupon_oid: number, _expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCoupon(coupon_oid, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single coupon using the specified merchant code. 
     * @summary Retrieve a coupon by merchant code
     * @param {string} merchant_code The coupon merchant code to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCouponByMerchantCode(merchant_code: string, _expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCouponByMerchantCode(merchant_code, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons
     * @param {string} [merchant_code] Merchant code
     * @param {string} [description] Description
     * @param {string} [coupon_type] Coupon type
     * @param {string} [start_date_begin] Start date begin
     * @param {string} [start_date_end] Start date end
     * @param {string} [expiration_date_begin] Expiration date begin
     * @param {string} [expiration_date_end] Expiration date end
     * @param {number} [affiliate_oid] Affiliate oid
     * @param {boolean} [exclude_expired] Exclude expired
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCoupons(merchant_code?: string, description?: string, coupon_type?: string, start_date_begin?: string, start_date_end?: string, expiration_date_begin?: string, expiration_date_end?: string, affiliate_oid?: number, exclude_expired?: boolean, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCoupons(merchant_code, description, coupon_type, start_date_begin, start_date_end, expiration_date_begin, expiration_date_end, affiliate_oid, exclude_expired, _limit, _offset, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve coupons by query
     * @param {CouponQuery} coupon_query Coupon query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getCouponsByQuery(coupon_query: CouponQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
        return CouponApiFp(this.configuration).getCouponsByQuery(coupon_query, _limit, _offset, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve values needed for a coupon editor 
     * @summary Retrieve values needed for a coupon editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public getEditorValues(options?: any) {
        return CouponApiFp(this.configuration).getEditorValues(options)(this.fetch, this.basePath);
    }

    /**
     * Insert a coupon on the UltraCart account. 
     * @summary Insert a coupon
     * @param {Coupon} coupon Coupon to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public insertCoupon(coupon: Coupon, _expand?: string, options?: any) {
        return CouponApiFp(this.configuration).insertCoupon(coupon, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Insert multiple coupon on the UltraCart account. 
     * @summary Insert multiple coupons
     * @param {CouponsRequest} coupons_request Coupons to insert (maximum 50)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public insertCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, options?: any) {
        return CouponApiFp(this.configuration).insertCoupons(coupons_request, _expand, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Searches for items to display within a coupon editor and assign to coupons 
     * @summary Searches for items to display within a coupon editor and assign to coupons
     * @param {string} [s] 
     * @param {number} [m] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public searchItems(s?: string, m?: number, options?: any) {
        return CouponApiFp(this.configuration).searchItems(s, m, options)(this.fetch, this.basePath);
    }

    /**
     * Update auto apply rules and conditions 
     * @summary Update auto apply rules and conditions
     * @param {CouponAutoApplyConditions} conditions Conditions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public updateAutoApply(conditions: CouponAutoApplyConditions, options?: any) {
        return CouponApiFp(this.configuration).updateAutoApply(conditions, options)(this.fetch, this.basePath);
    }

    /**
     * Update a coupon on the UltraCart account. 
     * @summary Update a coupon
     * @param {Coupon} coupon Coupon to update
     * @param {number} coupon_oid The coupon_oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public updateCoupon(coupon: Coupon, coupon_oid: number, _expand?: string, options?: any) {
        return CouponApiFp(this.configuration).updateCoupon(coupon, coupon_oid, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update multiple coupon on the UltraCart account. 
     * @summary Update multiple coupons
     * @param {CouponsRequest} coupons_request Coupons to update (synchronous maximum 50 / asynchronous maximum 100)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [_async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public updateCoupons(coupons_request: CouponsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any) {
        return CouponApiFp(this.configuration).updateCoupons(coupons_request, _expand, _placeholders, _async, options)(this.fetch, this.basePath);
    }

    /**
     * Upload one-time codes for a coupon 
     * @summary Upload one-time codes for a coupon
     * @param {number} coupon_oid The coupon oid to associate with the provided one-time codes.
     * @param {UploadCouponCodesRequest} upload_coupon_codes_request One-time coupon codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public uploadCouponCodes(coupon_oid: number, upload_coupon_codes_request: UploadCouponCodesRequest, options?: any) {
        return CouponApiFp(this.configuration).uploadCouponCodes(coupon_oid, upload_coupon_codes_request, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerApi - fetch parameter creator
 * @export
 */
export const CustomerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a customer on the UltraCart account. 
         * @summary Delete a customer
         * @param {number} customer_profile_oid The customer_profile_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customer_profile_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'customer_profile_oid' is not null or undefined
            if (customer_profile_oid === null || customer_profile_oid === undefined) {
                throw new RequiredError('customer_profile_oid','Required parameter customer_profile_oid was null or undefined when calling deleteCustomer.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customer_profile_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single customer using the specified customer profile oid. 
         * @summary Retrieve a customer
         * @param {number} customer_profile_oid The customer oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customer_profile_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customer_profile_oid' is not null or undefined
            if (customer_profile_oid === null || customer_profile_oid === undefined) {
                throw new RequiredError('customer_profile_oid','Required parameter customer_profile_oid was null or undefined when calling getCustomer.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customer_profile_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single customer using the specified customer email address. 
         * @summary Retrieve a customer by Email
         * @param {string} email The email address of the customer to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByEmail(email: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getCustomerByEmail.');
            }
            const localVarPath = `/customer/customers/by_email/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve values needed for a customer profile editor. 
         * @summary Retrieve values needed for a customer profile editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEditorValues(options: any = {}): FetchArgs {
            const localVarPath = `/customer/editor_values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all email lists across all storefronts 
         * @summary Retrieve all email lists across all storefronts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEmailLists(options: any = {}): FetchArgs {
            const localVarPath = `/customer/email_lists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers
         * @param {string} [email] Email
         * @param {string} [qb_class] Quickbooks class
         * @param {string} [quickbooks_code] Quickbooks code
         * @param {string} [last_modified_dts_start] Last modified date start
         * @param {string} [last_modified_dts_end] Last modified date end
         * @param {string} [signup_dts_start] Signup date start
         * @param {string} [signup_dts_end] Signup date end
         * @param {string} [billing_first_name] Billing first name
         * @param {string} [billing_last_name] Billing last name
         * @param {string} [billing_company] Billing company
         * @param {string} [billing_city] Billing city
         * @param {string} [billing_state] Billing state
         * @param {string} [billing_postal_code] Billing postal code
         * @param {string} [billing_country_code] Billing country code
         * @param {string} [billing_day_phone] Billing day phone
         * @param {string} [billing_evening_phone] Billing evening phone
         * @param {string} [shipping_first_name] Shipping first name
         * @param {string} [shipping_last_name] Shipping last name
         * @param {string} [shipping_company] Shipping company
         * @param {string} [shipping_city] Shipping city
         * @param {string} [shipping_state] Shipping state
         * @param {string} [shipping_postal_code] Shipping postal code
         * @param {string} [shipping_country_code] Shipping country code
         * @param {string} [shipping_day_phone] Shipping day phone
         * @param {string} [shipping_evening_phone] Shipping evening phone
         * @param {number} [pricing_tier_oid] Pricing tier oid
         * @param {string} [pricing_tier_name] Pricing tier name
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(email?: string, qb_class?: string, quickbooks_code?: string, last_modified_dts_start?: string, last_modified_dts_end?: string, signup_dts_start?: string, signup_dts_end?: string, billing_first_name?: string, billing_last_name?: string, billing_company?: string, billing_city?: string, billing_state?: string, billing_postal_code?: string, billing_country_code?: string, billing_day_phone?: string, billing_evening_phone?: string, shipping_first_name?: string, shipping_last_name?: string, shipping_company?: string, shipping_city?: string, shipping_state?: string, shipping_postal_code?: string, shipping_country_code?: string, shipping_day_phone?: string, shipping_evening_phone?: string, pricing_tier_oid?: number, pricing_tier_name?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/customer/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (qb_class !== undefined) {
                localVarQueryParameter['qb_class'] = qb_class;
            }

            if (quickbooks_code !== undefined) {
                localVarQueryParameter['quickbooks_code'] = quickbooks_code;
            }

            if (last_modified_dts_start !== undefined) {
                localVarQueryParameter['last_modified_dts_start'] = last_modified_dts_start;
            }

            if (last_modified_dts_end !== undefined) {
                localVarQueryParameter['last_modified_dts_end'] = last_modified_dts_end;
            }

            if (signup_dts_start !== undefined) {
                localVarQueryParameter['signup_dts_start'] = signup_dts_start;
            }

            if (signup_dts_end !== undefined) {
                localVarQueryParameter['signup_dts_end'] = signup_dts_end;
            }

            if (billing_first_name !== undefined) {
                localVarQueryParameter['billing_first_name'] = billing_first_name;
            }

            if (billing_last_name !== undefined) {
                localVarQueryParameter['billing_last_name'] = billing_last_name;
            }

            if (billing_company !== undefined) {
                localVarQueryParameter['billing_company'] = billing_company;
            }

            if (billing_city !== undefined) {
                localVarQueryParameter['billing_city'] = billing_city;
            }

            if (billing_state !== undefined) {
                localVarQueryParameter['billing_state'] = billing_state;
            }

            if (billing_postal_code !== undefined) {
                localVarQueryParameter['billing_postal_code'] = billing_postal_code;
            }

            if (billing_country_code !== undefined) {
                localVarQueryParameter['billing_country_code'] = billing_country_code;
            }

            if (billing_day_phone !== undefined) {
                localVarQueryParameter['billing_day_phone'] = billing_day_phone;
            }

            if (billing_evening_phone !== undefined) {
                localVarQueryParameter['billing_evening_phone'] = billing_evening_phone;
            }

            if (shipping_first_name !== undefined) {
                localVarQueryParameter['shipping_first_name'] = shipping_first_name;
            }

            if (shipping_last_name !== undefined) {
                localVarQueryParameter['shipping_last_name'] = shipping_last_name;
            }

            if (shipping_company !== undefined) {
                localVarQueryParameter['shipping_company'] = shipping_company;
            }

            if (shipping_city !== undefined) {
                localVarQueryParameter['shipping_city'] = shipping_city;
            }

            if (shipping_state !== undefined) {
                localVarQueryParameter['shipping_state'] = shipping_state;
            }

            if (shipping_postal_code !== undefined) {
                localVarQueryParameter['shipping_postal_code'] = shipping_postal_code;
            }

            if (shipping_country_code !== undefined) {
                localVarQueryParameter['shipping_country_code'] = shipping_country_code;
            }

            if (shipping_day_phone !== undefined) {
                localVarQueryParameter['shipping_day_phone'] = shipping_day_phone;
            }

            if (shipping_evening_phone !== undefined) {
                localVarQueryParameter['shipping_evening_phone'] = shipping_evening_phone;
            }

            if (pricing_tier_oid !== undefined) {
                localVarQueryParameter['pricing_tier_oid'] = pricing_tier_oid;
            }

            if (pricing_tier_name !== undefined) {
                localVarQueryParameter['pricing_tier_name'] = pricing_tier_name;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_since !== undefined) {
                localVarQueryParameter['_since'] = _since;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers by query
         * @param {CustomerQuery} customer_query Customer query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByQuery(customer_query: CustomerQuery, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customer_query' is not null or undefined
            if (customer_query === null || customer_query === undefined) {
                throw new RequiredError('customer_query','Required parameter customer_query was null or undefined when calling getCustomersByQuery.');
            }
            const localVarPath = `/customer/customers/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_since !== undefined) {
                localVarQueryParameter['_since'] = _since;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customer_query || {}) : (customer_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
         * @summary Retrieve customers for DataTables plugin
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersForDataTables(_expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/customer/customers/dataTables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
         * @summary Create a token that can be used to verify a customer email address
         * @param {EmailVerifyTokenRequest} token_request Token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailVerificationToken(token_request: EmailVerifyTokenRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token_request' is not null or undefined
            if (token_request === null || token_request === undefined) {
                throw new RequiredError('token_request','Required parameter token_request was null or undefined when calling getEmailVerificationToken.');
            }
            const localVarPath = `/customer/customers/email_verify/get_token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailVerifyTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(token_request || {}) : (token_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a customer on the UltraCart account. 
         * @summary Insert a customer
         * @param {Customer} customer Customer to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCustomer(customer: Customer, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customer' is not null or undefined
            if (customer === null || customer === undefined) {
                throw new RequiredError('customer','Required parameter customer was null or undefined when calling insertCustomer.');
            }
            const localVarPath = `/customer/customers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customer || {}) : (customer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a customer on the UltraCart account. 
         * @summary Update a customer
         * @param {Customer} customer Customer to update
         * @param {number} customer_profile_oid The customer_profile_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customer: Customer, customer_profile_oid: number, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customer' is not null or undefined
            if (customer === null || customer === undefined) {
                throw new RequiredError('customer','Required parameter customer was null or undefined when calling updateCustomer.');
            }
            // verify required parameter 'customer_profile_oid' is not null or undefined
            if (customer_profile_oid === null || customer_profile_oid === undefined) {
                throw new RequiredError('customer_profile_oid','Required parameter customer_profile_oid was null or undefined when calling updateCustomer.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customer_profile_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customer || {}) : (customer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update email list subscriptions for a customer 
         * @summary Update email list subscriptions for a customer
         * @param {number} customer_profile_oid The customer profile oid
         * @param {CustomerEmailListChanges} list_changes List changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerEmailLists(customer_profile_oid: number, list_changes: CustomerEmailListChanges, options: any = {}): FetchArgs {
            // verify required parameter 'customer_profile_oid' is not null or undefined
            if (customer_profile_oid === null || customer_profile_oid === undefined) {
                throw new RequiredError('customer_profile_oid','Required parameter customer_profile_oid was null or undefined when calling updateCustomerEmailLists.');
            }
            // verify required parameter 'list_changes' is not null or undefined
            if (list_changes === null || list_changes === undefined) {
                throw new RequiredError('list_changes','Required parameter list_changes was null or undefined when calling updateCustomerEmailLists.');
            }
            const localVarPath = `/customer/customers/{customer_profile_oid}/email_lists`
                .replace(`{${"customer_profile_oid"}}`, encodeURIComponent(String(customer_profile_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerEmailListChanges" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(list_changes || {}) : (list_changes || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
         * @summary Validate a token that can be used to verify a customer email address
         * @param {EmailVerifyTokenValidateRequest} validation_request Token validation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmailVerificationToken(validation_request: EmailVerifyTokenValidateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'validation_request' is not null or undefined
            if (validation_request === null || validation_request === undefined) {
                throw new RequiredError('validation_request','Required parameter validation_request was null or undefined when calling validateEmailVerificationToken.');
            }
            const localVarPath = `/customer/customers/email_verify/validate_token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["customer_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailVerifyTokenValidateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(validation_request || {}) : (validation_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a customer on the UltraCart account. 
         * @summary Delete a customer
         * @param {number} customer_profile_oid The customer_profile_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customer_profile_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).deleteCustomer(customer_profile_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single customer using the specified customer profile oid. 
         * @summary Retrieve a customer
         * @param {number} customer_profile_oid The customer oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customer_profile_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomer(customer_profile_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single customer using the specified customer email address. 
         * @summary Retrieve a customer by Email
         * @param {string} email The email address of the customer to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByEmail(email: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomerByEmail(email, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve values needed for a customer profile editor. 
         * @summary Retrieve values needed for a customer profile editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEditorValues(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerEditorValues> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomerEditorValues(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve all email lists across all storefronts 
         * @summary Retrieve all email lists across all storefronts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEmailLists(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListsResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomerEmailLists(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers
         * @param {string} [email] Email
         * @param {string} [qb_class] Quickbooks class
         * @param {string} [quickbooks_code] Quickbooks code
         * @param {string} [last_modified_dts_start] Last modified date start
         * @param {string} [last_modified_dts_end] Last modified date end
         * @param {string} [signup_dts_start] Signup date start
         * @param {string} [signup_dts_end] Signup date end
         * @param {string} [billing_first_name] Billing first name
         * @param {string} [billing_last_name] Billing last name
         * @param {string} [billing_company] Billing company
         * @param {string} [billing_city] Billing city
         * @param {string} [billing_state] Billing state
         * @param {string} [billing_postal_code] Billing postal code
         * @param {string} [billing_country_code] Billing country code
         * @param {string} [billing_day_phone] Billing day phone
         * @param {string} [billing_evening_phone] Billing evening phone
         * @param {string} [shipping_first_name] Shipping first name
         * @param {string} [shipping_last_name] Shipping last name
         * @param {string} [shipping_company] Shipping company
         * @param {string} [shipping_city] Shipping city
         * @param {string} [shipping_state] Shipping state
         * @param {string} [shipping_postal_code] Shipping postal code
         * @param {string} [shipping_country_code] Shipping country code
         * @param {string} [shipping_day_phone] Shipping day phone
         * @param {string} [shipping_evening_phone] Shipping evening phone
         * @param {number} [pricing_tier_oid] Pricing tier oid
         * @param {string} [pricing_tier_name] Pricing tier name
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(email?: string, qb_class?: string, quickbooks_code?: string, last_modified_dts_start?: string, last_modified_dts_end?: string, signup_dts_start?: string, signup_dts_end?: string, billing_first_name?: string, billing_last_name?: string, billing_company?: string, billing_city?: string, billing_state?: string, billing_postal_code?: string, billing_country_code?: string, billing_day_phone?: string, billing_evening_phone?: string, shipping_first_name?: string, shipping_last_name?: string, shipping_company?: string, shipping_city?: string, shipping_state?: string, shipping_postal_code?: string, shipping_country_code?: string, shipping_day_phone?: string, shipping_evening_phone?: string, pricing_tier_oid?: number, pricing_tier_name?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomersResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomers(email, qb_class, quickbooks_code, last_modified_dts_start, last_modified_dts_end, signup_dts_start, signup_dts_end, billing_first_name, billing_last_name, billing_company, billing_city, billing_state, billing_postal_code, billing_country_code, billing_day_phone, billing_evening_phone, shipping_first_name, shipping_last_name, shipping_company, shipping_city, shipping_state, shipping_postal_code, shipping_country_code, shipping_day_phone, shipping_evening_phone, pricing_tier_oid, pricing_tier_name, _limit, _offset, _since, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers by query
         * @param {CustomerQuery} customer_query Customer query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByQuery(customer_query: CustomerQuery, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomersResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomersByQuery(customer_query, _limit, _offset, _since, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
         * @summary Retrieve customers for DataTables plugin
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersForDataTables(_expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DataTablesServerSideResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getCustomersForDataTables(_expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
         * @summary Create a token that can be used to verify a customer email address
         * @param {EmailVerifyTokenRequest} token_request Token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailVerificationToken(token_request: EmailVerifyTokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailVerifyTokenResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getEmailVerificationToken(token_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a customer on the UltraCart account. 
         * @summary Insert a customer
         * @param {Customer} customer Customer to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCustomer(customer: Customer, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).insertCustomer(customer, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a customer on the UltraCart account. 
         * @summary Update a customer
         * @param {Customer} customer Customer to update
         * @param {number} customer_profile_oid The customer_profile_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customer: Customer, customer_profile_oid: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).updateCustomer(customer, customer_profile_oid, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update email list subscriptions for a customer 
         * @summary Update email list subscriptions for a customer
         * @param {number} customer_profile_oid The customer profile oid
         * @param {CustomerEmailListChanges} list_changes List changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerEmailLists(customer_profile_oid: number, list_changes: CustomerEmailListChanges, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerEmailListChanges> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).updateCustomerEmailLists(customer_profile_oid, list_changes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
         * @summary Validate a token that can be used to verify a customer email address
         * @param {EmailVerifyTokenValidateRequest} validation_request Token validation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmailVerificationToken(validation_request: EmailVerifyTokenValidateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailVerifyTokenValidateResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).validateEmailVerificationToken(validation_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a customer on the UltraCart account. 
         * @summary Delete a customer
         * @param {number} customer_profile_oid The customer_profile_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customer_profile_oid: number, options?: any) {
            return CustomerApiFp(configuration).deleteCustomer(customer_profile_oid, options)(fetch, basePath);
        },
        /**
         * Retrieves a single customer using the specified customer profile oid. 
         * @summary Retrieve a customer
         * @param {number} customer_profile_oid The customer oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customer_profile_oid: number, _expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomer(customer_profile_oid, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single customer using the specified customer email address. 
         * @summary Retrieve a customer by Email
         * @param {string} email The email address of the customer to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByEmail(email: string, _expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomerByEmail(email, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieve values needed for a customer profile editor. 
         * @summary Retrieve values needed for a customer profile editor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEditorValues(options?: any) {
            return CustomerApiFp(configuration).getCustomerEditorValues(options)(fetch, basePath);
        },
        /**
         * Retrieve all email lists across all storefronts 
         * @summary Retrieve all email lists across all storefronts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerEmailLists(options?: any) {
            return CustomerApiFp(configuration).getCustomerEmailLists(options)(fetch, basePath);
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers
         * @param {string} [email] Email
         * @param {string} [qb_class] Quickbooks class
         * @param {string} [quickbooks_code] Quickbooks code
         * @param {string} [last_modified_dts_start] Last modified date start
         * @param {string} [last_modified_dts_end] Last modified date end
         * @param {string} [signup_dts_start] Signup date start
         * @param {string} [signup_dts_end] Signup date end
         * @param {string} [billing_first_name] Billing first name
         * @param {string} [billing_last_name] Billing last name
         * @param {string} [billing_company] Billing company
         * @param {string} [billing_city] Billing city
         * @param {string} [billing_state] Billing state
         * @param {string} [billing_postal_code] Billing postal code
         * @param {string} [billing_country_code] Billing country code
         * @param {string} [billing_day_phone] Billing day phone
         * @param {string} [billing_evening_phone] Billing evening phone
         * @param {string} [shipping_first_name] Shipping first name
         * @param {string} [shipping_last_name] Shipping last name
         * @param {string} [shipping_company] Shipping company
         * @param {string} [shipping_city] Shipping city
         * @param {string} [shipping_state] Shipping state
         * @param {string} [shipping_postal_code] Shipping postal code
         * @param {string} [shipping_country_code] Shipping country code
         * @param {string} [shipping_day_phone] Shipping day phone
         * @param {string} [shipping_evening_phone] Shipping evening phone
         * @param {number} [pricing_tier_oid] Pricing tier oid
         * @param {string} [pricing_tier_name] Pricing tier name
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(email?: string, qb_class?: string, quickbooks_code?: string, last_modified_dts_start?: string, last_modified_dts_end?: string, signup_dts_start?: string, signup_dts_end?: string, billing_first_name?: string, billing_last_name?: string, billing_company?: string, billing_city?: string, billing_state?: string, billing_postal_code?: string, billing_country_code?: string, billing_day_phone?: string, billing_evening_phone?: string, shipping_first_name?: string, shipping_last_name?: string, shipping_company?: string, shipping_city?: string, shipping_state?: string, shipping_postal_code?: string, shipping_country_code?: string, shipping_day_phone?: string, shipping_evening_phone?: string, pricing_tier_oid?: number, pricing_tier_name?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomers(email, qb_class, quickbooks_code, last_modified_dts_start, last_modified_dts_end, signup_dts_start, signup_dts_end, billing_first_name, billing_last_name, billing_company, billing_city, billing_state, billing_postal_code, billing_country_code, billing_day_phone, billing_evening_phone, shipping_first_name, shipping_last_name, shipping_company, shipping_city, shipping_state, shipping_postal_code, shipping_country_code, shipping_day_phone, shipping_evening_phone, pricing_tier_oid, pricing_tier_name, _limit, _offset, _since, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve customers by query
         * @param {CustomerQuery} customer_query Customer query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersByQuery(customer_query: CustomerQuery, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomersByQuery(customer_query, _limit, _offset, _since, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
         * @summary Retrieve customers for DataTables plugin
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersForDataTables(_expand?: string, options?: any) {
            return CustomerApiFp(configuration).getCustomersForDataTables(_expand, options)(fetch, basePath);
        },
        /**
         * Create a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
         * @summary Create a token that can be used to verify a customer email address
         * @param {EmailVerifyTokenRequest} token_request Token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailVerificationToken(token_request: EmailVerifyTokenRequest, options?: any) {
            return CustomerApiFp(configuration).getEmailVerificationToken(token_request, options)(fetch, basePath);
        },
        /**
         * Insert a customer on the UltraCart account. 
         * @summary Insert a customer
         * @param {Customer} customer Customer to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertCustomer(customer: Customer, _expand?: string, options?: any) {
            return CustomerApiFp(configuration).insertCustomer(customer, _expand, options)(fetch, basePath);
        },
        /**
         * Update a customer on the UltraCart account. 
         * @summary Update a customer
         * @param {Customer} customer Customer to update
         * @param {number} customer_profile_oid The customer_profile_oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customer: Customer, customer_profile_oid: number, _expand?: string, options?: any) {
            return CustomerApiFp(configuration).updateCustomer(customer, customer_profile_oid, _expand, options)(fetch, basePath);
        },
        /**
         * Update email list subscriptions for a customer 
         * @summary Update email list subscriptions for a customer
         * @param {number} customer_profile_oid The customer profile oid
         * @param {CustomerEmailListChanges} list_changes List changes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerEmailLists(customer_profile_oid: number, list_changes: CustomerEmailListChanges, options?: any) {
            return CustomerApiFp(configuration).updateCustomerEmailLists(customer_profile_oid, list_changes, options)(fetch, basePath);
        },
        /**
         * Validate a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
         * @summary Validate a token that can be used to verify a customer email address
         * @param {EmailVerifyTokenValidateRequest} validation_request Token validation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmailVerificationToken(validation_request: EmailVerifyTokenValidateRequest, options?: any) {
            return CustomerApiFp(configuration).validateEmailVerificationToken(validation_request, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerApi - interface
 * @export
 * @interface CustomerApi
 */
export interface CustomerApiInterface {
    /**
     * Delete a customer on the UltraCart account. 
     * @summary Delete a customer
     * @param {number} customer_profile_oid The customer_profile_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    deleteCustomer(customer_profile_oid: number, options?: any): Promise<CustomerResponse>;

    /**
     * Retrieves a single customer using the specified customer profile oid. 
     * @summary Retrieve a customer
     * @param {number} customer_profile_oid The customer oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomer(customer_profile_oid: number, _expand?: string, options?: any): Promise<CustomerResponse>;

    /**
     * Retrieves a single customer using the specified customer email address. 
     * @summary Retrieve a customer by Email
     * @param {string} email The email address of the customer to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomerByEmail(email: string, _expand?: string, options?: any): Promise<CustomerResponse>;

    /**
     * Retrieve values needed for a customer profile editor. 
     * @summary Retrieve values needed for a customer profile editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomerEditorValues(options?: any): Promise<CustomerEditorValues>;

    /**
     * Retrieve all email lists across all storefronts 
     * @summary Retrieve all email lists across all storefronts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomerEmailLists(options?: any): Promise<EmailListsResponse>;

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers
     * @param {string} [email] Email
     * @param {string} [qb_class] Quickbooks class
     * @param {string} [quickbooks_code] Quickbooks code
     * @param {string} [last_modified_dts_start] Last modified date start
     * @param {string} [last_modified_dts_end] Last modified date end
     * @param {string} [signup_dts_start] Signup date start
     * @param {string} [signup_dts_end] Signup date end
     * @param {string} [billing_first_name] Billing first name
     * @param {string} [billing_last_name] Billing last name
     * @param {string} [billing_company] Billing company
     * @param {string} [billing_city] Billing city
     * @param {string} [billing_state] Billing state
     * @param {string} [billing_postal_code] Billing postal code
     * @param {string} [billing_country_code] Billing country code
     * @param {string} [billing_day_phone] Billing day phone
     * @param {string} [billing_evening_phone] Billing evening phone
     * @param {string} [shipping_first_name] Shipping first name
     * @param {string} [shipping_last_name] Shipping last name
     * @param {string} [shipping_company] Shipping company
     * @param {string} [shipping_city] Shipping city
     * @param {string} [shipping_state] Shipping state
     * @param {string} [shipping_postal_code] Shipping postal code
     * @param {string} [shipping_country_code] Shipping country code
     * @param {string} [shipping_day_phone] Shipping day phone
     * @param {string} [shipping_evening_phone] Shipping evening phone
     * @param {number} [pricing_tier_oid] Pricing tier oid
     * @param {string} [pricing_tier_name] Pricing tier name
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomers(email?: string, qb_class?: string, quickbooks_code?: string, last_modified_dts_start?: string, last_modified_dts_end?: string, signup_dts_start?: string, signup_dts_end?: string, billing_first_name?: string, billing_last_name?: string, billing_company?: string, billing_city?: string, billing_state?: string, billing_postal_code?: string, billing_country_code?: string, billing_day_phone?: string, billing_evening_phone?: string, shipping_first_name?: string, shipping_last_name?: string, shipping_company?: string, shipping_city?: string, shipping_state?: string, shipping_postal_code?: string, shipping_country_code?: string, shipping_day_phone?: string, shipping_evening_phone?: string, pricing_tier_oid?: number, pricing_tier_name?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): Promise<CustomersResponse>;

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers by query
     * @param {CustomerQuery} customer_query Customer query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomersByQuery(customer_query: CustomerQuery, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any): Promise<CustomersResponse>;

    /**
     * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
     * @summary Retrieve customers for DataTables plugin
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getCustomersForDataTables(_expand?: string, options?: any): Promise<DataTablesServerSideResponse>;

    /**
     * Create a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
     * @summary Create a token that can be used to verify a customer email address
     * @param {EmailVerifyTokenRequest} token_request Token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    getEmailVerificationToken(token_request: EmailVerifyTokenRequest, options?: any): Promise<EmailVerifyTokenResponse>;

    /**
     * Insert a customer on the UltraCart account. 
     * @summary Insert a customer
     * @param {Customer} customer Customer to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    insertCustomer(customer: Customer, _expand?: string, options?: any): Promise<CustomerResponse>;

    /**
     * Update a customer on the UltraCart account. 
     * @summary Update a customer
     * @param {Customer} customer Customer to update
     * @param {number} customer_profile_oid The customer_profile_oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    updateCustomer(customer: Customer, customer_profile_oid: number, _expand?: string, options?: any): Promise<CustomerResponse>;

    /**
     * Update email list subscriptions for a customer 
     * @summary Update email list subscriptions for a customer
     * @param {number} customer_profile_oid The customer profile oid
     * @param {CustomerEmailListChanges} list_changes List changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    updateCustomerEmailLists(customer_profile_oid: number, list_changes: CustomerEmailListChanges, options?: any): Promise<CustomerEmailListChanges>;

    /**
     * Validate a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
     * @summary Validate a token that can be used to verify a customer email address
     * @param {EmailVerifyTokenValidateRequest} validation_request Token validation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApiInterface
     */
    validateEmailVerificationToken(validation_request: EmailVerifyTokenValidateRequest, options?: any): Promise<EmailVerifyTokenValidateResponse>;

}

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI implements CustomerApiInterface {
    /**
     * Delete a customer on the UltraCart account. 
     * @summary Delete a customer
     * @param {number} customer_profile_oid The customer_profile_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public deleteCustomer(customer_profile_oid: number, options?: any) {
        return CustomerApiFp(this.configuration).deleteCustomer(customer_profile_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single customer using the specified customer profile oid. 
     * @summary Retrieve a customer
     * @param {number} customer_profile_oid The customer oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomer(customer_profile_oid: number, _expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomer(customer_profile_oid, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single customer using the specified customer email address. 
     * @summary Retrieve a customer by Email
     * @param {string} email The email address of the customer to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomerByEmail(email: string, _expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomerByEmail(email, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve values needed for a customer profile editor. 
     * @summary Retrieve values needed for a customer profile editor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomerEditorValues(options?: any) {
        return CustomerApiFp(this.configuration).getCustomerEditorValues(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve all email lists across all storefronts 
     * @summary Retrieve all email lists across all storefronts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomerEmailLists(options?: any) {
        return CustomerApiFp(this.configuration).getCustomerEmailLists(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers
     * @param {string} [email] Email
     * @param {string} [qb_class] Quickbooks class
     * @param {string} [quickbooks_code] Quickbooks code
     * @param {string} [last_modified_dts_start] Last modified date start
     * @param {string} [last_modified_dts_end] Last modified date end
     * @param {string} [signup_dts_start] Signup date start
     * @param {string} [signup_dts_end] Signup date end
     * @param {string} [billing_first_name] Billing first name
     * @param {string} [billing_last_name] Billing last name
     * @param {string} [billing_company] Billing company
     * @param {string} [billing_city] Billing city
     * @param {string} [billing_state] Billing state
     * @param {string} [billing_postal_code] Billing postal code
     * @param {string} [billing_country_code] Billing country code
     * @param {string} [billing_day_phone] Billing day phone
     * @param {string} [billing_evening_phone] Billing evening phone
     * @param {string} [shipping_first_name] Shipping first name
     * @param {string} [shipping_last_name] Shipping last name
     * @param {string} [shipping_company] Shipping company
     * @param {string} [shipping_city] Shipping city
     * @param {string} [shipping_state] Shipping state
     * @param {string} [shipping_postal_code] Shipping postal code
     * @param {string} [shipping_country_code] Shipping country code
     * @param {string} [shipping_day_phone] Shipping day phone
     * @param {string} [shipping_evening_phone] Shipping evening phone
     * @param {number} [pricing_tier_oid] Pricing tier oid
     * @param {string} [pricing_tier_name] Pricing tier name
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomers(email?: string, qb_class?: string, quickbooks_code?: string, last_modified_dts_start?: string, last_modified_dts_end?: string, signup_dts_start?: string, signup_dts_end?: string, billing_first_name?: string, billing_last_name?: string, billing_company?: string, billing_city?: string, billing_state?: string, billing_postal_code?: string, billing_country_code?: string, billing_day_phone?: string, billing_evening_phone?: string, shipping_first_name?: string, shipping_last_name?: string, shipping_company?: string, shipping_city?: string, shipping_state?: string, shipping_postal_code?: string, shipping_country_code?: string, shipping_day_phone?: string, shipping_evening_phone?: string, pricing_tier_oid?: number, pricing_tier_name?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomers(email, qb_class, quickbooks_code, last_modified_dts_start, last_modified_dts_end, signup_dts_start, signup_dts_end, billing_first_name, billing_last_name, billing_company, billing_city, billing_state, billing_postal_code, billing_country_code, billing_day_phone, billing_evening_phone, shipping_first_name, shipping_last_name, shipping_company, shipping_city, shipping_state, shipping_postal_code, shipping_country_code, shipping_day_phone, shipping_evening_phone, pricing_tier_oid, pricing_tier_name, _limit, _offset, _since, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve customers by query
     * @param {CustomerQuery} customer_query Customer query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch customers that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomersByQuery(customer_query: CustomerQuery, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomersByQuery(customer_query, _limit, _offset, _since, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
     * @summary Retrieve customers for DataTables plugin
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getCustomersForDataTables(_expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).getCustomersForDataTables(_expand, options)(this.fetch, this.basePath);
    }

    /**
     * Create a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
     * @summary Create a token that can be used to verify a customer email address
     * @param {EmailVerifyTokenRequest} token_request Token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getEmailVerificationToken(token_request: EmailVerifyTokenRequest, options?: any) {
        return CustomerApiFp(this.configuration).getEmailVerificationToken(token_request, options)(this.fetch, this.basePath);
    }

    /**
     * Insert a customer on the UltraCart account. 
     * @summary Insert a customer
     * @param {Customer} customer Customer to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public insertCustomer(customer: Customer, _expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).insertCustomer(customer, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update a customer on the UltraCart account. 
     * @summary Update a customer
     * @param {Customer} customer Customer to update
     * @param {number} customer_profile_oid The customer_profile_oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public updateCustomer(customer: Customer, customer_profile_oid: number, _expand?: string, options?: any) {
        return CustomerApiFp(this.configuration).updateCustomer(customer, customer_profile_oid, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Update email list subscriptions for a customer 
     * @summary Update email list subscriptions for a customer
     * @param {number} customer_profile_oid The customer profile oid
     * @param {CustomerEmailListChanges} list_changes List changes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public updateCustomerEmailLists(customer_profile_oid: number, list_changes: CustomerEmailListChanges, options?: any) {
        return CustomerApiFp(this.configuration).updateCustomerEmailLists(customer_profile_oid, list_changes, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a token that can be used to verify a customer email address.  The implementation of how a customer interacts with this token is left to the merchant. 
     * @summary Validate a token that can be used to verify a customer email address
     * @param {EmailVerifyTokenValidateRequest} validation_request Token validation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public validateEmailVerificationToken(validation_request: EmailVerifyTokenValidateRequest, options?: any) {
        return CustomerApiFp(this.configuration).validateEmailVerificationToken(validation_request, options)(this.fetch, this.basePath);
    }

}

/**
 * FulfillmentApi - fetch parameter creator
 * @export
 */
export const FulfillmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
         * @summary Acknowledge receipt of orders.
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeOrders(distribution_center_code: string, orderIds: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'distribution_center_code' is not null or undefined
            if (distribution_center_code === null || distribution_center_code === undefined) {
                throw new RequiredError('distribution_center_code','Required parameter distribution_center_code was null or undefined when calling acknowledgeOrders.');
            }
            // verify required parameter 'orderIds' is not null or undefined
            if (orderIds === null || orderIds === undefined) {
                throw new RequiredError('orderIds','Required parameter orderIds was null or undefined when calling acknowledgeOrders.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/acknowledgements`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distribution_center_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(orderIds || {}) : (orderIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order for the given distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlip(distribution_center_code: string, order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'distribution_center_code' is not null or undefined
            if (distribution_center_code === null || distribution_center_code === undefined) {
                throw new RequiredError('distribution_center_code','Required parameter distribution_center_code was null or undefined when calling generatePackingSlip.');
            }
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling generatePackingSlip.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/orders/{order_id}`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distribution_center_code)))
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
         * @summary Retrieve orders queued up for this distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenterOrders(distribution_center_code: string, options: any = {}): FetchArgs {
            // verify required parameter 'distribution_center_code' is not null or undefined
            if (distribution_center_code === null || distribution_center_code === undefined) {
                throw new RequiredError('distribution_center_code','Required parameter distribution_center_code was null or undefined when calling getDistributionCenterOrders.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/orders`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distribution_center_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the distribution centers that this user has access to. 
         * @summary Retrieve distribution centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenters(options: any = {}): FetchArgs {
            const localVarPath = `/fulfillment/distribution_centers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Store the tracking information and mark the order shipped for this distribution center. 
         * @summary Mark orders as shipped
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipOrders(distribution_center_code: string, shipments: Array<FulfillmentShipment>, options: any = {}): FetchArgs {
            // verify required parameter 'distribution_center_code' is not null or undefined
            if (distribution_center_code === null || distribution_center_code === undefined) {
                throw new RequiredError('distribution_center_code','Required parameter distribution_center_code was null or undefined when calling shipOrders.');
            }
            // verify required parameter 'shipments' is not null or undefined
            if (shipments === null || shipments === undefined) {
                throw new RequiredError('shipments','Required parameter shipments was null or undefined when calling shipOrders.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/shipments`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distribution_center_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FulfillmentShipment&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(shipments || {}) : (shipments || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the inventory for items associated with this distribution center 
         * @summary Update inventory
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(distribution_center_code: string, inventories: Array<FulfillmentInventory>, options: any = {}): FetchArgs {
            // verify required parameter 'distribution_center_code' is not null or undefined
            if (distribution_center_code === null || distribution_center_code === undefined) {
                throw new RequiredError('distribution_center_code','Required parameter distribution_center_code was null or undefined when calling updateInventory.');
            }
            // verify required parameter 'inventories' is not null or undefined
            if (inventories === null || inventories === undefined) {
                throw new RequiredError('inventories','Required parameter inventories was null or undefined when calling updateInventory.');
            }
            const localVarPath = `/fulfillment/distribution_centers/{distribution_center_code}/inventory`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distribution_center_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;FulfillmentInventory&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inventories || {}) : (inventories || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FulfillmentApi - functional programming interface
 * @export
 */
export const FulfillmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
         * @summary Acknowledge receipt of orders.
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeOrders(distribution_center_code: string, orderIds: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).acknowledgeOrders(distribution_center_code, orderIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order for the given distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlip(distribution_center_code: string, order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).generatePackingSlip(distribution_center_code, order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
         * @summary Retrieve orders queued up for this distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenterOrders(distribution_center_code: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).getDistributionCenterOrders(distribution_center_code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the distribution centers that this user has access to. 
         * @summary Retrieve distribution centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenters(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DistributionCentersResponse> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).getDistributionCenters(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Store the tracking information and mark the order shipped for this distribution center. 
         * @summary Mark orders as shipped
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipOrders(distribution_center_code: string, shipments: Array<FulfillmentShipment>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).shipOrders(distribution_center_code, shipments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the inventory for items associated with this distribution center 
         * @summary Update inventory
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(distribution_center_code: string, inventories: Array<FulfillmentInventory>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FulfillmentApiFetchParamCreator(configuration).updateInventory(distribution_center_code, inventories, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FulfillmentApi - factory interface
 * @export
 */
export const FulfillmentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
         * @summary Acknowledge receipt of orders.
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeOrders(distribution_center_code: string, orderIds: Array<string>, options?: any) {
            return FulfillmentApiFp(configuration).acknowledgeOrders(distribution_center_code, orderIds, options)(fetch, basePath);
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order for the given distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlip(distribution_center_code: string, order_id: string, options?: any) {
            return FulfillmentApiFp(configuration).generatePackingSlip(distribution_center_code, order_id, options)(fetch, basePath);
        },
        /**
         * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
         * @summary Retrieve orders queued up for this distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenterOrders(distribution_center_code: string, options?: any) {
            return FulfillmentApiFp(configuration).getDistributionCenterOrders(distribution_center_code, options)(fetch, basePath);
        },
        /**
         * Retrieves the distribution centers that this user has access to. 
         * @summary Retrieve distribution centers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistributionCenters(options?: any) {
            return FulfillmentApiFp(configuration).getDistributionCenters(options)(fetch, basePath);
        },
        /**
         * Store the tracking information and mark the order shipped for this distribution center. 
         * @summary Mark orders as shipped
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shipOrders(distribution_center_code: string, shipments: Array<FulfillmentShipment>, options?: any) {
            return FulfillmentApiFp(configuration).shipOrders(distribution_center_code, shipments, options)(fetch, basePath);
        },
        /**
         * Update the inventory for items associated with this distribution center 
         * @summary Update inventory
         * @param {string} distribution_center_code Distribution center code
         * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventory(distribution_center_code: string, inventories: Array<FulfillmentInventory>, options?: any) {
            return FulfillmentApiFp(configuration).updateInventory(distribution_center_code, inventories, options)(fetch, basePath);
        },
    };
};

/**
 * FulfillmentApi - interface
 * @export
 * @interface FulfillmentApi
 */
export interface FulfillmentApiInterface {
    /**
     * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
     * @summary Acknowledge receipt of orders.
     * @param {string} distribution_center_code Distribution center code
     * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    acknowledgeOrders(distribution_center_code: string, orderIds: Array<string>, options?: any): Promise<{}>;

    /**
     * The packing slip PDF that is returned is base 64 encoded 
     * @summary Generate a packing slip for this order for the given distribution center.
     * @param {string} distribution_center_code Distribution center code
     * @param {string} order_id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    generatePackingSlip(distribution_center_code: string, order_id: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
     * @summary Retrieve orders queued up for this distribution center.
     * @param {string} distribution_center_code Distribution center code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    getDistributionCenterOrders(distribution_center_code: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieves the distribution centers that this user has access to. 
     * @summary Retrieve distribution centers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    getDistributionCenters(options?: any): Promise<DistributionCentersResponse>;

    /**
     * Store the tracking information and mark the order shipped for this distribution center. 
     * @summary Mark orders as shipped
     * @param {string} distribution_center_code Distribution center code
     * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    shipOrders(distribution_center_code: string, shipments: Array<FulfillmentShipment>, options?: any): Promise<{}>;

    /**
     * Update the inventory for items associated with this distribution center 
     * @summary Update inventory
     * @param {string} distribution_center_code Distribution center code
     * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApiInterface
     */
    updateInventory(distribution_center_code: string, inventories: Array<FulfillmentInventory>, options?: any): Promise<{}>;

}

/**
 * FulfillmentApi - object-oriented interface
 * @export
 * @class FulfillmentApi
 * @extends {BaseAPI}
 */
export class FulfillmentApi extends BaseAPI implements FulfillmentApiInterface {
    /**
     * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
     * @summary Acknowledge receipt of orders.
     * @param {string} distribution_center_code Distribution center code
     * @param {Array<string>} orderIds Orders to acknowledge receipt of (limit 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public acknowledgeOrders(distribution_center_code: string, orderIds: Array<string>, options?: any) {
        return FulfillmentApiFp(this.configuration).acknowledgeOrders(distribution_center_code, orderIds, options)(this.fetch, this.basePath);
    }

    /**
     * The packing slip PDF that is returned is base 64 encoded 
     * @summary Generate a packing slip for this order for the given distribution center.
     * @param {string} distribution_center_code Distribution center code
     * @param {string} order_id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public generatePackingSlip(distribution_center_code: string, order_id: string, options?: any) {
        return FulfillmentApiFp(this.configuration).generatePackingSlip(distribution_center_code, order_id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You'll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
     * @summary Retrieve orders queued up for this distribution center.
     * @param {string} distribution_center_code Distribution center code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getDistributionCenterOrders(distribution_center_code: string, options?: any) {
        return FulfillmentApiFp(this.configuration).getDistributionCenterOrders(distribution_center_code, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the distribution centers that this user has access to. 
     * @summary Retrieve distribution centers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public getDistributionCenters(options?: any) {
        return FulfillmentApiFp(this.configuration).getDistributionCenters(options)(this.fetch, this.basePath);
    }

    /**
     * Store the tracking information and mark the order shipped for this distribution center. 
     * @summary Mark orders as shipped
     * @param {string} distribution_center_code Distribution center code
     * @param {Array<FulfillmentShipment>} shipments Orders to mark shipped
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public shipOrders(distribution_center_code: string, shipments: Array<FulfillmentShipment>, options?: any) {
        return FulfillmentApiFp(this.configuration).shipOrders(distribution_center_code, shipments, options)(this.fetch, this.basePath);
    }

    /**
     * Update the inventory for items associated with this distribution center 
     * @summary Update inventory
     * @param {string} distribution_center_code Distribution center code
     * @param {Array<FulfillmentInventory>} inventories Inventory updates (limit 500)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FulfillmentApi
     */
    public updateInventory(distribution_center_code: string, inventories: Array<FulfillmentInventory>, options?: any) {
        return FulfillmentApiFp(this.configuration).updateInventory(distribution_center_code, inventories, options)(this.fetch, this.basePath);
    }

}

/**
 * IntegrationLogApi - fetch parameter creator
 * @export
 */
export const IntegrationLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an integration logs from the account based identifiers 
         * @summary Retrieve an integration log
         * @param {string} pk 
         * @param {string} sk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLog(pk: string, sk: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling getIntegrationLog.');
            }
            // verify required parameter 'sk' is not null or undefined
            if (sk === null || sk === undefined) {
                throw new RequiredError('sk','Required parameter sk was null or undefined when calling getIntegrationLog.');
            }
            const localVarPath = `/integration_log/query/{pk}/{sk}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"sk"}}`, encodeURIComponent(String(sk)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["integration_log_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an integration log file from the account based identifiers 
         * @summary Retrieve an integration log file
         * @param {string} pk 
         * @param {string} sk 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogFile(pk: string, sk: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'pk' is not null or undefined
            if (pk === null || pk === undefined) {
                throw new RequiredError('pk','Required parameter pk was null or undefined when calling getIntegrationLogFile.');
            }
            // verify required parameter 'sk' is not null or undefined
            if (sk === null || sk === undefined) {
                throw new RequiredError('sk','Required parameter sk was null or undefined when calling getIntegrationLogFile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getIntegrationLogFile.');
            }
            const localVarPath = `/integration_log/query/{pk}/{sk}/{uuid}`
                .replace(`{${"pk"}}`, encodeURIComponent(String(pk)))
                .replace(`{${"sk"}}`, encodeURIComponent(String(sk)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["integration_log_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a set of integration log summaries from the account based on a query object. 
         * @summary Retrieve integration log summaries
         * @param {IntegrationLogSummaryQueryRequest} integration_log_summaries_query Integration log summaries query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogSummariesQuery(integration_log_summaries_query: IntegrationLogSummaryQueryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'integration_log_summaries_query' is not null or undefined
            if (integration_log_summaries_query === null || integration_log_summaries_query === undefined) {
                throw new RequiredError('integration_log_summaries_query','Required parameter integration_log_summaries_query was null or undefined when calling getIntegrationLogSummariesQuery.');
            }
            const localVarPath = `/integration_log/summary/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["integration_log_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationLogSummaryQueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(integration_log_summaries_query || {}) : (integration_log_summaries_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a set of integration logs from the account based on a query object. 
         * @summary Retrieve integration logs
         * @param {IntegrationLogQueryRequest} integration_log_query Integration log query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogsQuery(integration_log_query: IntegrationLogQueryRequest, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'integration_log_query' is not null or undefined
            if (integration_log_query === null || integration_log_query === undefined) {
                throw new RequiredError('integration_log_query','Required parameter integration_log_query was null or undefined when calling getIntegrationLogsQuery.');
            }
            const localVarPath = `/integration_log/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["integration_log_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationLogQueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(integration_log_query || {}) : (integration_log_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationLogApi - functional programming interface
 * @export
 */
export const IntegrationLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve an integration logs from the account based identifiers 
         * @summary Retrieve an integration log
         * @param {string} pk 
         * @param {string} sk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLog(pk: string, sk: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IntegrationLogResponse> {
            const localVarFetchArgs = IntegrationLogApiFetchParamCreator(configuration).getIntegrationLog(pk, sk, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve an integration log file from the account based identifiers 
         * @summary Retrieve an integration log file
         * @param {string} pk 
         * @param {string} sk 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogFile(pk: string, sk: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = IntegrationLogApiFetchParamCreator(configuration).getIntegrationLogFile(pk, sk, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      
                      return response.blob();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a set of integration log summaries from the account based on a query object. 
         * @summary Retrieve integration log summaries
         * @param {IntegrationLogSummaryQueryRequest} integration_log_summaries_query Integration log summaries query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogSummariesQuery(integration_log_summaries_query: IntegrationLogSummaryQueryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IntegrationLogSummaryQueryResponse> {
            const localVarFetchArgs = IntegrationLogApiFetchParamCreator(configuration).getIntegrationLogSummariesQuery(integration_log_summaries_query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a set of integration logs from the account based on a query object. 
         * @summary Retrieve integration logs
         * @param {IntegrationLogQueryRequest} integration_log_query Integration log query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogsQuery(integration_log_query: IntegrationLogQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IntegrationLogQueryResponse> {
            const localVarFetchArgs = IntegrationLogApiFetchParamCreator(configuration).getIntegrationLogsQuery(integration_log_query, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationLogApi - factory interface
 * @export
 */
export const IntegrationLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve an integration logs from the account based identifiers 
         * @summary Retrieve an integration log
         * @param {string} pk 
         * @param {string} sk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLog(pk: string, sk: string, options?: any) {
            return IntegrationLogApiFp(configuration).getIntegrationLog(pk, sk, options)(fetch, basePath);
        },
        /**
         * Retrieve an integration log file from the account based identifiers 
         * @summary Retrieve an integration log file
         * @param {string} pk 
         * @param {string} sk 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogFile(pk: string, sk: string, uuid: string, options?: any) {
            return IntegrationLogApiFp(configuration).getIntegrationLogFile(pk, sk, uuid, options)(fetch, basePath);
        },
        /**
         * Retrieves a set of integration log summaries from the account based on a query object. 
         * @summary Retrieve integration log summaries
         * @param {IntegrationLogSummaryQueryRequest} integration_log_summaries_query Integration log summaries query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogSummariesQuery(integration_log_summaries_query: IntegrationLogSummaryQueryRequest, options?: any) {
            return IntegrationLogApiFp(configuration).getIntegrationLogSummariesQuery(integration_log_summaries_query, options)(fetch, basePath);
        },
        /**
         * Retrieves a set of integration logs from the account based on a query object. 
         * @summary Retrieve integration logs
         * @param {IntegrationLogQueryRequest} integration_log_query Integration log query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationLogsQuery(integration_log_query: IntegrationLogQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return IntegrationLogApiFp(configuration).getIntegrationLogsQuery(integration_log_query, _limit, _offset, _sort, options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationLogApi - interface
 * @export
 * @interface IntegrationLogApi
 */
export interface IntegrationLogApiInterface {
    /**
     * Retrieve an integration logs from the account based identifiers 
     * @summary Retrieve an integration log
     * @param {string} pk 
     * @param {string} sk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApiInterface
     */
    getIntegrationLog(pk: string, sk: string, options?: any): Promise<IntegrationLogResponse>;

    /**
     * Retrieve an integration log file from the account based identifiers 
     * @summary Retrieve an integration log file
     * @param {string} pk 
     * @param {string} sk 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApiInterface
     */
    getIntegrationLogFile(pk: string, sk: string, uuid: string, options?: any): Promise<Blob>;

    /**
     * Retrieves a set of integration log summaries from the account based on a query object. 
     * @summary Retrieve integration log summaries
     * @param {IntegrationLogSummaryQueryRequest} integration_log_summaries_query Integration log summaries query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApiInterface
     */
    getIntegrationLogSummariesQuery(integration_log_summaries_query: IntegrationLogSummaryQueryRequest, options?: any): Promise<IntegrationLogSummaryQueryResponse>;

    /**
     * Retrieves a set of integration logs from the account based on a query object. 
     * @summary Retrieve integration logs
     * @param {IntegrationLogQueryRequest} integration_log_query Integration log query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApiInterface
     */
    getIntegrationLogsQuery(integration_log_query: IntegrationLogQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<IntegrationLogQueryResponse>;

}

/**
 * IntegrationLogApi - object-oriented interface
 * @export
 * @class IntegrationLogApi
 * @extends {BaseAPI}
 */
export class IntegrationLogApi extends BaseAPI implements IntegrationLogApiInterface {
    /**
     * Retrieve an integration logs from the account based identifiers 
     * @summary Retrieve an integration log
     * @param {string} pk 
     * @param {string} sk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApi
     */
    public getIntegrationLog(pk: string, sk: string, options?: any) {
        return IntegrationLogApiFp(this.configuration).getIntegrationLog(pk, sk, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve an integration log file from the account based identifiers 
     * @summary Retrieve an integration log file
     * @param {string} pk 
     * @param {string} sk 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApi
     */
    public getIntegrationLogFile(pk: string, sk: string, uuid: string, options?: any) {
        return IntegrationLogApiFp(this.configuration).getIntegrationLogFile(pk, sk, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a set of integration log summaries from the account based on a query object. 
     * @summary Retrieve integration log summaries
     * @param {IntegrationLogSummaryQueryRequest} integration_log_summaries_query Integration log summaries query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApi
     */
    public getIntegrationLogSummariesQuery(integration_log_summaries_query: IntegrationLogSummaryQueryRequest, options?: any) {
        return IntegrationLogApiFp(this.configuration).getIntegrationLogSummariesQuery(integration_log_summaries_query, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a set of integration logs from the account based on a query object. 
     * @summary Retrieve integration logs
     * @param {IntegrationLogQueryRequest} integration_log_query Integration log query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationLogApi
     */
    public getIntegrationLogsQuery(integration_log_query: IntegrationLogQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return IntegrationLogApiFp(this.configuration).getIntegrationLogsQuery(integration_log_query, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

}

/**
 * ItemApi - fetch parameter creator
 * @export
 */
export const ItemApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an item on the UltraCart account. 
         * @summary Delete an item
         * @param {number} merchant_item_oid The item oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(merchant_item_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'merchant_item_oid' is not null or undefined
            if (merchant_item_oid === null || merchant_item_oid === undefined) {
                throw new RequiredError('merchant_item_oid','Required parameter merchant_item_oid was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/item/items/{merchant_item_oid}`
                .replace(`{${"merchant_item_oid"}}`, encodeURIComponent(String(merchant_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single item using the specified item oid. 
         * @summary Retrieve an item
         * @param {number} merchant_item_oid The item oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'merchant_item_oid' is not null or undefined
            if (merchant_item_oid === null || merchant_item_oid === undefined) {
                throw new RequiredError('merchant_item_oid','Required parameter merchant_item_oid was null or undefined when calling getItem.');
            }
            const localVarPath = `/item/items/{merchant_item_oid}`
                .replace(`{${"merchant_item_oid"}}`, encodeURIComponent(String(merchant_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single item using the specified item id. 
         * @summary Retrieve an item by item id
         * @param {string} merchant_item_id The item id to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByMerchantItemId(merchant_item_id: string, _expand?: string, _placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'merchant_item_id' is not null or undefined
            if (merchant_item_id === null || merchant_item_id === undefined) {
                throw new RequiredError('merchant_item_id','Required parameter merchant_item_id was null or undefined when calling getItemByMerchantItemId.');
            }
            const localVarPath = `/item/items/merchant_item_id/{merchant_item_id}`
                .replace(`{${"merchant_item_id"}}`, encodeURIComponent(String(merchant_item_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve items
         * @param {number} [parent_category_id] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
         * @param {string} [parent_category_path] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch items that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(parent_category_id?: number, parent_category_path?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, _placeholders?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/item/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (parent_category_id !== undefined) {
                localVarQueryParameter['parent_category_id'] = parent_category_id;
            }

            if (parent_category_path !== undefined) {
                localVarQueryParameter['parent_category_path'] = parent_category_path;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_since !== undefined) {
                localVarQueryParameter['_since'] = _since;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingTiers(_expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/item/pricing_tiers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new item on the UltraCart account. 
         * @summary Create an item
         * @param {Item} item Item to create
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertItem(item: Item, _expand?: string, _placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling insertItem.');
            }
            const localVarPath = `/item/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Item" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item || {}) : (item || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a new item on the UltraCart account. 
         * @summary Update an item
         * @param {Item} item Item to update
         * @param {number} merchant_item_oid The item oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(item: Item, merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling updateItem.');
            }
            // verify required parameter 'merchant_item_oid' is not null or undefined
            if (merchant_item_oid === null || merchant_item_oid === undefined) {
                throw new RequiredError('merchant_item_oid','Required parameter merchant_item_oid was null or undefined when calling updateItem.');
            }
            const localVarPath = `/item/items/{merchant_item_oid}`
                .replace(`{${"merchant_item_oid"}}`, encodeURIComponent(String(merchant_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Item" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item || {}) : (item || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple item on the UltraCart account. 
         * @summary Update multiple items
         * @param {ItemsRequest} items_request Items to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItems(items_request: ItemsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'items_request' is not null or undefined
            if (items_request === null || items_request === undefined) {
                throw new RequiredError('items_request','Required parameter items_request was null or undefined when calling updateItems.');
            }
            const localVarPath = `/item/items/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            if (_async !== undefined) {
                localVarQueryParameter['_async'] = _async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(items_request || {}) : (items_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
         * @summary Upload an image to the temporary multimedia.
         * @param {Blob} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryMultimedia(file: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling uploadTemporaryMultimedia.');
            }
            const localVarPath = `/item/temp_multimedia`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }


            const localVarFormParams = new url.URLSearchParams();

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete an item on the UltraCart account. 
         * @summary Delete an item
         * @param {number} merchant_item_oid The item oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(merchant_item_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).deleteItem(merchant_item_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single item using the specified item oid. 
         * @summary Retrieve an item
         * @param {number} merchant_item_oid The item oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getItem(merchant_item_oid, _expand, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single item using the specified item id. 
         * @summary Retrieve an item by item id
         * @param {string} merchant_item_id The item id to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByMerchantItemId(merchant_item_id: string, _expand?: string, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getItemByMerchantItemId(merchant_item_id, _expand, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve items
         * @param {number} [parent_category_id] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
         * @param {string} [parent_category_path] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch items that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(parent_category_id?: number, parent_category_path?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getItems(parent_category_id, parent_category_path, _limit, _offset, _since, _sort, _expand, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingTiers(_expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PricingTiersResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).getPricingTiers(_expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new item on the UltraCart account. 
         * @summary Create an item
         * @param {Item} item Item to create
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertItem(item: Item, _expand?: string, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).insertItem(item, _expand, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a new item on the UltraCart account. 
         * @summary Update an item
         * @param {Item} item Item to update
         * @param {number} merchant_item_oid The item oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(item: Item, merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).updateItem(item, merchant_item_oid, _expand, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update multiple item on the UltraCart account. 
         * @summary Update multiple items
         * @param {ItemsRequest} items_request Items to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItems(items_request: ItemsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemsResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).updateItems(items_request, _expand, _placeholders, _async, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
         * @summary Upload an image to the temporary multimedia.
         * @param {Blob} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryMultimedia(file: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TempMultimediaResponse> {
            const localVarFetchArgs = ItemApiFetchParamCreator(configuration).uploadTemporaryMultimedia(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete an item on the UltraCart account. 
         * @summary Delete an item
         * @param {number} merchant_item_oid The item oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(merchant_item_oid: number, options?: any) {
            return ItemApiFp(configuration).deleteItem(merchant_item_oid, options)(fetch, basePath);
        },
        /**
         * Retrieves a single item using the specified item oid. 
         * @summary Retrieve an item
         * @param {number} merchant_item_oid The item oid to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).getItem(merchant_item_oid, _expand, _placeholders, options)(fetch, basePath);
        },
        /**
         * Retrieves a single item using the specified item id. 
         * @summary Retrieve an item by item id
         * @param {string} merchant_item_id The item id to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemByMerchantItemId(merchant_item_id: string, _expand?: string, _placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).getItemByMerchantItemId(merchant_item_id, _expand, _placeholders, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve items
         * @param {number} [parent_category_id] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
         * @param {string} [parent_category_path] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch items that have been created/modified since this date/time.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(parent_category_id?: number, parent_category_path?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, _placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).getItems(parent_category_id, parent_category_path, _limit, _offset, _since, _sort, _expand, _placeholders, options)(fetch, basePath);
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingTiers(_expand?: string, options?: any) {
            return ItemApiFp(configuration).getPricingTiers(_expand, options)(fetch, basePath);
        },
        /**
         * Create a new item on the UltraCart account. 
         * @summary Create an item
         * @param {Item} item Item to create
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertItem(item: Item, _expand?: string, _placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).insertItem(item, _expand, _placeholders, options)(fetch, basePath);
        },
        /**
         * Update a new item on the UltraCart account. 
         * @summary Update an item
         * @param {Item} item Item to update
         * @param {number} merchant_item_oid The item oid to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(item: Item, merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any) {
            return ItemApiFp(configuration).updateItem(item, merchant_item_oid, _expand, _placeholders, options)(fetch, basePath);
        },
        /**
         * Update multiple item on the UltraCart account. 
         * @summary Update multiple items
         * @param {ItemsRequest} items_request Items to update (synchronous maximum 20 / asynchronous maximum 100)
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {boolean} [_async] True if the operation should be run async.  No result returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItems(items_request: ItemsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any) {
            return ItemApiFp(configuration).updateItems(items_request, _expand, _placeholders, _async, options)(fetch, basePath);
        },
        /**
         * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
         * @summary Upload an image to the temporary multimedia.
         * @param {Blob} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryMultimedia(file: Blob, options?: any) {
            return ItemApiFp(configuration).uploadTemporaryMultimedia(file, options)(fetch, basePath);
        },
    };
};

/**
 * ItemApi - interface
 * @export
 * @interface ItemApi
 */
export interface ItemApiInterface {
    /**
     * Delete an item on the UltraCart account. 
     * @summary Delete an item
     * @param {number} merchant_item_oid The item oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    deleteItem(merchant_item_oid: number, options?: any): Promise<{}>;

    /**
     * Retrieves a single item using the specified item oid. 
     * @summary Retrieve an item
     * @param {number} merchant_item_oid The item oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getItem(merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Retrieves a single item using the specified item id. 
     * @summary Retrieve an item by item id
     * @param {string} merchant_item_id The item id to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getItemByMerchantItemId(merchant_item_id: string, _expand?: string, _placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve items
     * @param {number} [parent_category_id] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
     * @param {string} [parent_category_path] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch items that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getItems(parent_category_id?: number, parent_category_path?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, _placeholders?: boolean, options?: any): Promise<ItemsResponse>;

    /**
     * Retrieves the pricing tiers 
     * @summary Retrieve pricing tiers
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    getPricingTiers(_expand?: string, options?: any): Promise<PricingTiersResponse>;

    /**
     * Create a new item on the UltraCart account. 
     * @summary Create an item
     * @param {Item} item Item to create
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    insertItem(item: Item, _expand?: string, _placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Update a new item on the UltraCart account. 
     * @summary Update an item
     * @param {Item} item Item to update
     * @param {number} merchant_item_oid The item oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    updateItem(item: Item, merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any): Promise<ItemResponse>;

    /**
     * Update multiple item on the UltraCart account. 
     * @summary Update multiple items
     * @param {ItemsRequest} items_request Items to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [_async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    updateItems(items_request: ItemsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any): Promise<ItemsResponse>;

    /**
     * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
     * @summary Upload an image to the temporary multimedia.
     * @param {Blob} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApiInterface
     */
    uploadTemporaryMultimedia(file: Blob, options?: any): Promise<TempMultimediaResponse>;

}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI implements ItemApiInterface {
    /**
     * Delete an item on the UltraCart account. 
     * @summary Delete an item
     * @param {number} merchant_item_oid The item oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public deleteItem(merchant_item_oid: number, options?: any) {
        return ItemApiFp(this.configuration).deleteItem(merchant_item_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single item using the specified item oid. 
     * @summary Retrieve an item
     * @param {number} merchant_item_oid The item oid to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItem(merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).getItem(merchant_item_oid, _expand, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single item using the specified item id. 
     * @summary Retrieve an item by item id
     * @param {string} merchant_item_id The item id to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItemByMerchantItemId(merchant_item_id: string, _expand?: string, _placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).getItemByMerchantItemId(merchant_item_id, _expand, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve items
     * @param {number} [parent_category_id] The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
     * @param {string} [parent_category_path] The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 2000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch items that have been created/modified since this date/time.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getItems(parent_category_id?: number, parent_category_path?: string, _limit?: number, _offset?: number, _since?: string, _sort?: string, _expand?: string, _placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).getItems(parent_category_id, parent_category_path, _limit, _offset, _since, _sort, _expand, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the pricing tiers 
     * @summary Retrieve pricing tiers
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public getPricingTiers(_expand?: string, options?: any) {
        return ItemApiFp(this.configuration).getPricingTiers(_expand, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new item on the UltraCart account. 
     * @summary Create an item
     * @param {Item} item Item to create
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public insertItem(item: Item, _expand?: string, _placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).insertItem(item, _expand, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Update a new item on the UltraCart account. 
     * @summary Update an item
     * @param {Item} item Item to update
     * @param {number} merchant_item_oid The item oid to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItem(item: Item, merchant_item_oid: number, _expand?: string, _placeholders?: boolean, options?: any) {
        return ItemApiFp(this.configuration).updateItem(item, merchant_item_oid, _expand, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Update multiple item on the UltraCart account. 
     * @summary Update multiple items
     * @param {ItemsRequest} items_request Items to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {boolean} [_async] True if the operation should be run async.  No result returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public updateItems(items_request: ItemsRequest, _expand?: string, _placeholders?: boolean, _async?: boolean, options?: any) {
        return ItemApiFp(this.configuration).updateItems(items_request, _expand, _placeholders, _async, options)(this.fetch, this.basePath);
    }

    /**
     * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
     * @summary Upload an image to the temporary multimedia.
     * @param {Blob} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public uploadTemporaryMultimedia(file: Blob, options?: any) {
        return ItemApiFp(this.configuration).uploadTemporaryMultimedia(file, options)(this.fetch, this.basePath);
    }

}

/**
 * OauthApi - fetch parameter creator
 * @export
 */
export const OauthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
         * @summary Exchange authorization code for access token.
         * @param {string} client_id The OAuth application client_id.
         * @param {string} grant_type Type of grant
         * @param {string} [code] Authorization code received back from the browser redirect
         * @param {string} [redirect_uri] The URI that you redirect the browser to to start the authorization process
         * @param {string} [refresh_token] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAccessToken(client_id: string, grant_type: string, code?: string, redirect_uri?: string, refresh_token?: string, options: any = {}): FetchArgs {
            // verify required parameter 'client_id' is not null or undefined
            if (client_id === null || client_id === undefined) {
                throw new RequiredError('client_id','Required parameter client_id was null or undefined when calling oauthAccessToken.');
            }
            // verify required parameter 'grant_type' is not null or undefined
            if (grant_type === null || grant_type === undefined) {
                throw new RequiredError('grant_type','Required parameter grant_type was null or undefined when calling oauthAccessToken.');
            }
            const localVarPath = `/oauth/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }


            const localVarFormParams = new url.URLSearchParams();

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["ultrabooks_write", "auto_order_write", "coupon_read", "affiliate_read", "coupon_write", "tax_read", "fulfillment_write", "tax_write", "item_read", "fulfillment_read", "webhook_write", "chargeback_write", "user_write", "checkout_write", "storefront_read", "webhook_read", "item_write", "auto_order_read", "customer_read", "user_read", "configuration_read", "customer_write", "order_read", "affiliate_write", "storefront_write", "ultrabooks_read", "order_write", "chargeback_read", "integration_log_write", "configuration_write", "checkout_read", "integration_log_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (client_id !== undefined) {
                localVarFormParams.set('client_id', client_id as any);
            }

            if (grant_type !== undefined) {
                localVarFormParams.set('grant_type', grant_type as any);
            }

            if (code !== undefined) {
                localVarFormParams.set('code', code as any);
            }

            if (redirect_uri !== undefined) {
                localVarFormParams.set('redirect_uri', redirect_uri as any);
            }

            if (refresh_token !== undefined) {
                localVarFormParams.set('refresh_token', refresh_token as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes the OAuth application associated with the specified client_id and token. 
         * @summary Revoke this OAuth application.
         * @param {string} client_id The OAuth application client_id.
         * @param {string} token The OAuth access token that is to be revoked..
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke(client_id: string, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'client_id' is not null or undefined
            if (client_id === null || client_id === undefined) {
                throw new RequiredError('client_id','Required parameter client_id was null or undefined when calling oauthRevoke.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling oauthRevoke.');
            }
            const localVarPath = `/oauth/revoke`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }


            const localVarFormParams = new url.URLSearchParams();

            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["ultrabooks_write", "auto_order_write", "coupon_read", "affiliate_read", "coupon_write", "tax_read", "fulfillment_write", "tax_write", "item_read", "fulfillment_read", "webhook_write", "chargeback_write", "user_write", "checkout_write", "storefront_read", "webhook_read", "item_write", "auto_order_read", "customer_read", "user_read", "configuration_read", "customer_write", "order_read", "affiliate_write", "storefront_write", "ultrabooks_read", "order_write", "chargeback_read", "integration_log_write", "configuration_write", "checkout_read", "integration_log_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (client_id !== undefined) {
                localVarFormParams.set('client_id', client_id as any);
            }

            if (token !== undefined) {
                localVarFormParams.set('token', token as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
         * @summary Exchange authorization code for access token.
         * @param {string} client_id The OAuth application client_id.
         * @param {string} grant_type Type of grant
         * @param {string} [code] Authorization code received back from the browser redirect
         * @param {string} [redirect_uri] The URI that you redirect the browser to to start the authorization process
         * @param {string} [refresh_token] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAccessToken(client_id: string, grant_type: string, code?: string, redirect_uri?: string, refresh_token?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OauthTokenResponse> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauthAccessToken(client_id, grant_type, code, redirect_uri, refresh_token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revokes the OAuth application associated with the specified client_id and token. 
         * @summary Revoke this OAuth application.
         * @param {string} client_id The OAuth application client_id.
         * @param {string} token The OAuth access token that is to be revoked..
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke(client_id: string, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OauthRevokeSuccessResponse> {
            const localVarFetchArgs = OauthApiFetchParamCreator(configuration).oauthRevoke(client_id, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
         * @summary Exchange authorization code for access token.
         * @param {string} client_id The OAuth application client_id.
         * @param {string} grant_type Type of grant
         * @param {string} [code] Authorization code received back from the browser redirect
         * @param {string} [redirect_uri] The URI that you redirect the browser to to start the authorization process
         * @param {string} [refresh_token] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAccessToken(client_id: string, grant_type: string, code?: string, redirect_uri?: string, refresh_token?: string, options?: any) {
            return OauthApiFp(configuration).oauthAccessToken(client_id, grant_type, code, redirect_uri, refresh_token, options)(fetch, basePath);
        },
        /**
         * Revokes the OAuth application associated with the specified client_id and token. 
         * @summary Revoke this OAuth application.
         * @param {string} client_id The OAuth application client_id.
         * @param {string} token The OAuth access token that is to be revoked..
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthRevoke(client_id: string, token: string, options?: any) {
            return OauthApiFp(configuration).oauthRevoke(client_id, token, options)(fetch, basePath);
        },
    };
};

/**
 * OauthApi - interface
 * @export
 * @interface OauthApi
 */
export interface OauthApiInterface {
    /**
     * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
     * @summary Exchange authorization code for access token.
     * @param {string} client_id The OAuth application client_id.
     * @param {string} grant_type Type of grant
     * @param {string} [code] Authorization code received back from the browser redirect
     * @param {string} [redirect_uri] The URI that you redirect the browser to to start the authorization process
     * @param {string} [refresh_token] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApiInterface
     */
    oauthAccessToken(client_id: string, grant_type: string, code?: string, redirect_uri?: string, refresh_token?: string, options?: any): Promise<OauthTokenResponse>;

    /**
     * Revokes the OAuth application associated with the specified client_id and token. 
     * @summary Revoke this OAuth application.
     * @param {string} client_id The OAuth application client_id.
     * @param {string} token The OAuth access token that is to be revoked..
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApiInterface
     */
    oauthRevoke(client_id: string, token: string, options?: any): Promise<OauthRevokeSuccessResponse>;

}

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI implements OauthApiInterface {
    /**
     * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
     * @summary Exchange authorization code for access token.
     * @param {string} client_id The OAuth application client_id.
     * @param {string} grant_type Type of grant
     * @param {string} [code] Authorization code received back from the browser redirect
     * @param {string} [redirect_uri] The URI that you redirect the browser to to start the authorization process
     * @param {string} [refresh_token] The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauthAccessToken(client_id: string, grant_type: string, code?: string, redirect_uri?: string, refresh_token?: string, options?: any) {
        return OauthApiFp(this.configuration).oauthAccessToken(client_id, grant_type, code, redirect_uri, refresh_token, options)(this.fetch, this.basePath);
    }

    /**
     * Revokes the OAuth application associated with the specified client_id and token. 
     * @summary Revoke this OAuth application.
     * @param {string} client_id The OAuth application client_id.
     * @param {string} token The OAuth access token that is to be revoked..
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauthRevoke(client_id: string, token: string, options?: any) {
        return OauthApiFp(this.configuration).oauthRevoke(client_id, token, options)(this.fetch, this.basePath);
    }

}

/**
 * OrderApi - fetch parameter creator
 * @export
 */
export const OrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order and must be less than the current total and greater than zero.  This call will change the order total.  It returns true if the desired total is achieved.  If the goal seeking algorithm falls short (usually by pennies), this method returns back false.  View the merchant notes for the order for further details. 
         * @summary Adjusts an order total
         * @param {string} order_id The order id to cancel.
         * @param {string} desired_total The desired total with no formatting. example 123.45
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustOrderTotal(order_id: string, desired_total: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling adjustOrderTotal.');
            }
            // verify required parameter 'desired_total' is not null or undefined
            if (desired_total === null || desired_total === undefined) {
                throw new RequiredError('desired_total','Required parameter desired_total was null or undefined when calling adjustOrderTotal.');
            }
            const localVarPath = `/order/orders/{order_id}/adjust_order_total/{desired_total}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)))
                .replace(`{${"desired_total"}}`, encodeURIComponent(String(desired_total)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
         * @summary Cancel an order
         * @param {string} order_id The order id to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling cancelOrder.');
            }
            const localVarPath = `/order/orders/{order_id}/cancel`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an order on the UltraCart account. 
         * @summary Delete an order
         * @param {string} order_id The order id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling deleteOrder.');
            }
            const localVarPath = `/order/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Format the order for display at text or html 
         * @summary Format order
         * @param {string} order_id The order id to format
         * @param {OrderFormat} format_options Format options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        format(order_id: string, format_options: OrderFormat, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling format.');
            }
            // verify required parameter 'format_options' is not null or undefined
            if (format_options === null || format_options === undefined) {
                throw new RequiredError('format_options','Required parameter format_options was null or undefined when calling format.');
            }
            const localVarPath = `/order/orders/{order_id}/format`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderFormat" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(format_options || {}) : (format_options || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
         * @summary Generate an order token for a given order id
         * @param {string} order_id The order id to generate a token for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOrderToken(order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling generateOrderToken.');
            }
            const localVarPath = `/order/orders/token/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order across all distribution centers.
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlipAllDC(order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling generatePackingSlipAllDC.');
            }
            const localVarPath = `/order/orders/{order_id}/packing_slip`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order for the given distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlipSpecificDC(distribution_center_code: string, order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'distribution_center_code' is not null or undefined
            if (distribution_center_code === null || distribution_center_code === undefined) {
                throw new RequiredError('distribution_center_code','Required parameter distribution_center_code was null or undefined when calling generatePackingSlipSpecificDC.');
            }
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling generatePackingSlipSpecificDC.');
            }
            const localVarPath = `/order/orders/{order_id}/packing_slip/{distribution_center_code}`
                .replace(`{${"distribution_center_code"}}`, encodeURIComponent(String(distribution_center_code)))
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["fulfillment_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryConfig(options: any = {}): FetchArgs {
            const localVarPath = `/order/accountsReceivableRetryConfig`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryStats(from?: string, to?: string, options: any = {}): FetchArgs {
            const localVarPath = `/order/accountsReceivableRetryConfig/stats`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single order using the specified order id. 
         * @summary Retrieve an order
         * @param {string} order_id The order id to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(order_id: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling getOrder.');
            }
            const localVarPath = `/order/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single order using the specified order token. 
         * @summary Retrieve an order using a token
         * @param {OrderByTokenQuery} order_by_token_query Order by token query
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByToken(order_by_token_query: OrderByTokenQuery, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_by_token_query' is not null or undefined
            if (order_by_token_query === null || order_by_token_query === undefined) {
                throw new RequiredError('order_by_token_query','Required parameter order_by_token_query was null or undefined when calling getOrderByToken.');
            }
            const localVarPath = `/order/orders/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderByTokenQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order_by_token_query || {}) : (order_by_token_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {string} [order_id] Order Id
         * @param {string} [payment_method] Payment Method
         * @param {string} [company] Company
         * @param {string} [first_name] First Name
         * @param {string} [last_name] Last Name
         * @param {string} [city] City
         * @param {string} [state_region] State/Region
         * @param {string} [postal_code] Postal Code
         * @param {string} [country_code] Country Code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [cc_email] CC Email
         * @param {number} [total] Total
         * @param {string} [screen_branding_theme_code] Screen Branding Theme Code
         * @param {string} [storefront_host_name] StoreFront Host Name
         * @param {string} [creation_date_begin] Creation Date Begin
         * @param {string} [creation_date_end] Creation Date End
         * @param {string} [payment_date_begin] Payment Date Begin
         * @param {string} [payment_date_end] Payment Date End
         * @param {string} [shipment_date_begin] Shipment Date Begin
         * @param {string} [shipment_date_end] Shipment Date End
         * @param {string} [rma] RMA
         * @param {string} [purchase_order_number] Purchase Order Number
         * @param {string} [item_id] Item Id
         * @param {string} [current_stage] Current Stage
         * @param {string} [channel_partner_code] Channel Partner Code
         * @param {string} [channel_partner_order_id] Channel Partner Order ID
         * @param {number} [customer_profile_oid] 
         * @param {string} [Refund_Date_Begin] 
         * @param {string} [Refund_Date_End] 
         * @param {string} [Custom_Field_1] 
         * @param {string} [Custom_Field_2] 
         * @param {string} [Custom_Field_3] 
         * @param {string} [Custom_Field_4] 
         * @param {string} [Custom_Field_5] 
         * @param {string} [Custom_Field_6] 
         * @param {string} [Custom_Field_7] 
         * @param {string} [ship_on_date_begin] 
         * @param {string} [ship_on_date_end] 
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(order_id?: string, payment_method?: string, company?: string, first_name?: string, last_name?: string, city?: string, state_region?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, cc_email?: string, total?: number, screen_branding_theme_code?: string, storefront_host_name?: string, creation_date_begin?: string, creation_date_end?: string, payment_date_begin?: string, payment_date_end?: string, shipment_date_begin?: string, shipment_date_end?: string, rma?: string, purchase_order_number?: string, item_id?: string, current_stage?: string, channel_partner_code?: string, channel_partner_order_id?: string, customer_profile_oid?: number, Refund_Date_Begin?: string, Refund_Date_End?: string, Custom_Field_1?: string, Custom_Field_2?: string, Custom_Field_3?: string, Custom_Field_4?: string, Custom_Field_5?: string, Custom_Field_6?: string, Custom_Field_7?: string, ship_on_date_begin?: string, ship_on_date_end?: string, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/order/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (order_id !== undefined) {
                localVarQueryParameter['order_id'] = order_id;
            }

            if (payment_method !== undefined) {
                localVarQueryParameter['payment_method'] = payment_method;
            }

            if (company !== undefined) {
                localVarQueryParameter['company'] = company;
            }

            if (first_name !== undefined) {
                localVarQueryParameter['first_name'] = first_name;
            }

            if (last_name !== undefined) {
                localVarQueryParameter['last_name'] = last_name;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (state_region !== undefined) {
                localVarQueryParameter['state_region'] = state_region;
            }

            if (postal_code !== undefined) {
                localVarQueryParameter['postal_code'] = postal_code;
            }

            if (country_code !== undefined) {
                localVarQueryParameter['country_code'] = country_code;
            }

            if (phone !== undefined) {
                localVarQueryParameter['phone'] = phone;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (cc_email !== undefined) {
                localVarQueryParameter['cc_email'] = cc_email;
            }

            if (total !== undefined) {
                localVarQueryParameter['total'] = total;
            }

            if (screen_branding_theme_code !== undefined) {
                localVarQueryParameter['screen_branding_theme_code'] = screen_branding_theme_code;
            }

            if (storefront_host_name !== undefined) {
                localVarQueryParameter['storefront_host_name'] = storefront_host_name;
            }

            if (creation_date_begin !== undefined) {
                localVarQueryParameter['creation_date_begin'] = creation_date_begin;
            }

            if (creation_date_end !== undefined) {
                localVarQueryParameter['creation_date_end'] = creation_date_end;
            }

            if (payment_date_begin !== undefined) {
                localVarQueryParameter['payment_date_begin'] = payment_date_begin;
            }

            if (payment_date_end !== undefined) {
                localVarQueryParameter['payment_date_end'] = payment_date_end;
            }

            if (shipment_date_begin !== undefined) {
                localVarQueryParameter['shipment_date_begin'] = shipment_date_begin;
            }

            if (shipment_date_end !== undefined) {
                localVarQueryParameter['shipment_date_end'] = shipment_date_end;
            }

            if (rma !== undefined) {
                localVarQueryParameter['rma'] = rma;
            }

            if (purchase_order_number !== undefined) {
                localVarQueryParameter['purchase_order_number'] = purchase_order_number;
            }

            if (item_id !== undefined) {
                localVarQueryParameter['item_id'] = item_id;
            }

            if (current_stage !== undefined) {
                localVarQueryParameter['current_stage'] = current_stage;
            }

            if (channel_partner_code !== undefined) {
                localVarQueryParameter['channel_partner_code'] = channel_partner_code;
            }

            if (channel_partner_order_id !== undefined) {
                localVarQueryParameter['channel_partner_order_id'] = channel_partner_order_id;
            }

            if (customer_profile_oid !== undefined) {
                localVarQueryParameter['customer_profile_oid'] = customer_profile_oid;
            }

            if (Refund_Date_Begin !== undefined) {
                localVarQueryParameter['Refund Date Begin'] = Refund_Date_Begin;
            }

            if (Refund_Date_End !== undefined) {
                localVarQueryParameter['Refund Date End'] = Refund_Date_End;
            }

            if (Custom_Field_1 !== undefined) {
                localVarQueryParameter['Custom Field 1'] = Custom_Field_1;
            }

            if (Custom_Field_2 !== undefined) {
                localVarQueryParameter['Custom Field 2'] = Custom_Field_2;
            }

            if (Custom_Field_3 !== undefined) {
                localVarQueryParameter['Custom Field 3'] = Custom_Field_3;
            }

            if (Custom_Field_4 !== undefined) {
                localVarQueryParameter['Custom Field 4'] = Custom_Field_4;
            }

            if (Custom_Field_5 !== undefined) {
                localVarQueryParameter['Custom Field 5'] = Custom_Field_5;
            }

            if (Custom_Field_6 !== undefined) {
                localVarQueryParameter['Custom Field 6'] = Custom_Field_6;
            }

            if (Custom_Field_7 !== undefined) {
                localVarQueryParameter['Custom Field 7'] = Custom_Field_7;
            }

            if (ship_on_date_begin !== undefined) {
                localVarQueryParameter['ship_on_date_begin'] = ship_on_date_begin;
            }

            if (ship_on_date_end !== undefined) {
                localVarQueryParameter['ship_on_date_end'] = ship_on_date_end;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve order batch
         * @param {OrderQueryBatch} order_batch Order batch
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBatch(order_batch: OrderQueryBatch, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_batch' is not null or undefined
            if (order_batch === null || order_batch === undefined) {
                throw new RequiredError('order_batch','Required parameter order_batch was null or undefined when calling getOrdersBatch.');
            }
            const localVarPath = `/order/orders/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderQueryBatch" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order_batch || {}) : (order_batch || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders by query
         * @param {OrderQuery} order_query Order query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByQuery(order_query: OrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_query' is not null or undefined
            if (order_query === null || order_query === undefined) {
                throw new RequiredError('order_query','Required parameter order_query was null or undefined when calling getOrdersByQuery.');
            }
            const localVarPath = `/order/orders/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order_query || {}) : (order_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
         * @summary Insert an order
         * @param {Order} order Order to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertOrder(order: Order, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling insertOrder.');
            }
            const localVarPath = `/order/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Process payment on order 
         * @summary Process payment
         * @param {string} order_id The order id to process payment on
         * @param {OrderProcessPaymentRequest} process_payment_request Process payment parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(order_id: string, process_payment_request: OrderProcessPaymentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling processPayment.');
            }
            // verify required parameter 'process_payment_request' is not null or undefined
            if (process_payment_request === null || process_payment_request === undefined) {
                throw new RequiredError('process_payment_request','Required parameter process_payment_request was null or undefined when calling processPayment.');
            }
            const localVarPath = `/order/orders/{order_id}/process_payment`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderProcessPaymentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(process_payment_request || {}) : (process_payment_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a refund operation on an order and then update the order if successful 
         * @summary Refund an order
         * @param {Order} order Order to refund
         * @param {string} order_id The order id to refund.
         * @param {boolean} [reject_after_refund] Reject order after refund
         * @param {boolean} [skip_customer_notification] Skip customer email notification
         * @param {boolean} [auto_order_cancel] Cancel associated auto orders
         * @param {boolean} [manual_refund] Consider a manual refund done externally
         * @param {boolean} [reverse_affiliate_transactions] Reverse affiliate transactions
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundOrder(order: Order, order_id: string, reject_after_refund?: boolean, skip_customer_notification?: boolean, auto_order_cancel?: boolean, manual_refund?: boolean, reverse_affiliate_transactions?: boolean, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling refundOrder.');
            }
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling refundOrder.');
            }
            const localVarPath = `/order/orders/{order_id}/refund`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (reject_after_refund !== undefined) {
                localVarQueryParameter['reject_after_refund'] = reject_after_refund;
            }

            if (skip_customer_notification !== undefined) {
                localVarQueryParameter['skip_customer_notification'] = skip_customer_notification;
            }

            if (auto_order_cancel !== undefined) {
                localVarQueryParameter['auto_order_cancel'] = auto_order_cancel;
            }

            if (manual_refund !== undefined) {
                localVarQueryParameter['manual_refund'] = manual_refund;
            }

            if (reverse_affiliate_transactions !== undefined) {
                localVarQueryParameter['reverse_affiliate_transactions'] = reverse_affiliate_transactions;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a replacement order based upon a previous order 
         * @summary Replacement order
         * @param {string} order_id The order id to generate a replacement for.
         * @param {OrderReplacement} replacement Replacement order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacement(order_id: string, replacement: OrderReplacement, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling replacement.');
            }
            // verify required parameter 'replacement' is not null or undefined
            if (replacement === null || replacement === undefined) {
                throw new RequiredError('replacement','Required parameter replacement was null or undefined when calling replacement.');
            }
            const localVarPath = `/order/orders/{order_id}/replacement`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrderReplacement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(replacement || {}) : (replacement || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend the receipt for an order on the UltraCart account. 
         * @summary Resend receipt
         * @param {string} order_id The order id to resend the receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReceipt(order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling resendReceipt.');
            }
            const localVarPath = `/order/orders/{order_id}/resend_receipt`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend shipment confirmation for an order on the UltraCart account. 
         * @summary Resend shipment confirmation
         * @param {string} order_id The order id to resend the shipment notification for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendShipmentConfirmation(order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling resendShipmentConfirmation.');
            }
            const localVarPath = `/order/orders/{order_id}/resend_shipment_confirmation`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Update A/R Retry Configuration
         * @param {AccountsReceivableRetryConfig} retry_config AccountsReceivableRetryConfig object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountsReceivableRetryConfig(retry_config: AccountsReceivableRetryConfig, options: any = {}): FetchArgs {
            // verify required parameter 'retry_config' is not null or undefined
            if (retry_config === null || retry_config === undefined) {
                throw new RequiredError('retry_config','Required parameter retry_config was null or undefined when calling updateAccountsReceivableRetryConfig.');
            }
            const localVarPath = `/order/accountsReceivableRetryConfig`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccountsReceivableRetryConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(retry_config || {}) : (retry_config || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
         * @summary Update an order
         * @param {Order} order Order to update
         * @param {string} order_id The order id to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(order: Order, order_id: string, _expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling updateOrder.');
            }
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling updateOrder.');
            }
            const localVarPath = `/order/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["order_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(order || {}) : (order || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order and must be less than the current total and greater than zero.  This call will change the order total.  It returns true if the desired total is achieved.  If the goal seeking algorithm falls short (usually by pennies), this method returns back false.  View the merchant notes for the order for further details. 
         * @summary Adjusts an order total
         * @param {string} order_id The order id to cancel.
         * @param {string} desired_total The desired total with no formatting. example 123.45
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustOrderTotal(order_id: string, desired_total: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).adjustOrderTotal(order_id, desired_total, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
         * @summary Cancel an order
         * @param {string} order_id The order id to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).cancelOrder(order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an order on the UltraCart account. 
         * @summary Delete an order
         * @param {string} order_id The order id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).deleteOrder(order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Format the order for display at text or html 
         * @summary Format order
         * @param {string} order_id The order id to format
         * @param {OrderFormat} format_options Format options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        format(order_id: string, format_options: OrderFormat, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderFormatResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).format(order_id, format_options, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
         * @summary Generate an order token for a given order id
         * @param {string} order_id The order id to generate a token for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOrderToken(order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderTokenResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).generateOrderToken(order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order across all distribution centers.
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlipAllDC(order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).generatePackingSlipAllDC(order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order for the given distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlipSpecificDC(distribution_center_code: string, order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).generatePackingSlipSpecificDC(distribution_center_code, order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryConfig(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountsReceivableRetryConfigResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getAccountsReceivableRetryConfig(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryStats(from?: string, to?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountsReceivableRetryStatsResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getAccountsReceivableRetryStats(from, to, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single order using the specified order id. 
         * @summary Retrieve an order
         * @param {string} order_id The order id to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(order_id: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrder(order_id, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single order using the specified order token. 
         * @summary Retrieve an order using a token
         * @param {OrderByTokenQuery} order_by_token_query Order by token query
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByToken(order_by_token_query: OrderByTokenQuery, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrderByToken(order_by_token_query, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {string} [order_id] Order Id
         * @param {string} [payment_method] Payment Method
         * @param {string} [company] Company
         * @param {string} [first_name] First Name
         * @param {string} [last_name] Last Name
         * @param {string} [city] City
         * @param {string} [state_region] State/Region
         * @param {string} [postal_code] Postal Code
         * @param {string} [country_code] Country Code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [cc_email] CC Email
         * @param {number} [total] Total
         * @param {string} [screen_branding_theme_code] Screen Branding Theme Code
         * @param {string} [storefront_host_name] StoreFront Host Name
         * @param {string} [creation_date_begin] Creation Date Begin
         * @param {string} [creation_date_end] Creation Date End
         * @param {string} [payment_date_begin] Payment Date Begin
         * @param {string} [payment_date_end] Payment Date End
         * @param {string} [shipment_date_begin] Shipment Date Begin
         * @param {string} [shipment_date_end] Shipment Date End
         * @param {string} [rma] RMA
         * @param {string} [purchase_order_number] Purchase Order Number
         * @param {string} [item_id] Item Id
         * @param {string} [current_stage] Current Stage
         * @param {string} [channel_partner_code] Channel Partner Code
         * @param {string} [channel_partner_order_id] Channel Partner Order ID
         * @param {number} [customer_profile_oid] 
         * @param {string} [Refund_Date_Begin] 
         * @param {string} [Refund_Date_End] 
         * @param {string} [Custom_Field_1] 
         * @param {string} [Custom_Field_2] 
         * @param {string} [Custom_Field_3] 
         * @param {string} [Custom_Field_4] 
         * @param {string} [Custom_Field_5] 
         * @param {string} [Custom_Field_6] 
         * @param {string} [Custom_Field_7] 
         * @param {string} [ship_on_date_begin] 
         * @param {string} [ship_on_date_end] 
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(order_id?: string, payment_method?: string, company?: string, first_name?: string, last_name?: string, city?: string, state_region?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, cc_email?: string, total?: number, screen_branding_theme_code?: string, storefront_host_name?: string, creation_date_begin?: string, creation_date_end?: string, payment_date_begin?: string, payment_date_end?: string, shipment_date_begin?: string, shipment_date_end?: string, rma?: string, purchase_order_number?: string, item_id?: string, current_stage?: string, channel_partner_code?: string, channel_partner_order_id?: string, customer_profile_oid?: number, Refund_Date_Begin?: string, Refund_Date_End?: string, Custom_Field_1?: string, Custom_Field_2?: string, Custom_Field_3?: string, Custom_Field_4?: string, Custom_Field_5?: string, Custom_Field_6?: string, Custom_Field_7?: string, ship_on_date_begin?: string, ship_on_date_end?: string, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrders(order_id, payment_method, company, first_name, last_name, city, state_region, postal_code, country_code, phone, email, cc_email, total, screen_branding_theme_code, storefront_host_name, creation_date_begin, creation_date_end, payment_date_begin, payment_date_end, shipment_date_begin, shipment_date_end, rma, purchase_order_number, item_id, current_stage, channel_partner_code, channel_partner_order_id, customer_profile_oid, Refund_Date_Begin, Refund_Date_End, Custom_Field_1, Custom_Field_2, Custom_Field_3, Custom_Field_4, Custom_Field_5, Custom_Field_6, Custom_Field_7, ship_on_date_begin, ship_on_date_end, _limit, _offset, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve order batch
         * @param {OrderQueryBatch} order_batch Order batch
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBatch(order_batch: OrderQueryBatch, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrdersBatch(order_batch, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders by query
         * @param {OrderQuery} order_query Order query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByQuery(order_query: OrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrdersByQuery(order_query, _limit, _offset, _sort, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
         * @summary Insert an order
         * @param {Order} order Order to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertOrder(order: Order, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).insertOrder(order, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Process payment on order 
         * @summary Process payment
         * @param {string} order_id The order id to process payment on
         * @param {OrderProcessPaymentRequest} process_payment_request Process payment parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(order_id: string, process_payment_request: OrderProcessPaymentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProcessPaymentResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).processPayment(order_id, process_payment_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a refund operation on an order and then update the order if successful 
         * @summary Refund an order
         * @param {Order} order Order to refund
         * @param {string} order_id The order id to refund.
         * @param {boolean} [reject_after_refund] Reject order after refund
         * @param {boolean} [skip_customer_notification] Skip customer email notification
         * @param {boolean} [auto_order_cancel] Cancel associated auto orders
         * @param {boolean} [manual_refund] Consider a manual refund done externally
         * @param {boolean} [reverse_affiliate_transactions] Reverse affiliate transactions
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundOrder(order: Order, order_id: string, reject_after_refund?: boolean, skip_customer_notification?: boolean, auto_order_cancel?: boolean, manual_refund?: boolean, reverse_affiliate_transactions?: boolean, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).refundOrder(order, order_id, reject_after_refund, skip_customer_notification, auto_order_cancel, manual_refund, reverse_affiliate_transactions, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a replacement order based upon a previous order 
         * @summary Replacement order
         * @param {string} order_id The order id to generate a replacement for.
         * @param {OrderReplacement} replacement Replacement order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacement(order_id: string, replacement: OrderReplacement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderReplacementResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).replacement(order_id, replacement, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resend the receipt for an order on the UltraCart account. 
         * @summary Resend receipt
         * @param {string} order_id The order id to resend the receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReceipt(order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).resendReceipt(order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resend shipment confirmation for an order on the UltraCart account. 
         * @summary Resend shipment confirmation
         * @param {string} order_id The order id to resend the shipment notification for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendShipmentConfirmation(order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).resendShipmentConfirmation(order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Update A/R Retry Configuration
         * @param {AccountsReceivableRetryConfig} retry_config AccountsReceivableRetryConfig object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountsReceivableRetryConfig(retry_config: AccountsReceivableRetryConfig, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).updateAccountsReceivableRetryConfig(retry_config, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
         * @summary Update an order
         * @param {Order} order Order to update
         * @param {string} order_id The order id to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(order: Order, order_id: string, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderResponse> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).updateOrder(order, order_id, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order and must be less than the current total and greater than zero.  This call will change the order total.  It returns true if the desired total is achieved.  If the goal seeking algorithm falls short (usually by pennies), this method returns back false.  View the merchant notes for the order for further details. 
         * @summary Adjusts an order total
         * @param {string} order_id The order id to cancel.
         * @param {string} desired_total The desired total with no formatting. example 123.45
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustOrderTotal(order_id: string, desired_total: string, options?: any) {
            return OrderApiFp(configuration).adjustOrderTotal(order_id, desired_total, options)(fetch, basePath);
        },
        /**
         * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
         * @summary Cancel an order
         * @param {string} order_id The order id to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(order_id: string, options?: any) {
            return OrderApiFp(configuration).cancelOrder(order_id, options)(fetch, basePath);
        },
        /**
         * Delete an order on the UltraCart account. 
         * @summary Delete an order
         * @param {string} order_id The order id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(order_id: string, options?: any) {
            return OrderApiFp(configuration).deleteOrder(order_id, options)(fetch, basePath);
        },
        /**
         * Format the order for display at text or html 
         * @summary Format order
         * @param {string} order_id The order id to format
         * @param {OrderFormat} format_options Format options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        format(order_id: string, format_options: OrderFormat, options?: any) {
            return OrderApiFp(configuration).format(order_id, format_options, options)(fetch, basePath);
        },
        /**
         * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
         * @summary Generate an order token for a given order id
         * @param {string} order_id The order id to generate a token for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateOrderToken(order_id: string, options?: any) {
            return OrderApiFp(configuration).generateOrderToken(order_id, options)(fetch, basePath);
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order across all distribution centers.
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlipAllDC(order_id: string, options?: any) {
            return OrderApiFp(configuration).generatePackingSlipAllDC(order_id, options)(fetch, basePath);
        },
        /**
         * The packing slip PDF that is returned is base 64 encoded 
         * @summary Generate a packing slip for this order for the given distribution center.
         * @param {string} distribution_center_code Distribution center code
         * @param {string} order_id Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generatePackingSlipSpecificDC(distribution_center_code: string, order_id: string, options?: any) {
            return OrderApiFp(configuration).generatePackingSlipSpecificDC(distribution_center_code, order_id, options)(fetch, basePath);
        },
        /**
         * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryConfig(options?: any) {
            return OrderApiFp(configuration).getAccountsReceivableRetryConfig(options)(fetch, basePath);
        },
        /**
         * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Retrieve A/R Retry Statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsReceivableRetryStats(from?: string, to?: string, options?: any) {
            return OrderApiFp(configuration).getAccountsReceivableRetryStats(from, to, options)(fetch, basePath);
        },
        /**
         * Retrieves a single order using the specified order id. 
         * @summary Retrieve an order
         * @param {string} order_id The order id to retrieve.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(order_id: string, _expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrder(order_id, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a single order using the specified order token. 
         * @summary Retrieve an order using a token
         * @param {OrderByTokenQuery} order_by_token_query Order by token query
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderByToken(order_by_token_query: OrderByTokenQuery, _expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrderByToken(order_by_token_query, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders
         * @param {string} [order_id] Order Id
         * @param {string} [payment_method] Payment Method
         * @param {string} [company] Company
         * @param {string} [first_name] First Name
         * @param {string} [last_name] Last Name
         * @param {string} [city] City
         * @param {string} [state_region] State/Region
         * @param {string} [postal_code] Postal Code
         * @param {string} [country_code] Country Code (ISO-3166 two letter)
         * @param {string} [phone] Phone
         * @param {string} [email] Email
         * @param {string} [cc_email] CC Email
         * @param {number} [total] Total
         * @param {string} [screen_branding_theme_code] Screen Branding Theme Code
         * @param {string} [storefront_host_name] StoreFront Host Name
         * @param {string} [creation_date_begin] Creation Date Begin
         * @param {string} [creation_date_end] Creation Date End
         * @param {string} [payment_date_begin] Payment Date Begin
         * @param {string} [payment_date_end] Payment Date End
         * @param {string} [shipment_date_begin] Shipment Date Begin
         * @param {string} [shipment_date_end] Shipment Date End
         * @param {string} [rma] RMA
         * @param {string} [purchase_order_number] Purchase Order Number
         * @param {string} [item_id] Item Id
         * @param {string} [current_stage] Current Stage
         * @param {string} [channel_partner_code] Channel Partner Code
         * @param {string} [channel_partner_order_id] Channel Partner Order ID
         * @param {number} [customer_profile_oid] 
         * @param {string} [Refund_Date_Begin] 
         * @param {string} [Refund_Date_End] 
         * @param {string} [Custom_Field_1] 
         * @param {string} [Custom_Field_2] 
         * @param {string} [Custom_Field_3] 
         * @param {string} [Custom_Field_4] 
         * @param {string} [Custom_Field_5] 
         * @param {string} [Custom_Field_6] 
         * @param {string} [Custom_Field_7] 
         * @param {string} [ship_on_date_begin] 
         * @param {string} [ship_on_date_end] 
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(order_id?: string, payment_method?: string, company?: string, first_name?: string, last_name?: string, city?: string, state_region?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, cc_email?: string, total?: number, screen_branding_theme_code?: string, storefront_host_name?: string, creation_date_begin?: string, creation_date_end?: string, payment_date_begin?: string, payment_date_end?: string, shipment_date_begin?: string, shipment_date_end?: string, rma?: string, purchase_order_number?: string, item_id?: string, current_stage?: string, channel_partner_code?: string, channel_partner_order_id?: string, customer_profile_oid?: number, Refund_Date_Begin?: string, Refund_Date_End?: string, Custom_Field_1?: string, Custom_Field_2?: string, Custom_Field_3?: string, Custom_Field_4?: string, Custom_Field_5?: string, Custom_Field_6?: string, Custom_Field_7?: string, ship_on_date_begin?: string, ship_on_date_end?: string, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrders(order_id, payment_method, company, first_name, last_name, city, state_region, postal_code, country_code, phone, email, cc_email, total, screen_branding_theme_code, storefront_host_name, creation_date_begin, creation_date_end, payment_date_begin, payment_date_end, shipment_date_begin, shipment_date_end, rma, purchase_order_number, item_id, current_stage, channel_partner_code, channel_partner_order_id, customer_profile_oid, Refund_Date_Begin, Refund_Date_End, Custom_Field_1, Custom_Field_2, Custom_Field_3, Custom_Field_4, Custom_Field_5, Custom_Field_6, Custom_Field_7, ship_on_date_begin, ship_on_date_end, _limit, _offset, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
         * @summary Retrieve order batch
         * @param {OrderQueryBatch} order_batch Order batch
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBatch(order_batch: OrderQueryBatch, _expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrdersBatch(order_batch, _expand, options)(fetch, basePath);
        },
        /**
         * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve orders by query
         * @param {OrderQuery} order_query Order query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {string} [_expand] The object expansion to perform on the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByQuery(order_query: OrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
            return OrderApiFp(configuration).getOrdersByQuery(order_query, _limit, _offset, _sort, _expand, options)(fetch, basePath);
        },
        /**
         * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
         * @summary Insert an order
         * @param {Order} order Order to insert
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertOrder(order: Order, _expand?: string, options?: any) {
            return OrderApiFp(configuration).insertOrder(order, _expand, options)(fetch, basePath);
        },
        /**
         * Process payment on order 
         * @summary Process payment
         * @param {string} order_id The order id to process payment on
         * @param {OrderProcessPaymentRequest} process_payment_request Process payment parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(order_id: string, process_payment_request: OrderProcessPaymentRequest, options?: any) {
            return OrderApiFp(configuration).processPayment(order_id, process_payment_request, options)(fetch, basePath);
        },
        /**
         * Perform a refund operation on an order and then update the order if successful 
         * @summary Refund an order
         * @param {Order} order Order to refund
         * @param {string} order_id The order id to refund.
         * @param {boolean} [reject_after_refund] Reject order after refund
         * @param {boolean} [skip_customer_notification] Skip customer email notification
         * @param {boolean} [auto_order_cancel] Cancel associated auto orders
         * @param {boolean} [manual_refund] Consider a manual refund done externally
         * @param {boolean} [reverse_affiliate_transactions] Reverse affiliate transactions
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundOrder(order: Order, order_id: string, reject_after_refund?: boolean, skip_customer_notification?: boolean, auto_order_cancel?: boolean, manual_refund?: boolean, reverse_affiliate_transactions?: boolean, _expand?: string, options?: any) {
            return OrderApiFp(configuration).refundOrder(order, order_id, reject_after_refund, skip_customer_notification, auto_order_cancel, manual_refund, reverse_affiliate_transactions, _expand, options)(fetch, basePath);
        },
        /**
         * Create a replacement order based upon a previous order 
         * @summary Replacement order
         * @param {string} order_id The order id to generate a replacement for.
         * @param {OrderReplacement} replacement Replacement order details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacement(order_id: string, replacement: OrderReplacement, options?: any) {
            return OrderApiFp(configuration).replacement(order_id, replacement, options)(fetch, basePath);
        },
        /**
         * Resend the receipt for an order on the UltraCart account. 
         * @summary Resend receipt
         * @param {string} order_id The order id to resend the receipt for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendReceipt(order_id: string, options?: any) {
            return OrderApiFp(configuration).resendReceipt(order_id, options)(fetch, basePath);
        },
        /**
         * Resend shipment confirmation for an order on the UltraCart account. 
         * @summary Resend shipment confirmation
         * @param {string} order_id The order id to resend the shipment notification for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendShipmentConfirmation(order_id: string, options?: any) {
            return OrderApiFp(configuration).resendShipmentConfirmation(order_id, options)(fetch, basePath);
        },
        /**
         * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
         * @summary Update A/R Retry Configuration
         * @param {AccountsReceivableRetryConfig} retry_config AccountsReceivableRetryConfig object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountsReceivableRetryConfig(retry_config: AccountsReceivableRetryConfig, options?: any) {
            return OrderApiFp(configuration).updateAccountsReceivableRetryConfig(retry_config, options)(fetch, basePath);
        },
        /**
         * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
         * @summary Update an order
         * @param {Order} order Order to update
         * @param {string} order_id The order id to update.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(order: Order, order_id: string, _expand?: string, options?: any) {
            return OrderApiFp(configuration).updateOrder(order, order_id, _expand, options)(fetch, basePath);
        },
    };
};

/**
 * OrderApi - interface
 * @export
 * @interface OrderApi
 */
export interface OrderApiInterface {
    /**
     * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order and must be less than the current total and greater than zero.  This call will change the order total.  It returns true if the desired total is achieved.  If the goal seeking algorithm falls short (usually by pennies), this method returns back false.  View the merchant notes for the order for further details. 
     * @summary Adjusts an order total
     * @param {string} order_id The order id to cancel.
     * @param {string} desired_total The desired total with no formatting. example 123.45
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    adjustOrderTotal(order_id: string, desired_total: string, options?: any): Promise<BaseResponse>;

    /**
     * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
     * @summary Cancel an order
     * @param {string} order_id The order id to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    cancelOrder(order_id: string, options?: any): Promise<BaseResponse>;

    /**
     * Delete an order on the UltraCart account. 
     * @summary Delete an order
     * @param {string} order_id The order id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    deleteOrder(order_id: string, options?: any): Promise<{}>;

    /**
     * Format the order for display at text or html 
     * @summary Format order
     * @param {string} order_id The order id to format
     * @param {OrderFormat} format_options Format options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    format(order_id: string, format_options: OrderFormat, options?: any): Promise<OrderFormatResponse>;

    /**
     * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
     * @summary Generate an order token for a given order id
     * @param {string} order_id The order id to generate a token for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    generateOrderToken(order_id: string, options?: any): Promise<OrderTokenResponse>;

    /**
     * The packing slip PDF that is returned is base 64 encoded 
     * @summary Generate a packing slip for this order across all distribution centers.
     * @param {string} order_id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    generatePackingSlipAllDC(order_id: string, options?: any): Promise<OrdersResponse>;

    /**
     * The packing slip PDF that is returned is base 64 encoded 
     * @summary Generate a packing slip for this order for the given distribution center.
     * @param {string} distribution_center_code Distribution center code
     * @param {string} order_id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    generatePackingSlipSpecificDC(distribution_center_code: string, order_id: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getAccountsReceivableRetryConfig(options?: any): Promise<AccountsReceivableRetryConfigResponse>;

    /**
     * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Statistics
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getAccountsReceivableRetryStats(from?: string, to?: string, options?: any): Promise<AccountsReceivableRetryStatsResponse>;

    /**
     * Retrieves a single order using the specified order id. 
     * @summary Retrieve an order
     * @param {string} order_id The order id to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrder(order_id: string, _expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Retrieves a single order using the specified order token. 
     * @summary Retrieve an order using a token
     * @param {OrderByTokenQuery} order_by_token_query Order by token query
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrderByToken(order_by_token_query: OrderByTokenQuery, _expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param {string} [order_id] Order Id
     * @param {string} [payment_method] Payment Method
     * @param {string} [company] Company
     * @param {string} [first_name] First Name
     * @param {string} [last_name] Last Name
     * @param {string} [city] City
     * @param {string} [state_region] State/Region
     * @param {string} [postal_code] Postal Code
     * @param {string} [country_code] Country Code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [cc_email] CC Email
     * @param {number} [total] Total
     * @param {string} [screen_branding_theme_code] Screen Branding Theme Code
     * @param {string} [storefront_host_name] StoreFront Host Name
     * @param {string} [creation_date_begin] Creation Date Begin
     * @param {string} [creation_date_end] Creation Date End
     * @param {string} [payment_date_begin] Payment Date Begin
     * @param {string} [payment_date_end] Payment Date End
     * @param {string} [shipment_date_begin] Shipment Date Begin
     * @param {string} [shipment_date_end] Shipment Date End
     * @param {string} [rma] RMA
     * @param {string} [purchase_order_number] Purchase Order Number
     * @param {string} [item_id] Item Id
     * @param {string} [current_stage] Current Stage
     * @param {string} [channel_partner_code] Channel Partner Code
     * @param {string} [channel_partner_order_id] Channel Partner Order ID
     * @param {number} [customer_profile_oid] 
     * @param {string} [Refund_Date_Begin] 
     * @param {string} [Refund_Date_End] 
     * @param {string} [Custom_Field_1] 
     * @param {string} [Custom_Field_2] 
     * @param {string} [Custom_Field_3] 
     * @param {string} [Custom_Field_4] 
     * @param {string} [Custom_Field_5] 
     * @param {string} [Custom_Field_6] 
     * @param {string} [Custom_Field_7] 
     * @param {string} [ship_on_date_begin] 
     * @param {string} [ship_on_date_end] 
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrders(order_id?: string, payment_method?: string, company?: string, first_name?: string, last_name?: string, city?: string, state_region?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, cc_email?: string, total?: number, screen_branding_theme_code?: string, storefront_host_name?: string, creation_date_begin?: string, creation_date_end?: string, payment_date_begin?: string, payment_date_end?: string, shipment_date_begin?: string, shipment_date_end?: string, rma?: string, purchase_order_number?: string, item_id?: string, current_stage?: string, channel_partner_code?: string, channel_partner_order_id?: string, customer_profile_oid?: number, Refund_Date_Begin?: string, Refund_Date_End?: string, Custom_Field_1?: string, Custom_Field_2?: string, Custom_Field_3?: string, Custom_Field_4?: string, Custom_Field_5?: string, Custom_Field_6?: string, Custom_Field_7?: string, ship_on_date_begin?: string, ship_on_date_end?: string, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve order batch
     * @param {OrderQueryBatch} order_batch Order batch
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrdersBatch(order_batch: OrderQueryBatch, _expand?: string, options?: any): Promise<OrdersResponse>;

    /**
     * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders by query
     * @param {OrderQuery} order_query Order query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    getOrdersByQuery(order_query: OrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any): Promise<OrdersResponse>;

    /**
     * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
     * @summary Insert an order
     * @param {Order} order Order to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    insertOrder(order: Order, _expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Process payment on order 
     * @summary Process payment
     * @param {string} order_id The order id to process payment on
     * @param {OrderProcessPaymentRequest} process_payment_request Process payment parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    processPayment(order_id: string, process_payment_request: OrderProcessPaymentRequest, options?: any): Promise<OrderProcessPaymentResponse>;

    /**
     * Perform a refund operation on an order and then update the order if successful 
     * @summary Refund an order
     * @param {Order} order Order to refund
     * @param {string} order_id The order id to refund.
     * @param {boolean} [reject_after_refund] Reject order after refund
     * @param {boolean} [skip_customer_notification] Skip customer email notification
     * @param {boolean} [auto_order_cancel] Cancel associated auto orders
     * @param {boolean} [manual_refund] Consider a manual refund done externally
     * @param {boolean} [reverse_affiliate_transactions] Reverse affiliate transactions
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    refundOrder(order: Order, order_id: string, reject_after_refund?: boolean, skip_customer_notification?: boolean, auto_order_cancel?: boolean, manual_refund?: boolean, reverse_affiliate_transactions?: boolean, _expand?: string, options?: any): Promise<OrderResponse>;

    /**
     * Create a replacement order based upon a previous order 
     * @summary Replacement order
     * @param {string} order_id The order id to generate a replacement for.
     * @param {OrderReplacement} replacement Replacement order details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    replacement(order_id: string, replacement: OrderReplacement, options?: any): Promise<OrderReplacementResponse>;

    /**
     * Resend the receipt for an order on the UltraCart account. 
     * @summary Resend receipt
     * @param {string} order_id The order id to resend the receipt for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    resendReceipt(order_id: string, options?: any): Promise<BaseResponse>;

    /**
     * Resend shipment confirmation for an order on the UltraCart account. 
     * @summary Resend shipment confirmation
     * @param {string} order_id The order id to resend the shipment notification for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    resendShipmentConfirmation(order_id: string, options?: any): Promise<BaseResponse>;

    /**
     * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Update A/R Retry Configuration
     * @param {AccountsReceivableRetryConfig} retry_config AccountsReceivableRetryConfig object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    updateAccountsReceivableRetryConfig(retry_config: AccountsReceivableRetryConfig, options?: any): Promise<BaseResponse>;

    /**
     * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
     * @summary Update an order
     * @param {Order} order Order to update
     * @param {string} order_id The order id to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    updateOrder(order: Order, order_id: string, _expand?: string, options?: any): Promise<OrderResponse>;

}

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI implements OrderApiInterface {
    /**
     * Adjusts an order total.  Adjusts individual items appropriately and considers taxes.  Desired total should be provided in the same currency as the order and must be less than the current total and greater than zero.  This call will change the order total.  It returns true if the desired total is achieved.  If the goal seeking algorithm falls short (usually by pennies), this method returns back false.  View the merchant notes for the order for further details. 
     * @summary Adjusts an order total
     * @param {string} order_id The order id to cancel.
     * @param {string} desired_total The desired total with no formatting. example 123.45
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public adjustOrderTotal(order_id: string, desired_total: string, options?: any) {
        return OrderApiFp(this.configuration).adjustOrderTotal(order_id, desired_total, options)(this.fetch, this.basePath);
    }

    /**
     * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
     * @summary Cancel an order
     * @param {string} order_id The order id to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrder(order_id: string, options?: any) {
        return OrderApiFp(this.configuration).cancelOrder(order_id, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an order on the UltraCart account. 
     * @summary Delete an order
     * @param {string} order_id The order id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public deleteOrder(order_id: string, options?: any) {
        return OrderApiFp(this.configuration).deleteOrder(order_id, options)(this.fetch, this.basePath);
    }

    /**
     * Format the order for display at text or html 
     * @summary Format order
     * @param {string} order_id The order id to format
     * @param {OrderFormat} format_options Format options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public format(order_id: string, format_options: OrderFormat, options?: any) {
        return OrderApiFp(this.configuration).format(order_id, format_options, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single order token for a given order id.  The token can be used with the getOrderByToken API. 
     * @summary Generate an order token for a given order id
     * @param {string} order_id The order id to generate a token for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public generateOrderToken(order_id: string, options?: any) {
        return OrderApiFp(this.configuration).generateOrderToken(order_id, options)(this.fetch, this.basePath);
    }

    /**
     * The packing slip PDF that is returned is base 64 encoded 
     * @summary Generate a packing slip for this order across all distribution centers.
     * @param {string} order_id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public generatePackingSlipAllDC(order_id: string, options?: any) {
        return OrderApiFp(this.configuration).generatePackingSlipAllDC(order_id, options)(this.fetch, this.basePath);
    }

    /**
     * The packing slip PDF that is returned is base 64 encoded 
     * @summary Generate a packing slip for this order for the given distribution center.
     * @param {string} distribution_center_code Distribution center code
     * @param {string} order_id Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public generatePackingSlipSpecificDC(distribution_center_code: string, order_id: string, options?: any) {
        return OrderApiFp(this.configuration).generatePackingSlipSpecificDC(distribution_center_code, order_id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getAccountsReceivableRetryConfig(options?: any) {
        return OrderApiFp(this.configuration).getAccountsReceivableRetryConfig(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Retrieve A/R Retry Statistics
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getAccountsReceivableRetryStats(from?: string, to?: string, options?: any) {
        return OrderApiFp(this.configuration).getAccountsReceivableRetryStats(from, to, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single order using the specified order id. 
     * @summary Retrieve an order
     * @param {string} order_id The order id to retrieve.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrder(order_id: string, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrder(order_id, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single order using the specified order token. 
     * @summary Retrieve an order using a token
     * @param {OrderByTokenQuery} order_by_token_query Order by token query
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderByToken(order_by_token_query: OrderByTokenQuery, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderByToken(order_by_token_query, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders
     * @param {string} [order_id] Order Id
     * @param {string} [payment_method] Payment Method
     * @param {string} [company] Company
     * @param {string} [first_name] First Name
     * @param {string} [last_name] Last Name
     * @param {string} [city] City
     * @param {string} [state_region] State/Region
     * @param {string} [postal_code] Postal Code
     * @param {string} [country_code] Country Code (ISO-3166 two letter)
     * @param {string} [phone] Phone
     * @param {string} [email] Email
     * @param {string} [cc_email] CC Email
     * @param {number} [total] Total
     * @param {string} [screen_branding_theme_code] Screen Branding Theme Code
     * @param {string} [storefront_host_name] StoreFront Host Name
     * @param {string} [creation_date_begin] Creation Date Begin
     * @param {string} [creation_date_end] Creation Date End
     * @param {string} [payment_date_begin] Payment Date Begin
     * @param {string} [payment_date_end] Payment Date End
     * @param {string} [shipment_date_begin] Shipment Date Begin
     * @param {string} [shipment_date_end] Shipment Date End
     * @param {string} [rma] RMA
     * @param {string} [purchase_order_number] Purchase Order Number
     * @param {string} [item_id] Item Id
     * @param {string} [current_stage] Current Stage
     * @param {string} [channel_partner_code] Channel Partner Code
     * @param {string} [channel_partner_order_id] Channel Partner Order ID
     * @param {number} [customer_profile_oid] 
     * @param {string} [Refund_Date_Begin] 
     * @param {string} [Refund_Date_End] 
     * @param {string} [Custom_Field_1] 
     * @param {string} [Custom_Field_2] 
     * @param {string} [Custom_Field_3] 
     * @param {string} [Custom_Field_4] 
     * @param {string} [Custom_Field_5] 
     * @param {string} [Custom_Field_6] 
     * @param {string} [Custom_Field_7] 
     * @param {string} [ship_on_date_begin] 
     * @param {string} [ship_on_date_end] 
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrders(order_id?: string, payment_method?: string, company?: string, first_name?: string, last_name?: string, city?: string, state_region?: string, postal_code?: string, country_code?: string, phone?: string, email?: string, cc_email?: string, total?: number, screen_branding_theme_code?: string, storefront_host_name?: string, creation_date_begin?: string, creation_date_end?: string, payment_date_begin?: string, payment_date_end?: string, shipment_date_begin?: string, shipment_date_end?: string, rma?: string, purchase_order_number?: string, item_id?: string, current_stage?: string, channel_partner_code?: string, channel_partner_order_id?: string, customer_profile_oid?: number, Refund_Date_Begin?: string, Refund_Date_End?: string, Custom_Field_1?: string, Custom_Field_2?: string, Custom_Field_3?: string, Custom_Field_4?: string, Custom_Field_5?: string, Custom_Field_6?: string, Custom_Field_7?: string, ship_on_date_begin?: string, ship_on_date_end?: string, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrders(order_id, payment_method, company, first_name, last_name, city, state_region, postal_code, country_code, phone, email, cc_email, total, screen_branding_theme_code, storefront_host_name, creation_date_begin, creation_date_end, payment_date_begin, payment_date_end, shipment_date_begin, shipment_date_end, rma, purchase_order_number, item_id, current_stage, channel_partner_code, channel_partner_order_id, customer_profile_oid, Refund_Date_Begin, Refund_Date_End, Custom_Field_1, Custom_Field_2, Custom_Field_3, Custom_Field_4, Custom_Field_5, Custom_Field_6, Custom_Field_7, ship_on_date_begin, ship_on_date_end, _limit, _offset, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
     * @summary Retrieve order batch
     * @param {OrderQueryBatch} order_batch Order batch
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrdersBatch(order_batch: OrderQueryBatch, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrdersBatch(order_batch, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve orders by query
     * @param {OrderQuery} order_query Order query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {string} [_expand] The object expansion to perform on the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrdersByQuery(order_query: OrderQuery, _limit?: number, _offset?: number, _sort?: string, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).getOrdersByQuery(order_query, _limit, _offset, _sort, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
     * @summary Insert an order
     * @param {Order} order Order to insert
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public insertOrder(order: Order, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).insertOrder(order, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Process payment on order 
     * @summary Process payment
     * @param {string} order_id The order id to process payment on
     * @param {OrderProcessPaymentRequest} process_payment_request Process payment parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public processPayment(order_id: string, process_payment_request: OrderProcessPaymentRequest, options?: any) {
        return OrderApiFp(this.configuration).processPayment(order_id, process_payment_request, options)(this.fetch, this.basePath);
    }

    /**
     * Perform a refund operation on an order and then update the order if successful 
     * @summary Refund an order
     * @param {Order} order Order to refund
     * @param {string} order_id The order id to refund.
     * @param {boolean} [reject_after_refund] Reject order after refund
     * @param {boolean} [skip_customer_notification] Skip customer email notification
     * @param {boolean} [auto_order_cancel] Cancel associated auto orders
     * @param {boolean} [manual_refund] Consider a manual refund done externally
     * @param {boolean} [reverse_affiliate_transactions] Reverse affiliate transactions
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public refundOrder(order: Order, order_id: string, reject_after_refund?: boolean, skip_customer_notification?: boolean, auto_order_cancel?: boolean, manual_refund?: boolean, reverse_affiliate_transactions?: boolean, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).refundOrder(order, order_id, reject_after_refund, skip_customer_notification, auto_order_cancel, manual_refund, reverse_affiliate_transactions, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Create a replacement order based upon a previous order 
     * @summary Replacement order
     * @param {string} order_id The order id to generate a replacement for.
     * @param {OrderReplacement} replacement Replacement order details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public replacement(order_id: string, replacement: OrderReplacement, options?: any) {
        return OrderApiFp(this.configuration).replacement(order_id, replacement, options)(this.fetch, this.basePath);
    }

    /**
     * Resend the receipt for an order on the UltraCart account. 
     * @summary Resend receipt
     * @param {string} order_id The order id to resend the receipt for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public resendReceipt(order_id: string, options?: any) {
        return OrderApiFp(this.configuration).resendReceipt(order_id, options)(this.fetch, this.basePath);
    }

    /**
     * Resend shipment confirmation for an order on the UltraCart account. 
     * @summary Resend shipment confirmation
     * @param {string} order_id The order id to resend the shipment notification for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public resendShipmentConfirmation(order_id: string, options?: any) {
        return OrderApiFp(this.configuration).resendShipmentConfirmation(order_id, options)(this.fetch, this.basePath);
    }

    /**
     * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @summary Update A/R Retry Configuration
     * @param {AccountsReceivableRetryConfig} retry_config AccountsReceivableRetryConfig object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateAccountsReceivableRetryConfig(retry_config: AccountsReceivableRetryConfig, options?: any) {
        return OrderApiFp(this.configuration).updateAccountsReceivableRetryConfig(retry_config, options)(this.fetch, this.basePath);
    }

    /**
     * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
     * @summary Update an order
     * @param {Order} order Order to update
     * @param {string} order_id The order id to update.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateOrder(order: Order, order_id: string, _expand?: string, options?: any) {
        return OrderApiFp(this.configuration).updateOrder(order, order_id, _expand, options)(this.fetch, this.basePath);
    }

}

/**
 * SsoApi - fetch parameter creator
 * @export
 */
export const SsoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is the equivalent of logging out of the single sign on session 
         * @summary Get single sign on session user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSessionUser(options: any = {}): FetchArgs {
            const localVarPath = `/sso/session/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the process of authorizing a single sign on session. 
         * @summary Authorize a single sign on session
         * @param {SingleSignOnAuthorizeRequest} authorization_request Authorization request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoAuthorize(authorization_request: SingleSignOnAuthorizeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'authorization_request' is not null or undefined
            if (authorization_request === null || authorization_request === undefined) {
                throw new RequiredError('authorization_request','Required parameter authorization_request was null or undefined when calling ssoAuthorize.');
            }
            const localVarPath = `/sso/authorize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SingleSignOnAuthorizeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(authorization_request || {}) : (authorization_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the equivalent of logging out of the single sign on session 
         * @summary Revoke single sign on session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoSessionRevoke(options: any = {}): FetchArgs {
            const localVarPath = `/sso/session/revoke`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Called by your application after receiving the code back on the redirect URI to obtain a simple key token to make API calls with 
         * @summary Exchange a single sign on code for a simple key token
         * @param {SingleSignOnTokenRequest} token_request Token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoToken(token_request: SingleSignOnTokenRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token_request' is not null or undefined
            if (token_request === null || token_request === undefined) {
                throw new RequiredError('token_request','Required parameter token_request was null or undefined when calling ssoToken.');
            }
            const localVarPath = `/sso/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", [])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SingleSignOnTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(token_request || {}) : (token_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SsoApi - functional programming interface
 * @export
 */
export const SsoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This is the equivalent of logging out of the single sign on session 
         * @summary Get single sign on session user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSessionUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = SsoApiFetchParamCreator(configuration).getSsoSessionUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts the process of authorizing a single sign on session. 
         * @summary Authorize a single sign on session
         * @param {SingleSignOnAuthorizeRequest} authorization_request Authorization request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoAuthorize(authorization_request: SingleSignOnAuthorizeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SingleSignOnAuthorizeResponse> {
            const localVarFetchArgs = SsoApiFetchParamCreator(configuration).ssoAuthorize(authorization_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is the equivalent of logging out of the single sign on session 
         * @summary Revoke single sign on session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoSessionRevoke(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SsoApiFetchParamCreator(configuration).ssoSessionRevoke(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Called by your application after receiving the code back on the redirect URI to obtain a simple key token to make API calls with 
         * @summary Exchange a single sign on code for a simple key token
         * @param {SingleSignOnTokenRequest} token_request Token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoToken(token_request: SingleSignOnTokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SingleSignOnTokenResponse> {
            const localVarFetchArgs = SsoApiFetchParamCreator(configuration).ssoToken(token_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SsoApi - factory interface
 * @export
 */
export const SsoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This is the equivalent of logging out of the single sign on session 
         * @summary Get single sign on session user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoSessionUser(options?: any) {
            return SsoApiFp(configuration).getSsoSessionUser(options)(fetch, basePath);
        },
        /**
         * Starts the process of authorizing a single sign on session. 
         * @summary Authorize a single sign on session
         * @param {SingleSignOnAuthorizeRequest} authorization_request Authorization request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoAuthorize(authorization_request: SingleSignOnAuthorizeRequest, options?: any) {
            return SsoApiFp(configuration).ssoAuthorize(authorization_request, options)(fetch, basePath);
        },
        /**
         * This is the equivalent of logging out of the single sign on session 
         * @summary Revoke single sign on session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoSessionRevoke(options?: any) {
            return SsoApiFp(configuration).ssoSessionRevoke(options)(fetch, basePath);
        },
        /**
         * Called by your application after receiving the code back on the redirect URI to obtain a simple key token to make API calls with 
         * @summary Exchange a single sign on code for a simple key token
         * @param {SingleSignOnTokenRequest} token_request Token request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoToken(token_request: SingleSignOnTokenRequest, options?: any) {
            return SsoApiFp(configuration).ssoToken(token_request, options)(fetch, basePath);
        },
    };
};

/**
 * SsoApi - interface
 * @export
 * @interface SsoApi
 */
export interface SsoApiInterface {
    /**
     * This is the equivalent of logging out of the single sign on session 
     * @summary Get single sign on session user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApiInterface
     */
    getSsoSessionUser(options?: any): Promise<User>;

    /**
     * Starts the process of authorizing a single sign on session. 
     * @summary Authorize a single sign on session
     * @param {SingleSignOnAuthorizeRequest} authorization_request Authorization request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApiInterface
     */
    ssoAuthorize(authorization_request: SingleSignOnAuthorizeRequest, options?: any): Promise<SingleSignOnAuthorizeResponse>;

    /**
     * This is the equivalent of logging out of the single sign on session 
     * @summary Revoke single sign on session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApiInterface
     */
    ssoSessionRevoke(options?: any): Promise<{}>;

    /**
     * Called by your application after receiving the code back on the redirect URI to obtain a simple key token to make API calls with 
     * @summary Exchange a single sign on code for a simple key token
     * @param {SingleSignOnTokenRequest} token_request Token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApiInterface
     */
    ssoToken(token_request: SingleSignOnTokenRequest, options?: any): Promise<SingleSignOnTokenResponse>;

}

/**
 * SsoApi - object-oriented interface
 * @export
 * @class SsoApi
 * @extends {BaseAPI}
 */
export class SsoApi extends BaseAPI implements SsoApiInterface {
    /**
     * This is the equivalent of logging out of the single sign on session 
     * @summary Get single sign on session user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public getSsoSessionUser(options?: any) {
        return SsoApiFp(this.configuration).getSsoSessionUser(options)(this.fetch, this.basePath);
    }

    /**
     * Starts the process of authorizing a single sign on session. 
     * @summary Authorize a single sign on session
     * @param {SingleSignOnAuthorizeRequest} authorization_request Authorization request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoAuthorize(authorization_request: SingleSignOnAuthorizeRequest, options?: any) {
        return SsoApiFp(this.configuration).ssoAuthorize(authorization_request, options)(this.fetch, this.basePath);
    }

    /**
     * This is the equivalent of logging out of the single sign on session 
     * @summary Revoke single sign on session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoSessionRevoke(options?: any) {
        return SsoApiFp(this.configuration).ssoSessionRevoke(options)(this.fetch, this.basePath);
    }

    /**
     * Called by your application after receiving the code back on the redirect URI to obtain a simple key token to make API calls with 
     * @summary Exchange a single sign on code for a simple key token
     * @param {SingleSignOnTokenRequest} token_request Token request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoApi
     */
    public ssoToken(token_request: SingleSignOnTokenRequest, options?: any) {
        return SsoApiFp(this.configuration).ssoToken(token_request, options)(this.fetch, this.basePath);
    }

}

/**
 * StorefrontApi - fetch parameter creator
 * @export
 */
export const StorefrontApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add to library
         * @param {AddLibraryItemRequest} add_library_request New library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToLibrary(add_library_request: AddLibraryItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'add_library_request' is not null or undefined
            if (add_library_request === null || add_library_request === undefined) {
                throw new RequiredError('add_library_request','Required parameter add_library_request was null or undefined when calling addToLibrary.');
            }
            const localVarPath = `/storefront/code_library`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddLibraryItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(add_library_request || {}) : (add_library_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply library item to storefront.
         * @param {ApplyLibraryItemRequest} apply_library_request New library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToStoreFront(apply_library_request: ApplyLibraryItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'apply_library_request' is not null or undefined
            if (apply_library_request === null || apply_library_request === undefined) {
                throw new RequiredError('apply_library_request','Required parameter apply_library_request was null or undefined when calling applyToStoreFront.');
            }
            const localVarPath = `/storefront/code_library/apply`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApplyLibraryItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(apply_library_request || {}) : (apply_library_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailList(storefront_oid: number, email_list_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling archiveEmailList.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling archiveEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/archive`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Archive email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailSegment(storefront_oid: number, email_segment_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling archiveEmailSegment.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling archiveEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/archive`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Back populate email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {EmailFlowBackPopulateRequest} back_populate_request The request to back populate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backPopulateEmailFlow(storefront_oid: number, email_flow_uuid: string, back_populate_request: EmailFlowBackPopulateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling backPopulateEmailFlow.');
            }
            // verify required parameter 'email_flow_uuid' is not null or undefined
            if (email_flow_uuid === null || email_flow_uuid === undefined) {
                throw new RequiredError('email_flow_uuid','Required parameter email_flow_uuid was null or undefined when calling backPopulateEmailFlow.');
            }
            // verify required parameter 'back_populate_request' is not null or undefined
            if (back_populate_request === null || back_populate_request === undefined) {
                throw new RequiredError('back_populate_request','Required parameter back_populate_request was null or undefined when calling backPopulateEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/backfill`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(email_flow_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlowBackPopulateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(back_populate_request || {}) : (back_populate_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check download of email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} email_segment_rebuild_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment_rebuild_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling checkDownloadEmailSegment.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling checkDownloadEmailSegment.');
            }
            // verify required parameter 'email_segment_rebuild_uuid' is not null or undefined
            if (email_segment_rebuild_uuid === null || email_segment_rebuild_uuid === undefined) {
                throw new RequiredError('email_segment_rebuild_uuid','Required parameter email_segment_rebuild_uuid was null or undefined when calling checkDownloadEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/downloadPrepare/{email_segment_rebuild_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)))
                .replace(`{${"email_segment_rebuild_uuid"}}`, encodeURIComponent(String(email_segment_rebuild_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clone email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {number} [target_storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailCampaign(storefront_oid: number, email_campaign_uuid: string, target_storefront_oid?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling cloneEmailCampaign.');
            }
            // verify required parameter 'email_campaign_uuid' is not null or undefined
            if (email_campaign_uuid === null || email_campaign_uuid === undefined) {
                throw new RequiredError('email_campaign_uuid','Required parameter email_campaign_uuid was null or undefined when calling cloneEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/clone`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(email_campaign_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (target_storefront_oid !== undefined) {
                localVarQueryParameter['target_storefront_oid'] = target_storefront_oid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clone email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {number} [target_storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailFlow(storefront_oid: number, email_flow_uuid: string, target_storefront_oid?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling cloneEmailFlow.');
            }
            // verify required parameter 'email_flow_uuid' is not null or undefined
            if (email_flow_uuid === null || email_flow_uuid === undefined) {
                throw new RequiredError('email_flow_uuid','Required parameter email_flow_uuid was null or undefined when calling cloneEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/clone`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(email_flow_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (target_storefront_oid !== undefined) {
                localVarQueryParameter['target_storefront_oid'] = target_storefront_oid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSendingDomain(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling createEmailSendingDomain.');
            }
            const localVarPath = `/storefront/email/sending_domains/{domain}/create`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Twilio account
         * @param {Twilio} twilio Twilio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwilioAccount(twilio: Twilio, options: any = {}): FetchArgs {
            // verify required parameter 'twilio' is not null or undefined
            if (twilio === null || twilio === undefined) {
                throw new RequiredError('twilio','Required parameter twilio was null or undefined when calling createTwilioAccount.');
            }
            const localVarPath = `/storefront/twilio/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Twilio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(twilio || {}) : (twilio || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email campaignFolder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteEmailCampaignFolder.');
            }
            // verify required parameter 'email_campaign_folder_uuid' is not null or undefined
            if (email_campaign_folder_uuid === null || email_campaign_folder_uuid === undefined) {
                throw new RequiredError('email_campaign_folder_uuid','Required parameter email_campaign_folder_uuid was null or undefined when calling deleteEmailCampaignFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaign_folders/{email_campaign_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_folder_uuid"}}`, encodeURIComponent(String(email_campaign_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete communication sequence stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCommseqStat(storefront_oid: number, commseq_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteEmailCommseqStat.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling deleteEmailCommseqStat.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stat`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailEmail(storefront_oid: number, commseq_email_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteEmailEmail.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling deleteEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email flowFolder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteEmailFlowFolder.');
            }
            // verify required parameter 'email_flow_folder_uuid' is not null or undefined
            if (email_flow_folder_uuid === null || email_flow_folder_uuid === undefined) {
                throw new RequiredError('email_flow_folder_uuid','Required parameter email_flow_folder_uuid was null or undefined when calling deleteEmailFlowFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flow_folders/{email_flow_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_folder_uuid"}}`, encodeURIComponent(String(email_flow_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email list customer
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListCustomer(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteEmailListCustomer.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling deleteEmailListCustomer.');
            }
            // verify required parameter 'email_customer_uuid' is not null or undefined
            if (email_customer_uuid === null || email_customer_uuid === undefined) {
                throw new RequiredError('email_customer_uuid','Required parameter email_customer_uuid was null or undefined when calling deleteEmailListCustomer.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(email_customer_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email ListSegmentFolder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteEmailListSegmentFolder.');
            }
            // verify required parameter 'email_list_segment_folder_uuid' is not null or undefined
            if (email_list_segment_folder_uuid === null || email_list_segment_folder_uuid === undefined) {
                throw new RequiredError('email_list_segment_folder_uuid','Required parameter email_list_segment_folder_uuid was null or undefined when calling deleteEmailListSegmentFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/list_segment_folders/{email_list_segment_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_segment_folder_uuid"}}`, encodeURIComponent(String(email_list_segment_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteEmailPostcard.');
            }
            // verify required parameter 'commseq_postcard_uuid' is not null or undefined
            if (commseq_postcard_uuid === null || commseq_postcard_uuid === undefined) {
                throw new RequiredError('commseq_postcard_uuid','Required parameter commseq_postcard_uuid was null or undefined when calling deleteEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseq_postcard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSendingDomain(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling deleteEmailSendingDomain.');
            }
            const localVarPath = `/storefront/email/sending_domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete experiment
         * @param {number} storefront_oid 
         * @param {number} storefront_experiment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(storefront_oid: number, storefront_experiment_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteExperiment.');
            }
            // verify required parameter 'storefront_experiment_oid' is not null or undefined
            if (storefront_experiment_oid === null || storefront_experiment_oid === undefined) {
                throw new RequiredError('storefront_experiment_oid','Required parameter storefront_experiment_oid was null or undefined when calling deleteExperiment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"storefront_experiment_oid"}}`, encodeURIComponent(String(storefront_experiment_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete screen recording heatmap 
         * @summary Delete screen recording heatmap
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapReset} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapReset, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteHeatmap.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling deleteHeatmap.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/heatmap`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingHeatmapReset" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete library item
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItem(library_item_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling deleteLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all published versions for a library item, including anything in review.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItemPublishedVersions(library_item_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling deleteLibraryItemPublishedVersions.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/published_versions`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling deleteScreenRecordingSegment.');
            }
            // verify required parameter 'screen_recording_segment_oid' is not null or undefined
            if (screen_recording_segment_oid === null || screen_recording_segment_oid === undefined) {
                throw new RequiredError('screen_recording_segment_oid','Required parameter screen_recording_segment_oid was null or undefined when calling deleteScreenRecordingSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/segments/{screen_recording_segment_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_segment_oid"}}`, encodeURIComponent(String(screen_recording_segment_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwilioAccount(esp_twilio_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'esp_twilio_uuid' is not null or undefined
            if (esp_twilio_uuid === null || esp_twilio_uuid === undefined) {
                throw new RequiredError('esp_twilio_uuid','Required parameter esp_twilio_uuid was null or undefined when calling deleteTwilioAccount.');
            }
            const localVarPath = `/storefront/twilio/accounts/{esp_twilio_uuid}`
                .replace(`{${"esp_twilio_uuid"}}`, encodeURIComponent(String(esp_twilio_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Duplicate library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateLibraryItem(library_item_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling duplicateLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/duplicate`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update favorite flag on screen recording 
         * @summary Update favorite flag on screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling favoriteScreenRecording.');
            }
            // verify required parameter 'screen_recording_uuid' is not null or undefined
            if (screen_recording_uuid === null || screen_recording_uuid === undefined) {
                throw new RequiredError('screen_recording_uuid','Required parameter screen_recording_uuid was null or undefined when calling favoriteScreenRecording.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/{screen_recording_uuid}/favorite`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_uuid"}}`, encodeURIComponent(String(screen_recording_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtain lat/long for an address
         * @param {number} storefront_oid 
         * @param {GeocodeRequest} geocode_request geocode request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeAddress(storefront_oid: number, geocode_request: GeocodeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling geocodeAddress.');
            }
            // verify required parameter 'geocode_request' is not null or undefined
            if (geocode_request === null || geocode_request === undefined) {
                throw new RequiredError('geocode_request','Required parameter geocode_request was null or undefined when calling geocodeAddress.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/geocode`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GeocodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(geocode_request || {}) : (geocode_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of all the countries 
         * @summary Get countries
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getCountries.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/countries`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a temporary authentication token for the editor 
         * @summary Gets editor token
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorToken(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEditorToken.');
            }
            const localVarPath = `/storefront/{storefront_oid}/editor_token`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication base templates
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailBaseTemplates(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailBaseTemplates.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/baseTemplates`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCampaign.');
            }
            // verify required parameter 'email_campaign_uuid' is not null or undefined
            if (email_campaign_uuid === null || email_campaign_uuid === undefined) {
                throw new RequiredError('email_campaign_uuid','Required parameter email_campaign_uuid was null or undefined when calling getEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(email_campaign_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCampaignFolder.');
            }
            // verify required parameter 'email_campaign_folder_uuid' is not null or undefined
            if (email_campaign_folder_uuid === null || email_campaign_folder_uuid === undefined) {
                throw new RequiredError('email_campaign_folder_uuid','Required parameter email_campaign_folder_uuid was null or undefined when calling getEmailCampaignFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaign_folders/{email_campaign_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_folder_uuid"}}`, encodeURIComponent(String(email_campaign_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignFolders(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCampaignFolders.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaign_folders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign screenshots
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignScreenshots(storefront_oid: number, email_campaign_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCampaignScreenshots.');
            }
            // verify required parameter 'email_campaign_uuid' is not null or undefined
            if (email_campaign_uuid === null || email_campaign_uuid === undefined) {
                throw new RequiredError('email_campaign_uuid','Required parameter email_campaign_uuid was null or undefined when calling getEmailCampaignScreenshots.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/screenshots`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(email_campaign_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaigns
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaigns(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCampaigns.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaigns with stats
         * @param {number} storefront_oid 
         * @param {string} stat_days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignsWithStats(storefront_oid: number, stat_days: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCampaignsWithStats.');
            }
            // verify required parameter 'stat_days' is not null or undefined
            if (stat_days === null || stat_days === undefined) {
                throw new RequiredError('stat_days','Required parameter stat_days was null or undefined when calling getEmailCampaignsWithStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaignsWithStats/{stat_days}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"stat_days"}}`, encodeURIComponent(String(stat_days)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email commseq
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseq(storefront_oid: number, commseq_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseq.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailCommseq.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence emails stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStatSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqEmailStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatSummaryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseqEmailStats.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailCommseqEmailStats.');
            }
            // verify required parameter 'statsRequest' is not null or undefined
            if (statsRequest === null || statsRequest === undefined) {
                throw new RequiredError('statsRequest','Required parameter statsRequest was null or undefined when calling getEmailCommseqEmailStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/emailStats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStatSummaryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(statsRequest || {}) : (statsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence postcard stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqPostcardStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatPostcardSummaryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseqPostcardStats.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailCommseqPostcardStats.');
            }
            // verify required parameter 'statsRequest' is not null or undefined
            if (statsRequest === null || statsRequest === undefined) {
                throw new RequiredError('statsRequest','Required parameter statsRequest was null or undefined when calling getEmailCommseqPostcardStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/postcardStats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStatPostcardSummaryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(statsRequest || {}) : (statsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get communication sequence stats overall
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStatOverall(storefront_oid: number, commseq_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseqStatOverall.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailCommseqStatOverall.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stat`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence step stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStepStatRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStepStatRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseqStepStats.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailCommseqStepStats.');
            }
            // verify required parameter 'statsRequest' is not null or undefined
            if (statsRequest === null || statsRequest === undefined) {
                throw new RequiredError('statsRequest','Required parameter statsRequest was null or undefined when calling getEmailCommseqStepStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stepStats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStepStatRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(statsRequest || {}) : (statsRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email communication sequence customers waiting at each requested step
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, waitingRequest: EmailStepWaitingRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseqStepWaiting.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailCommseqStepWaiting.');
            }
            // verify required parameter 'waitingRequest' is not null or undefined
            if (waitingRequest === null || waitingRequest === undefined) {
                throw new RequiredError('waitingRequest','Required parameter waitingRequest was null or undefined when calling getEmailCommseqStepWaiting.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/waiting`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailStepWaitingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(waitingRequest || {}) : (waitingRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email webhook editor values
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqWebhookEditorValues(storefront_oid: number, commseq_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseqWebhookEditorValues.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailCommseqWebhookEditorValues.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/webhookEditorValues`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email commseqs
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqs(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCommseqs.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get customers editor URL
         * @param {number} storefront_oid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomerEditorUrl(storefront_oid: number, email_customer_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCustomerEditorUrl.');
            }
            // verify required parameter 'email_customer_uuid' is not null or undefined
            if (email_customer_uuid === null || email_customer_uuid === undefined) {
                throw new RequiredError('email_customer_uuid','Required parameter email_customer_uuid was null or undefined when calling getEmailCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/customers/{email_customer_uuid}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(email_customer_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email customers
         * @param {number} storefront_oid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [searchEmailPrefix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomers(storefront_oid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/customers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (searchEmailPrefix !== undefined) {
                localVarQueryParameter['searchEmailPrefix'] = searchEmailPrefix;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email dashboard activity
         * @param {number} storefront_oid 
         * @param {number} [last_records] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardActivity(storefront_oid: number, last_records?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailDashboardActivity.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/dashboard_activity`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (last_records !== undefined) {
                localVarQueryParameter['last_records'] = last_records;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard stats
         * @param {number} storefront_oid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardStats(storefront_oid: number, days?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailDashboardStats.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/dashboard_stats`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email dispatch logs
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDispatchLogs(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailDispatchLogs.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailDispatchLogs.');
            }
            // verify required parameter 'commseq_step_uuid' is not null or undefined
            if (commseq_step_uuid === null || commseq_step_uuid === undefined) {
                throw new RequiredError('commseq_step_uuid','Required parameter commseq_step_uuid was null or undefined when calling getEmailDispatchLogs.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/steps/{commseq_step_uuid}/logs`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)))
                .replace(`{${"commseq_step_uuid"}}`, encodeURIComponent(String(commseq_step_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmail(storefront_oid: number, commseq_email_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailEmail.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling getEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email email clicks
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {string} commseq_email_uuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailClicks(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailEmailClicks.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailEmailClicks.');
            }
            // verify required parameter 'commseq_step_uuid' is not null or undefined
            if (commseq_step_uuid === null || commseq_step_uuid === undefined) {
                throw new RequiredError('commseq_step_uuid','Required parameter commseq_step_uuid was null or undefined when calling getEmailEmailClicks.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling getEmailEmailClicks.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/steps/{commseq_step_uuid}/emails/{commseq_email_uuid}/clicks`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)))
                .replace(`{${"commseq_step_uuid"}}`, encodeURIComponent(String(commseq_step_uuid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email order customer editor url
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {string} order_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailCustomerEditorUrl(storefront_oid: number, commseq_email_uuid: string, order_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailEmailCustomerEditorUrl.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling getEmailEmailCustomerEditorUrl.');
            }
            // verify required parameter 'order_id' is not null or undefined
            if (order_id === null || order_id === undefined) {
                throw new RequiredError('order_id','Required parameter order_id was null or undefined when calling getEmailEmailCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/orders/{order_id}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)))
                .replace(`{${"order_id"}}`, encodeURIComponent(String(order_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email email orders
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {string} commseq_email_uuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailOrders(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailEmailOrders.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling getEmailEmailOrders.');
            }
            // verify required parameter 'commseq_step_uuid' is not null or undefined
            if (commseq_step_uuid === null || commseq_step_uuid === undefined) {
                throw new RequiredError('commseq_step_uuid','Required parameter commseq_step_uuid was null or undefined when calling getEmailEmailOrders.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling getEmailEmailOrders.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/steps/{commseq_step_uuid}/emails/{commseq_email_uuid}/orders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)))
                .replace(`{${"commseq_step_uuid"}}`, encodeURIComponent(String(commseq_step_uuid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email emails
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmails(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailEmails.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email emails multiple
         * @param {number} storefront_oid 
         * @param {EmailCommseqEmailsRequest} email_commseq_emails_request Request of email uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailsMultiple(storefront_oid: number, email_commseq_emails_request: EmailCommseqEmailsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailEmailsMultiple.');
            }
            // verify required parameter 'email_commseq_emails_request' is not null or undefined
            if (email_commseq_emails_request === null || email_commseq_emails_request === undefined) {
                throw new RequiredError('email_commseq_emails_request','Required parameter email_commseq_emails_request was null or undefined when calling getEmailEmailsMultiple.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/multiple`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmailsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_emails_request || {}) : (email_commseq_emails_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlow(storefront_oid: number, email_flow_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailFlow.');
            }
            // verify required parameter 'email_flow_uuid' is not null or undefined
            if (email_flow_uuid === null || email_flow_uuid === undefined) {
                throw new RequiredError('email_flow_uuid','Required parameter email_flow_uuid was null or undefined when calling getEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(email_flow_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flow folder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailFlowFolder.');
            }
            // verify required parameter 'email_flow_folder_uuid' is not null or undefined
            if (email_flow_folder_uuid === null || email_flow_folder_uuid === undefined) {
                throw new RequiredError('email_flow_folder_uuid','Required parameter email_flow_folder_uuid was null or undefined when calling getEmailFlowFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flow_folders/{email_flow_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_folder_uuid"}}`, encodeURIComponent(String(email_flow_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flow folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowFolders(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailFlowFolders.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flow_folders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flow screenshots
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowScreenshots(storefront_oid: number, email_flow_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailFlowScreenshots.');
            }
            // verify required parameter 'email_flow_uuid' is not null or undefined
            if (email_flow_uuid === null || email_flow_uuid === undefined) {
                throw new RequiredError('email_flow_uuid','Required parameter email_flow_uuid was null or undefined when calling getEmailFlowScreenshots.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/screenshots`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(email_flow_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email flows
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlows(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailFlows.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email globalsettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailGlobalSettings(options: any = {}): FetchArgs {
            const localVarPath = `/storefront/email/global_settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailList(storefront_oid: number, email_list_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailList.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling getEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email list customer editor url
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomerEditorUrl(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailListCustomerEditorUrl.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling getEmailListCustomerEditorUrl.');
            }
            // verify required parameter 'email_customer_uuid' is not null or undefined
            if (email_customer_uuid === null || email_customer_uuid === undefined) {
                throw new RequiredError('email_customer_uuid','Required parameter email_customer_uuid was null or undefined when calling getEmailListCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(email_customer_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email list customers
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomers(storefront_oid: number, email_list_uuid: string, pageNumber?: number, pageSize?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailListCustomers.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling getEmailListCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailListSegmentFolder.');
            }
            // verify required parameter 'email_list_segment_folder_uuid' is not null or undefined
            if (email_list_segment_folder_uuid === null || email_list_segment_folder_uuid === undefined) {
                throw new RequiredError('email_list_segment_folder_uuid','Required parameter email_list_segment_folder_uuid was null or undefined when calling getEmailListSegmentFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/list_segment_folders/{email_list_segment_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_segment_folder_uuid"}}`, encodeURIComponent(String(email_list_segment_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email campaign folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListSegmentFolders(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailListSegmentFolders.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/list_segment_folders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email lists
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailLists.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email performance
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPerformance(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailPerformance.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/performance`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email plan
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPlan(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailPlan.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/plan`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailPostcard.');
            }
            // verify required parameter 'commseq_postcard_uuid' is not null or undefined
            if (commseq_postcard_uuid === null || commseq_postcard_uuid === undefined) {
                throw new RequiredError('commseq_postcard_uuid','Required parameter commseq_postcard_uuid was null or undefined when calling getEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseq_postcard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email postcards
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcards(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailPostcards.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email postcards multiple
         * @param {number} storefront_oid 
         * @param {EmailCommseqPostcardsRequest} email_commseq_postcards_request Request of postcard uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcardsMultiple(storefront_oid: number, email_commseq_postcards_request: EmailCommseqPostcardsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailPostcardsMultiple.');
            }
            // verify required parameter 'email_commseq_postcards_request' is not null or undefined
            if (email_commseq_postcards_request === null || email_commseq_postcards_request === undefined) {
                throw new RequiredError('email_commseq_postcards_request','Required parameter email_commseq_postcards_request was null or undefined when calling getEmailPostcardsMultiple.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/multiple`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcardsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_postcards_request || {}) : (email_commseq_postcards_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegment(storefront_oid: number, email_segment_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailSegment.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling getEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segment customers editor URL
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomerEditorUrl(storefront_oid: number, email_segment_uuid: string, email_customer_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
            }
            // verify required parameter 'email_customer_uuid' is not null or undefined
            if (email_customer_uuid === null || email_customer_uuid === undefined) {
                throw new RequiredError('email_customer_uuid','Required parameter email_customer_uuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers/{email_customer_uuid}/editor_url`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(email_customer_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segment customers
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, pageNumber?: number, pageSize?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailSegmentCustomers.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling getEmailSegmentCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email segments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegments(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailSegments.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email sending domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomain(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling getEmailSendingDomain.');
            }
            const localVarPath = `/storefront/email/sending_domain/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email sending domain status
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomainStatus(domain: string, options: any = {}): FetchArgs {
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling getEmailSendingDomainStatus.');
            }
            const localVarPath = `/storefront/email/sending_domains/{domain}/status`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email sending domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomains(options: any = {}): FetchArgs {
            const localVarPath = `/storefront/email/sending_domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email settings
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSettings(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailSettings.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/settings`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email template
         * @param {number} storefront_oid 
         * @param {number} email_template_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate(storefront_oid: number, email_template_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailTemplate.');
            }
            // verify required parameter 'email_template_oid' is not null or undefined
            if (email_template_oid === null || email_template_oid === undefined) {
                throw new RequiredError('email_template_oid','Required parameter email_template_oid was null or undefined when calling getEmailTemplate.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/templates/{email_template_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_template_oid"}}`, encodeURIComponent(String(email_template_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get email templates
         * @param {number} storefront_oid 
         * @param {string} [trigger_type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplates(storefront_oid: number, trigger_type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailTemplates.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/templates`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (trigger_type !== undefined) {
                localVarQueryParameter['trigger_type'] = trigger_type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of third party email providers
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailThirdPartyProviders(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getEmailThirdPartyProviders.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/third_party_providers`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get experiments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getExperiments.');
            }
            const localVarPath = `/storefront/{storefront_oid}/experiments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get screen recording heatmap 
         * @summary Get screen recording heatmap
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapRequest} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getHeatmap.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling getHeatmap.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/heatmap`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingHeatmapRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get screen recording heatmap index 
         * @summary Get screen recording heatmap index
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapIndexRequest} query Query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmapIndex(storefront_oid: number, query: ScreenRecordingHeatmapIndexRequest, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getHeatmapIndex.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling getHeatmapIndex.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/heatmap/index`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingHeatmapIndexRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of property names for a given property type 
         * @summary Get histogram property names
         * @param {number} storefront_oid 
         * @param {string} [property_type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyNames(storefront_oid: number, property_type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getHistogramPropertyNames.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/histogram/property_names`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (property_type !== undefined) {
                localVarQueryParameter['property_type'] = property_type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of property values for a given property name and type 
         * @summary Get histogram property values
         * @param {number} storefront_oid 
         * @param {string} [property_name] 
         * @param {string} [property_type] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyValues(storefront_oid: number, property_name?: string, property_type?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getHistogramPropertyValues.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/histogram/property_values`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (property_name !== undefined) {
                localVarQueryParameter['property_name'] = property_name;
            }

            if (property_type !== undefined) {
                localVarQueryParameter['property_type'] = property_type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get library values used to populate drop down boxes for filtering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryFilterValues(options: any = {}): FetchArgs {
            const localVarPath = `/storefront/code_library/filter_values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItem(library_item_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling getLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all published versions for a library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItemPublishedVersions(library_item_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling getLibraryItemPublishedVersions.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/published_versions`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get screen recording 
         * @summary Get screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecording(storefront_oid: number, screen_recording_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecording.');
            }
            // verify required parameter 'screen_recording_uuid' is not null or undefined
            if (screen_recording_uuid === null || screen_recording_uuid === undefined) {
                throw new RequiredError('screen_recording_uuid','Required parameter screen_recording_uuid was null or undefined when calling getScreenRecording.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/{screen_recording_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_uuid"}}`, encodeURIComponent(String(screen_recording_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get screen recording page view data 
         * @summary Get screen recording page view data
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {string} screen_recording_page_view_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingPageViewData(storefront_oid: number, screen_recording_uuid: string, screen_recording_page_view_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecordingPageViewData.');
            }
            // verify required parameter 'screen_recording_uuid' is not null or undefined
            if (screen_recording_uuid === null || screen_recording_uuid === undefined) {
                throw new RequiredError('screen_recording_uuid','Required parameter screen_recording_uuid was null or undefined when calling getScreenRecordingPageViewData.');
            }
            // verify required parameter 'screen_recording_page_view_uuid' is not null or undefined
            if (screen_recording_page_view_uuid === null || screen_recording_page_view_uuid === undefined) {
                throw new RequiredError('screen_recording_page_view_uuid','Required parameter screen_recording_page_view_uuid was null or undefined when calling getScreenRecordingPageViewData.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/{screen_recording_uuid}/page_view_data/{screen_recording_page_view_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_uuid"}}`, encodeURIComponent(String(screen_recording_uuid)))
                .replace(`{${"screen_recording_page_view_uuid"}}`, encodeURIComponent(String(screen_recording_page_view_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecordingSegment.');
            }
            // verify required parameter 'screen_recording_segment_oid' is not null or undefined
            if (screen_recording_segment_oid === null || screen_recording_segment_oid === undefined) {
                throw new RequiredError('screen_recording_segment_oid','Required parameter screen_recording_segment_oid was null or undefined when calling getScreenRecordingSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/segments/{screen_recording_segment_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_segment_oid"}}`, encodeURIComponent(String(screen_recording_segment_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get screen recording segments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSegments(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecordingSegments.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/segments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get screen recording settings
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSettings(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecordingSettings.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/settings`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tags used by screen recording 
         * @summary Get tags used by screen recording
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingTags(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecordingTags.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/tags`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query screen recordings 
         * @summary Query screen recordings
         * @param {number} storefront_oid 
         * @param {ScreenRecordingQueryRequest} query Query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingsByQuery(storefront_oid: number, query: ScreenRecordingQueryRequest, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecordingsByQuery.');
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new RequiredError('query','Required parameter query was null or undefined when calling getScreenRecordingsByQuery.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/query`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingQueryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(query || {}) : (query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get screen recordings by segment 
         * @summary Get screen recordings by segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingsBySegment(storefront_oid: number, screen_recording_segment_oid: number, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getScreenRecordingsBySegment.');
            }
            // verify required parameter 'screen_recording_segment_oid' is not null or undefined
            if (screen_recording_segment_oid === null || screen_recording_segment_oid === undefined) {
                throw new RequiredError('screen_recording_segment_oid','Required parameter screen_recording_segment_oid was null or undefined when calling getScreenRecordingsBySegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/segments/{screen_recording_segment_oid}/query`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_segment_oid"}}`, encodeURIComponent(String(screen_recording_segment_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreFrontPricingTiers(_expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/storefront/pricing_tiers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["item_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get thumbnail parameters
         * @param {ThumbnailParametersRequest} thumbnail_parameters Thumbnail Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailParameters(thumbnail_parameters: ThumbnailParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'thumbnail_parameters' is not null or undefined
            if (thumbnail_parameters === null || thumbnail_parameters === undefined) {
                throw new RequiredError('thumbnail_parameters','Required parameter thumbnail_parameters was null or undefined when calling getThumbnailParameters.');
            }
            const localVarPath = `/storefront/thumbnailParameters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ThumbnailParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(thumbnail_parameters || {}) : (thumbnail_parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a transactional email 
         * @summary Gets a transaction email object
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmail(storefront_oid: number, email_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getTransactionEmail.');
            }
            // verify required parameter 'email_id' is not null or undefined
            if (email_id === null || email_id === undefined) {
                throw new RequiredError('email_id','Required parameter email_id was null or undefined when calling getTransactionEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list/{email_id}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(email_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain a list of all transactional emails and return back just their names 
         * @summary Gets a list of transaction email names
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailList(storefront_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getTransactionEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transactional email screenshots
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailScreenshots(storefront_oid: number, email_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling getTransactionEmailScreenshots.');
            }
            // verify required parameter 'email_id' is not null or undefined
            if (email_id === null || email_id === undefined) {
                throw new RequiredError('email_id','Required parameter email_id was null or undefined when calling getTransactionEmailScreenshots.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list/{email_id}/screenshots`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(email_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwilioAccount(esp_twilio_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'esp_twilio_uuid' is not null or undefined
            if (esp_twilio_uuid === null || esp_twilio_uuid === undefined) {
                throw new RequiredError('esp_twilio_uuid','Required parameter esp_twilio_uuid was null or undefined when calling getTwilioAccount.');
            }
            const localVarPath = `/storefront/twilio/accounts/{esp_twilio_uuid}`
                .replace(`{${"esp_twilio_uuid"}}`, encodeURIComponent(String(esp_twilio_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Twilio accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwilioAccounts(options: any = {}): FetchArgs {
            const localVarPath = `/storefront/twilio/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Globally unsubscribe a customer
         * @param {number} storefront_oid 
         * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnsubscribe(storefront_oid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling globalUnsubscribe.');
            }
            // verify required parameter 'unsubscribe' is not null or undefined
            if (unsubscribe === null || unsubscribe === undefined) {
                throw new RequiredError('unsubscribe','Required parameter unsubscribe was null or undefined when calling globalUnsubscribe.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/globalUnsubscribe`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailGlobalUnsubscribeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(unsubscribe || {}) : (unsubscribe || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a third party provider list
         * @param {number} storefront_oid 
         * @param {EmailThirdPartyListImportRequest} import_request lists to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmailThirdPartyProviderList(storefront_oid: number, import_request: EmailThirdPartyListImportRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling importEmailThirdPartyProviderList.');
            }
            // verify required parameter 'import_request' is not null or undefined
            if (import_request === null || import_request === undefined) {
                throw new RequiredError('import_request','Required parameter import_request was null or undefined when calling importEmailThirdPartyProviderList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/third_party_providers/import`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailThirdPartyListImportRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(import_request || {}) : (import_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email campaign
         * @param {number} storefront_oid 
         * @param {EmailCampaign} email_campaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaign(storefront_oid: number, email_campaign: EmailCampaign, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailCampaign.');
            }
            // verify required parameter 'email_campaign' is not null or undefined
            if (email_campaign === null || email_campaign === undefined) {
                throw new RequiredError('email_campaign','Required parameter email_campaign was null or undefined when calling insertEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCampaign" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_campaign || {}) : (email_campaign || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email campaign folder
         * @param {number} storefront_oid 
         * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaignFolder(storefront_oid: number, email_campaign_folder: EmailCampaignFolder, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailCampaignFolder.');
            }
            // verify required parameter 'email_campaign_folder' is not null or undefined
            if (email_campaign_folder === null || email_campaign_folder === undefined) {
                throw new RequiredError('email_campaign_folder','Required parameter email_campaign_folder was null or undefined when calling insertEmailCampaignFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaign_folders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCampaignFolder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_campaign_folder || {}) : (email_campaign_folder || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email commseq
         * @param {number} storefront_oid 
         * @param {EmailCommseq} email_commseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCommseq(storefront_oid: number, email_commseq: EmailCommseq, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailCommseq.');
            }
            // verify required parameter 'email_commseq' is not null or undefined
            if (email_commseq === null || email_commseq === undefined) {
                throw new RequiredError('email_commseq','Required parameter email_commseq was null or undefined when calling insertEmailCommseq.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq || {}) : (email_commseq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email email
         * @param {number} storefront_oid 
         * @param {EmailCommseqEmail} email_commseq_email Email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailEmail(storefront_oid: number, email_commseq_email: EmailCommseqEmail, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailEmail.');
            }
            // verify required parameter 'email_commseq_email' is not null or undefined
            if (email_commseq_email === null || email_commseq_email === undefined) {
                throw new RequiredError('email_commseq_email','Required parameter email_commseq_email was null or undefined when calling insertEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_email || {}) : (email_commseq_email || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email flow
         * @param {number} storefront_oid 
         * @param {EmailFlow} email_flow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlow(storefront_oid: number, email_flow: EmailFlow, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailFlow.');
            }
            // verify required parameter 'email_flow' is not null or undefined
            if (email_flow === null || email_flow === undefined) {
                throw new RequiredError('email_flow','Required parameter email_flow was null or undefined when calling insertEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlow" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_flow || {}) : (email_flow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email flow folder
         * @param {number} storefront_oid 
         * @param {EmailFlowFolder} email_flow_folder Email flow folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlowFolder(storefront_oid: number, email_flow_folder: EmailFlowFolder, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailFlowFolder.');
            }
            // verify required parameter 'email_flow_folder' is not null or undefined
            if (email_flow_folder === null || email_flow_folder === undefined) {
                throw new RequiredError('email_flow_folder','Required parameter email_flow_folder was null or undefined when calling insertEmailFlowFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flow_folders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlowFolder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_flow_folder || {}) : (email_flow_folder || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email list
         * @param {number} storefront_oid 
         * @param {EmailList} email_list Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailList(storefront_oid: number, email_list: EmailList, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailList.');
            }
            // verify required parameter 'email_list' is not null or undefined
            if (email_list === null || email_list === undefined) {
                throw new RequiredError('email_list','Required parameter email_list was null or undefined when calling insertEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailList" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_list || {}) : (email_list || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email campaign folder
         * @param {number} storefront_oid 
         * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder: EmailListSegmentFolder, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailListSegmentFolder.');
            }
            // verify required parameter 'email_list_segment_folder' is not null or undefined
            if (email_list_segment_folder === null || email_list_segment_folder === undefined) {
                throw new RequiredError('email_list_segment_folder','Required parameter email_list_segment_folder was null or undefined when calling insertEmailListSegmentFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/list_segment_folders`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailListSegmentFolder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_list_segment_folder || {}) : (email_list_segment_folder || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email postcard
         * @param {number} storefront_oid 
         * @param {EmailCommseqPostcard} email_commseq_postcard Email postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailPostcard(storefront_oid: number, email_commseq_postcard: EmailCommseqPostcard, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailPostcard.');
            }
            // verify required parameter 'email_commseq_postcard' is not null or undefined
            if (email_commseq_postcard === null || email_commseq_postcard === undefined) {
                throw new RequiredError('email_commseq_postcard','Required parameter email_commseq_postcard was null or undefined when calling insertEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_postcard || {}) : (email_commseq_postcard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert email segment
         * @param {number} storefront_oid 
         * @param {EmailSegment} email_segment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailSegment(storefront_oid: number, email_segment: EmailSegment, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertEmailSegment.');
            }
            // verify required parameter 'email_segment' is not null or undefined
            if (email_segment === null || email_segment === undefined) {
                throw new RequiredError('email_segment','Required parameter email_segment was null or undefined when calling insertEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailSegment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_segment || {}) : (email_segment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Insert screen recording segment
         * @param {number} storefront_oid 
         * @param {ScreenRecordingSegment} segment Segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertScreenRecordingSegment(storefront_oid: number, segment: ScreenRecordingSegment, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling insertScreenRecordingSegment.');
            }
            // verify required parameter 'segment' is not null or undefined
            if (segment === null || segment === undefined) {
                throw new RequiredError('segment','Required parameter segment was null or undefined when calling insertScreenRecordingSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/segments`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingSegment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(segment || {}) : (segment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare download of email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling prepareDownloadEmailSegment.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling prepareDownloadEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/downloadPrepare`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publish library item.
         * @param {number} library_item_oid 
         * @param {PublishLibraryItemRequest} publish_library_request Publish library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishLibraryItem(library_item_oid: number, publish_library_request: PublishLibraryItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling publishLibraryItem.');
            }
            // verify required parameter 'publish_library_request' is not null or undefined
            if (publish_library_request === null || publish_library_request === undefined) {
                throw new RequiredError('publish_library_request','Required parameter publish_library_request was null or undefined when calling publishLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/publish`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublishLibraryItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(publish_library_request || {}) : (publish_library_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchase public library item, which creates a copy of the item in your personal code library
         * @param {number} library_item_oid 
         * @param {number} [storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLibraryItem(library_item_oid: number, storefront_oid?: number, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling purchaseLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}/purchase`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (storefront_oid !== undefined) {
                localVarQueryParameter['storefront_oid'] = storefront_oid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Release email communication sequence customers waiting at the specified step
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling releaseEmailCommseqStepWaiting.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling releaseEmailCommseqStepWaiting.');
            }
            // verify required parameter 'commseq_step_uuid' is not null or undefined
            if (commseq_step_uuid === null || commseq_step_uuid === undefined) {
                throw new RequiredError('commseq_step_uuid','Required parameter commseq_step_uuid was null or undefined when calling releaseEmailCommseqStepWaiting.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/waiting/{commseq_step_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)))
                .replace(`{${"commseq_step_uuid"}}`, encodeURIComponent(String(commseq_step_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request a review of an email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_review_request Email commseq email review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        review(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_review_request: EmailCommseqEmailSendTestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling review.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling review.');
            }
            // verify required parameter 'email_commseq_email_review_request' is not null or undefined
            if (email_commseq_email_review_request === null || email_commseq_email_review_request === undefined) {
                throw new RequiredError('email_commseq_email_review_request','Required parameter email_commseq_email_review_request was null or undefined when calling review.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/review`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmailSendTestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_email_review_request || {}) : (email_commseq_email_review_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Searches for all matching values
         * @param {string} [category] 
         * @param {string} [matches] 
         * @param {string} [storefront_oid] 
         * @param {number} [max_hits] 
         * @param {string} [subcategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(category?: string, matches?: string, storefront_oid?: string, max_hits?: number, subcategory?: string, options: any = {}): FetchArgs {
            const localVarPath = `/storefront/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (matches !== undefined) {
                localVarQueryParameter['matches'] = matches;
            }

            if (storefront_oid !== undefined) {
                localVarQueryParameter['storefront_oid'] = storefront_oid;
            }

            if (max_hits !== undefined) {
                localVarQueryParameter['max_hits'] = max_hits;
            }

            if (subcategory !== undefined) {
                localVarQueryParameter['subcategory'] = subcategory;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Searches for all matching values (using POST)
         * @param {LookupRequest} lookup_request LookupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(lookup_request: LookupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'lookup_request' is not null or undefined
            if (lookup_request === null || lookup_request === undefined) {
                throw new RequiredError('lookup_request','Required parameter lookup_request was null or undefined when calling search2.');
            }
            const localVarPath = `/storefront/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(lookup_request || {}) : (lookup_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search email list customers
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailListCustomers(storefront_oid: number, email_list_uuid: string, startsWith?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling searchEmailListCustomers.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling searchEmailListCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/search`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (startsWith !== undefined) {
                localVarQueryParameter['startsWith'] = startsWith;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search email segment customers
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, startsWith?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling searchEmailSegmentCustomers.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling searchEmailSegmentCustomers.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/search`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (startsWith !== undefined) {
                localVarQueryParameter['startsWith'] = startsWith;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLibraryItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'item_query' is not null or undefined
            if (item_query === null || item_query === undefined) {
                throw new RequiredError('item_query','Required parameter item_query was null or undefined when calling searchLibraryItems.');
            }
            const localVarPath = `/storefront/code_library/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item_query || {}) : (item_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPublishedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'item_query' is not null or undefined
            if (item_query === null || item_query === undefined) {
                throw new RequiredError('item_query','Required parameter item_query was null or undefined when calling searchPublishedItems.');
            }
            const localVarPath = `/storefront/code_library/search_published`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item_query || {}) : (item_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items needing review or rejected
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReviewItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'item_query' is not null or undefined
            if (item_query === null || item_query === undefined) {
                throw new RequiredError('item_query','Required parameter item_query was null or undefined when calling searchReviewItems.');
            }
            const localVarPath = `/storefront/code_library/search_review`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item_query || {}) : (item_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSharedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options: any = {}): FetchArgs {
            // verify required parameter 'item_query' is not null or undefined
            if (item_query === null || item_query === undefined) {
                throw new RequiredError('item_query','Required parameter item_query was null or undefined when calling searchSharedItems.');
            }
            const localVarPath = `/storefront/code_library/search_shared`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["affiliate_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItemQuery" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(item_query || {}) : (item_query || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send email test
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_test_request Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailTest(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_test_request: EmailCommseqEmailSendTestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling sendEmailTest.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling sendEmailTest.');
            }
            // verify required parameter 'email_commseq_email_test_request' is not null or undefined
            if (email_commseq_email_test_request === null || email_commseq_email_test_request === undefined) {
                throw new RequiredError('email_commseq_email_test_request','Required parameter email_commseq_email_test_request was null or undefined when calling sendEmailTest.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}/test`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmailSendTestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_email_test_request || {}) : (email_commseq_email_test_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send postcard test
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {EmailCommseqPostcardSendTestRequest} email_commseq_postcard_test_request Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPostcardTest(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard_test_request: EmailCommseqPostcardSendTestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling sendPostcardTest.');
            }
            // verify required parameter 'commseq_postcard_uuid' is not null or undefined
            if (commseq_postcard_uuid === null || commseq_postcard_uuid === undefined) {
                throw new RequiredError('commseq_postcard_uuid','Required parameter commseq_postcard_uuid was null or undefined when calling sendPostcardTest.');
            }
            // verify required parameter 'email_commseq_postcard_test_request' is not null or undefined
            if (email_commseq_postcard_test_request === null || email_commseq_postcard_test_request === undefined) {
                throw new RequiredError('email_commseq_postcard_test_request','Required parameter email_commseq_postcard_test_request was null or undefined when calling sendPostcardTest.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}/test`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseq_postcard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcardSendTestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_postcard_test_request || {}) : (email_commseq_postcard_test_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send webhook test
         * @param {number} storefront_oid 
         * @param {EmailCommseqWebhookSendTestRequest} email_commseq_webhook_test_request Email commseq webhook test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWebhookTest(storefront_oid: number, email_commseq_webhook_test_request: EmailCommseqWebhookSendTestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling sendWebhookTest.');
            }
            // verify required parameter 'email_commseq_webhook_test_request' is not null or undefined
            if (email_commseq_webhook_test_request === null || email_commseq_webhook_test_request === undefined) {
                throw new RequiredError('email_commseq_webhook_test_request','Required parameter email_commseq_webhook_test_request was null or undefined when calling sendWebhookTest.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/webhooks/test`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqWebhookSendTestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_webhook_test_request || {}) : (email_commseq_webhook_test_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling startEmailCampaign.');
            }
            // verify required parameter 'email_campaign_uuid' is not null or undefined
            if (email_campaign_uuid === null || email_campaign_uuid === undefined) {
                throw new RequiredError('email_campaign_uuid','Required parameter email_campaign_uuid was null or undefined when calling startEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/start`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(email_campaign_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe customers to email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {Array<EmailCustomer>} customers Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEmailList(storefront_oid: number, email_list_uuid: string, customers: Array<EmailCustomer>, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling subscribeToEmailList.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling subscribeToEmailList.');
            }
            // verify required parameter 'customers' is not null or undefined
            if (customers === null || customers === undefined) {
                throw new RequiredError('customers','Required parameter customers was null or undefined when calling subscribeToEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}/subscribe`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;EmailCustomer&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(customers || {}) : (customers || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove favorite flag on screen recording 
         * @summary Remove favorite flag on screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling unfavoriteScreenRecording.');
            }
            // verify required parameter 'screen_recording_uuid' is not null or undefined
            if (screen_recording_uuid === null || screen_recording_uuid === undefined) {
                throw new RequiredError('screen_recording_uuid','Required parameter screen_recording_uuid was null or undefined when calling unfavoriteScreenRecording.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/{screen_recording_uuid}/favorite`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_uuid"}}`, encodeURIComponent(String(screen_recording_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {EmailCampaign} email_campaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaign(storefront_oid: number, email_campaign_uuid: string, email_campaign: EmailCampaign, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailCampaign.');
            }
            // verify required parameter 'email_campaign_uuid' is not null or undefined
            if (email_campaign_uuid === null || email_campaign_uuid === undefined) {
                throw new RequiredError('email_campaign_uuid','Required parameter email_campaign_uuid was null or undefined when calling updateEmailCampaign.');
            }
            // verify required parameter 'email_campaign' is not null or undefined
            if (email_campaign === null || email_campaign === undefined) {
                throw new RequiredError('email_campaign','Required parameter email_campaign was null or undefined when calling updateEmailCampaign.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_uuid"}}`, encodeURIComponent(String(email_campaign_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCampaign" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_campaign || {}) : (email_campaign || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, email_campaign_folder: EmailCampaignFolder, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailCampaignFolder.');
            }
            // verify required parameter 'email_campaign_folder_uuid' is not null or undefined
            if (email_campaign_folder_uuid === null || email_campaign_folder_uuid === undefined) {
                throw new RequiredError('email_campaign_folder_uuid','Required parameter email_campaign_folder_uuid was null or undefined when calling updateEmailCampaignFolder.');
            }
            // verify required parameter 'email_campaign_folder' is not null or undefined
            if (email_campaign_folder === null || email_campaign_folder === undefined) {
                throw new RequiredError('email_campaign_folder','Required parameter email_campaign_folder was null or undefined when calling updateEmailCampaignFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/campaign_folders/{email_campaign_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_campaign_folder_uuid"}}`, encodeURIComponent(String(email_campaign_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCampaignFolder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_campaign_folder || {}) : (email_campaign_folder || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email commseq
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailCommseq} email_commseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCommseq(storefront_oid: number, commseq_uuid: string, email_commseq: EmailCommseq, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailCommseq.');
            }
            // verify required parameter 'commseq_uuid' is not null or undefined
            if (commseq_uuid === null || commseq_uuid === undefined) {
                throw new RequiredError('commseq_uuid','Required parameter commseq_uuid was null or undefined when calling updateEmailCommseq.');
            }
            // verify required parameter 'email_commseq' is not null or undefined
            if (email_commseq === null || email_commseq === undefined) {
                throw new RequiredError('email_commseq','Required parameter email_commseq was null or undefined when calling updateEmailCommseq.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_uuid"}}`, encodeURIComponent(String(commseq_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq || {}) : (email_commseq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email customer
         * @param {number} storefront_oid 
         * @param {string} email_customer_uuid 
         * @param {EmailCustomer} email_customer Email customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCustomer(storefront_oid: number, email_customer_uuid: string, email_customer: EmailCustomer, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailCustomer.');
            }
            // verify required parameter 'email_customer_uuid' is not null or undefined
            if (email_customer_uuid === null || email_customer_uuid === undefined) {
                throw new RequiredError('email_customer_uuid','Required parameter email_customer_uuid was null or undefined when calling updateEmailCustomer.');
            }
            // verify required parameter 'email_customer' is not null or undefined
            if (email_customer === null || email_customer === undefined) {
                throw new RequiredError('email_customer','Required parameter email_customer was null or undefined when calling updateEmailCustomer.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/customers/{email_customer_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_customer_uuid"}}`, encodeURIComponent(String(email_customer_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCustomer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_customer || {}) : (email_customer || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmail} email_commseq_email Email commseq email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailEmail(storefront_oid: number, commseq_email_uuid: string, email_commseq_email: EmailCommseqEmail, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailEmail.');
            }
            // verify required parameter 'commseq_email_uuid' is not null or undefined
            if (commseq_email_uuid === null || commseq_email_uuid === undefined) {
                throw new RequiredError('commseq_email_uuid','Required parameter commseq_email_uuid was null or undefined when calling updateEmailEmail.');
            }
            // verify required parameter 'email_commseq_email' is not null or undefined
            if (email_commseq_email === null || email_commseq_email === undefined) {
                throw new RequiredError('email_commseq_email','Required parameter email_commseq_email was null or undefined when calling updateEmailEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_email_uuid"}}`, encodeURIComponent(String(commseq_email_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_email || {}) : (email_commseq_email || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {EmailFlow} email_flow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlow(storefront_oid: number, email_flow_uuid: string, email_flow: EmailFlow, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailFlow.');
            }
            // verify required parameter 'email_flow_uuid' is not null or undefined
            if (email_flow_uuid === null || email_flow_uuid === undefined) {
                throw new RequiredError('email_flow_uuid','Required parameter email_flow_uuid was null or undefined when calling updateEmailFlow.');
            }
            // verify required parameter 'email_flow' is not null or undefined
            if (email_flow === null || email_flow === undefined) {
                throw new RequiredError('email_flow','Required parameter email_flow was null or undefined when calling updateEmailFlow.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flows/{email_flow_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_uuid"}}`, encodeURIComponent(String(email_flow_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlow" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_flow || {}) : (email_flow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email flow folder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {EmailFlowFolder} email_flow_folder Email flow folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, email_flow_folder: EmailFlowFolder, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailFlowFolder.');
            }
            // verify required parameter 'email_flow_folder_uuid' is not null or undefined
            if (email_flow_folder_uuid === null || email_flow_folder_uuid === undefined) {
                throw new RequiredError('email_flow_folder_uuid','Required parameter email_flow_folder_uuid was null or undefined when calling updateEmailFlowFolder.');
            }
            // verify required parameter 'email_flow_folder' is not null or undefined
            if (email_flow_folder === null || email_flow_folder === undefined) {
                throw new RequiredError('email_flow_folder','Required parameter email_flow_folder was null or undefined when calling updateEmailFlowFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/flow_folders/{email_flow_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_flow_folder_uuid"}}`, encodeURIComponent(String(email_flow_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailFlowFolder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_flow_folder || {}) : (email_flow_folder || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email global settings
         * @param {EmailGlobalSettings} global_settings global settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailGlobalSettings(global_settings: EmailGlobalSettings, options: any = {}): FetchArgs {
            // verify required parameter 'global_settings' is not null or undefined
            if (global_settings === null || global_settings === undefined) {
                throw new RequiredError('global_settings','Required parameter global_settings was null or undefined when calling updateEmailGlobalSettings.');
            }
            const localVarPath = `/storefront/email/global_settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailGlobalSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(global_settings || {}) : (global_settings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {EmailList} email_list Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailList(storefront_oid: number, email_list_uuid: string, email_list: EmailList, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailList.');
            }
            // verify required parameter 'email_list_uuid' is not null or undefined
            if (email_list_uuid === null || email_list_uuid === undefined) {
                throw new RequiredError('email_list_uuid','Required parameter email_list_uuid was null or undefined when calling updateEmailList.');
            }
            // verify required parameter 'email_list' is not null or undefined
            if (email_list === null || email_list === undefined) {
                throw new RequiredError('email_list','Required parameter email_list was null or undefined when calling updateEmailList.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/lists/{email_list_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_uuid"}}`, encodeURIComponent(String(email_list_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailList" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_list || {}) : (email_list || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, email_list_segment_folder: EmailListSegmentFolder, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailListSegmentFolder.');
            }
            // verify required parameter 'email_list_segment_folder_uuid' is not null or undefined
            if (email_list_segment_folder_uuid === null || email_list_segment_folder_uuid === undefined) {
                throw new RequiredError('email_list_segment_folder_uuid','Required parameter email_list_segment_folder_uuid was null or undefined when calling updateEmailListSegmentFolder.');
            }
            // verify required parameter 'email_list_segment_folder' is not null or undefined
            if (email_list_segment_folder === null || email_list_segment_folder === undefined) {
                throw new RequiredError('email_list_segment_folder','Required parameter email_list_segment_folder was null or undefined when calling updateEmailListSegmentFolder.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/list_segment_folders/{email_list_segment_folder_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_list_segment_folder_uuid"}}`, encodeURIComponent(String(email_list_segment_folder_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailListSegmentFolder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_list_segment_folder || {}) : (email_list_segment_folder || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email plan
         * @param {number} storefront_oid 
         * @param {EmailPlan} settings plan request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPlan(storefront_oid: number, settings: EmailPlan, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailPlan.');
            }
            // verify required parameter 'settings' is not null or undefined
            if (settings === null || settings === undefined) {
                throw new RequiredError('settings','Required parameter settings was null or undefined when calling updateEmailPlan.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/plan`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailPlan" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(settings || {}) : (settings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {EmailCommseqPostcard} email_commseq_postcard Email commseq postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard: EmailCommseqPostcard, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailPostcard.');
            }
            // verify required parameter 'commseq_postcard_uuid' is not null or undefined
            if (commseq_postcard_uuid === null || commseq_postcard_uuid === undefined) {
                throw new RequiredError('commseq_postcard_uuid','Required parameter commseq_postcard_uuid was null or undefined when calling updateEmailPostcard.');
            }
            // verify required parameter 'email_commseq_postcard' is not null or undefined
            if (email_commseq_postcard === null || email_commseq_postcard === undefined) {
                throw new RequiredError('email_commseq_postcard','Required parameter email_commseq_postcard was null or undefined when calling updateEmailPostcard.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/postcards/{commseq_postcard_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"commseq_postcard_uuid"}}`, encodeURIComponent(String(commseq_postcard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailCommseqPostcard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_commseq_postcard || {}) : (email_commseq_postcard || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {EmailSegment} email_segment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment: EmailSegment, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailSegment.');
            }
            // verify required parameter 'email_segment_uuid' is not null or undefined
            if (email_segment_uuid === null || email_segment_uuid === undefined) {
                throw new RequiredError('email_segment_uuid','Required parameter email_segment_uuid was null or undefined when calling updateEmailSegment.');
            }
            // verify required parameter 'email_segment' is not null or undefined
            if (email_segment === null || email_segment === undefined) {
                throw new RequiredError('email_segment','Required parameter email_segment was null or undefined when calling updateEmailSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/segments/{email_segment_uuid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_segment_uuid"}}`, encodeURIComponent(String(email_segment_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailSegment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(email_segment || {}) : (email_segment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update email settings
         * @param {number} storefront_oid 
         * @param {EmailSettings} settings settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSettings(storefront_oid: number, settings: EmailSettings, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateEmailSettings.');
            }
            // verify required parameter 'settings' is not null or undefined
            if (settings === null || settings === undefined) {
                throw new RequiredError('settings','Required parameter settings was null or undefined when calling updateEmailSettings.');
            }
            const localVarPath = `/storefront/{storefront_oid}/email/settings`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(settings || {}) : (settings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update experiment
         * @param {number} storefront_oid 
         * @param {number} storefront_experiment_oid 
         * @param {Experiment} experiment Experiment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment(storefront_oid: number, storefront_experiment_oid: number, experiment: Experiment, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateExperiment.');
            }
            // verify required parameter 'storefront_experiment_oid' is not null or undefined
            if (storefront_experiment_oid === null || storefront_experiment_oid === undefined) {
                throw new RequiredError('storefront_experiment_oid','Required parameter storefront_experiment_oid was null or undefined when calling updateExperiment.');
            }
            // verify required parameter 'experiment' is not null or undefined
            if (experiment === null || experiment === undefined) {
                throw new RequiredError('experiment','Required parameter experiment was null or undefined when calling updateExperiment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"storefront_experiment_oid"}}`, encodeURIComponent(String(storefront_experiment_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Experiment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(experiment || {}) : (experiment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update library item. Note that only certain fields may be updated via this method.
         * @param {number} library_item_oid 
         * @param {LibraryItem} library_item Library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryItem(library_item_oid: number, library_item: LibraryItem, options: any = {}): FetchArgs {
            // verify required parameter 'library_item_oid' is not null or undefined
            if (library_item_oid === null || library_item_oid === undefined) {
                throw new RequiredError('library_item_oid','Required parameter library_item_oid was null or undefined when calling updateLibraryItem.');
            }
            // verify required parameter 'library_item' is not null or undefined
            if (library_item === null || library_item === undefined) {
                throw new RequiredError('library_item','Required parameter library_item was null or undefined when calling updateLibraryItem.');
            }
            const localVarPath = `/storefront/code_library/{library_item_oid}`
                .replace(`{${"library_item_oid"}}`, encodeURIComponent(String(library_item_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LibraryItem" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(library_item || {}) : (library_item || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update merchant notes on a screen recording 
         * @summary Update merchant notes on a screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {ScreenRecordingMerchantNotesRequest} merchant_notes_request Merchant Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingMerchantNotes(storefront_oid: number, screen_recording_uuid: string, merchant_notes_request: ScreenRecordingMerchantNotesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateScreenRecordingMerchantNotes.');
            }
            // verify required parameter 'screen_recording_uuid' is not null or undefined
            if (screen_recording_uuid === null || screen_recording_uuid === undefined) {
                throw new RequiredError('screen_recording_uuid','Required parameter screen_recording_uuid was null or undefined when calling updateScreenRecordingMerchantNotes.');
            }
            // verify required parameter 'merchant_notes_request' is not null or undefined
            if (merchant_notes_request === null || merchant_notes_request === undefined) {
                throw new RequiredError('merchant_notes_request','Required parameter merchant_notes_request was null or undefined when calling updateScreenRecordingMerchantNotes.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/{screen_recording_uuid}/merchant_notes`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_uuid"}}`, encodeURIComponent(String(screen_recording_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingMerchantNotesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(merchant_notes_request || {}) : (merchant_notes_request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {ScreenRecordingSegment} segment Segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, segment: ScreenRecordingSegment, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateScreenRecordingSegment.');
            }
            // verify required parameter 'screen_recording_segment_oid' is not null or undefined
            if (screen_recording_segment_oid === null || screen_recording_segment_oid === undefined) {
                throw new RequiredError('screen_recording_segment_oid','Required parameter screen_recording_segment_oid was null or undefined when calling updateScreenRecordingSegment.');
            }
            // verify required parameter 'segment' is not null or undefined
            if (segment === null || segment === undefined) {
                throw new RequiredError('segment','Required parameter segment was null or undefined when calling updateScreenRecordingSegment.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/segments/{screen_recording_segment_oid}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_segment_oid"}}`, encodeURIComponent(String(screen_recording_segment_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingSegment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(segment || {}) : (segment || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update screen recording settings
         * @param {number} storefront_oid 
         * @param {ScreenRecordingSettings} settings Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingSettings(storefront_oid: number, settings: ScreenRecordingSettings, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateScreenRecordingSettings.');
            }
            // verify required parameter 'settings' is not null or undefined
            if (settings === null || settings === undefined) {
                throw new RequiredError('settings','Required parameter settings was null or undefined when calling updateScreenRecordingSettings.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/settings`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(settings || {}) : (settings || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tags on a screen recording 
         * @summary Update tags on a screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {ScreenRecordingTagsRequest} tags Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingTags(storefront_oid: number, screen_recording_uuid: string, tags: ScreenRecordingTagsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateScreenRecordingTags.');
            }
            // verify required parameter 'screen_recording_uuid' is not null or undefined
            if (screen_recording_uuid === null || screen_recording_uuid === undefined) {
                throw new RequiredError('screen_recording_uuid','Required parameter screen_recording_uuid was null or undefined when calling updateScreenRecordingTags.');
            }
            // verify required parameter 'tags' is not null or undefined
            if (tags === null || tags === undefined) {
                throw new RequiredError('tags','Required parameter tags was null or undefined when calling updateScreenRecordingTags.');
            }
            const localVarPath = `/storefront/{storefront_oid}/screen_recordings/{screen_recording_uuid}/tags`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"screen_recording_uuid"}}`, encodeURIComponent(String(screen_recording_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScreenRecordingTagsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tags || {}) : (tags || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a transactional email 
         * @summary Updates a transaction email object
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {TransactionEmail} transaction_email TransactionEmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionEmail(storefront_oid: number, email_id: string, transaction_email: TransactionEmail, options: any = {}): FetchArgs {
            // verify required parameter 'storefront_oid' is not null or undefined
            if (storefront_oid === null || storefront_oid === undefined) {
                throw new RequiredError('storefront_oid','Required parameter storefront_oid was null or undefined when calling updateTransactionEmail.');
            }
            // verify required parameter 'email_id' is not null or undefined
            if (email_id === null || email_id === undefined) {
                throw new RequiredError('email_id','Required parameter email_id was null or undefined when calling updateTransactionEmail.');
            }
            // verify required parameter 'transaction_email' is not null or undefined
            if (transaction_email === null || transaction_email === undefined) {
                throw new RequiredError('transaction_email','Required parameter transaction_email was null or undefined when calling updateTransactionEmail.');
            }
            const localVarPath = `/storefront/{storefront_oid}/transaction_email/list/{email_id}`
                .replace(`{${"storefront_oid"}}`, encodeURIComponent(String(storefront_oid)))
                .replace(`{${"email_id"}}`, encodeURIComponent(String(email_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransactionEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(transaction_email || {}) : (transaction_email || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {Twilio} twilio Twilio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwilioAccount(esp_twilio_uuid: string, twilio: Twilio, options: any = {}): FetchArgs {
            // verify required parameter 'esp_twilio_uuid' is not null or undefined
            if (esp_twilio_uuid === null || esp_twilio_uuid === undefined) {
                throw new RequiredError('esp_twilio_uuid','Required parameter esp_twilio_uuid was null or undefined when calling updateTwilioAccount.');
            }
            // verify required parameter 'twilio' is not null or undefined
            if (twilio === null || twilio === undefined) {
                throw new RequiredError('twilio','Required parameter twilio was null or undefined when calling updateTwilioAccount.');
            }
            const localVarPath = `/storefront/twilio/accounts/{esp_twilio_uuid}`
                .replace(`{${"esp_twilio_uuid"}}`, encodeURIComponent(String(esp_twilio_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartBrowserApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-browser-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-browser-key"] = localVarApiKeyValue;
            }

            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["storefront_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Twilio" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(twilio || {}) : (twilio || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorefrontApi - functional programming interface
 * @export
 */
export const StorefrontApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add to library
         * @param {AddLibraryItemRequest} add_library_request New library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToLibrary(add_library_request: AddLibraryItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).addToLibrary(add_library_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Apply library item to storefront.
         * @param {ApplyLibraryItemRequest} apply_library_request New library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToStoreFront(apply_library_request: ApplyLibraryItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplyLibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).applyToStoreFront(apply_library_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailList(storefront_oid: number, email_list_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListArchiveResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).archiveEmailList(storefront_oid, email_list_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Archive email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentArchiveResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).archiveEmailSegment(storefront_oid, email_segment_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Back populate email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {EmailFlowBackPopulateRequest} back_populate_request The request to back populate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backPopulateEmailFlow(storefront_oid: number, email_flow_uuid: string, back_populate_request: EmailFlowBackPopulateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowBackPopulateResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).backPopulateEmailFlow(storefront_oid, email_flow_uuid, back_populate_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check download of email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} email_segment_rebuild_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment_rebuild_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentDownloadPrepareResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).checkDownloadEmailSegment(storefront_oid, email_segment_uuid, email_segment_rebuild_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clone email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {number} [target_storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailCampaign(storefront_oid: number, email_campaign_uuid: string, target_storefront_oid?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).cloneEmailCampaign(storefront_oid, email_campaign_uuid, target_storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clone email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {number} [target_storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailFlow(storefront_oid: number, email_flow_uuid: string, target_storefront_oid?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).cloneEmailFlow(storefront_oid, email_flow_uuid, target_storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSendingDomain(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).createEmailSendingDomain(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create Twilio account
         * @param {Twilio} twilio Twilio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwilioAccount(twilio: Twilio, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TwilioResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).createTwilioAccount(twilio, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email campaignFolder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete communication sequence stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCommseqStat(storefront_oid: number, commseq_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailCommseqStat(storefront_oid, commseq_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailEmail(storefront_oid, commseq_email_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email flowFolder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailFlowFolder(storefront_oid, email_flow_folder_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email list customer
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListCustomer(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailListCustomer(storefront_oid, email_list_uuid, email_customer_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email ListSegmentFolder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailPostcard(storefront_oid, commseq_postcard_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary delete email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSendingDomain(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteEmailSendingDomain(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete experiment
         * @param {number} storefront_oid 
         * @param {number} storefront_experiment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(storefront_oid: number, storefront_experiment_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteExperiment(storefront_oid, storefront_experiment_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete screen recording heatmap 
         * @summary Delete screen recording heatmap
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapReset} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapReset, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteHeatmap(storefront_oid, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete library item
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItem(library_item_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteLibraryItem(library_item_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete all published versions for a library item, including anything in review.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItemPublishedVersions(library_item_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteLibraryItemPublishedVersions(library_item_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary delete Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwilioAccount(esp_twilio_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).deleteTwilioAccount(esp_twilio_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Duplicate library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateLibraryItem(library_item_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).duplicateLibraryItem(library_item_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update favorite flag on screen recording 
         * @summary Update favorite flag on screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).favoriteScreenRecording(storefront_oid, screen_recording_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Obtain lat/long for an address
         * @param {number} storefront_oid 
         * @param {GeocodeRequest} geocode_request geocode request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeAddress(storefront_oid: number, geocode_request: GeocodeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GeocodeResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).geocodeAddress(storefront_oid, geocode_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of all the countries 
         * @summary Get countries
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountriesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getCountries(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches a temporary authentication token for the editor 
         * @summary Gets editor token
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorToken(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailEditorTokenResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEditorToken(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication base templates
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailBaseTemplates(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailBaseTemplateListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailBaseTemplates(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaign(storefront_oid, email_campaign_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignFolders(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignFoldersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaignFolders(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign screenshots
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignScreenshots(storefront_oid: number, email_campaign_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenshotsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaignScreenshots(storefront_oid, email_campaign_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaigns
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaigns(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaigns(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaigns with stats
         * @param {number} storefront_oid 
         * @param {string} stat_days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignsWithStats(storefront_oid: number, stat_days: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCampaignsWithStats(storefront_oid, stat_days, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email commseq
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseq(storefront_oid: number, commseq_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseq(storefront_oid, commseq_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence emails stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStatSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqEmailStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatSummaryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStatSummaryResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqEmailStats(storefront_oid, commseq_uuid, statsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence postcard stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqPostcardStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStatPostcardSummaryResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqPostcardStats(storefront_oid, commseq_uuid, statsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get communication sequence stats overall
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStatOverall(storefront_oid: number, commseq_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqStatResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqStatOverall(storefront_oid, commseq_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence step stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStepStatRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStepStatRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStepStatResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqStepStats(storefront_oid, commseq_uuid, statsRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email communication sequence customers waiting at each requested step
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, waitingRequest: EmailStepWaitingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailStepWaitingResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqStepWaiting(storefront_oid, commseq_uuid, waitingRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email webhook editor values
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqWebhookEditorValues(storefront_oid: number, commseq_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailWebhookEditorValuesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqWebhookEditorValues(storefront_oid, commseq_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email commseqs
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqs(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCommseqs(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get customers editor URL
         * @param {number} storefront_oid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomerEditorUrl(storefront_oid: number, email_customer_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCustomerEditorUrl(storefront_oid, email_customer_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email customers
         * @param {number} storefront_oid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [searchEmailPrefix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomers(storefront_oid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailCustomers(storefront_oid, pageNumber, pageSize, searchEmailPrefix, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email dashboard activity
         * @param {number} storefront_oid 
         * @param {number} [last_records] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardActivity(storefront_oid: number, last_records?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailDashboardActivityResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailDashboardActivity(storefront_oid, last_records, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get dashboard stats
         * @param {number} storefront_oid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardStats(storefront_oid: number, days?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailDashboardStatsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailDashboardStats(storefront_oid, days, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email dispatch logs
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDispatchLogs(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqStepLogsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailDispatchLogs(storefront_oid, commseq_uuid, commseq_step_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmail(storefront_oid, commseq_email_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email email clicks
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {string} commseq_email_uuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailClicks(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailClicksResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailClicks(storefront_oid, commseq_uuid, commseq_step_uuid, commseq_email_uuid, days, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email order customer editor url
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {string} order_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailCustomerEditorUrl(storefront_oid: number, commseq_email_uuid: string, order_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailCustomerEditorUrl(storefront_oid, commseq_email_uuid, order_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email email orders
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {string} commseq_email_uuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailOrders(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailOrdersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailOrders(storefront_oid, commseq_uuid, commseq_step_uuid, commseq_email_uuid, days, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email emails
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmails(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmails(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email emails multiple
         * @param {number} storefront_oid 
         * @param {EmailCommseqEmailsRequest} email_commseq_emails_request Request of email uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailsMultiple(storefront_oid: number, email_commseq_emails_request: EmailCommseqEmailsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailEmailsMultiple(storefront_oid, email_commseq_emails_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlow(storefront_oid: number, email_flow_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlow(storefront_oid, email_flow_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flow folder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlowFolder(storefront_oid, email_flow_folder_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flow folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowFolders(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowFoldersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlowFolders(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flow screenshots
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowScreenshots(storefront_oid: number, email_flow_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenshotsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlowScreenshots(storefront_oid, email_flow_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email flows
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlows(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailFlows(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email globalsettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailGlobalSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailGlobalSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailGlobalSettings(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailList(storefront_oid: number, email_list_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailList(storefront_oid, email_list_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email list customer editor url
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomerEditorUrl(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailListCustomerEditorUrl(storefront_oid, email_list_uuid, email_customer_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email list customers
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomers(storefront_oid: number, email_list_uuid: string, pageNumber?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailListCustomers(storefront_oid, email_list_uuid, pageNumber, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListSegmentFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email campaign folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListSegmentFolders(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListSegmentFoldersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailListSegmentFolders(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email lists
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailLists(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email performance
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPerformance(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPerformanceResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPerformance(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email plan
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPlan(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPlanResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPlan(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPostcard(storefront_oid, commseq_postcard_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email postcards
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcards(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPostcards(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email postcards multiple
         * @param {number} storefront_oid 
         * @param {EmailCommseqPostcardsRequest} email_commseq_postcards_request Request of postcard uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcardsMultiple(storefront_oid: number, email_commseq_postcards_request: EmailCommseqPostcardsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailPostcardsMultiple(storefront_oid, email_commseq_postcards_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegment(storefront_oid, email_segment_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segment customers editor URL
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomerEditorUrl(storefront_oid: number, email_segment_uuid: string, email_customer_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCustomerEditorUrlResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegmentCustomerEditorUrl(storefront_oid, email_segment_uuid, email_customer_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segment customers
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, pageNumber?: number, pageSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegmentCustomers(storefront_oid, email_segment_uuid, pageNumber, pageSize, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email segments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegments(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSegments(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email sending domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomain(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSendingDomain(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email sending domain status
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomainStatus(domain: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSendingDomainStatus(domain, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email sending domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomains(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSendingDomainsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSendingDomains(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email settings
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSettings(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailSettings(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email template
         * @param {number} storefront_oid 
         * @param {number} email_template_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate(storefront_oid: number, email_template_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailTemplate> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailTemplate(storefront_oid, email_template_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get email templates
         * @param {number} storefront_oid 
         * @param {string} [trigger_type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplates(storefront_oid: number, trigger_type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailTemplatesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailTemplates(storefront_oid, trigger_type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a list of third party email providers
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailThirdPartyProviders(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailThirdPartyProvidersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getEmailThirdPartyProviders(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get experiments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExperimentsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getExperiments(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get screen recording heatmap 
         * @summary Get screen recording heatmap
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapRequest} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingHeatmapResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getHeatmap(storefront_oid, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get screen recording heatmap index 
         * @summary Get screen recording heatmap index
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapIndexRequest} query Query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmapIndex(storefront_oid: number, query: ScreenRecordingHeatmapIndexRequest, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingHeatmapIndexResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getHeatmapIndex(storefront_oid, query, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of property names for a given property type 
         * @summary Get histogram property names
         * @param {number} storefront_oid 
         * @param {string} [property_type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyNames(storefront_oid: number, property_type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailHistogramPropertyNamesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getHistogramPropertyNames(storefront_oid, property_type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of property values for a given property name and type 
         * @summary Get histogram property values
         * @param {number} storefront_oid 
         * @param {string} [property_name] 
         * @param {string} [property_type] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyValues(storefront_oid: number, property_name?: string, property_type?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailHistogramPropertyValuesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getHistogramPropertyValues(storefront_oid, property_name, property_type, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get library values used to populate drop down boxes for filtering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryFilterValues(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryFilterValuesResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getLibraryFilterValues(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItem(library_item_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getLibraryItem(library_item_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all published versions for a library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItemPublishedVersions(library_item_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getLibraryItemPublishedVersions(library_item_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get screen recording 
         * @summary Get screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecording(storefront_oid, screen_recording_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get screen recording page view data 
         * @summary Get screen recording page view data
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {string} screen_recording_page_view_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingPageViewData(storefront_oid: number, screen_recording_uuid: string, screen_recording_page_view_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingPageViewDataResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecordingPageViewData(storefront_oid, screen_recording_uuid, screen_recording_page_view_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get screen recording segments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSegments(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingSegmentsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecordingSegments(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get screen recording settings
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSettings(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecordingSettings(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get tags used by screen recording 
         * @summary Get tags used by screen recording
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingTags(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingTagsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecordingTags(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Query screen recordings 
         * @summary Query screen recordings
         * @param {number} storefront_oid 
         * @param {ScreenRecordingQueryRequest} query Query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingsByQuery(storefront_oid: number, query: ScreenRecordingQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingQueryResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecordingsByQuery(storefront_oid, query, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get screen recordings by segment 
         * @summary Get screen recordings by segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingsBySegment(storefront_oid: number, screen_recording_segment_oid: number, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingQueryResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getScreenRecordingsBySegment(storefront_oid, screen_recording_segment_oid, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreFrontPricingTiers(_expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PricingTiersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getStoreFrontPricingTiers(_expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get thumbnail parameters
         * @param {ThumbnailParametersRequest} thumbnail_parameters Thumbnail Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailParameters(thumbnail_parameters: ThumbnailParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ThumbnailParametersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getThumbnailParameters(thumbnail_parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a transactional email 
         * @summary Gets a transaction email object
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmail(storefront_oid: number, email_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTransactionEmail(storefront_oid, email_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Obtain a list of all transactional emails and return back just their names 
         * @summary Gets a list of transaction email names
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailList(storefront_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionEmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTransactionEmailList(storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get transactional email screenshots
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailScreenshots(storefront_oid: number, email_id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenshotsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTransactionEmailScreenshots(storefront_oid, email_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwilioAccount(esp_twilio_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TwilioResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTwilioAccount(esp_twilio_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all Twilio accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwilioAccounts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TwiliosResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).getTwilioAccounts(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Globally unsubscribe a customer
         * @param {number} storefront_oid 
         * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnsubscribe(storefront_oid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailGlobalUnsubscribeResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).globalUnsubscribe(storefront_oid, unsubscribe, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Import a third party provider list
         * @param {number} storefront_oid 
         * @param {EmailThirdPartyListImportRequest} import_request lists to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmailThirdPartyProviderList(storefront_oid: number, import_request: EmailThirdPartyListImportRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).importEmailThirdPartyProviderList(storefront_oid, import_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email campaign
         * @param {number} storefront_oid 
         * @param {EmailCampaign} email_campaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaign(storefront_oid: number, email_campaign: EmailCampaign, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailCampaign(storefront_oid, email_campaign, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email campaign folder
         * @param {number} storefront_oid 
         * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaignFolder(storefront_oid: number, email_campaign_folder: EmailCampaignFolder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailCampaignFolder(storefront_oid, email_campaign_folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email commseq
         * @param {number} storefront_oid 
         * @param {EmailCommseq} email_commseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCommseq(storefront_oid: number, email_commseq: EmailCommseq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailCommseq(storefront_oid, email_commseq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email email
         * @param {number} storefront_oid 
         * @param {EmailCommseqEmail} email_commseq_email Email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailEmail(storefront_oid: number, email_commseq_email: EmailCommseqEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailEmail(storefront_oid, email_commseq_email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email flow
         * @param {number} storefront_oid 
         * @param {EmailFlow} email_flow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlow(storefront_oid: number, email_flow: EmailFlow, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailFlow(storefront_oid, email_flow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email flow folder
         * @param {number} storefront_oid 
         * @param {EmailFlowFolder} email_flow_folder Email flow folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlowFolder(storefront_oid: number, email_flow_folder: EmailFlowFolder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailFlowFolder(storefront_oid, email_flow_folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email list
         * @param {number} storefront_oid 
         * @param {EmailList} email_list Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailList(storefront_oid: number, email_list: EmailList, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailList(storefront_oid, email_list, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email campaign folder
         * @param {number} storefront_oid 
         * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder: EmailListSegmentFolder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListSegmentFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailListSegmentFolder(storefront_oid, email_list_segment_folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email postcard
         * @param {number} storefront_oid 
         * @param {EmailCommseqPostcard} email_commseq_postcard Email postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailPostcard(storefront_oid: number, email_commseq_postcard: EmailCommseqPostcard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailPostcard(storefront_oid, email_commseq_postcard, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert email segment
         * @param {number} storefront_oid 
         * @param {EmailSegment} email_segment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailSegment(storefront_oid: number, email_segment: EmailSegment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertEmailSegment(storefront_oid, email_segment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Insert screen recording segment
         * @param {number} storefront_oid 
         * @param {ScreenRecordingSegment} segment Segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertScreenRecordingSegment(storefront_oid: number, segment: ScreenRecordingSegment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).insertScreenRecordingSegment(storefront_oid, segment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Prepare download of email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentDownloadPrepareResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).prepareDownloadEmailSegment(storefront_oid, email_segment_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Publish library item.
         * @param {number} library_item_oid 
         * @param {PublishLibraryItemRequest} publish_library_request Publish library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishLibraryItem(library_item_oid: number, publish_library_request: PublishLibraryItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).publishLibraryItem(library_item_oid, publish_library_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Purchase public library item, which creates a copy of the item in your personal code library
         * @param {number} library_item_oid 
         * @param {number} [storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLibraryItem(library_item_oid: number, storefront_oid?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).purchaseLibraryItem(library_item_oid, storefront_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Release email communication sequence customers waiting at the specified step
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).releaseEmailCommseqStepWaiting(storefront_oid, commseq_uuid, commseq_step_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Request a review of an email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_review_request Email commseq email review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        review(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_review_request: EmailCommseqEmailSendTestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailSendTestResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).review(storefront_oid, commseq_email_uuid, email_commseq_email_review_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Searches for all matching values
         * @param {string} [category] 
         * @param {string} [matches] 
         * @param {string} [storefront_oid] 
         * @param {number} [max_hits] 
         * @param {string} [subcategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(category?: string, matches?: string, storefront_oid?: string, max_hits?: number, subcategory?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LookupResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).search(category, matches, storefront_oid, max_hits, subcategory, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Searches for all matching values (using POST)
         * @param {LookupRequest} lookup_request LookupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(lookup_request: LookupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LookupResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).search2(lookup_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search email list customers
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailListCustomers(storefront_oid: number, email_list_uuid: string, startsWith?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchEmailListCustomers(storefront_oid, email_list_uuid, startsWith, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Search email segment customers
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, startsWith?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentCustomersResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchEmailSegmentCustomers(storefront_oid, email_segment_uuid, startsWith, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLibraryItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchLibraryItems(item_query, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPublishedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchPublishedItems(item_query, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items needing review or rejected
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReviewItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchReviewItems(item_query, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSharedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).searchSharedItems(item_query, _limit, _offset, _sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send email test
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_test_request Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailTest(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_test_request: EmailCommseqEmailSendTestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailSendTestResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).sendEmailTest(storefront_oid, commseq_email_uuid, email_commseq_email_test_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send postcard test
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {EmailCommseqPostcardSendTestRequest} email_commseq_postcard_test_request Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPostcardTest(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard_test_request: EmailCommseqPostcardSendTestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardSendTestResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).sendPostcardTest(storefront_oid, commseq_postcard_uuid, email_commseq_postcard_test_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Send webhook test
         * @param {number} storefront_oid 
         * @param {EmailCommseqWebhookSendTestRequest} email_commseq_webhook_test_request Email commseq webhook test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWebhookTest(storefront_oid: number, email_commseq_webhook_test_request: EmailCommseqWebhookSendTestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailSendTestResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).sendWebhookTest(storefront_oid, email_commseq_webhook_test_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).startEmailCampaign(storefront_oid, email_campaign_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Subscribe customers to email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {Array<EmailCustomer>} customers Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEmailList(storefront_oid: number, email_list_uuid: string, customers: Array<EmailCustomer>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListSubscribeResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).subscribeToEmailList(storefront_oid, email_list_uuid, customers, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove favorite flag on screen recording 
         * @summary Remove favorite flag on screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).unfavoriteScreenRecording(storefront_oid, screen_recording_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {EmailCampaign} email_campaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaign(storefront_oid: number, email_campaign_uuid: string, email_campaign: EmailCampaign, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailCampaign(storefront_oid, email_campaign_uuid, email_campaign, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, email_campaign_folder: EmailCampaignFolder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCampaignFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, email_campaign_folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email commseq
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailCommseq} email_commseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCommseq(storefront_oid: number, commseq_uuid: string, email_commseq: EmailCommseq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailCommseq(storefront_oid, commseq_uuid, email_commseq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email customer
         * @param {number} storefront_oid 
         * @param {string} email_customer_uuid 
         * @param {EmailCustomer} email_customer Email customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCustomer(storefront_oid: number, email_customer_uuid: string, email_customer: EmailCustomer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailCustomer(storefront_oid, email_customer_uuid, email_customer, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmail} email_commseq_email Email commseq email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailEmail(storefront_oid: number, commseq_email_uuid: string, email_commseq_email: EmailCommseqEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailEmail(storefront_oid, commseq_email_uuid, email_commseq_email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {EmailFlow} email_flow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlow(storefront_oid: number, email_flow_uuid: string, email_flow: EmailFlow, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailFlow(storefront_oid, email_flow_uuid, email_flow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email flow folder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {EmailFlowFolder} email_flow_folder Email flow folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, email_flow_folder: EmailFlowFolder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailFlowFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailFlowFolder(storefront_oid, email_flow_folder_uuid, email_flow_folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email global settings
         * @param {EmailGlobalSettings} global_settings global settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailGlobalSettings(global_settings: EmailGlobalSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailGlobalSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailGlobalSettings(global_settings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {EmailList} email_list Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailList(storefront_oid: number, email_list_uuid: string, email_list: EmailList, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailList(storefront_oid, email_list_uuid, email_list, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, email_list_segment_folder: EmailListSegmentFolder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailListSegmentFolderResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, email_list_segment_folder, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email plan
         * @param {number} storefront_oid 
         * @param {EmailPlan} settings plan request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPlan(storefront_oid: number, settings: EmailPlan, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPlanResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailPlan(storefront_oid, settings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {EmailCommseqPostcard} email_commseq_postcard Email commseq postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard: EmailCommseqPostcard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCommseqPostcardResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailPostcard(storefront_oid, commseq_postcard_uuid, email_commseq_postcard, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {EmailSegment} email_segment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment: EmailSegment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailSegment(storefront_oid, email_segment_uuid, email_segment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update email settings
         * @param {number} storefront_oid 
         * @param {EmailSettings} settings settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSettings(storefront_oid: number, settings: EmailSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateEmailSettings(storefront_oid, settings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update experiment
         * @param {number} storefront_oid 
         * @param {number} storefront_experiment_oid 
         * @param {Experiment} experiment Experiment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment(storefront_oid: number, storefront_experiment_oid: number, experiment: Experiment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExperimentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateExperiment(storefront_oid, storefront_experiment_oid, experiment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update library item. Note that only certain fields may be updated via this method.
         * @param {number} library_item_oid 
         * @param {LibraryItem} library_item Library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryItem(library_item_oid: number, library_item: LibraryItem, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LibraryItemResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateLibraryItem(library_item_oid, library_item, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update merchant notes on a screen recording 
         * @summary Update merchant notes on a screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {ScreenRecordingMerchantNotesRequest} merchant_notes_request Merchant Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingMerchantNotes(storefront_oid: number, screen_recording_uuid: string, merchant_notes_request: ScreenRecordingMerchantNotesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateScreenRecordingMerchantNotes(storefront_oid, screen_recording_uuid, merchant_notes_request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {ScreenRecordingSegment} segment Segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, segment: ScreenRecordingSegment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingSegmentResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, segment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update screen recording settings
         * @param {number} storefront_oid 
         * @param {ScreenRecordingSettings} settings Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingSettings(storefront_oid: number, settings: ScreenRecordingSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ScreenRecordingSettingsResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateScreenRecordingSettings(storefront_oid, settings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update tags on a screen recording 
         * @summary Update tags on a screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {ScreenRecordingTagsRequest} tags Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingTags(storefront_oid: number, screen_recording_uuid: string, tags: ScreenRecordingTagsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateScreenRecordingTags(storefront_oid, screen_recording_uuid, tags, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a transactional email 
         * @summary Updates a transaction email object
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {TransactionEmail} transaction_email TransactionEmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionEmail(storefront_oid: number, email_id: string, transaction_email: TransactionEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionEmailResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateTransactionEmail(storefront_oid, email_id, transaction_email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {Twilio} twilio Twilio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwilioAccount(esp_twilio_uuid: string, twilio: Twilio, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TwilioResponse> {
            const localVarFetchArgs = StorefrontApiFetchParamCreator(configuration).updateTwilioAccount(esp_twilio_uuid, twilio, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StorefrontApi - factory interface
 * @export
 */
export const StorefrontApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add to library
         * @param {AddLibraryItemRequest} add_library_request New library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToLibrary(add_library_request: AddLibraryItemRequest, options?: any) {
            return StorefrontApiFp(configuration).addToLibrary(add_library_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Apply library item to storefront.
         * @param {ApplyLibraryItemRequest} apply_library_request New library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToStoreFront(apply_library_request: ApplyLibraryItemRequest, options?: any) {
            return StorefrontApiFp(configuration).applyToStoreFront(apply_library_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailList(storefront_oid: number, email_list_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).archiveEmailList(storefront_oid, email_list_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Archive email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).archiveEmailSegment(storefront_oid, email_segment_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Back populate email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {EmailFlowBackPopulateRequest} back_populate_request The request to back populate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backPopulateEmailFlow(storefront_oid: number, email_flow_uuid: string, back_populate_request: EmailFlowBackPopulateRequest, options?: any) {
            return StorefrontApiFp(configuration).backPopulateEmailFlow(storefront_oid, email_flow_uuid, back_populate_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check download of email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} email_segment_rebuild_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment_rebuild_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).checkDownloadEmailSegment(storefront_oid, email_segment_uuid, email_segment_rebuild_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clone email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {number} [target_storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailCampaign(storefront_oid: number, email_campaign_uuid: string, target_storefront_oid?: number, options?: any) {
            return StorefrontApiFp(configuration).cloneEmailCampaign(storefront_oid, email_campaign_uuid, target_storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clone email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {number} [target_storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneEmailFlow(storefront_oid: number, email_flow_uuid: string, target_storefront_oid?: number, options?: any) {
            return StorefrontApiFp(configuration).cloneEmailFlow(storefront_oid, email_flow_uuid, target_storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailSendingDomain(domain: string, options?: any) {
            return StorefrontApiFp(configuration).createEmailSendingDomain(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create Twilio account
         * @param {Twilio} twilio Twilio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwilioAccount(twilio: Twilio, options?: any) {
            return StorefrontApiFp(configuration).createTwilioAccount(twilio, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email campaignFolder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete communication sequence stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailCommseqStat(storefront_oid: number, commseq_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailCommseqStat(storefront_oid, commseq_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailEmail(storefront_oid, commseq_email_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email flowFolder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailFlowFolder(storefront_oid, email_flow_folder_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email list customer
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListCustomer(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailListCustomer(storefront_oid, email_list_uuid, email_customer_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email ListSegmentFolder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailPostcard(storefront_oid, commseq_postcard_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary delete email campaign
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailSendingDomain(domain: string, options?: any) {
            return StorefrontApiFp(configuration).deleteEmailSendingDomain(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete experiment
         * @param {number} storefront_oid 
         * @param {number} storefront_experiment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExperiment(storefront_oid: number, storefront_experiment_oid: number, options?: any) {
            return StorefrontApiFp(configuration).deleteExperiment(storefront_oid, storefront_experiment_oid, options)(fetch, basePath);
        },
        /**
         * Delete screen recording heatmap 
         * @summary Delete screen recording heatmap
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapReset} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapReset, options?: any) {
            return StorefrontApiFp(configuration).deleteHeatmap(storefront_oid, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete library item
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItem(library_item_oid: number, options?: any) {
            return StorefrontApiFp(configuration).deleteLibraryItem(library_item_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete all published versions for a library item, including anything in review.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryItemPublishedVersions(library_item_oid: number, options?: any) {
            return StorefrontApiFp(configuration).deleteLibraryItemPublishedVersions(library_item_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any) {
            return StorefrontApiFp(configuration).deleteScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary delete Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwilioAccount(esp_twilio_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).deleteTwilioAccount(esp_twilio_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Duplicate library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateLibraryItem(library_item_oid: number, options?: any) {
            return StorefrontApiFp(configuration).duplicateLibraryItem(library_item_oid, options)(fetch, basePath);
        },
        /**
         * Update favorite flag on screen recording 
         * @summary Update favorite flag on screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        favoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).favoriteScreenRecording(storefront_oid, screen_recording_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Obtain lat/long for an address
         * @param {number} storefront_oid 
         * @param {GeocodeRequest} geocode_request geocode request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodeAddress(storefront_oid: number, geocode_request: GeocodeRequest, options?: any) {
            return StorefrontApiFp(configuration).geocodeAddress(storefront_oid, geocode_request, options)(fetch, basePath);
        },
        /**
         * Obtain a list of all the countries 
         * @summary Get countries
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getCountries(storefront_oid, options)(fetch, basePath);
        },
        /**
         * Fetches a temporary authentication token for the editor 
         * @summary Gets editor token
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEditorToken(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEditorToken(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication base templates
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailBaseTemplates(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailBaseTemplates(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaign(storefront_oid, email_campaign_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignFolders(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaignFolders(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign screenshots
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignScreenshots(storefront_oid: number, email_campaign_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaignScreenshots(storefront_oid, email_campaign_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaigns
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaigns(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaigns(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaigns with stats
         * @param {number} storefront_oid 
         * @param {string} stat_days 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCampaignsWithStats(storefront_oid: number, stat_days: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCampaignsWithStats(storefront_oid, stat_days, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email commseq
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseq(storefront_oid: number, commseq_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseq(storefront_oid, commseq_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence emails stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStatSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqEmailStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatSummaryRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqEmailStats(storefront_oid, commseq_uuid, statsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence postcard stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqPostcardStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqPostcardStats(storefront_oid, commseq_uuid, statsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get communication sequence stats overall
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStatOverall(storefront_oid: number, commseq_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqStatOverall(storefront_oid, commseq_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence step stats
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStepStatRequest} statsRequest StatsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStepStatRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqStepStats(storefront_oid, commseq_uuid, statsRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email communication sequence customers waiting at each requested step
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, waitingRequest: EmailStepWaitingRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqStepWaiting(storefront_oid, commseq_uuid, waitingRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email webhook editor values
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqWebhookEditorValues(storefront_oid: number, commseq_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqWebhookEditorValues(storefront_oid, commseq_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email commseqs
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCommseqs(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailCommseqs(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get customers editor URL
         * @param {number} storefront_oid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomerEditorUrl(storefront_oid: number, email_customer_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCustomerEditorUrl(storefront_oid, email_customer_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email customers
         * @param {number} storefront_oid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {string} [searchEmailPrefix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailCustomers(storefront_oid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailCustomers(storefront_oid, pageNumber, pageSize, searchEmailPrefix, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email dashboard activity
         * @param {number} storefront_oid 
         * @param {number} [last_records] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardActivity(storefront_oid: number, last_records?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailDashboardActivity(storefront_oid, last_records, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get dashboard stats
         * @param {number} storefront_oid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDashboardStats(storefront_oid: number, days?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailDashboardStats(storefront_oid, days, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email dispatch logs
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailDispatchLogs(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailDispatchLogs(storefront_oid, commseq_uuid, commseq_step_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmail(storefront_oid, commseq_email_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email email clicks
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {string} commseq_email_uuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailClicks(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailClicks(storefront_oid, commseq_uuid, commseq_step_uuid, commseq_email_uuid, days, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email order customer editor url
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {string} order_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailCustomerEditorUrl(storefront_oid: number, commseq_email_uuid: string, order_id: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailCustomerEditorUrl(storefront_oid, commseq_email_uuid, order_id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email email orders
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {string} commseq_email_uuid 
         * @param {number} [days] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailOrders(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailOrders(storefront_oid, commseq_uuid, commseq_step_uuid, commseq_email_uuid, days, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email emails
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmails(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmails(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email emails multiple
         * @param {number} storefront_oid 
         * @param {EmailCommseqEmailsRequest} email_commseq_emails_request Request of email uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailEmailsMultiple(storefront_oid: number, email_commseq_emails_request: EmailCommseqEmailsRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailEmailsMultiple(storefront_oid, email_commseq_emails_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlow(storefront_oid: number, email_flow_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlow(storefront_oid, email_flow_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flow folder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlowFolder(storefront_oid, email_flow_folder_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flow folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowFolders(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlowFolders(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flow screenshots
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlowScreenshots(storefront_oid: number, email_flow_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlowScreenshots(storefront_oid, email_flow_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email flows
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailFlows(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailFlows(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email globalsettings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailGlobalSettings(options?: any) {
            return StorefrontApiFp(configuration).getEmailGlobalSettings(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailList(storefront_oid: number, email_list_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailList(storefront_oid, email_list_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email list customer editor url
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomerEditorUrl(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailListCustomerEditorUrl(storefront_oid, email_list_uuid, email_customer_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email list customers
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListCustomers(storefront_oid: number, email_list_uuid: string, pageNumber?: number, pageSize?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailListCustomers(storefront_oid, email_list_uuid, pageNumber, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email campaign folders
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailListSegmentFolders(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailListSegmentFolders(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email lists
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailLists(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailLists(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email performance
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPerformance(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailPerformance(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email plan
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPlan(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailPlan(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailPostcard(storefront_oid, commseq_postcard_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email postcards
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcards(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailPostcards(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email postcards multiple
         * @param {number} storefront_oid 
         * @param {EmailCommseqPostcardsRequest} email_commseq_postcards_request Request of postcard uuids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailPostcardsMultiple(storefront_oid: number, email_commseq_postcards_request: EmailCommseqPostcardsRequest, options?: any) {
            return StorefrontApiFp(configuration).getEmailPostcardsMultiple(storefront_oid, email_commseq_postcards_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegment(storefront_oid, email_segment_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segment customers editor URL
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} email_customer_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomerEditorUrl(storefront_oid: number, email_segment_uuid: string, email_customer_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegmentCustomerEditorUrl(storefront_oid, email_segment_uuid, email_customer_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segment customers
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, pageNumber?: number, pageSize?: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegmentCustomers(storefront_oid, email_segment_uuid, pageNumber, pageSize, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email segments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSegments(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailSegments(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email sending domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomain(domain: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSendingDomain(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email sending domain status
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomainStatus(domain: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailSendingDomainStatus(domain, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email sending domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSendingDomains(options?: any) {
            return StorefrontApiFp(configuration).getEmailSendingDomains(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email settings
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailSettings(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailSettings(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email template
         * @param {number} storefront_oid 
         * @param {number} email_template_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplate(storefront_oid: number, email_template_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailTemplate(storefront_oid, email_template_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get email templates
         * @param {number} storefront_oid 
         * @param {string} [trigger_type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplates(storefront_oid: number, trigger_type?: string, options?: any) {
            return StorefrontApiFp(configuration).getEmailTemplates(storefront_oid, trigger_type, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of third party email providers
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailThirdPartyProviders(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getEmailThirdPartyProviders(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get experiments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExperiments(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getExperiments(storefront_oid, options)(fetch, basePath);
        },
        /**
         * Get screen recording heatmap 
         * @summary Get screen recording heatmap
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapRequest} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapRequest, options?: any) {
            return StorefrontApiFp(configuration).getHeatmap(storefront_oid, query, options)(fetch, basePath);
        },
        /**
         * Get screen recording heatmap index 
         * @summary Get screen recording heatmap index
         * @param {number} storefront_oid 
         * @param {ScreenRecordingHeatmapIndexRequest} query Query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeatmapIndex(storefront_oid: number, query: ScreenRecordingHeatmapIndexRequest, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return StorefrontApiFp(configuration).getHeatmapIndex(storefront_oid, query, _limit, _offset, _sort, options)(fetch, basePath);
        },
        /**
         * Obtain a list of property names for a given property type 
         * @summary Get histogram property names
         * @param {number} storefront_oid 
         * @param {string} [property_type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyNames(storefront_oid: number, property_type?: string, options?: any) {
            return StorefrontApiFp(configuration).getHistogramPropertyNames(storefront_oid, property_type, options)(fetch, basePath);
        },
        /**
         * Obtain a list of property values for a given property name and type 
         * @summary Get histogram property values
         * @param {number} storefront_oid 
         * @param {string} [property_name] 
         * @param {string} [property_type] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistogramPropertyValues(storefront_oid: number, property_name?: string, property_type?: string, limit?: number, options?: any) {
            return StorefrontApiFp(configuration).getHistogramPropertyValues(storefront_oid, property_name, property_type, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get library values used to populate drop down boxes for filtering.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryFilterValues(options?: any) {
            return StorefrontApiFp(configuration).getLibraryFilterValues(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItem(library_item_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getLibraryItem(library_item_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all published versions for a library item.
         * @param {number} library_item_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryItemPublishedVersions(library_item_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getLibraryItemPublishedVersions(library_item_oid, options)(fetch, basePath);
        },
        /**
         * Get screen recording 
         * @summary Get screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecording(storefront_oid, screen_recording_uuid, options)(fetch, basePath);
        },
        /**
         * Get screen recording page view data 
         * @summary Get screen recording page view data
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {string} screen_recording_page_view_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingPageViewData(storefront_oid: number, screen_recording_uuid: string, screen_recording_page_view_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecordingPageViewData(storefront_oid, screen_recording_uuid, screen_recording_page_view_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get screen recording segments
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSegments(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecordingSegments(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get screen recording settings
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingSettings(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecordingSettings(storefront_oid, options)(fetch, basePath);
        },
        /**
         * Get tags used by screen recording 
         * @summary Get tags used by screen recording
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingTags(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecordingTags(storefront_oid, options)(fetch, basePath);
        },
        /**
         * Query screen recordings 
         * @summary Query screen recordings
         * @param {number} storefront_oid 
         * @param {ScreenRecordingQueryRequest} query Query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingsByQuery(storefront_oid: number, query: ScreenRecordingQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecordingsByQuery(storefront_oid, query, _limit, _offset, _sort, options)(fetch, basePath);
        },
        /**
         * Get screen recordings by segment 
         * @summary Get screen recordings by segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenRecordingsBySegment(storefront_oid: number, screen_recording_segment_oid: number, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return StorefrontApiFp(configuration).getScreenRecordingsBySegment(storefront_oid, screen_recording_segment_oid, _limit, _offset, _sort, options)(fetch, basePath);
        },
        /**
         * Retrieves the pricing tiers 
         * @summary Retrieve pricing tiers
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStoreFrontPricingTiers(_expand?: string, options?: any) {
            return StorefrontApiFp(configuration).getStoreFrontPricingTiers(_expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get thumbnail parameters
         * @param {ThumbnailParametersRequest} thumbnail_parameters Thumbnail Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailParameters(thumbnail_parameters: ThumbnailParametersRequest, options?: any) {
            return StorefrontApiFp(configuration).getThumbnailParameters(thumbnail_parameters, options)(fetch, basePath);
        },
        /**
         * Fetch a transactional email 
         * @summary Gets a transaction email object
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmail(storefront_oid: number, email_id: string, options?: any) {
            return StorefrontApiFp(configuration).getTransactionEmail(storefront_oid, email_id, options)(fetch, basePath);
        },
        /**
         * Obtain a list of all transactional emails and return back just their names 
         * @summary Gets a list of transaction email names
         * @param {number} storefront_oid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailList(storefront_oid: number, options?: any) {
            return StorefrontApiFp(configuration).getTransactionEmailList(storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get transactional email screenshots
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionEmailScreenshots(storefront_oid: number, email_id: string, options?: any) {
            return StorefrontApiFp(configuration).getTransactionEmailScreenshots(storefront_oid, email_id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwilioAccount(esp_twilio_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).getTwilioAccount(esp_twilio_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all Twilio accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwilioAccounts(options?: any) {
            return StorefrontApiFp(configuration).getTwilioAccounts(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Globally unsubscribe a customer
         * @param {number} storefront_oid 
         * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnsubscribe(storefront_oid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any) {
            return StorefrontApiFp(configuration).globalUnsubscribe(storefront_oid, unsubscribe, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Import a third party provider list
         * @param {number} storefront_oid 
         * @param {EmailThirdPartyListImportRequest} import_request lists to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importEmailThirdPartyProviderList(storefront_oid: number, import_request: EmailThirdPartyListImportRequest, options?: any) {
            return StorefrontApiFp(configuration).importEmailThirdPartyProviderList(storefront_oid, import_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email campaign
         * @param {number} storefront_oid 
         * @param {EmailCampaign} email_campaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaign(storefront_oid: number, email_campaign: EmailCampaign, options?: any) {
            return StorefrontApiFp(configuration).insertEmailCampaign(storefront_oid, email_campaign, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email campaign folder
         * @param {number} storefront_oid 
         * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCampaignFolder(storefront_oid: number, email_campaign_folder: EmailCampaignFolder, options?: any) {
            return StorefrontApiFp(configuration).insertEmailCampaignFolder(storefront_oid, email_campaign_folder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email commseq
         * @param {number} storefront_oid 
         * @param {EmailCommseq} email_commseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailCommseq(storefront_oid: number, email_commseq: EmailCommseq, options?: any) {
            return StorefrontApiFp(configuration).insertEmailCommseq(storefront_oid, email_commseq, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email email
         * @param {number} storefront_oid 
         * @param {EmailCommseqEmail} email_commseq_email Email email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailEmail(storefront_oid: number, email_commseq_email: EmailCommseqEmail, options?: any) {
            return StorefrontApiFp(configuration).insertEmailEmail(storefront_oid, email_commseq_email, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email flow
         * @param {number} storefront_oid 
         * @param {EmailFlow} email_flow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlow(storefront_oid: number, email_flow: EmailFlow, options?: any) {
            return StorefrontApiFp(configuration).insertEmailFlow(storefront_oid, email_flow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email flow folder
         * @param {number} storefront_oid 
         * @param {EmailFlowFolder} email_flow_folder Email flow folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailFlowFolder(storefront_oid: number, email_flow_folder: EmailFlowFolder, options?: any) {
            return StorefrontApiFp(configuration).insertEmailFlowFolder(storefront_oid, email_flow_folder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email list
         * @param {number} storefront_oid 
         * @param {EmailList} email_list Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailList(storefront_oid: number, email_list: EmailList, options?: any) {
            return StorefrontApiFp(configuration).insertEmailList(storefront_oid, email_list, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email campaign folder
         * @param {number} storefront_oid 
         * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder: EmailListSegmentFolder, options?: any) {
            return StorefrontApiFp(configuration).insertEmailListSegmentFolder(storefront_oid, email_list_segment_folder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email postcard
         * @param {number} storefront_oid 
         * @param {EmailCommseqPostcard} email_commseq_postcard Email postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailPostcard(storefront_oid: number, email_commseq_postcard: EmailCommseqPostcard, options?: any) {
            return StorefrontApiFp(configuration).insertEmailPostcard(storefront_oid, email_commseq_postcard, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert email segment
         * @param {number} storefront_oid 
         * @param {EmailSegment} email_segment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertEmailSegment(storefront_oid: number, email_segment: EmailSegment, options?: any) {
            return StorefrontApiFp(configuration).insertEmailSegment(storefront_oid, email_segment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Insert screen recording segment
         * @param {number} storefront_oid 
         * @param {ScreenRecordingSegment} segment Segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertScreenRecordingSegment(storefront_oid: number, segment: ScreenRecordingSegment, options?: any) {
            return StorefrontApiFp(configuration).insertScreenRecordingSegment(storefront_oid, segment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Prepare download of email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).prepareDownloadEmailSegment(storefront_oid, email_segment_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Publish library item.
         * @param {number} library_item_oid 
         * @param {PublishLibraryItemRequest} publish_library_request Publish library item request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishLibraryItem(library_item_oid: number, publish_library_request: PublishLibraryItemRequest, options?: any) {
            return StorefrontApiFp(configuration).publishLibraryItem(library_item_oid, publish_library_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Purchase public library item, which creates a copy of the item in your personal code library
         * @param {number} library_item_oid 
         * @param {number} [storefront_oid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseLibraryItem(library_item_oid: number, storefront_oid?: number, options?: any) {
            return StorefrontApiFp(configuration).purchaseLibraryItem(library_item_oid, storefront_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Release email communication sequence customers waiting at the specified step
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {string} commseq_step_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releaseEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).releaseEmailCommseqStepWaiting(storefront_oid, commseq_uuid, commseq_step_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Request a review of an email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_review_request Email commseq email review request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        review(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_review_request: EmailCommseqEmailSendTestRequest, options?: any) {
            return StorefrontApiFp(configuration).review(storefront_oid, commseq_email_uuid, email_commseq_email_review_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Searches for all matching values
         * @param {string} [category] 
         * @param {string} [matches] 
         * @param {string} [storefront_oid] 
         * @param {number} [max_hits] 
         * @param {string} [subcategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(category?: string, matches?: string, storefront_oid?: string, max_hits?: number, subcategory?: string, options?: any) {
            return StorefrontApiFp(configuration).search(category, matches, storefront_oid, max_hits, subcategory, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Searches for all matching values (using POST)
         * @param {LookupRequest} lookup_request LookupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(lookup_request: LookupRequest, options?: any) {
            return StorefrontApiFp(configuration).search2(lookup_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search email list customers
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailListCustomers(storefront_oid: number, email_list_uuid: string, startsWith?: string, options?: any) {
            return StorefrontApiFp(configuration).searchEmailListCustomers(storefront_oid, email_list_uuid, startsWith, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search email segment customers
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {string} [startsWith] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, startsWith?: string, options?: any) {
            return StorefrontApiFp(configuration).searchEmailSegmentCustomers(storefront_oid, email_segment_uuid, startsWith, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLibraryItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchLibraryItems(item_query, _limit, _offset, _sort, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPublishedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchPublishedItems(item_query, _limit, _offset, _sort, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items needing review or rejected
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReviewItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchReviewItems(item_query, _limit, _offset, _sort, options)(fetch, basePath);
        },
        /**
         * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
         * @summary Retrieve library items
         * @param {LibraryItemQuery} item_query Item query
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSharedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
            return StorefrontApiFp(configuration).searchSharedItems(item_query, _limit, _offset, _sort, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send email test
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_test_request Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailTest(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_test_request: EmailCommseqEmailSendTestRequest, options?: any) {
            return StorefrontApiFp(configuration).sendEmailTest(storefront_oid, commseq_email_uuid, email_commseq_email_test_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send postcard test
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {EmailCommseqPostcardSendTestRequest} email_commseq_postcard_test_request Email commseq email test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPostcardTest(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard_test_request: EmailCommseqPostcardSendTestRequest, options?: any) {
            return StorefrontApiFp(configuration).sendPostcardTest(storefront_oid, commseq_postcard_uuid, email_commseq_postcard_test_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send webhook test
         * @param {number} storefront_oid 
         * @param {EmailCommseqWebhookSendTestRequest} email_commseq_webhook_test_request Email commseq webhook test request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendWebhookTest(storefront_oid: number, email_commseq_webhook_test_request: EmailCommseqWebhookSendTestRequest, options?: any) {
            return StorefrontApiFp(configuration).sendWebhookTest(storefront_oid, email_commseq_webhook_test_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).startEmailCampaign(storefront_oid, email_campaign_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Subscribe customers to email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {Array<EmailCustomer>} customers Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeToEmailList(storefront_oid: number, email_list_uuid: string, customers: Array<EmailCustomer>, options?: any) {
            return StorefrontApiFp(configuration).subscribeToEmailList(storefront_oid, email_list_uuid, customers, options)(fetch, basePath);
        },
        /**
         * Remove favorite flag on screen recording 
         * @summary Remove favorite flag on screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfavoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any) {
            return StorefrontApiFp(configuration).unfavoriteScreenRecording(storefront_oid, screen_recording_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email campaign
         * @param {number} storefront_oid 
         * @param {string} email_campaign_uuid 
         * @param {EmailCampaign} email_campaign Email campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaign(storefront_oid: number, email_campaign_uuid: string, email_campaign: EmailCampaign, options?: any) {
            return StorefrontApiFp(configuration).updateEmailCampaign(storefront_oid, email_campaign_uuid, email_campaign, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_campaign_folder_uuid 
         * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, email_campaign_folder: EmailCampaignFolder, options?: any) {
            return StorefrontApiFp(configuration).updateEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, email_campaign_folder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email commseq
         * @param {number} storefront_oid 
         * @param {string} commseq_uuid 
         * @param {EmailCommseq} email_commseq Email commseq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCommseq(storefront_oid: number, commseq_uuid: string, email_commseq: EmailCommseq, options?: any) {
            return StorefrontApiFp(configuration).updateEmailCommseq(storefront_oid, commseq_uuid, email_commseq, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email customer
         * @param {number} storefront_oid 
         * @param {string} email_customer_uuid 
         * @param {EmailCustomer} email_customer Email customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailCustomer(storefront_oid: number, email_customer_uuid: string, email_customer: EmailCustomer, options?: any) {
            return StorefrontApiFp(configuration).updateEmailCustomer(storefront_oid, email_customer_uuid, email_customer, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email email
         * @param {number} storefront_oid 
         * @param {string} commseq_email_uuid 
         * @param {EmailCommseqEmail} email_commseq_email Email commseq email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailEmail(storefront_oid: number, commseq_email_uuid: string, email_commseq_email: EmailCommseqEmail, options?: any) {
            return StorefrontApiFp(configuration).updateEmailEmail(storefront_oid, commseq_email_uuid, email_commseq_email, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email flow
         * @param {number} storefront_oid 
         * @param {string} email_flow_uuid 
         * @param {EmailFlow} email_flow Email flow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlow(storefront_oid: number, email_flow_uuid: string, email_flow: EmailFlow, options?: any) {
            return StorefrontApiFp(configuration).updateEmailFlow(storefront_oid, email_flow_uuid, email_flow, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email flow folder
         * @param {number} storefront_oid 
         * @param {string} email_flow_folder_uuid 
         * @param {EmailFlowFolder} email_flow_folder Email flow folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, email_flow_folder: EmailFlowFolder, options?: any) {
            return StorefrontApiFp(configuration).updateEmailFlowFolder(storefront_oid, email_flow_folder_uuid, email_flow_folder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email global settings
         * @param {EmailGlobalSettings} global_settings global settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailGlobalSettings(global_settings: EmailGlobalSettings, options?: any) {
            return StorefrontApiFp(configuration).updateEmailGlobalSettings(global_settings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email list
         * @param {number} storefront_oid 
         * @param {string} email_list_uuid 
         * @param {EmailList} email_list Email list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailList(storefront_oid: number, email_list_uuid: string, email_list: EmailList, options?: any) {
            return StorefrontApiFp(configuration).updateEmailList(storefront_oid, email_list_uuid, email_list, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email campaign folder
         * @param {number} storefront_oid 
         * @param {string} email_list_segment_folder_uuid 
         * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, email_list_segment_folder: EmailListSegmentFolder, options?: any) {
            return StorefrontApiFp(configuration).updateEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, email_list_segment_folder, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email plan
         * @param {number} storefront_oid 
         * @param {EmailPlan} settings plan request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPlan(storefront_oid: number, settings: EmailPlan, options?: any) {
            return StorefrontApiFp(configuration).updateEmailPlan(storefront_oid, settings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email postcard
         * @param {number} storefront_oid 
         * @param {string} commseq_postcard_uuid 
         * @param {EmailCommseqPostcard} email_commseq_postcard Email commseq postcard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard: EmailCommseqPostcard, options?: any) {
            return StorefrontApiFp(configuration).updateEmailPostcard(storefront_oid, commseq_postcard_uuid, email_commseq_postcard, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email segment
         * @param {number} storefront_oid 
         * @param {string} email_segment_uuid 
         * @param {EmailSegment} email_segment Email segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment: EmailSegment, options?: any) {
            return StorefrontApiFp(configuration).updateEmailSegment(storefront_oid, email_segment_uuid, email_segment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update email settings
         * @param {number} storefront_oid 
         * @param {EmailSettings} settings settings request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailSettings(storefront_oid: number, settings: EmailSettings, options?: any) {
            return StorefrontApiFp(configuration).updateEmailSettings(storefront_oid, settings, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update experiment
         * @param {number} storefront_oid 
         * @param {number} storefront_experiment_oid 
         * @param {Experiment} experiment Experiment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExperiment(storefront_oid: number, storefront_experiment_oid: number, experiment: Experiment, options?: any) {
            return StorefrontApiFp(configuration).updateExperiment(storefront_oid, storefront_experiment_oid, experiment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update library item. Note that only certain fields may be updated via this method.
         * @param {number} library_item_oid 
         * @param {LibraryItem} library_item Library item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryItem(library_item_oid: number, library_item: LibraryItem, options?: any) {
            return StorefrontApiFp(configuration).updateLibraryItem(library_item_oid, library_item, options)(fetch, basePath);
        },
        /**
         * Update merchant notes on a screen recording 
         * @summary Update merchant notes on a screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {ScreenRecordingMerchantNotesRequest} merchant_notes_request Merchant Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingMerchantNotes(storefront_oid: number, screen_recording_uuid: string, merchant_notes_request: ScreenRecordingMerchantNotesRequest, options?: any) {
            return StorefrontApiFp(configuration).updateScreenRecordingMerchantNotes(storefront_oid, screen_recording_uuid, merchant_notes_request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update screen recording segment
         * @param {number} storefront_oid 
         * @param {number} screen_recording_segment_oid 
         * @param {ScreenRecordingSegment} segment Segment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, segment: ScreenRecordingSegment, options?: any) {
            return StorefrontApiFp(configuration).updateScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, segment, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update screen recording settings
         * @param {number} storefront_oid 
         * @param {ScreenRecordingSettings} settings Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingSettings(storefront_oid: number, settings: ScreenRecordingSettings, options?: any) {
            return StorefrontApiFp(configuration).updateScreenRecordingSettings(storefront_oid, settings, options)(fetch, basePath);
        },
        /**
         * Update tags on a screen recording 
         * @summary Update tags on a screen recording
         * @param {number} storefront_oid 
         * @param {string} screen_recording_uuid 
         * @param {ScreenRecordingTagsRequest} tags Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreenRecordingTags(storefront_oid: number, screen_recording_uuid: string, tags: ScreenRecordingTagsRequest, options?: any) {
            return StorefrontApiFp(configuration).updateScreenRecordingTags(storefront_oid, screen_recording_uuid, tags, options)(fetch, basePath);
        },
        /**
         * Updates a transactional email 
         * @summary Updates a transaction email object
         * @param {number} storefront_oid 
         * @param {string} email_id 
         * @param {TransactionEmail} transaction_email TransactionEmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionEmail(storefront_oid: number, email_id: string, transaction_email: TransactionEmail, options?: any) {
            return StorefrontApiFp(configuration).updateTransactionEmail(storefront_oid, email_id, transaction_email, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update Twilio account
         * @param {string} esp_twilio_uuid 
         * @param {Twilio} twilio Twilio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwilioAccount(esp_twilio_uuid: string, twilio: Twilio, options?: any) {
            return StorefrontApiFp(configuration).updateTwilioAccount(esp_twilio_uuid, twilio, options)(fetch, basePath);
        },
    };
};

/**
 * StorefrontApi - interface
 * @export
 * @interface StorefrontApi
 */
export interface StorefrontApiInterface {
    /**
     * 
     * @summary Add to library
     * @param {AddLibraryItemRequest} add_library_request New library item request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    addToLibrary(add_library_request: AddLibraryItemRequest, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Apply library item to storefront.
     * @param {ApplyLibraryItemRequest} apply_library_request New library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    applyToStoreFront(apply_library_request: ApplyLibraryItemRequest, options?: any): Promise<ApplyLibraryItemResponse>;

    /**
     * 
     * @summary Archive email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    archiveEmailList(storefront_oid: number, email_list_uuid: string, options?: any): Promise<EmailListArchiveResponse>;

    /**
     * 
     * @summary Archive email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    archiveEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any): Promise<EmailSegmentArchiveResponse>;

    /**
     * 
     * @summary Back populate email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {EmailFlowBackPopulateRequest} back_populate_request The request to back populate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    backPopulateEmailFlow(storefront_oid: number, email_flow_uuid: string, back_populate_request: EmailFlowBackPopulateRequest, options?: any): Promise<EmailFlowBackPopulateResponse>;

    /**
     * 
     * @summary Check download of email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {string} email_segment_rebuild_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    checkDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment_rebuild_uuid: string, options?: any): Promise<EmailSegmentDownloadPrepareResponse>;

    /**
     * 
     * @summary Clone email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {number} [target_storefront_oid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    cloneEmailCampaign(storefront_oid: number, email_campaign_uuid: string, target_storefront_oid?: number, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Clone email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {number} [target_storefront_oid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    cloneEmailFlow(storefront_oid: number, email_flow_uuid: string, target_storefront_oid?: number, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Create email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    createEmailSendingDomain(domain: string, options?: any): Promise<EmailSendingDomainResponse>;

    /**
     * 
     * @summary Create Twilio account
     * @param {Twilio} twilio Twilio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    createTwilioAccount(twilio: Twilio, options?: any): Promise<TwilioResponse>;

    /**
     * 
     * @summary Delete email campaignFolder
     * @param {number} storefront_oid 
     * @param {string} email_campaign_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete communication sequence stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailCommseqStat(storefront_oid: number, commseq_uuid: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Delete email email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete email flowFolder
     * @param {number} storefront_oid 
     * @param {string} email_flow_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete email list customer
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailListCustomer(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete email ListSegmentFolder
     * @param {number} storefront_oid 
     * @param {string} email_list_segment_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete email postcard
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary delete email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteEmailSendingDomain(domain: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Delete experiment
     * @param {number} storefront_oid 
     * @param {number} storefront_experiment_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteExperiment(storefront_oid: number, storefront_experiment_oid: number, options?: any): Promise<{}>;

    /**
     * Delete screen recording heatmap 
     * @summary Delete screen recording heatmap
     * @param {number} storefront_oid 
     * @param {ScreenRecordingHeatmapReset} query Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapReset, options?: any): Promise<{}>;

    /**
     * 
     * @summary Delete library item
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteLibraryItem(library_item_oid: number, options?: any): Promise<{}>;

    /**
     * 
     * @summary Delete all published versions for a library item, including anything in review.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteLibraryItemPublishedVersions(library_item_oid: number, options?: any): Promise<{}>;

    /**
     * 
     * @summary Delete screen recording segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any): Promise<{}>;

    /**
     * 
     * @summary delete Twilio account
     * @param {string} esp_twilio_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    deleteTwilioAccount(esp_twilio_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Duplicate library item.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    duplicateLibraryItem(library_item_oid: number, options?: any): Promise<LibraryItemResponse>;

    /**
     * Update favorite flag on screen recording 
     * @summary Update favorite flag on screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    favoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Obtain lat/long for an address
     * @param {number} storefront_oid 
     * @param {GeocodeRequest} geocode_request geocode request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    geocodeAddress(storefront_oid: number, geocode_request: GeocodeRequest, options?: any): Promise<GeocodeResponse>;

    /**
     * Obtain a list of all the countries 
     * @summary Get countries
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getCountries(storefront_oid: number, options?: any): Promise<CountriesResponse>;

    /**
     * Fetches a temporary authentication token for the editor 
     * @summary Gets editor token
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEditorToken(storefront_oid: number, options?: any): Promise<EmailEditorTokenResponse>;

    /**
     * 
     * @summary Get email communication base templates
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailBaseTemplates(storefront_oid: number, options?: any): Promise<EmailBaseTemplateListResponse>;

    /**
     * 
     * @summary Get email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Get email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_campaign_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any): Promise<EmailCampaignFolderResponse>;

    /**
     * 
     * @summary Get email campaign folders
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaignFolders(storefront_oid: number, options?: any): Promise<EmailCampaignFoldersResponse>;

    /**
     * 
     * @summary Get email campaign screenshots
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaignScreenshots(storefront_oid: number, email_campaign_uuid: string, options?: any): Promise<ScreenshotsResponse>;

    /**
     * 
     * @summary Get email campaigns
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaigns(storefront_oid: number, options?: any): Promise<EmailCampaignsResponse>;

    /**
     * 
     * @summary Get email campaigns with stats
     * @param {number} storefront_oid 
     * @param {string} stat_days 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCampaignsWithStats(storefront_oid: number, stat_days: string, options?: any): Promise<EmailCampaignsResponse>;

    /**
     * 
     * @summary Get email commseq
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseq(storefront_oid: number, commseq_uuid: string, options?: any): Promise<EmailCommseqResponse>;

    /**
     * 
     * @summary Get email communication sequence emails stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStatSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqEmailStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatSummaryRequest, options?: any): Promise<EmailStatSummaryResponse>;

    /**
     * 
     * @summary Get email communication sequence postcard stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqPostcardStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any): Promise<EmailStatPostcardSummaryResponse>;

    /**
     * 
     * @summary Get communication sequence stats overall
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqStatOverall(storefront_oid: number, commseq_uuid: string, options?: any): Promise<EmailCommseqStatResponse>;

    /**
     * 
     * @summary Get email communication sequence step stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStepStatRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqStepStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStepStatRequest, options?: any): Promise<EmailStepStatResponse>;

    /**
     * 
     * @summary Get email communication sequence customers waiting at each requested step
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, waitingRequest: EmailStepWaitingRequest, options?: any): Promise<EmailStepWaitingResponse>;

    /**
     * 
     * @summary Get email webhook editor values
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqWebhookEditorValues(storefront_oid: number, commseq_uuid: string, options?: any): Promise<EmailWebhookEditorValuesResponse>;

    /**
     * 
     * @summary Get email commseqs
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCommseqs(storefront_oid: number, options?: any): Promise<EmailCommseqsResponse>;

    /**
     * 
     * @summary Get customers editor URL
     * @param {number} storefront_oid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCustomerEditorUrl(storefront_oid: number, email_customer_uuid: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email customers
     * @param {number} storefront_oid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {string} [searchEmailPrefix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailCustomers(storefront_oid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any): Promise<EmailCustomersResponse>;

    /**
     * 
     * @summary Get email dashboard activity
     * @param {number} storefront_oid 
     * @param {number} [last_records] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailDashboardActivity(storefront_oid: number, last_records?: number, options?: any): Promise<EmailDashboardActivityResponse>;

    /**
     * 
     * @summary Get dashboard stats
     * @param {number} storefront_oid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailDashboardStats(storefront_oid: number, days?: number, options?: any): Promise<EmailDashboardStatsResponse>;

    /**
     * 
     * @summary Get email dispatch logs
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailDispatchLogs(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any): Promise<EmailCommseqStepLogsResponse>;

    /**
     * 
     * @summary Get email email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any): Promise<EmailCommseqEmailResponse>;

    /**
     * 
     * @summary Get email email clicks
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {string} commseq_email_uuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailClicks(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any): Promise<EmailClicksResponse>;

    /**
     * 
     * @summary Get email order customer editor url
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {string} order_id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailCustomerEditorUrl(storefront_oid: number, commseq_email_uuid: string, order_id: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email email orders
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {string} commseq_email_uuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailOrders(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any): Promise<EmailOrdersResponse>;

    /**
     * 
     * @summary Get email emails
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmails(storefront_oid: number, options?: any): Promise<EmailCommseqEmailsResponse>;

    /**
     * 
     * @summary Get email emails multiple
     * @param {number} storefront_oid 
     * @param {EmailCommseqEmailsRequest} email_commseq_emails_request Request of email uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailEmailsMultiple(storefront_oid: number, email_commseq_emails_request: EmailCommseqEmailsRequest, options?: any): Promise<EmailCommseqEmailsResponse>;

    /**
     * 
     * @summary Get email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlow(storefront_oid: number, email_flow_uuid: string, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Get email flow folder
     * @param {number} storefront_oid 
     * @param {string} email_flow_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any): Promise<EmailFlowFolderResponse>;

    /**
     * 
     * @summary Get email flow folders
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlowFolders(storefront_oid: number, options?: any): Promise<EmailFlowFoldersResponse>;

    /**
     * 
     * @summary Get email flow screenshots
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlowScreenshots(storefront_oid: number, email_flow_uuid: string, options?: any): Promise<ScreenshotsResponse>;

    /**
     * 
     * @summary Get email flows
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailFlows(storefront_oid: number, options?: any): Promise<EmailFlowsResponse>;

    /**
     * 
     * @summary Get email globalsettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailGlobalSettings(options?: any): Promise<EmailGlobalSettingsResponse>;

    /**
     * 
     * @summary Get email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailList(storefront_oid: number, email_list_uuid: string, options?: any): Promise<EmailListResponse>;

    /**
     * 
     * @summary Get email list customer editor url
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailListCustomerEditorUrl(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email list customers
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailListCustomers(storefront_oid: number, email_list_uuid: string, pageNumber?: number, pageSize?: number, options?: any): Promise<EmailListCustomersResponse>;

    /**
     * 
     * @summary Get email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_list_segment_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any): Promise<EmailListSegmentFolderResponse>;

    /**
     * 
     * @summary Get email campaign folders
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailListSegmentFolders(storefront_oid: number, options?: any): Promise<EmailListSegmentFoldersResponse>;

    /**
     * 
     * @summary Get email lists
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailLists(storefront_oid: number, options?: any): Promise<EmailListsResponse>;

    /**
     * 
     * @summary Get email performance
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPerformance(storefront_oid: number, options?: any): Promise<EmailPerformanceResponse>;

    /**
     * 
     * @summary Get email plan
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPlan(storefront_oid: number, options?: any): Promise<EmailPlanResponse>;

    /**
     * 
     * @summary Get email postcard
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any): Promise<EmailCommseqPostcardResponse>;

    /**
     * 
     * @summary Get email postcards
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPostcards(storefront_oid: number, options?: any): Promise<EmailCommseqPostcardsResponse>;

    /**
     * 
     * @summary Get email postcards multiple
     * @param {number} storefront_oid 
     * @param {EmailCommseqPostcardsRequest} email_commseq_postcards_request Request of postcard uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailPostcardsMultiple(storefront_oid: number, email_commseq_postcards_request: EmailCommseqPostcardsRequest, options?: any): Promise<EmailCommseqPostcardsResponse>;

    /**
     * 
     * @summary Get email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any): Promise<EmailSegmentResponse>;

    /**
     * 
     * @summary Get email segment customers editor URL
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegmentCustomerEditorUrl(storefront_oid: number, email_segment_uuid: string, email_customer_uuid: string, options?: any): Promise<EmailCustomerEditorUrlResponse>;

    /**
     * 
     * @summary Get email segment customers
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, pageNumber?: number, pageSize?: number, options?: any): Promise<EmailSegmentCustomersResponse>;

    /**
     * 
     * @summary Get email segments
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSegments(storefront_oid: number, options?: any): Promise<EmailSegmentsResponse>;

    /**
     * 
     * @summary Get email sending domain
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSendingDomain(domain: string, options?: any): Promise<EmailSendingDomainResponse>;

    /**
     * 
     * @summary Get email sending domain status
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSendingDomainStatus(domain: string, options?: any): Promise<EmailSendingDomainResponse>;

    /**
     * 
     * @summary Get email sending domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSendingDomains(options?: any): Promise<EmailSendingDomainsResponse>;

    /**
     * 
     * @summary Get email settings
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailSettings(storefront_oid: number, options?: any): Promise<EmailSettingsResponse>;

    /**
     * 
     * @summary Get email template
     * @param {number} storefront_oid 
     * @param {number} email_template_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailTemplate(storefront_oid: number, email_template_oid: number, options?: any): Promise<EmailTemplate>;

    /**
     * 
     * @summary Get email templates
     * @param {number} storefront_oid 
     * @param {string} [trigger_type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailTemplates(storefront_oid: number, trigger_type?: string, options?: any): Promise<EmailTemplatesResponse>;

    /**
     * 
     * @summary Get a list of third party email providers
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getEmailThirdPartyProviders(storefront_oid: number, options?: any): Promise<EmailThirdPartyProvidersResponse>;

    /**
     * 
     * @summary Get experiments
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getExperiments(storefront_oid: number, options?: any): Promise<ExperimentsResponse>;

    /**
     * Get screen recording heatmap 
     * @summary Get screen recording heatmap
     * @param {number} storefront_oid 
     * @param {ScreenRecordingHeatmapRequest} query Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapRequest, options?: any): Promise<ScreenRecordingHeatmapResponse>;

    /**
     * Get screen recording heatmap index 
     * @summary Get screen recording heatmap index
     * @param {number} storefront_oid 
     * @param {ScreenRecordingHeatmapIndexRequest} query Query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getHeatmapIndex(storefront_oid: number, query: ScreenRecordingHeatmapIndexRequest, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<ScreenRecordingHeatmapIndexResponse>;

    /**
     * Obtain a list of property names for a given property type 
     * @summary Get histogram property names
     * @param {number} storefront_oid 
     * @param {string} [property_type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getHistogramPropertyNames(storefront_oid: number, property_type?: string, options?: any): Promise<EmailHistogramPropertyNamesResponse>;

    /**
     * Obtain a list of property values for a given property name and type 
     * @summary Get histogram property values
     * @param {number} storefront_oid 
     * @param {string} [property_name] 
     * @param {string} [property_type] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getHistogramPropertyValues(storefront_oid: number, property_name?: string, property_type?: string, limit?: number, options?: any): Promise<EmailHistogramPropertyValuesResponse>;

    /**
     * 
     * @summary Get library values used to populate drop down boxes for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getLibraryFilterValues(options?: any): Promise<LibraryFilterValuesResponse>;

    /**
     * 
     * @summary Get library item.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getLibraryItem(library_item_oid: number, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Get all published versions for a library item.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getLibraryItemPublishedVersions(library_item_oid: number, options?: any): Promise<LibraryItemsResponse>;

    /**
     * Get screen recording 
     * @summary Get screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any): Promise<ScreenRecordingResponse>;

    /**
     * Get screen recording page view data 
     * @summary Get screen recording page view data
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {string} screen_recording_page_view_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecordingPageViewData(storefront_oid: number, screen_recording_uuid: string, screen_recording_page_view_uuid: string, options?: any): Promise<ScreenRecordingPageViewDataResponse>;

    /**
     * 
     * @summary Get screen recording segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any): Promise<ScreenRecordingSegmentResponse>;

    /**
     * 
     * @summary Get screen recording segments
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecordingSegments(storefront_oid: number, options?: any): Promise<ScreenRecordingSegmentsResponse>;

    /**
     * 
     * @summary Get screen recording settings
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecordingSettings(storefront_oid: number, options?: any): Promise<ScreenRecordingSettingsResponse>;

    /**
     * Get tags used by screen recording 
     * @summary Get tags used by screen recording
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecordingTags(storefront_oid: number, options?: any): Promise<ScreenRecordingTagsResponse>;

    /**
     * Query screen recordings 
     * @summary Query screen recordings
     * @param {number} storefront_oid 
     * @param {ScreenRecordingQueryRequest} query Query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecordingsByQuery(storefront_oid: number, query: ScreenRecordingQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<ScreenRecordingQueryResponse>;

    /**
     * Get screen recordings by segment 
     * @summary Get screen recordings by segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getScreenRecordingsBySegment(storefront_oid: number, screen_recording_segment_oid: number, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<ScreenRecordingQueryResponse>;

    /**
     * Retrieves the pricing tiers 
     * @summary Retrieve pricing tiers
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getStoreFrontPricingTiers(_expand?: string, options?: any): Promise<PricingTiersResponse>;

    /**
     * 
     * @summary Get thumbnail parameters
     * @param {ThumbnailParametersRequest} thumbnail_parameters Thumbnail Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getThumbnailParameters(thumbnail_parameters: ThumbnailParametersRequest, options?: any): Promise<ThumbnailParametersResponse>;

    /**
     * Fetch a transactional email 
     * @summary Gets a transaction email object
     * @param {number} storefront_oid 
     * @param {string} email_id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTransactionEmail(storefront_oid: number, email_id: string, options?: any): Promise<TransactionEmailResponse>;

    /**
     * Obtain a list of all transactional emails and return back just their names 
     * @summary Gets a list of transaction email names
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTransactionEmailList(storefront_oid: number, options?: any): Promise<TransactionEmailListResponse>;

    /**
     * 
     * @summary Get transactional email screenshots
     * @param {number} storefront_oid 
     * @param {string} email_id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTransactionEmailScreenshots(storefront_oid: number, email_id: string, options?: any): Promise<ScreenshotsResponse>;

    /**
     * 
     * @summary Get Twilio account
     * @param {string} esp_twilio_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTwilioAccount(esp_twilio_uuid: string, options?: any): Promise<TwilioResponse>;

    /**
     * 
     * @summary Get all Twilio accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    getTwilioAccounts(options?: any): Promise<TwiliosResponse>;

    /**
     * 
     * @summary Globally unsubscribe a customer
     * @param {number} storefront_oid 
     * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    globalUnsubscribe(storefront_oid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any): Promise<EmailGlobalUnsubscribeResponse>;

    /**
     * 
     * @summary Import a third party provider list
     * @param {number} storefront_oid 
     * @param {EmailThirdPartyListImportRequest} import_request lists to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    importEmailThirdPartyProviderList(storefront_oid: number, import_request: EmailThirdPartyListImportRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary Insert email campaign
     * @param {number} storefront_oid 
     * @param {EmailCampaign} email_campaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailCampaign(storefront_oid: number, email_campaign: EmailCampaign, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Insert email campaign folder
     * @param {number} storefront_oid 
     * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailCampaignFolder(storefront_oid: number, email_campaign_folder: EmailCampaignFolder, options?: any): Promise<EmailCampaignFolderResponse>;

    /**
     * 
     * @summary Insert email commseq
     * @param {number} storefront_oid 
     * @param {EmailCommseq} email_commseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailCommseq(storefront_oid: number, email_commseq: EmailCommseq, options?: any): Promise<EmailCommseqResponse>;

    /**
     * 
     * @summary Insert email email
     * @param {number} storefront_oid 
     * @param {EmailCommseqEmail} email_commseq_email Email email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailEmail(storefront_oid: number, email_commseq_email: EmailCommseqEmail, options?: any): Promise<EmailCommseqEmailResponse>;

    /**
     * 
     * @summary Insert email flow
     * @param {number} storefront_oid 
     * @param {EmailFlow} email_flow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailFlow(storefront_oid: number, email_flow: EmailFlow, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Insert email flow folder
     * @param {number} storefront_oid 
     * @param {EmailFlowFolder} email_flow_folder Email flow folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailFlowFolder(storefront_oid: number, email_flow_folder: EmailFlowFolder, options?: any): Promise<EmailFlowFolderResponse>;

    /**
     * 
     * @summary Insert email list
     * @param {number} storefront_oid 
     * @param {EmailList} email_list Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailList(storefront_oid: number, email_list: EmailList, options?: any): Promise<EmailListResponse>;

    /**
     * 
     * @summary Insert email campaign folder
     * @param {number} storefront_oid 
     * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder: EmailListSegmentFolder, options?: any): Promise<EmailListSegmentFolderResponse>;

    /**
     * 
     * @summary Insert email postcard
     * @param {number} storefront_oid 
     * @param {EmailCommseqPostcard} email_commseq_postcard Email postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailPostcard(storefront_oid: number, email_commseq_postcard: EmailCommseqPostcard, options?: any): Promise<EmailCommseqPostcardResponse>;

    /**
     * 
     * @summary Insert email segment
     * @param {number} storefront_oid 
     * @param {EmailSegment} email_segment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertEmailSegment(storefront_oid: number, email_segment: EmailSegment, options?: any): Promise<EmailSegmentResponse>;

    /**
     * 
     * @summary Insert screen recording segment
     * @param {number} storefront_oid 
     * @param {ScreenRecordingSegment} segment Segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    insertScreenRecordingSegment(storefront_oid: number, segment: ScreenRecordingSegment, options?: any): Promise<ScreenRecordingSegmentResponse>;

    /**
     * 
     * @summary Prepare download of email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    prepareDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any): Promise<EmailSegmentDownloadPrepareResponse>;

    /**
     * 
     * @summary Publish library item.
     * @param {number} library_item_oid 
     * @param {PublishLibraryItemRequest} publish_library_request Publish library item request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    publishLibraryItem(library_item_oid: number, publish_library_request: PublishLibraryItemRequest, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Purchase public library item, which creates a copy of the item in your personal code library
     * @param {number} library_item_oid 
     * @param {number} [storefront_oid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    purchaseLibraryItem(library_item_oid: number, storefront_oid?: number, options?: any): Promise<LibraryItemResponse>;

    /**
     * 
     * @summary Release email communication sequence customers waiting at the specified step
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    releaseEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Request a review of an email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_review_request Email commseq email review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    review(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_review_request: EmailCommseqEmailSendTestRequest, options?: any): Promise<EmailCommseqEmailSendTestResponse>;

    /**
     * 
     * @summary Searches for all matching values
     * @param {string} [category] 
     * @param {string} [matches] 
     * @param {string} [storefront_oid] 
     * @param {number} [max_hits] 
     * @param {string} [subcategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    search(category?: string, matches?: string, storefront_oid?: string, max_hits?: number, subcategory?: string, options?: any): Promise<LookupResponse>;

    /**
     * 
     * @summary Searches for all matching values (using POST)
     * @param {LookupRequest} lookup_request LookupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    search2(lookup_request: LookupRequest, options?: any): Promise<LookupResponse>;

    /**
     * 
     * @summary Search email list customers
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchEmailListCustomers(storefront_oid: number, email_list_uuid: string, startsWith?: string, options?: any): Promise<EmailListCustomersResponse>;

    /**
     * 
     * @summary Search email segment customers
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, startsWith?: string, options?: any): Promise<EmailSegmentCustomersResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchLibraryItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchPublishedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items needing review or rejected
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchReviewItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    searchSharedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any): Promise<LibraryItemsResponse>;

    /**
     * 
     * @summary Send email test
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_test_request Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    sendEmailTest(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_test_request: EmailCommseqEmailSendTestRequest, options?: any): Promise<EmailCommseqEmailSendTestResponse>;

    /**
     * 
     * @summary Send postcard test
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {EmailCommseqPostcardSendTestRequest} email_commseq_postcard_test_request Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    sendPostcardTest(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard_test_request: EmailCommseqPostcardSendTestRequest, options?: any): Promise<EmailCommseqPostcardSendTestResponse>;

    /**
     * 
     * @summary Send webhook test
     * @param {number} storefront_oid 
     * @param {EmailCommseqWebhookSendTestRequest} email_commseq_webhook_test_request Email commseq webhook test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    sendWebhookTest(storefront_oid: number, email_commseq_webhook_test_request: EmailCommseqWebhookSendTestRequest, options?: any): Promise<EmailCommseqEmailSendTestResponse>;

    /**
     * 
     * @summary Start email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    startEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any): Promise<BaseResponse>;

    /**
     * 
     * @summary Subscribe customers to email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {Array<EmailCustomer>} customers Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    subscribeToEmailList(storefront_oid: number, email_list_uuid: string, customers: Array<EmailCustomer>, options?: any): Promise<EmailListSubscribeResponse>;

    /**
     * Remove favorite flag on screen recording 
     * @summary Remove favorite flag on screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    unfavoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Update email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {EmailCampaign} email_campaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailCampaign(storefront_oid: number, email_campaign_uuid: string, email_campaign: EmailCampaign, options?: any): Promise<EmailCampaignResponse>;

    /**
     * 
     * @summary Update email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_campaign_folder_uuid 
     * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, email_campaign_folder: EmailCampaignFolder, options?: any): Promise<EmailCampaignFolderResponse>;

    /**
     * 
     * @summary Update email commseq
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailCommseq} email_commseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailCommseq(storefront_oid: number, commseq_uuid: string, email_commseq: EmailCommseq, options?: any): Promise<EmailCommseqResponse>;

    /**
     * 
     * @summary Update email customer
     * @param {number} storefront_oid 
     * @param {string} email_customer_uuid 
     * @param {EmailCustomer} email_customer Email customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailCustomer(storefront_oid: number, email_customer_uuid: string, email_customer: EmailCustomer, options?: any): Promise<{}>;

    /**
     * 
     * @summary Update email email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {EmailCommseqEmail} email_commseq_email Email commseq email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailEmail(storefront_oid: number, commseq_email_uuid: string, email_commseq_email: EmailCommseqEmail, options?: any): Promise<EmailCommseqEmailResponse>;

    /**
     * 
     * @summary Update email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {EmailFlow} email_flow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailFlow(storefront_oid: number, email_flow_uuid: string, email_flow: EmailFlow, options?: any): Promise<EmailFlowResponse>;

    /**
     * 
     * @summary Update email flow folder
     * @param {number} storefront_oid 
     * @param {string} email_flow_folder_uuid 
     * @param {EmailFlowFolder} email_flow_folder Email flow folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, email_flow_folder: EmailFlowFolder, options?: any): Promise<EmailFlowFolderResponse>;

    /**
     * 
     * @summary Update email global settings
     * @param {EmailGlobalSettings} global_settings global settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailGlobalSettings(global_settings: EmailGlobalSettings, options?: any): Promise<EmailGlobalSettingsResponse>;

    /**
     * 
     * @summary Update email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {EmailList} email_list Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailList(storefront_oid: number, email_list_uuid: string, email_list: EmailList, options?: any): Promise<EmailListResponse>;

    /**
     * 
     * @summary Update email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_list_segment_folder_uuid 
     * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, email_list_segment_folder: EmailListSegmentFolder, options?: any): Promise<EmailListSegmentFolderResponse>;

    /**
     * 
     * @summary Update email plan
     * @param {number} storefront_oid 
     * @param {EmailPlan} settings plan request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailPlan(storefront_oid: number, settings: EmailPlan, options?: any): Promise<EmailPlanResponse>;

    /**
     * 
     * @summary Update email postcard
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {EmailCommseqPostcard} email_commseq_postcard Email commseq postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard: EmailCommseqPostcard, options?: any): Promise<EmailCommseqPostcardResponse>;

    /**
     * 
     * @summary Update email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {EmailSegment} email_segment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment: EmailSegment, options?: any): Promise<EmailSegmentResponse>;

    /**
     * 
     * @summary Update email settings
     * @param {number} storefront_oid 
     * @param {EmailSettings} settings settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateEmailSettings(storefront_oid: number, settings: EmailSettings, options?: any): Promise<EmailSettingsResponse>;

    /**
     * 
     * @summary Update experiment
     * @param {number} storefront_oid 
     * @param {number} storefront_experiment_oid 
     * @param {Experiment} experiment Experiment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateExperiment(storefront_oid: number, storefront_experiment_oid: number, experiment: Experiment, options?: any): Promise<ExperimentResponse>;

    /**
     * 
     * @summary Update library item. Note that only certain fields may be updated via this method.
     * @param {number} library_item_oid 
     * @param {LibraryItem} library_item Library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateLibraryItem(library_item_oid: number, library_item: LibraryItem, options?: any): Promise<LibraryItemResponse>;

    /**
     * Update merchant notes on a screen recording 
     * @summary Update merchant notes on a screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {ScreenRecordingMerchantNotesRequest} merchant_notes_request Merchant Notes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateScreenRecordingMerchantNotes(storefront_oid: number, screen_recording_uuid: string, merchant_notes_request: ScreenRecordingMerchantNotesRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary Update screen recording segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {ScreenRecordingSegment} segment Segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, segment: ScreenRecordingSegment, options?: any): Promise<ScreenRecordingSegmentResponse>;

    /**
     * 
     * @summary Update screen recording settings
     * @param {number} storefront_oid 
     * @param {ScreenRecordingSettings} settings Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateScreenRecordingSettings(storefront_oid: number, settings: ScreenRecordingSettings, options?: any): Promise<ScreenRecordingSettingsResponse>;

    /**
     * Update tags on a screen recording 
     * @summary Update tags on a screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {ScreenRecordingTagsRequest} tags Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateScreenRecordingTags(storefront_oid: number, screen_recording_uuid: string, tags: ScreenRecordingTagsRequest, options?: any): Promise<{}>;

    /**
     * Updates a transactional email 
     * @summary Updates a transaction email object
     * @param {number} storefront_oid 
     * @param {string} email_id 
     * @param {TransactionEmail} transaction_email TransactionEmail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateTransactionEmail(storefront_oid: number, email_id: string, transaction_email: TransactionEmail, options?: any): Promise<TransactionEmailResponse>;

    /**
     * 
     * @summary Update Twilio account
     * @param {string} esp_twilio_uuid 
     * @param {Twilio} twilio Twilio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApiInterface
     */
    updateTwilioAccount(esp_twilio_uuid: string, twilio: Twilio, options?: any): Promise<TwilioResponse>;

}

/**
 * StorefrontApi - object-oriented interface
 * @export
 * @class StorefrontApi
 * @extends {BaseAPI}
 */
export class StorefrontApi extends BaseAPI implements StorefrontApiInterface {
    /**
     * 
     * @summary Add to library
     * @param {AddLibraryItemRequest} add_library_request New library item request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public addToLibrary(add_library_request: AddLibraryItemRequest, options?: any) {
        return StorefrontApiFp(this.configuration).addToLibrary(add_library_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Apply library item to storefront.
     * @param {ApplyLibraryItemRequest} apply_library_request New library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public applyToStoreFront(apply_library_request: ApplyLibraryItemRequest, options?: any) {
        return StorefrontApiFp(this.configuration).applyToStoreFront(apply_library_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public archiveEmailList(storefront_oid: number, email_list_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).archiveEmailList(storefront_oid, email_list_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Archive email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public archiveEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).archiveEmailSegment(storefront_oid, email_segment_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Back populate email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {EmailFlowBackPopulateRequest} back_populate_request The request to back populate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public backPopulateEmailFlow(storefront_oid: number, email_flow_uuid: string, back_populate_request: EmailFlowBackPopulateRequest, options?: any) {
        return StorefrontApiFp(this.configuration).backPopulateEmailFlow(storefront_oid, email_flow_uuid, back_populate_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check download of email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {string} email_segment_rebuild_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public checkDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment_rebuild_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).checkDownloadEmailSegment(storefront_oid, email_segment_uuid, email_segment_rebuild_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clone email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {number} [target_storefront_oid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public cloneEmailCampaign(storefront_oid: number, email_campaign_uuid: string, target_storefront_oid?: number, options?: any) {
        return StorefrontApiFp(this.configuration).cloneEmailCampaign(storefront_oid, email_campaign_uuid, target_storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clone email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {number} [target_storefront_oid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public cloneEmailFlow(storefront_oid: number, email_flow_uuid: string, target_storefront_oid?: number, options?: any) {
        return StorefrontApiFp(this.configuration).cloneEmailFlow(storefront_oid, email_flow_uuid, target_storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public createEmailSendingDomain(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).createEmailSendingDomain(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create Twilio account
     * @param {Twilio} twilio Twilio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public createTwilioAccount(twilio: Twilio, options?: any) {
        return StorefrontApiFp(this.configuration).createTwilioAccount(twilio, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email campaignFolder
     * @param {number} storefront_oid 
     * @param {string} email_campaign_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete communication sequence stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailCommseqStat(storefront_oid: number, commseq_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailCommseqStat(storefront_oid, commseq_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailEmail(storefront_oid, commseq_email_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email flowFolder
     * @param {number} storefront_oid 
     * @param {string} email_flow_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailFlowFolder(storefront_oid, email_flow_folder_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email list customer
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailListCustomer(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailListCustomer(storefront_oid, email_list_uuid, email_customer_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email ListSegmentFolder
     * @param {number} storefront_oid 
     * @param {string} email_list_segment_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete email postcard
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailPostcard(storefront_oid, commseq_postcard_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary delete email campaign
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteEmailSendingDomain(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteEmailSendingDomain(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete experiment
     * @param {number} storefront_oid 
     * @param {number} storefront_experiment_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteExperiment(storefront_oid: number, storefront_experiment_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).deleteExperiment(storefront_oid, storefront_experiment_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete screen recording heatmap 
     * @summary Delete screen recording heatmap
     * @param {number} storefront_oid 
     * @param {ScreenRecordingHeatmapReset} query Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapReset, options?: any) {
        return StorefrontApiFp(this.configuration).deleteHeatmap(storefront_oid, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete library item
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteLibraryItem(library_item_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).deleteLibraryItem(library_item_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete all published versions for a library item, including anything in review.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteLibraryItemPublishedVersions(library_item_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).deleteLibraryItemPublishedVersions(library_item_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete screen recording segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).deleteScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary delete Twilio account
     * @param {string} esp_twilio_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public deleteTwilioAccount(esp_twilio_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).deleteTwilioAccount(esp_twilio_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Duplicate library item.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public duplicateLibraryItem(library_item_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).duplicateLibraryItem(library_item_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Update favorite flag on screen recording 
     * @summary Update favorite flag on screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public favoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).favoriteScreenRecording(storefront_oid, screen_recording_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Obtain lat/long for an address
     * @param {number} storefront_oid 
     * @param {GeocodeRequest} geocode_request geocode request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public geocodeAddress(storefront_oid: number, geocode_request: GeocodeRequest, options?: any) {
        return StorefrontApiFp(this.configuration).geocodeAddress(storefront_oid, geocode_request, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of all the countries 
     * @summary Get countries
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getCountries(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getCountries(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches a temporary authentication token for the editor 
     * @summary Gets editor token
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEditorToken(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEditorToken(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication base templates
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailBaseTemplates(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailBaseTemplates(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaign(storefront_oid, email_campaign_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_campaign_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign folders
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaignFolders(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaignFolders(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign screenshots
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaignScreenshots(storefront_oid: number, email_campaign_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaignScreenshots(storefront_oid, email_campaign_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaigns
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaigns(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaigns(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaigns with stats
     * @param {number} storefront_oid 
     * @param {string} stat_days 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCampaignsWithStats(storefront_oid: number, stat_days: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCampaignsWithStats(storefront_oid, stat_days, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email commseq
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseq(storefront_oid: number, commseq_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseq(storefront_oid, commseq_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence emails stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStatSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqEmailStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatSummaryRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqEmailStats(storefront_oid, commseq_uuid, statsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence postcard stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStatPostcardSummaryRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqPostcardStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStatPostcardSummaryRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqPostcardStats(storefront_oid, commseq_uuid, statsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get communication sequence stats overall
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqStatOverall(storefront_oid: number, commseq_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqStatOverall(storefront_oid, commseq_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence step stats
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStepStatRequest} statsRequest StatsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqStepStats(storefront_oid: number, commseq_uuid: string, statsRequest: EmailStepStatRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqStepStats(storefront_oid, commseq_uuid, statsRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email communication sequence customers waiting at each requested step
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailStepWaitingRequest} waitingRequest WaitingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, waitingRequest: EmailStepWaitingRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqStepWaiting(storefront_oid, commseq_uuid, waitingRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email webhook editor values
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqWebhookEditorValues(storefront_oid: number, commseq_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqWebhookEditorValues(storefront_oid, commseq_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email commseqs
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCommseqs(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCommseqs(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get customers editor URL
     * @param {number} storefront_oid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCustomerEditorUrl(storefront_oid: number, email_customer_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCustomerEditorUrl(storefront_oid, email_customer_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email customers
     * @param {number} storefront_oid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {string} [searchEmailPrefix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailCustomers(storefront_oid: number, pageNumber?: number, pageSize?: number, searchEmailPrefix?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailCustomers(storefront_oid, pageNumber, pageSize, searchEmailPrefix, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email dashboard activity
     * @param {number} storefront_oid 
     * @param {number} [last_records] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailDashboardActivity(storefront_oid: number, last_records?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailDashboardActivity(storefront_oid, last_records, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get dashboard stats
     * @param {number} storefront_oid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailDashboardStats(storefront_oid: number, days?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailDashboardStats(storefront_oid, days, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email dispatch logs
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailDispatchLogs(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailDispatchLogs(storefront_oid, commseq_uuid, commseq_step_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmail(storefront_oid: number, commseq_email_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmail(storefront_oid, commseq_email_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email email clicks
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {string} commseq_email_uuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailClicks(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailClicks(storefront_oid, commseq_uuid, commseq_step_uuid, commseq_email_uuid, days, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email order customer editor url
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {string} order_id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailCustomerEditorUrl(storefront_oid: number, commseq_email_uuid: string, order_id: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailCustomerEditorUrl(storefront_oid, commseq_email_uuid, order_id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email email orders
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {string} commseq_email_uuid 
     * @param {number} [days] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailOrders(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, commseq_email_uuid: string, days?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailOrders(storefront_oid, commseq_uuid, commseq_step_uuid, commseq_email_uuid, days, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email emails
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmails(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmails(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email emails multiple
     * @param {number} storefront_oid 
     * @param {EmailCommseqEmailsRequest} email_commseq_emails_request Request of email uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailEmailsMultiple(storefront_oid: number, email_commseq_emails_request: EmailCommseqEmailsRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailEmailsMultiple(storefront_oid, email_commseq_emails_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlow(storefront_oid: number, email_flow_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlow(storefront_oid, email_flow_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flow folder
     * @param {number} storefront_oid 
     * @param {string} email_flow_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlowFolder(storefront_oid, email_flow_folder_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flow folders
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlowFolders(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlowFolders(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flow screenshots
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlowScreenshots(storefront_oid: number, email_flow_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlowScreenshots(storefront_oid, email_flow_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email flows
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailFlows(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailFlows(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email globalsettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailGlobalSettings(options?: any) {
        return StorefrontApiFp(this.configuration).getEmailGlobalSettings(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailList(storefront_oid: number, email_list_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailList(storefront_oid, email_list_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email list customer editor url
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailListCustomerEditorUrl(storefront_oid: number, email_list_uuid: string, email_customer_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailListCustomerEditorUrl(storefront_oid, email_list_uuid, email_customer_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email list customers
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailListCustomers(storefront_oid: number, email_list_uuid: string, pageNumber?: number, pageSize?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailListCustomers(storefront_oid, email_list_uuid, pageNumber, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_list_segment_folder_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email campaign folders
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailListSegmentFolders(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailListSegmentFolders(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email lists
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailLists(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailLists(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email performance
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPerformance(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPerformance(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email plan
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPlan(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPlan(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email postcard
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPostcard(storefront_oid, commseq_postcard_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email postcards
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPostcards(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPostcards(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email postcards multiple
     * @param {number} storefront_oid 
     * @param {EmailCommseqPostcardsRequest} email_commseq_postcards_request Request of postcard uuids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailPostcardsMultiple(storefront_oid: number, email_commseq_postcards_request: EmailCommseqPostcardsRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailPostcardsMultiple(storefront_oid, email_commseq_postcards_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegment(storefront_oid, email_segment_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segment customers editor URL
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {string} email_customer_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegmentCustomerEditorUrl(storefront_oid: number, email_segment_uuid: string, email_customer_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegmentCustomerEditorUrl(storefront_oid, email_segment_uuid, email_customer_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segment customers
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, pageNumber?: number, pageSize?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegmentCustomers(storefront_oid, email_segment_uuid, pageNumber, pageSize, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email segments
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSegments(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSegments(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email sending domain
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSendingDomain(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSendingDomain(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email sending domain status
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSendingDomainStatus(domain: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSendingDomainStatus(domain, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email sending domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSendingDomains(options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSendingDomains(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email settings
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailSettings(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailSettings(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email template
     * @param {number} storefront_oid 
     * @param {number} email_template_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailTemplate(storefront_oid: number, email_template_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailTemplate(storefront_oid, email_template_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get email templates
     * @param {number} storefront_oid 
     * @param {string} [trigger_type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailTemplates(storefront_oid: number, trigger_type?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailTemplates(storefront_oid, trigger_type, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a list of third party email providers
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getEmailThirdPartyProviders(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getEmailThirdPartyProviders(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get experiments
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getExperiments(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getExperiments(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Get screen recording heatmap 
     * @summary Get screen recording heatmap
     * @param {number} storefront_oid 
     * @param {ScreenRecordingHeatmapRequest} query Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getHeatmap(storefront_oid: number, query: ScreenRecordingHeatmapRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getHeatmap(storefront_oid, query, options)(this.fetch, this.basePath);
    }

    /**
     * Get screen recording heatmap index 
     * @summary Get screen recording heatmap index
     * @param {number} storefront_oid 
     * @param {ScreenRecordingHeatmapIndexRequest} query Query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getHeatmapIndex(storefront_oid: number, query: ScreenRecordingHeatmapIndexRequest, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getHeatmapIndex(storefront_oid, query, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of property names for a given property type 
     * @summary Get histogram property names
     * @param {number} storefront_oid 
     * @param {string} [property_type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getHistogramPropertyNames(storefront_oid: number, property_type?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getHistogramPropertyNames(storefront_oid, property_type, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of property values for a given property name and type 
     * @summary Get histogram property values
     * @param {number} storefront_oid 
     * @param {string} [property_name] 
     * @param {string} [property_type] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getHistogramPropertyValues(storefront_oid: number, property_name?: string, property_type?: string, limit?: number, options?: any) {
        return StorefrontApiFp(this.configuration).getHistogramPropertyValues(storefront_oid, property_name, property_type, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get library values used to populate drop down boxes for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getLibraryFilterValues(options?: any) {
        return StorefrontApiFp(this.configuration).getLibraryFilterValues(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get library item.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getLibraryItem(library_item_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getLibraryItem(library_item_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all published versions for a library item.
     * @param {number} library_item_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getLibraryItemPublishedVersions(library_item_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getLibraryItemPublishedVersions(library_item_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Get screen recording 
     * @summary Get screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecording(storefront_oid, screen_recording_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * Get screen recording page view data 
     * @summary Get screen recording page view data
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {string} screen_recording_page_view_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecordingPageViewData(storefront_oid: number, screen_recording_uuid: string, screen_recording_page_view_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecordingPageViewData(storefront_oid, screen_recording_uuid, screen_recording_page_view_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get screen recording segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get screen recording segments
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecordingSegments(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecordingSegments(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get screen recording settings
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecordingSettings(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecordingSettings(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Get tags used by screen recording 
     * @summary Get tags used by screen recording
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecordingTags(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecordingTags(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Query screen recordings 
     * @summary Query screen recordings
     * @param {number} storefront_oid 
     * @param {ScreenRecordingQueryRequest} query Query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecordingsByQuery(storefront_oid: number, query: ScreenRecordingQueryRequest, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecordingsByQuery(storefront_oid, query, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

    /**
     * Get screen recordings by segment 
     * @summary Get screen recordings by segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Default 100, Max 500)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getScreenRecordingsBySegment(storefront_oid: number, screen_recording_segment_oid: number, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getScreenRecordingsBySegment(storefront_oid, screen_recording_segment_oid, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the pricing tiers 
     * @summary Retrieve pricing tiers
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getStoreFrontPricingTiers(_expand?: string, options?: any) {
        return StorefrontApiFp(this.configuration).getStoreFrontPricingTiers(_expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get thumbnail parameters
     * @param {ThumbnailParametersRequest} thumbnail_parameters Thumbnail Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getThumbnailParameters(thumbnail_parameters: ThumbnailParametersRequest, options?: any) {
        return StorefrontApiFp(this.configuration).getThumbnailParameters(thumbnail_parameters, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a transactional email 
     * @summary Gets a transaction email object
     * @param {number} storefront_oid 
     * @param {string} email_id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTransactionEmail(storefront_oid: number, email_id: string, options?: any) {
        return StorefrontApiFp(this.configuration).getTransactionEmail(storefront_oid, email_id, options)(this.fetch, this.basePath);
    }

    /**
     * Obtain a list of all transactional emails and return back just their names 
     * @summary Gets a list of transaction email names
     * @param {number} storefront_oid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTransactionEmailList(storefront_oid: number, options?: any) {
        return StorefrontApiFp(this.configuration).getTransactionEmailList(storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get transactional email screenshots
     * @param {number} storefront_oid 
     * @param {string} email_id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTransactionEmailScreenshots(storefront_oid: number, email_id: string, options?: any) {
        return StorefrontApiFp(this.configuration).getTransactionEmailScreenshots(storefront_oid, email_id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Twilio account
     * @param {string} esp_twilio_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTwilioAccount(esp_twilio_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).getTwilioAccount(esp_twilio_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all Twilio accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public getTwilioAccounts(options?: any) {
        return StorefrontApiFp(this.configuration).getTwilioAccounts(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Globally unsubscribe a customer
     * @param {number} storefront_oid 
     * @param {EmailGlobalUnsubscribeRequest} unsubscribe Unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public globalUnsubscribe(storefront_oid: number, unsubscribe: EmailGlobalUnsubscribeRequest, options?: any) {
        return StorefrontApiFp(this.configuration).globalUnsubscribe(storefront_oid, unsubscribe, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Import a third party provider list
     * @param {number} storefront_oid 
     * @param {EmailThirdPartyListImportRequest} import_request lists to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public importEmailThirdPartyProviderList(storefront_oid: number, import_request: EmailThirdPartyListImportRequest, options?: any) {
        return StorefrontApiFp(this.configuration).importEmailThirdPartyProviderList(storefront_oid, import_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email campaign
     * @param {number} storefront_oid 
     * @param {EmailCampaign} email_campaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailCampaign(storefront_oid: number, email_campaign: EmailCampaign, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailCampaign(storefront_oid, email_campaign, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email campaign folder
     * @param {number} storefront_oid 
     * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailCampaignFolder(storefront_oid: number, email_campaign_folder: EmailCampaignFolder, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailCampaignFolder(storefront_oid, email_campaign_folder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email commseq
     * @param {number} storefront_oid 
     * @param {EmailCommseq} email_commseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailCommseq(storefront_oid: number, email_commseq: EmailCommseq, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailCommseq(storefront_oid, email_commseq, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email email
     * @param {number} storefront_oid 
     * @param {EmailCommseqEmail} email_commseq_email Email email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailEmail(storefront_oid: number, email_commseq_email: EmailCommseqEmail, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailEmail(storefront_oid, email_commseq_email, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email flow
     * @param {number} storefront_oid 
     * @param {EmailFlow} email_flow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailFlow(storefront_oid: number, email_flow: EmailFlow, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailFlow(storefront_oid, email_flow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email flow folder
     * @param {number} storefront_oid 
     * @param {EmailFlowFolder} email_flow_folder Email flow folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailFlowFolder(storefront_oid: number, email_flow_folder: EmailFlowFolder, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailFlowFolder(storefront_oid, email_flow_folder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email list
     * @param {number} storefront_oid 
     * @param {EmailList} email_list Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailList(storefront_oid: number, email_list: EmailList, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailList(storefront_oid, email_list, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email campaign folder
     * @param {number} storefront_oid 
     * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder: EmailListSegmentFolder, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailListSegmentFolder(storefront_oid, email_list_segment_folder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email postcard
     * @param {number} storefront_oid 
     * @param {EmailCommseqPostcard} email_commseq_postcard Email postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailPostcard(storefront_oid: number, email_commseq_postcard: EmailCommseqPostcard, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailPostcard(storefront_oid, email_commseq_postcard, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert email segment
     * @param {number} storefront_oid 
     * @param {EmailSegment} email_segment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertEmailSegment(storefront_oid: number, email_segment: EmailSegment, options?: any) {
        return StorefrontApiFp(this.configuration).insertEmailSegment(storefront_oid, email_segment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Insert screen recording segment
     * @param {number} storefront_oid 
     * @param {ScreenRecordingSegment} segment Segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public insertScreenRecordingSegment(storefront_oid: number, segment: ScreenRecordingSegment, options?: any) {
        return StorefrontApiFp(this.configuration).insertScreenRecordingSegment(storefront_oid, segment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Prepare download of email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public prepareDownloadEmailSegment(storefront_oid: number, email_segment_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).prepareDownloadEmailSegment(storefront_oid, email_segment_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Publish library item.
     * @param {number} library_item_oid 
     * @param {PublishLibraryItemRequest} publish_library_request Publish library item request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public publishLibraryItem(library_item_oid: number, publish_library_request: PublishLibraryItemRequest, options?: any) {
        return StorefrontApiFp(this.configuration).publishLibraryItem(library_item_oid, publish_library_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Purchase public library item, which creates a copy of the item in your personal code library
     * @param {number} library_item_oid 
     * @param {number} [storefront_oid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public purchaseLibraryItem(library_item_oid: number, storefront_oid?: number, options?: any) {
        return StorefrontApiFp(this.configuration).purchaseLibraryItem(library_item_oid, storefront_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Release email communication sequence customers waiting at the specified step
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {string} commseq_step_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public releaseEmailCommseqStepWaiting(storefront_oid: number, commseq_uuid: string, commseq_step_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).releaseEmailCommseqStepWaiting(storefront_oid, commseq_uuid, commseq_step_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Request a review of an email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_review_request Email commseq email review request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public review(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_review_request: EmailCommseqEmailSendTestRequest, options?: any) {
        return StorefrontApiFp(this.configuration).review(storefront_oid, commseq_email_uuid, email_commseq_email_review_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Searches for all matching values
     * @param {string} [category] 
     * @param {string} [matches] 
     * @param {string} [storefront_oid] 
     * @param {number} [max_hits] 
     * @param {string} [subcategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public search(category?: string, matches?: string, storefront_oid?: string, max_hits?: number, subcategory?: string, options?: any) {
        return StorefrontApiFp(this.configuration).search(category, matches, storefront_oid, max_hits, subcategory, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Searches for all matching values (using POST)
     * @param {LookupRequest} lookup_request LookupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public search2(lookup_request: LookupRequest, options?: any) {
        return StorefrontApiFp(this.configuration).search2(lookup_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search email list customers
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchEmailListCustomers(storefront_oid: number, email_list_uuid: string, startsWith?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchEmailListCustomers(storefront_oid, email_list_uuid, startsWith, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Search email segment customers
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {string} [startsWith] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchEmailSegmentCustomers(storefront_oid: number, email_segment_uuid: string, startsWith?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchEmailSegmentCustomers(storefront_oid, email_segment_uuid, startsWith, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchLibraryItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchLibraryItems(item_query, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchPublishedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchPublishedItems(item_query, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items needing review or rejected
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchReviewItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchReviewItems(item_query, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a library items based on a query object.  If no parameters are specified, the API call will default to the merchant id only.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @summary Retrieve library items
     * @param {LibraryItemQuery} item_query Item query
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Maximum 10000)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the library items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public searchSharedItems(item_query: LibraryItemQuery, _limit?: number, _offset?: number, _sort?: string, options?: any) {
        return StorefrontApiFp(this.configuration).searchSharedItems(item_query, _limit, _offset, _sort, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send email test
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {EmailCommseqEmailSendTestRequest} email_commseq_email_test_request Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public sendEmailTest(storefront_oid: number, commseq_email_uuid: string, email_commseq_email_test_request: EmailCommseqEmailSendTestRequest, options?: any) {
        return StorefrontApiFp(this.configuration).sendEmailTest(storefront_oid, commseq_email_uuid, email_commseq_email_test_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send postcard test
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {EmailCommseqPostcardSendTestRequest} email_commseq_postcard_test_request Email commseq email test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public sendPostcardTest(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard_test_request: EmailCommseqPostcardSendTestRequest, options?: any) {
        return StorefrontApiFp(this.configuration).sendPostcardTest(storefront_oid, commseq_postcard_uuid, email_commseq_postcard_test_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Send webhook test
     * @param {number} storefront_oid 
     * @param {EmailCommseqWebhookSendTestRequest} email_commseq_webhook_test_request Email commseq webhook test request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public sendWebhookTest(storefront_oid: number, email_commseq_webhook_test_request: EmailCommseqWebhookSendTestRequest, options?: any) {
        return StorefrontApiFp(this.configuration).sendWebhookTest(storefront_oid, email_commseq_webhook_test_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public startEmailCampaign(storefront_oid: number, email_campaign_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).startEmailCampaign(storefront_oid, email_campaign_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Subscribe customers to email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {Array<EmailCustomer>} customers Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public subscribeToEmailList(storefront_oid: number, email_list_uuid: string, customers: Array<EmailCustomer>, options?: any) {
        return StorefrontApiFp(this.configuration).subscribeToEmailList(storefront_oid, email_list_uuid, customers, options)(this.fetch, this.basePath);
    }

    /**
     * Remove favorite flag on screen recording 
     * @summary Remove favorite flag on screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public unfavoriteScreenRecording(storefront_oid: number, screen_recording_uuid: string, options?: any) {
        return StorefrontApiFp(this.configuration).unfavoriteScreenRecording(storefront_oid, screen_recording_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email campaign
     * @param {number} storefront_oid 
     * @param {string} email_campaign_uuid 
     * @param {EmailCampaign} email_campaign Email campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailCampaign(storefront_oid: number, email_campaign_uuid: string, email_campaign: EmailCampaign, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailCampaign(storefront_oid, email_campaign_uuid, email_campaign, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_campaign_folder_uuid 
     * @param {EmailCampaignFolder} email_campaign_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailCampaignFolder(storefront_oid: number, email_campaign_folder_uuid: string, email_campaign_folder: EmailCampaignFolder, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailCampaignFolder(storefront_oid, email_campaign_folder_uuid, email_campaign_folder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email commseq
     * @param {number} storefront_oid 
     * @param {string} commseq_uuid 
     * @param {EmailCommseq} email_commseq Email commseq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailCommseq(storefront_oid: number, commseq_uuid: string, email_commseq: EmailCommseq, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailCommseq(storefront_oid, commseq_uuid, email_commseq, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email customer
     * @param {number} storefront_oid 
     * @param {string} email_customer_uuid 
     * @param {EmailCustomer} email_customer Email customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailCustomer(storefront_oid: number, email_customer_uuid: string, email_customer: EmailCustomer, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailCustomer(storefront_oid, email_customer_uuid, email_customer, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email email
     * @param {number} storefront_oid 
     * @param {string} commseq_email_uuid 
     * @param {EmailCommseqEmail} email_commseq_email Email commseq email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailEmail(storefront_oid: number, commseq_email_uuid: string, email_commseq_email: EmailCommseqEmail, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailEmail(storefront_oid, commseq_email_uuid, email_commseq_email, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email flow
     * @param {number} storefront_oid 
     * @param {string} email_flow_uuid 
     * @param {EmailFlow} email_flow Email flow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailFlow(storefront_oid: number, email_flow_uuid: string, email_flow: EmailFlow, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailFlow(storefront_oid, email_flow_uuid, email_flow, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email flow folder
     * @param {number} storefront_oid 
     * @param {string} email_flow_folder_uuid 
     * @param {EmailFlowFolder} email_flow_folder Email flow folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailFlowFolder(storefront_oid: number, email_flow_folder_uuid: string, email_flow_folder: EmailFlowFolder, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailFlowFolder(storefront_oid, email_flow_folder_uuid, email_flow_folder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email global settings
     * @param {EmailGlobalSettings} global_settings global settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailGlobalSettings(global_settings: EmailGlobalSettings, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailGlobalSettings(global_settings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email list
     * @param {number} storefront_oid 
     * @param {string} email_list_uuid 
     * @param {EmailList} email_list Email list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailList(storefront_oid: number, email_list_uuid: string, email_list: EmailList, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailList(storefront_oid, email_list_uuid, email_list, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email campaign folder
     * @param {number} storefront_oid 
     * @param {string} email_list_segment_folder_uuid 
     * @param {EmailListSegmentFolder} email_list_segment_folder Email campaign folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailListSegmentFolder(storefront_oid: number, email_list_segment_folder_uuid: string, email_list_segment_folder: EmailListSegmentFolder, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailListSegmentFolder(storefront_oid, email_list_segment_folder_uuid, email_list_segment_folder, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email plan
     * @param {number} storefront_oid 
     * @param {EmailPlan} settings plan request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailPlan(storefront_oid: number, settings: EmailPlan, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailPlan(storefront_oid, settings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email postcard
     * @param {number} storefront_oid 
     * @param {string} commseq_postcard_uuid 
     * @param {EmailCommseqPostcard} email_commseq_postcard Email commseq postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailPostcard(storefront_oid: number, commseq_postcard_uuid: string, email_commseq_postcard: EmailCommseqPostcard, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailPostcard(storefront_oid, commseq_postcard_uuid, email_commseq_postcard, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email segment
     * @param {number} storefront_oid 
     * @param {string} email_segment_uuid 
     * @param {EmailSegment} email_segment Email segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailSegment(storefront_oid: number, email_segment_uuid: string, email_segment: EmailSegment, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailSegment(storefront_oid, email_segment_uuid, email_segment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update email settings
     * @param {number} storefront_oid 
     * @param {EmailSettings} settings settings request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateEmailSettings(storefront_oid: number, settings: EmailSettings, options?: any) {
        return StorefrontApiFp(this.configuration).updateEmailSettings(storefront_oid, settings, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update experiment
     * @param {number} storefront_oid 
     * @param {number} storefront_experiment_oid 
     * @param {Experiment} experiment Experiment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateExperiment(storefront_oid: number, storefront_experiment_oid: number, experiment: Experiment, options?: any) {
        return StorefrontApiFp(this.configuration).updateExperiment(storefront_oid, storefront_experiment_oid, experiment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update library item. Note that only certain fields may be updated via this method.
     * @param {number} library_item_oid 
     * @param {LibraryItem} library_item Library item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateLibraryItem(library_item_oid: number, library_item: LibraryItem, options?: any) {
        return StorefrontApiFp(this.configuration).updateLibraryItem(library_item_oid, library_item, options)(this.fetch, this.basePath);
    }

    /**
     * Update merchant notes on a screen recording 
     * @summary Update merchant notes on a screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {ScreenRecordingMerchantNotesRequest} merchant_notes_request Merchant Notes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateScreenRecordingMerchantNotes(storefront_oid: number, screen_recording_uuid: string, merchant_notes_request: ScreenRecordingMerchantNotesRequest, options?: any) {
        return StorefrontApiFp(this.configuration).updateScreenRecordingMerchantNotes(storefront_oid, screen_recording_uuid, merchant_notes_request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update screen recording segment
     * @param {number} storefront_oid 
     * @param {number} screen_recording_segment_oid 
     * @param {ScreenRecordingSegment} segment Segment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateScreenRecordingSegment(storefront_oid: number, screen_recording_segment_oid: number, segment: ScreenRecordingSegment, options?: any) {
        return StorefrontApiFp(this.configuration).updateScreenRecordingSegment(storefront_oid, screen_recording_segment_oid, segment, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update screen recording settings
     * @param {number} storefront_oid 
     * @param {ScreenRecordingSettings} settings Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateScreenRecordingSettings(storefront_oid: number, settings: ScreenRecordingSettings, options?: any) {
        return StorefrontApiFp(this.configuration).updateScreenRecordingSettings(storefront_oid, settings, options)(this.fetch, this.basePath);
    }

    /**
     * Update tags on a screen recording 
     * @summary Update tags on a screen recording
     * @param {number} storefront_oid 
     * @param {string} screen_recording_uuid 
     * @param {ScreenRecordingTagsRequest} tags Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateScreenRecordingTags(storefront_oid: number, screen_recording_uuid: string, tags: ScreenRecordingTagsRequest, options?: any) {
        return StorefrontApiFp(this.configuration).updateScreenRecordingTags(storefront_oid, screen_recording_uuid, tags, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a transactional email 
     * @summary Updates a transaction email object
     * @param {number} storefront_oid 
     * @param {string} email_id 
     * @param {TransactionEmail} transaction_email TransactionEmail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateTransactionEmail(storefront_oid: number, email_id: string, transaction_email: TransactionEmail, options?: any) {
        return StorefrontApiFp(this.configuration).updateTransactionEmail(storefront_oid, email_id, transaction_email, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update Twilio account
     * @param {string} esp_twilio_uuid 
     * @param {Twilio} twilio Twilio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorefrontApi
     */
    public updateTwilioAccount(esp_twilio_uuid: string, twilio: Twilio, options?: any) {
        return StorefrontApiFp(this.configuration).updateTwilioAccount(esp_twilio_uuid, twilio, options)(this.fetch, this.basePath);
    }

}

/**
 * TaxApi - fetch parameter creator
 * @export
 */
export const TaxApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Self tax provider city. 
         * @summary Deletes a Self tax provider city
         * @param {string} city The city being deleted.
         * @param {TaxCity} tax_city tax city to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCity(city: string, tax_city: TaxCity, options: any = {}): FetchArgs {
            // verify required parameter 'city' is not null or undefined
            if (city === null || city === undefined) {
                throw new RequiredError('city','Required parameter city was null or undefined when calling deleteTaxProviderSelfCity.');
            }
            // verify required parameter 'tax_city' is not null or undefined
            if (tax_city === null || tax_city === undefined) {
                throw new RequiredError('tax_city','Required parameter tax_city was null or undefined when calling deleteTaxProviderSelfCity.');
            }
            const localVarPath = `/tax/providers/self/city/{city}`
                .replace(`{${"city"}}`, encodeURIComponent(String(city)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCity" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_city || {}) : (tax_city || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider country. 
         * @summary Deletes a Self tax provider country
         * @param {string} countryCode The country code being deleted.
         * @param {TaxCountry} tax_country tax country to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options: any = {}): FetchArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling deleteTaxProviderSelfCountry.');
            }
            // verify required parameter 'tax_country' is not null or undefined
            if (tax_country === null || tax_country === undefined) {
                throw new RequiredError('tax_country','Required parameter tax_country was null or undefined when calling deleteTaxProviderSelfCountry.');
            }
            const localVarPath = `/tax/providers/self/country/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCountry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_country || {}) : (tax_country || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider county. 
         * @summary Deletes a Self tax provider county
         * @param {string} county The county being deleted.
         * @param {TaxCounty} tax_county tax county to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options: any = {}): FetchArgs {
            // verify required parameter 'county' is not null or undefined
            if (county === null || county === undefined) {
                throw new RequiredError('county','Required parameter county was null or undefined when calling deleteTaxProviderSelfCounty.');
            }
            // verify required parameter 'tax_county' is not null or undefined
            if (tax_county === null || tax_county === undefined) {
                throw new RequiredError('tax_county','Required parameter tax_county was null or undefined when calling deleteTaxProviderSelfCounty.');
            }
            const localVarPath = `/tax/providers/self/county/{county}`
                .replace(`{${"county"}}`, encodeURIComponent(String(county)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCounty" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_county || {}) : (tax_county || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider postalCode. 
         * @summary Deletes a Self tax provider postalCode
         * @param {string} postal_code The postal code being deleted.
         * @param {TaxPostalCode} tax_postal_code tax postal code to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options: any = {}): FetchArgs {
            // verify required parameter 'postal_code' is not null or undefined
            if (postal_code === null || postal_code === undefined) {
                throw new RequiredError('postal_code','Required parameter postal_code was null or undefined when calling deleteTaxProviderSelfPostalCode.');
            }
            // verify required parameter 'tax_postal_code' is not null or undefined
            if (tax_postal_code === null || tax_postal_code === undefined) {
                throw new RequiredError('tax_postal_code','Required parameter tax_postal_code was null or undefined when calling deleteTaxProviderSelfPostalCode.');
            }
            const localVarPath = `/tax/providers/self/postalCode/{postal_code}`
                .replace(`{${"postal_code"}}`, encodeURIComponent(String(postal_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxPostalCode" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_postal_code || {}) : (tax_postal_code || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Self tax provider state. 
         * @summary Deletes a Self tax provider state
         * @param {string} stateCode The state code being deleted.
         * @param {TaxState} tax_state tax state to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfState(stateCode: string, tax_state: TaxState, options: any = {}): FetchArgs {
            // verify required parameter 'stateCode' is not null or undefined
            if (stateCode === null || stateCode === undefined) {
                throw new RequiredError('stateCode','Required parameter stateCode was null or undefined when calling deleteTaxProviderSelfState.');
            }
            // verify required parameter 'tax_state' is not null or undefined
            if (tax_state === null || tax_state === undefined) {
                throw new RequiredError('tax_state','Required parameter tax_state was null or undefined when calling deleteTaxProviderSelfState.');
            }
            const localVarPath = `/tax/providers/self/state/{stateCode}`
                .replace(`{${"stateCode"}}`, encodeURIComponent(String(stateCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_state || {}) : (tax_state || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Avalara tax provider. 
         * @summary Retrieve the Avalara tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalara(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/avalara`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Avalara Tax companies configured by the merchant 
         * @summary Returns Avalara Tax companies configured by the merchant
         * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraCompanies(tax_provider_avalara: TaxProviderAvalara, options: any = {}): FetchArgs {
            // verify required parameter 'tax_provider_avalara' is not null or undefined
            if (tax_provider_avalara === null || tax_provider_avalara === undefined) {
                throw new RequiredError('tax_provider_avalara','Required parameter tax_provider_avalara was null or undefined when calling getTaxProviderAvalaraCompanies.');
            }
            const localVarPath = `/tax/providers/avalara/companies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderAvalara" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_provider_avalara || {}) : (tax_provider_avalara || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to connect to Avalara and returns back the response. 
         * @summary Attempts to connect to Avalara and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraTest(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/avalara/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Self tax provider. 
         * @summary Retrieve the Self tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelf(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Self tax provider countries. 
         * @summary Retrieve the Self tax provider countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfCountries(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/self/countries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Self tax provider regions for a given country code. 
         * @summary Retrieve the Self tax provider regions for a given country code
         * @param {string} countryCode The country code regions desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfRegionsByCountryCode(countryCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling getTaxProviderSelfRegionsByCountryCode.');
            }
            const localVarPath = `/tax/providers/self/regions/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Sovos tax provider. 
         * @summary Retrieve the Sovos tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovos(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/sovos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to connect to Sovos and returns back the response. 
         * @summary Attempts to connect to Sovos and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovosTest(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/sovos/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the TaxJar tax provider. 
         * @summary Retrieve the TaxJar tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJar(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/taxjar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to connect to TaxJar and returns back the response. 
         * @summary Attempts to connect to TaxJar and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJarTest(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/taxjar/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the UltraCart tax provider. 
         * @summary Retrieve the UltraCart tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderUltraCart(options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers/ultracart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves tax methods for this account. 
         * @summary Retrieve tax methods
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviders(_limit?: number, _offset?: number, _expand?: string, options: any = {}): FetchArgs {
            const localVarPath = `/tax/providers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_expand !== undefined) {
                localVarQueryParameter['_expand'] = _expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle a tax provider to active. 
         * @summary Toggle a tax provider to active
         * @param {string} providerName The tax provider to set active.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveTaxProvider(providerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'providerName' is not null or undefined
            if (providerName === null || providerName === undefined) {
                throw new RequiredError('providerName','Required parameter providerName was null or undefined when calling setActiveTaxProvider.');
            }
            const localVarPath = `/tax/providers/setActive/{providerName}`
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Avalara tax provider. 
         * @summary Update the Avalara tax provider
         * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderAvalara(tax_provider_avalara: TaxProviderAvalara, options: any = {}): FetchArgs {
            // verify required parameter 'tax_provider_avalara' is not null or undefined
            if (tax_provider_avalara === null || tax_provider_avalara === undefined) {
                throw new RequiredError('tax_provider_avalara','Required parameter tax_provider_avalara was null or undefined when calling updateTaxProviderAvalara.');
            }
            const localVarPath = `/tax/providers/avalara`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderAvalara" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_provider_avalara || {}) : (tax_provider_avalara || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Self tax provider. 
         * @summary Update the Self tax provider
         * @param {TaxProviderSelf} tax_provider_self TaxProviderSelf object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelf(tax_provider_self: TaxProviderSelf, options: any = {}): FetchArgs {
            // verify required parameter 'tax_provider_self' is not null or undefined
            if (tax_provider_self === null || tax_provider_self === undefined) {
                throw new RequiredError('tax_provider_self','Required parameter tax_provider_self was null or undefined when calling updateTaxProviderSelf.');
            }
            const localVarPath = `/tax/providers/self`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderSelf" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_provider_self || {}) : (tax_provider_self || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider city. 
         * @summary Updates a Self tax provider city
         * @param {string} city The city being updated.
         * @param {TaxCity} tax_city tax city to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCity(city: string, tax_city: TaxCity, options: any = {}): FetchArgs {
            // verify required parameter 'city' is not null or undefined
            if (city === null || city === undefined) {
                throw new RequiredError('city','Required parameter city was null or undefined when calling updateTaxProviderSelfCity.');
            }
            // verify required parameter 'tax_city' is not null or undefined
            if (tax_city === null || tax_city === undefined) {
                throw new RequiredError('tax_city','Required parameter tax_city was null or undefined when calling updateTaxProviderSelfCity.');
            }
            const localVarPath = `/tax/providers/self/city/{city}`
                .replace(`{${"city"}}`, encodeURIComponent(String(city)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCity" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_city || {}) : (tax_city || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider country. 
         * @summary Updates a Self tax provider country
         * @param {string} countryCode The country code being updated.
         * @param {TaxCountry} tax_country tax country to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options: any = {}): FetchArgs {
            // verify required parameter 'countryCode' is not null or undefined
            if (countryCode === null || countryCode === undefined) {
                throw new RequiredError('countryCode','Required parameter countryCode was null or undefined when calling updateTaxProviderSelfCountry.');
            }
            // verify required parameter 'tax_country' is not null or undefined
            if (tax_country === null || tax_country === undefined) {
                throw new RequiredError('tax_country','Required parameter tax_country was null or undefined when calling updateTaxProviderSelfCountry.');
            }
            const localVarPath = `/tax/providers/self/country/{countryCode}`
                .replace(`{${"countryCode"}}`, encodeURIComponent(String(countryCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCountry" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_country || {}) : (tax_country || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider county. 
         * @summary Updates a Self tax provider county
         * @param {string} county The county being updated.
         * @param {TaxCounty} tax_county tax county to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options: any = {}): FetchArgs {
            // verify required parameter 'county' is not null or undefined
            if (county === null || county === undefined) {
                throw new RequiredError('county','Required parameter county was null or undefined when calling updateTaxProviderSelfCounty.');
            }
            // verify required parameter 'tax_county' is not null or undefined
            if (tax_county === null || tax_county === undefined) {
                throw new RequiredError('tax_county','Required parameter tax_county was null or undefined when calling updateTaxProviderSelfCounty.');
            }
            const localVarPath = `/tax/providers/self/county/{county}`
                .replace(`{${"county"}}`, encodeURIComponent(String(county)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxCounty" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_county || {}) : (tax_county || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider postalCode. 
         * @summary Updates a Self tax provider postalCode
         * @param {string} postal_code The postal code being updated.
         * @param {TaxPostalCode} tax_postal_code tax postal code to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options: any = {}): FetchArgs {
            // verify required parameter 'postal_code' is not null or undefined
            if (postal_code === null || postal_code === undefined) {
                throw new RequiredError('postal_code','Required parameter postal_code was null or undefined when calling updateTaxProviderSelfPostalCode.');
            }
            // verify required parameter 'tax_postal_code' is not null or undefined
            if (tax_postal_code === null || tax_postal_code === undefined) {
                throw new RequiredError('tax_postal_code','Required parameter tax_postal_code was null or undefined when calling updateTaxProviderSelfPostalCode.');
            }
            const localVarPath = `/tax/providers/self/postalCode/{postal_code}`
                .replace(`{${"postal_code"}}`, encodeURIComponent(String(postal_code)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxPostalCode" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_postal_code || {}) : (tax_postal_code || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Self tax provider state. 
         * @summary Updates a Self tax provider state
         * @param {string} stateCode The state code being updated.
         * @param {TaxState} tax_state tax state to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfState(stateCode: string, tax_state: TaxState, options: any = {}): FetchArgs {
            // verify required parameter 'stateCode' is not null or undefined
            if (stateCode === null || stateCode === undefined) {
                throw new RequiredError('stateCode','Required parameter stateCode was null or undefined when calling updateTaxProviderSelfState.');
            }
            // verify required parameter 'tax_state' is not null or undefined
            if (tax_state === null || tax_state === undefined) {
                throw new RequiredError('tax_state','Required parameter tax_state was null or undefined when calling updateTaxProviderSelfState.');
            }
            const localVarPath = `/tax/providers/self/state/{stateCode}`
                .replace(`{${"stateCode"}}`, encodeURIComponent(String(stateCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxState" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_state || {}) : (tax_state || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Sovos tax provider. 
         * @summary Update the Sovos tax provider
         * @param {TaxProviderSovos} tax_provider_sovos TaxProviderSovos object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSovos(tax_provider_sovos: TaxProviderSovos, options: any = {}): FetchArgs {
            // verify required parameter 'tax_provider_sovos' is not null or undefined
            if (tax_provider_sovos === null || tax_provider_sovos === undefined) {
                throw new RequiredError('tax_provider_sovos','Required parameter tax_provider_sovos was null or undefined when calling updateTaxProviderSovos.');
            }
            const localVarPath = `/tax/providers/sovos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderSovos" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_provider_sovos || {}) : (tax_provider_sovos || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the TaxJar tax provider. 
         * @summary Update the TaxJar tax provider
         * @param {TaxProviderTaxJar} tax_provider_taxJar TaxProviderTaxJar object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderTaxJar(tax_provider_taxJar: TaxProviderTaxJar, options: any = {}): FetchArgs {
            // verify required parameter 'tax_provider_taxJar' is not null or undefined
            if (tax_provider_taxJar === null || tax_provider_taxJar === undefined) {
                throw new RequiredError('tax_provider_taxJar','Required parameter tax_provider_taxJar was null or undefined when calling updateTaxProviderTaxJar.');
            }
            const localVarPath = `/tax/providers/taxjar`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderTaxJar" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_provider_taxJar || {}) : (tax_provider_taxJar || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the UltraCart tax provider. 
         * @summary Update the UltraCart tax provider
         * @param {TaxProviderUltraCart} tax_provider_ultracart TaxProviderUltraCart object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderUltraCart(tax_provider_ultracart: TaxProviderUltraCart, options: any = {}): FetchArgs {
            // verify required parameter 'tax_provider_ultracart' is not null or undefined
            if (tax_provider_ultracart === null || tax_provider_ultracart === undefined) {
                throw new RequiredError('tax_provider_ultracart','Required parameter tax_provider_ultracart was null or undefined when calling updateTaxProviderUltraCart.');
            }
            const localVarPath = `/tax/providers/ultracart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["tax_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaxProviderUltraCart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(tax_provider_ultracart || {}) : (tax_provider_ultracart || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxApi - functional programming interface
 * @export
 */
export const TaxApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a Self tax provider city. 
         * @summary Deletes a Self tax provider city
         * @param {string} city The city being deleted.
         * @param {TaxCity} tax_city tax city to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfCity(city, tax_city, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider country. 
         * @summary Deletes a Self tax provider country
         * @param {string} countryCode The country code being deleted.
         * @param {TaxCountry} tax_country tax country to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfCountry(countryCode, tax_country, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider county. 
         * @summary Deletes a Self tax provider county
         * @param {string} county The county being deleted.
         * @param {TaxCounty} tax_county tax county to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfCounty(county, tax_county, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider postalCode. 
         * @summary Deletes a Self tax provider postalCode
         * @param {string} postal_code The postal code being deleted.
         * @param {TaxPostalCode} tax_postal_code tax postal code to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfPostalCode(postal_code, tax_postal_code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Self tax provider state. 
         * @summary Deletes a Self tax provider state
         * @param {string} stateCode The state code being deleted.
         * @param {TaxState} tax_state tax state to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).deleteTaxProviderSelfState(stateCode, tax_state, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Avalara tax provider. 
         * @summary Retrieve the Avalara tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalara(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderAvalara> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderAvalara(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns Avalara Tax companies configured by the merchant 
         * @summary Returns Avalara Tax companies configured by the merchant
         * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraCompanies(tax_provider_avalara: TaxProviderAvalara, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderAvalaraCompaniesResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderAvalaraCompanies(tax_provider_avalara, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Attempts to connect to Avalara and returns back the response. 
         * @summary Attempts to connect to Avalara and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraTest(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTestResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderAvalaraTest(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Self tax provider. 
         * @summary Retrieve the Self tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelf(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelf> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSelf(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Self tax provider countries. 
         * @summary Retrieve the Self tax provider countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfCountries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelfCountriesResponse> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSelfCountries(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Self tax provider regions for a given country code. 
         * @summary Retrieve the Self tax provider regions for a given country code
         * @param {string} countryCode The country code regions desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelfRegionsResponse> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSelfRegionsByCountryCode(countryCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the Sovos tax provider. 
         * @summary Retrieve the Sovos tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSovos> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSovos(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Attempts to connect to Sovos and returns back the response. 
         * @summary Attempts to connect to Sovos and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovosTest(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTestResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderSovosTest(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the TaxJar tax provider. 
         * @summary Retrieve the TaxJar tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJar(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTaxJar> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderTaxJar(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Attempts to connect to TaxJar and returns back the response. 
         * @summary Attempts to connect to TaxJar and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJarTest(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTestResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderTaxJarTest(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the UltraCart tax provider. 
         * @summary Retrieve the UltraCart tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderUltraCart(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderUltraCart> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviderUltraCart(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves tax methods for this account. 
         * @summary Retrieve tax methods
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviders(_limit?: number, _offset?: number, _expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProvidersResponse> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).getTaxProviders(_limit, _offset, _expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Toggle a tax provider to active. 
         * @summary Toggle a tax provider to active
         * @param {string} providerName The tax provider to set active.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveTaxProvider(providerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderActivateResult> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).setActiveTaxProvider(providerName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Avalara tax provider. 
         * @summary Update the Avalara tax provider
         * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderAvalara(tax_provider_avalara: TaxProviderAvalara, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderAvalara> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderAvalara(tax_provider_avalara, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Self tax provider. 
         * @summary Update the Self tax provider
         * @param {TaxProviderSelf} tax_provider_self TaxProviderSelf object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelf(tax_provider_self: TaxProviderSelf, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSelf> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelf(tax_provider_self, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider city. 
         * @summary Updates a Self tax provider city
         * @param {string} city The city being updated.
         * @param {TaxCity} tax_city tax city to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxCity> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfCity(city, tax_city, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider country. 
         * @summary Updates a Self tax provider country
         * @param {string} countryCode The country code being updated.
         * @param {TaxCountry} tax_country tax country to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxCountry> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfCountry(countryCode, tax_country, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider county. 
         * @summary Updates a Self tax provider county
         * @param {string} county The county being updated.
         * @param {TaxCounty} tax_county tax county to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxCounty> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfCounty(county, tax_county, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider postalCode. 
         * @summary Updates a Self tax provider postalCode
         * @param {string} postal_code The postal code being updated.
         * @param {TaxPostalCode} tax_postal_code tax postal code to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxPostalCode> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfPostalCode(postal_code, tax_postal_code, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Self tax provider state. 
         * @summary Updates a Self tax provider state
         * @param {string} stateCode The state code being updated.
         * @param {TaxState} tax_state tax state to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxState> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSelfState(stateCode, tax_state, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Sovos tax provider. 
         * @summary Update the Sovos tax provider
         * @param {TaxProviderSovos} tax_provider_sovos TaxProviderSovos object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSovos(tax_provider_sovos: TaxProviderSovos, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderSovos> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderSovos(tax_provider_sovos, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the TaxJar tax provider. 
         * @summary Update the TaxJar tax provider
         * @param {TaxProviderTaxJar} tax_provider_taxJar TaxProviderTaxJar object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderTaxJar(tax_provider_taxJar: TaxProviderTaxJar, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderTaxJar> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderTaxJar(tax_provider_taxJar, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the UltraCart tax provider. 
         * @summary Update the UltraCart tax provider
         * @param {TaxProviderUltraCart} tax_provider_ultracart TaxProviderUltraCart object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderUltraCart(tax_provider_ultracart: TaxProviderUltraCart, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxProviderUltraCart> {
            const localVarFetchArgs = TaxApiFetchParamCreator(configuration).updateTaxProviderUltraCart(tax_provider_ultracart, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaxApi - factory interface
 * @export
 */
export const TaxApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a Self tax provider city. 
         * @summary Deletes a Self tax provider city
         * @param {string} city The city being deleted.
         * @param {TaxCity} tax_city tax city to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfCity(city, tax_city, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider country. 
         * @summary Deletes a Self tax provider country
         * @param {string} countryCode The country code being deleted.
         * @param {TaxCountry} tax_country tax country to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfCountry(countryCode, tax_country, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider county. 
         * @summary Deletes a Self tax provider county
         * @param {string} county The county being deleted.
         * @param {TaxCounty} tax_county tax county to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfCounty(county, tax_county, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider postalCode. 
         * @summary Deletes a Self tax provider postalCode
         * @param {string} postal_code The postal code being deleted.
         * @param {TaxPostalCode} tax_postal_code tax postal code to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfPostalCode(postal_code, tax_postal_code, options)(fetch, basePath);
        },
        /**
         * Deletes a Self tax provider state. 
         * @summary Deletes a Self tax provider state
         * @param {string} stateCode The state code being deleted.
         * @param {TaxState} tax_state tax state to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any) {
            return TaxApiFp(configuration).deleteTaxProviderSelfState(stateCode, tax_state, options)(fetch, basePath);
        },
        /**
         * Retrieves the Avalara tax provider. 
         * @summary Retrieve the Avalara tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalara(options?: any) {
            return TaxApiFp(configuration).getTaxProviderAvalara(options)(fetch, basePath);
        },
        /**
         * Returns Avalara Tax companies configured by the merchant 
         * @summary Returns Avalara Tax companies configured by the merchant
         * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraCompanies(tax_provider_avalara: TaxProviderAvalara, options?: any) {
            return TaxApiFp(configuration).getTaxProviderAvalaraCompanies(tax_provider_avalara, options)(fetch, basePath);
        },
        /**
         * Attempts to connect to Avalara and returns back the response. 
         * @summary Attempts to connect to Avalara and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderAvalaraTest(options?: any) {
            return TaxApiFp(configuration).getTaxProviderAvalaraTest(options)(fetch, basePath);
        },
        /**
         * Retrieves the Self tax provider. 
         * @summary Retrieve the Self tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelf(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSelf(options)(fetch, basePath);
        },
        /**
         * Retrieves the Self tax provider countries. 
         * @summary Retrieve the Self tax provider countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfCountries(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSelfCountries(options)(fetch, basePath);
        },
        /**
         * Retrieves the Self tax provider regions for a given country code. 
         * @summary Retrieve the Self tax provider regions for a given country code
         * @param {string} countryCode The country code regions desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any) {
            return TaxApiFp(configuration).getTaxProviderSelfRegionsByCountryCode(countryCode, options)(fetch, basePath);
        },
        /**
         * Retrieves the Sovos tax provider. 
         * @summary Retrieve the Sovos tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovos(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSovos(options)(fetch, basePath);
        },
        /**
         * Attempts to connect to Sovos and returns back the response. 
         * @summary Attempts to connect to Sovos and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderSovosTest(options?: any) {
            return TaxApiFp(configuration).getTaxProviderSovosTest(options)(fetch, basePath);
        },
        /**
         * Retrieves the TaxJar tax provider. 
         * @summary Retrieve the TaxJar tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJar(options?: any) {
            return TaxApiFp(configuration).getTaxProviderTaxJar(options)(fetch, basePath);
        },
        /**
         * Attempts to connect to TaxJar and returns back the response. 
         * @summary Attempts to connect to TaxJar and returns back the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderTaxJarTest(options?: any) {
            return TaxApiFp(configuration).getTaxProviderTaxJarTest(options)(fetch, basePath);
        },
        /**
         * Retrieves the UltraCart tax provider. 
         * @summary Retrieve the UltraCart tax provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviderUltraCart(options?: any) {
            return TaxApiFp(configuration).getTaxProviderUltraCart(options)(fetch, basePath);
        },
        /**
         * Retrieves tax methods for this account. 
         * @summary Retrieve tax methods
         * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxProviders(_limit?: number, _offset?: number, _expand?: string, options?: any) {
            return TaxApiFp(configuration).getTaxProviders(_limit, _offset, _expand, options)(fetch, basePath);
        },
        /**
         * Toggle a tax provider to active. 
         * @summary Toggle a tax provider to active
         * @param {string} providerName The tax provider to set active.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setActiveTaxProvider(providerName: string, options?: any) {
            return TaxApiFp(configuration).setActiveTaxProvider(providerName, options)(fetch, basePath);
        },
        /**
         * Update the Avalara tax provider. 
         * @summary Update the Avalara tax provider
         * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderAvalara(tax_provider_avalara: TaxProviderAvalara, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderAvalara(tax_provider_avalara, options)(fetch, basePath);
        },
        /**
         * Update the Self tax provider. 
         * @summary Update the Self tax provider
         * @param {TaxProviderSelf} tax_provider_self TaxProviderSelf object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelf(tax_provider_self: TaxProviderSelf, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelf(tax_provider_self, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider city. 
         * @summary Updates a Self tax provider city
         * @param {string} city The city being updated.
         * @param {TaxCity} tax_city tax city to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfCity(city, tax_city, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider country. 
         * @summary Updates a Self tax provider country
         * @param {string} countryCode The country code being updated.
         * @param {TaxCountry} tax_country tax country to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfCountry(countryCode, tax_country, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider county. 
         * @summary Updates a Self tax provider county
         * @param {string} county The county being updated.
         * @param {TaxCounty} tax_county tax county to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfCounty(county, tax_county, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider postalCode. 
         * @summary Updates a Self tax provider postalCode
         * @param {string} postal_code The postal code being updated.
         * @param {TaxPostalCode} tax_postal_code tax postal code to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfPostalCode(postal_code, tax_postal_code, options)(fetch, basePath);
        },
        /**
         * Updates a Self tax provider state. 
         * @summary Updates a Self tax provider state
         * @param {string} stateCode The state code being updated.
         * @param {TaxState} tax_state tax state to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSelfState(stateCode, tax_state, options)(fetch, basePath);
        },
        /**
         * Update the Sovos tax provider. 
         * @summary Update the Sovos tax provider
         * @param {TaxProviderSovos} tax_provider_sovos TaxProviderSovos object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderSovos(tax_provider_sovos: TaxProviderSovos, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderSovos(tax_provider_sovos, options)(fetch, basePath);
        },
        /**
         * Update the TaxJar tax provider. 
         * @summary Update the TaxJar tax provider
         * @param {TaxProviderTaxJar} tax_provider_taxJar TaxProviderTaxJar object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderTaxJar(tax_provider_taxJar: TaxProviderTaxJar, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderTaxJar(tax_provider_taxJar, options)(fetch, basePath);
        },
        /**
         * Update the UltraCart tax provider. 
         * @summary Update the UltraCart tax provider
         * @param {TaxProviderUltraCart} tax_provider_ultracart TaxProviderUltraCart object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxProviderUltraCart(tax_provider_ultracart: TaxProviderUltraCart, options?: any) {
            return TaxApiFp(configuration).updateTaxProviderUltraCart(tax_provider_ultracart, options)(fetch, basePath);
        },
    };
};

/**
 * TaxApi - interface
 * @export
 * @interface TaxApi
 */
export interface TaxApiInterface {
    /**
     * Deletes a Self tax provider city. 
     * @summary Deletes a Self tax provider city
     * @param {string} city The city being deleted.
     * @param {TaxCity} tax_city tax city to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider country. 
     * @summary Deletes a Self tax provider country
     * @param {string} countryCode The country code being deleted.
     * @param {TaxCountry} tax_country tax country to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider county. 
     * @summary Deletes a Self tax provider county
     * @param {string} county The county being deleted.
     * @param {TaxCounty} tax_county tax county to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider postalCode. 
     * @summary Deletes a Self tax provider postalCode
     * @param {string} postal_code The postal code being deleted.
     * @param {TaxPostalCode} tax_postal_code tax postal code to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any): Promise<{}>;

    /**
     * Deletes a Self tax provider state. 
     * @summary Deletes a Self tax provider state
     * @param {string} stateCode The state code being deleted.
     * @param {TaxState} tax_state tax state to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    deleteTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any): Promise<{}>;

    /**
     * Retrieves the Avalara tax provider. 
     * @summary Retrieve the Avalara tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderAvalara(options?: any): Promise<TaxProviderAvalara>;

    /**
     * Returns Avalara Tax companies configured by the merchant 
     * @summary Returns Avalara Tax companies configured by the merchant
     * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderAvalaraCompanies(tax_provider_avalara: TaxProviderAvalara, options?: any): Promise<TaxProviderAvalaraCompaniesResult>;

    /**
     * Attempts to connect to Avalara and returns back the response. 
     * @summary Attempts to connect to Avalara and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderAvalaraTest(options?: any): Promise<TaxProviderTestResult>;

    /**
     * Retrieves the Self tax provider. 
     * @summary Retrieve the Self tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSelf(options?: any): Promise<TaxProviderSelf>;

    /**
     * Retrieves the Self tax provider countries. 
     * @summary Retrieve the Self tax provider countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSelfCountries(options?: any): Promise<TaxProviderSelfCountriesResponse>;

    /**
     * Retrieves the Self tax provider regions for a given country code. 
     * @summary Retrieve the Self tax provider regions for a given country code
     * @param {string} countryCode The country code regions desired.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any): Promise<TaxProviderSelfRegionsResponse>;

    /**
     * Retrieves the Sovos tax provider. 
     * @summary Retrieve the Sovos tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSovos(options?: any): Promise<TaxProviderSovos>;

    /**
     * Attempts to connect to Sovos and returns back the response. 
     * @summary Attempts to connect to Sovos and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderSovosTest(options?: any): Promise<TaxProviderTestResult>;

    /**
     * Retrieves the TaxJar tax provider. 
     * @summary Retrieve the TaxJar tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderTaxJar(options?: any): Promise<TaxProviderTaxJar>;

    /**
     * Attempts to connect to TaxJar and returns back the response. 
     * @summary Attempts to connect to TaxJar and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderTaxJarTest(options?: any): Promise<TaxProviderTestResult>;

    /**
     * Retrieves the UltraCart tax provider. 
     * @summary Retrieve the UltraCart tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviderUltraCart(options?: any): Promise<TaxProviderUltraCart>;

    /**
     * Retrieves tax methods for this account. 
     * @summary Retrieve tax methods
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    getTaxProviders(_limit?: number, _offset?: number, _expand?: string, options?: any): Promise<TaxProvidersResponse>;

    /**
     * Toggle a tax provider to active. 
     * @summary Toggle a tax provider to active
     * @param {string} providerName The tax provider to set active.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    setActiveTaxProvider(providerName: string, options?: any): Promise<TaxProviderActivateResult>;

    /**
     * Update the Avalara tax provider. 
     * @summary Update the Avalara tax provider
     * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderAvalara(tax_provider_avalara: TaxProviderAvalara, options?: any): Promise<TaxProviderAvalara>;

    /**
     * Update the Self tax provider. 
     * @summary Update the Self tax provider
     * @param {TaxProviderSelf} tax_provider_self TaxProviderSelf object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelf(tax_provider_self: TaxProviderSelf, options?: any): Promise<TaxProviderSelf>;

    /**
     * Updates a Self tax provider city. 
     * @summary Updates a Self tax provider city
     * @param {string} city The city being updated.
     * @param {TaxCity} tax_city tax city to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any): Promise<TaxCity>;

    /**
     * Updates a Self tax provider country. 
     * @summary Updates a Self tax provider country
     * @param {string} countryCode The country code being updated.
     * @param {TaxCountry} tax_country tax country to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any): Promise<TaxCountry>;

    /**
     * Updates a Self tax provider county. 
     * @summary Updates a Self tax provider county
     * @param {string} county The county being updated.
     * @param {TaxCounty} tax_county tax county to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any): Promise<TaxCounty>;

    /**
     * Updates a Self tax provider postalCode. 
     * @summary Updates a Self tax provider postalCode
     * @param {string} postal_code The postal code being updated.
     * @param {TaxPostalCode} tax_postal_code tax postal code to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any): Promise<TaxPostalCode>;

    /**
     * Updates a Self tax provider state. 
     * @summary Updates a Self tax provider state
     * @param {string} stateCode The state code being updated.
     * @param {TaxState} tax_state tax state to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any): Promise<TaxState>;

    /**
     * Update the Sovos tax provider. 
     * @summary Update the Sovos tax provider
     * @param {TaxProviderSovos} tax_provider_sovos TaxProviderSovos object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderSovos(tax_provider_sovos: TaxProviderSovos, options?: any): Promise<TaxProviderSovos>;

    /**
     * Update the TaxJar tax provider. 
     * @summary Update the TaxJar tax provider
     * @param {TaxProviderTaxJar} tax_provider_taxJar TaxProviderTaxJar object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderTaxJar(tax_provider_taxJar: TaxProviderTaxJar, options?: any): Promise<TaxProviderTaxJar>;

    /**
     * Update the UltraCart tax provider. 
     * @summary Update the UltraCart tax provider
     * @param {TaxProviderUltraCart} tax_provider_ultracart TaxProviderUltraCart object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApiInterface
     */
    updateTaxProviderUltraCart(tax_provider_ultracart: TaxProviderUltraCart, options?: any): Promise<TaxProviderUltraCart>;

}

/**
 * TaxApi - object-oriented interface
 * @export
 * @class TaxApi
 * @extends {BaseAPI}
 */
export class TaxApi extends BaseAPI implements TaxApiInterface {
    /**
     * Deletes a Self tax provider city. 
     * @summary Deletes a Self tax provider city
     * @param {string} city The city being deleted.
     * @param {TaxCity} tax_city tax city to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfCity(city, tax_city, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider country. 
     * @summary Deletes a Self tax provider country
     * @param {string} countryCode The country code being deleted.
     * @param {TaxCountry} tax_country tax country to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfCountry(countryCode, tax_country, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider county. 
     * @summary Deletes a Self tax provider county
     * @param {string} county The county being deleted.
     * @param {TaxCounty} tax_county tax county to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfCounty(county, tax_county, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider postalCode. 
     * @summary Deletes a Self tax provider postalCode
     * @param {string} postal_code The postal code being deleted.
     * @param {TaxPostalCode} tax_postal_code tax postal code to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfPostalCode(postal_code, tax_postal_code, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Self tax provider state. 
     * @summary Deletes a Self tax provider state
     * @param {string} stateCode The state code being deleted.
     * @param {TaxState} tax_state tax state to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public deleteTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any) {
        return TaxApiFp(this.configuration).deleteTaxProviderSelfState(stateCode, tax_state, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Avalara tax provider. 
     * @summary Retrieve the Avalara tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderAvalara(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderAvalara(options)(this.fetch, this.basePath);
    }

    /**
     * Returns Avalara Tax companies configured by the merchant 
     * @summary Returns Avalara Tax companies configured by the merchant
     * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderAvalaraCompanies(tax_provider_avalara: TaxProviderAvalara, options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderAvalaraCompanies(tax_provider_avalara, options)(this.fetch, this.basePath);
    }

    /**
     * Attempts to connect to Avalara and returns back the response. 
     * @summary Attempts to connect to Avalara and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderAvalaraTest(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderAvalaraTest(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Self tax provider. 
     * @summary Retrieve the Self tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSelf(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSelf(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Self tax provider countries. 
     * @summary Retrieve the Self tax provider countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSelfCountries(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSelfCountries(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Self tax provider regions for a given country code. 
     * @summary Retrieve the Self tax provider regions for a given country code
     * @param {string} countryCode The country code regions desired.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSelfRegionsByCountryCode(countryCode: string, options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSelfRegionsByCountryCode(countryCode, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the Sovos tax provider. 
     * @summary Retrieve the Sovos tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSovos(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSovos(options)(this.fetch, this.basePath);
    }

    /**
     * Attempts to connect to Sovos and returns back the response. 
     * @summary Attempts to connect to Sovos and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderSovosTest(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderSovosTest(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the TaxJar tax provider. 
     * @summary Retrieve the TaxJar tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderTaxJar(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderTaxJar(options)(this.fetch, this.basePath);
    }

    /**
     * Attempts to connect to TaxJar and returns back the response. 
     * @summary Attempts to connect to TaxJar and returns back the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderTaxJarTest(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderTaxJarTest(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the UltraCart tax provider. 
     * @summary Retrieve the UltraCart tax provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviderUltraCart(options?: any) {
        return TaxApiFp(this.configuration).getTaxProviderUltraCart(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves tax methods for this account. 
     * @summary Retrieve tax methods
     * @param {number} [_limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public getTaxProviders(_limit?: number, _offset?: number, _expand?: string, options?: any) {
        return TaxApiFp(this.configuration).getTaxProviders(_limit, _offset, _expand, options)(this.fetch, this.basePath);
    }

    /**
     * Toggle a tax provider to active. 
     * @summary Toggle a tax provider to active
     * @param {string} providerName The tax provider to set active.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public setActiveTaxProvider(providerName: string, options?: any) {
        return TaxApiFp(this.configuration).setActiveTaxProvider(providerName, options)(this.fetch, this.basePath);
    }

    /**
     * Update the Avalara tax provider. 
     * @summary Update the Avalara tax provider
     * @param {TaxProviderAvalara} tax_provider_avalara TaxProviderAvalara object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderAvalara(tax_provider_avalara: TaxProviderAvalara, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderAvalara(tax_provider_avalara, options)(this.fetch, this.basePath);
    }

    /**
     * Update the Self tax provider. 
     * @summary Update the Self tax provider
     * @param {TaxProviderSelf} tax_provider_self TaxProviderSelf object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelf(tax_provider_self: TaxProviderSelf, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelf(tax_provider_self, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider city. 
     * @summary Updates a Self tax provider city
     * @param {string} city The city being updated.
     * @param {TaxCity} tax_city tax city to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfCity(city: string, tax_city: TaxCity, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfCity(city, tax_city, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider country. 
     * @summary Updates a Self tax provider country
     * @param {string} countryCode The country code being updated.
     * @param {TaxCountry} tax_country tax country to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfCountry(countryCode: string, tax_country: TaxCountry, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfCountry(countryCode, tax_country, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider county. 
     * @summary Updates a Self tax provider county
     * @param {string} county The county being updated.
     * @param {TaxCounty} tax_county tax county to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfCounty(county: string, tax_county: TaxCounty, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfCounty(county, tax_county, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider postalCode. 
     * @summary Updates a Self tax provider postalCode
     * @param {string} postal_code The postal code being updated.
     * @param {TaxPostalCode} tax_postal_code tax postal code to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfPostalCode(postal_code: string, tax_postal_code: TaxPostalCode, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfPostalCode(postal_code, tax_postal_code, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Self tax provider state. 
     * @summary Updates a Self tax provider state
     * @param {string} stateCode The state code being updated.
     * @param {TaxState} tax_state tax state to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSelfState(stateCode: string, tax_state: TaxState, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSelfState(stateCode, tax_state, options)(this.fetch, this.basePath);
    }

    /**
     * Update the Sovos tax provider. 
     * @summary Update the Sovos tax provider
     * @param {TaxProviderSovos} tax_provider_sovos TaxProviderSovos object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderSovos(tax_provider_sovos: TaxProviderSovos, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderSovos(tax_provider_sovos, options)(this.fetch, this.basePath);
    }

    /**
     * Update the TaxJar tax provider. 
     * @summary Update the TaxJar tax provider
     * @param {TaxProviderTaxJar} tax_provider_taxJar TaxProviderTaxJar object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderTaxJar(tax_provider_taxJar: TaxProviderTaxJar, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderTaxJar(tax_provider_taxJar, options)(this.fetch, this.basePath);
    }

    /**
     * Update the UltraCart tax provider. 
     * @summary Update the UltraCart tax provider
     * @param {TaxProviderUltraCart} tax_provider_ultracart TaxProviderUltraCart object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxApi
     */
    public updateTaxProviderUltraCart(tax_provider_ultracart: TaxProviderUltraCart, options?: any) {
        return TaxApiFp(this.configuration).updateTaxProviderUltraCart(tax_provider_ultracart, options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a group on the UltraCart account. 
         * @summary Delete a group
         * @param {number} group_oid The group_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(group_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'group_oid' is not null or undefined
            if (group_oid === null || group_oid === undefined) {
                throw new RequiredError('group_oid','Required parameter group_oid was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/user/groups/{group_oid}`
                .replace(`{${"group_oid"}}`, encodeURIComponent(String(group_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user on the UltraCart account. 
         * @summary Delete a user
         * @param {number} user_id The user_id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/user/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single group using the specified group id. 
         * @summary Retrieve a group
         * @param {number} group_oid The group id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(group_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'group_oid' is not null or undefined
            if (group_oid === null || group_oid === undefined) {
                throw new RequiredError('group_oid','Required parameter group_oid was null or undefined when calling getGroup.');
            }
            const localVarPath = `/user/groups/{group_oid}`
                .replace(`{${"group_oid"}}`, encodeURIComponent(String(group_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options: any = {}): FetchArgs {
            const localVarPath = `/user/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single user using the specified user id. 
         * @summary Retrieve a user
         * @param {number} user_id The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling getUser.');
            }
            const localVarPath = `/user/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves logins for a single user using the specified user id. 
         * @summary Retrieve a user's login history
         * @param {number} user_id The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLogins(user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling getUserLogins.');
            }
            const localVarPath = `/user/users/{user_id}/logins`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options: any = {}): FetchArgs {
            const localVarPath = `/user/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a group on the UltraCart account. 
         * @summary Insert a group
         * @param {Group} group Group to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertGroup(group: Group, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling insertGroup.');
            }
            const localVarPath = `/user/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(group || {}) : (group || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a user on the UltraCart account. 
         * @summary Insert a user
         * @param {User} user User to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUser(user: User, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling insertUser.');
            }
            const localVarPath = `/user/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a group on the UltraCart account. 
         * @summary Update a group
         * @param {Group} group Group to update
         * @param {number} group_oid The group_oid to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(group: Group, group_oid: number, options: any = {}): FetchArgs {
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'group_oid' is not null or undefined
            if (group_oid === null || group_oid === undefined) {
                throw new RequiredError('group_oid','Required parameter group_oid was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/user/groups/{group_oid}`
                .replace(`{${"group_oid"}}`, encodeURIComponent(String(group_oid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(group || {}) : (group || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user on the UltraCart account. 
         * @summary Update a user
         * @param {User} user User to update
         * @param {number} user_id The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, user_id: number, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateUser.');
            }
            // verify required parameter 'user_id' is not null or undefined
            if (user_id === null || user_id === undefined) {
                throw new RequiredError('user_id','Required parameter user_id was null or undefined when calling updateUser.');
            }
            const localVarPath = `/user/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(user_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["user_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(user || {}) : (user || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a group on the UltraCart account. 
         * @summary Delete a group
         * @param {number} group_oid The group_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(group_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteGroup(group_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user on the UltraCart account. 
         * @summary Delete a user
         * @param {number} user_id The user_id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single group using the specified group id. 
         * @summary Retrieve a group
         * @param {number} group_oid The group id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(group_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getGroup(group_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupsResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getGroups(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a single user using the specified user id. 
         * @summary Retrieve a user
         * @param {number} user_id The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves logins for a single user using the specified user id. 
         * @summary Retrieve a user's login history
         * @param {number} user_id The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLogins(user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserLoginsResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserLogins(user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsersResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a group on the UltraCart account. 
         * @summary Insert a group
         * @param {Group} group Group to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertGroup(group: Group, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).insertGroup(group, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Insert a user on the UltraCart account. 
         * @summary Insert a user
         * @param {User} user User to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUser(user: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).insertUser(user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a group on the UltraCart account. 
         * @summary Update a group
         * @param {Group} group Group to update
         * @param {number} group_oid The group_oid to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(group: Group, group_oid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateGroup(group, group_oid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user on the UltraCart account. 
         * @summary Update a user
         * @param {User} user User to update
         * @param {number} user_id The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, user_id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(user, user_id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a group on the UltraCart account. 
         * @summary Delete a group
         * @param {number} group_oid The group_oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(group_oid: number, options?: any) {
            return UserApiFp(configuration).deleteGroup(group_oid, options)(fetch, basePath);
        },
        /**
         * Delete a user on the UltraCart account. 
         * @summary Delete a user
         * @param {number} user_id The user_id to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user_id: number, options?: any) {
            return UserApiFp(configuration).deleteUser(user_id, options)(fetch, basePath);
        },
        /**
         * Retrieves a single group using the specified group id. 
         * @summary Retrieve a group
         * @param {number} group_oid The group id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(group_oid: number, options?: any) {
            return UserApiFp(configuration).getGroup(group_oid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any) {
            return UserApiFp(configuration).getGroups(options)(fetch, basePath);
        },
        /**
         * Retrieves a single user using the specified user id. 
         * @summary Retrieve a user
         * @param {number} user_id The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(user_id: number, options?: any) {
            return UserApiFp(configuration).getUser(user_id, options)(fetch, basePath);
        },
        /**
         * Retrieves logins for a single user using the specified user id. 
         * @summary Retrieve a user's login history
         * @param {number} user_id The user id to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLogins(user_id: number, options?: any) {
            return UserApiFp(configuration).getUserLogins(user_id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any) {
            return UserApiFp(configuration).getUsers(options)(fetch, basePath);
        },
        /**
         * Insert a group on the UltraCart account. 
         * @summary Insert a group
         * @param {Group} group Group to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertGroup(group: Group, options?: any) {
            return UserApiFp(configuration).insertGroup(group, options)(fetch, basePath);
        },
        /**
         * Insert a user on the UltraCart account. 
         * @summary Insert a user
         * @param {User} user User to insert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUser(user: User, options?: any) {
            return UserApiFp(configuration).insertUser(user, options)(fetch, basePath);
        },
        /**
         * Update a group on the UltraCart account. 
         * @summary Update a group
         * @param {Group} group Group to update
         * @param {number} group_oid The group_oid to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(group: Group, group_oid: number, options?: any) {
            return UserApiFp(configuration).updateGroup(group, group_oid, options)(fetch, basePath);
        },
        /**
         * Update a user on the UltraCart account. 
         * @summary Update a user
         * @param {User} user User to update
         * @param {number} user_id The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, user_id: number, options?: any) {
            return UserApiFp(configuration).updateUser(user, user_id, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Delete a group on the UltraCart account. 
     * @summary Delete a group
     * @param {number} group_oid The group_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteGroup(group_oid: number, options?: any): Promise<{}>;

    /**
     * Delete a user on the UltraCart account. 
     * @summary Delete a user
     * @param {number} user_id The user_id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUser(user_id: number, options?: any): Promise<{}>;

    /**
     * Retrieves a single group using the specified group id. 
     * @summary Retrieve a group
     * @param {number} group_oid The group id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getGroup(group_oid: number, options?: any): Promise<{}>;

    /**
     * 
     * @summary Get groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getGroups(options?: any): Promise<GroupsResponse>;

    /**
     * Retrieves a single user using the specified user id. 
     * @summary Retrieve a user
     * @param {number} user_id The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUser(user_id: number, options?: any): Promise<UserResponse>;

    /**
     * Retrieves logins for a single user using the specified user id. 
     * @summary Retrieve a user's login history
     * @param {number} user_id The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserLogins(user_id: number, options?: any): Promise<UserLoginsResponse>;

    /**
     * 
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsers(options?: any): Promise<UsersResponse>;

    /**
     * Insert a group on the UltraCart account. 
     * @summary Insert a group
     * @param {Group} group Group to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    insertGroup(group: Group, options?: any): Promise<GroupResponse>;

    /**
     * Insert a user on the UltraCart account. 
     * @summary Insert a user
     * @param {User} user User to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    insertUser(user: User, options?: any): Promise<UserResponse>;

    /**
     * Update a group on the UltraCart account. 
     * @summary Update a group
     * @param {Group} group Group to update
     * @param {number} group_oid The group_oid to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateGroup(group: Group, group_oid: number, options?: any): Promise<GroupResponse>;

    /**
     * Update a user on the UltraCart account. 
     * @summary Update a user
     * @param {User} user User to update
     * @param {number} user_id The user_id to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUser(user: User, user_id: number, options?: any): Promise<UserResponse>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Delete a group on the UltraCart account. 
     * @summary Delete a group
     * @param {number} group_oid The group_oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteGroup(group_oid: number, options?: any) {
        return UserApiFp(this.configuration).deleteGroup(group_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user on the UltraCart account. 
     * @summary Delete a user
     * @param {number} user_id The user_id to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(user_id: number, options?: any) {
        return UserApiFp(this.configuration).deleteUser(user_id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single group using the specified group id. 
     * @summary Retrieve a group
     * @param {number} group_oid The group id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getGroup(group_oid: number, options?: any) {
        return UserApiFp(this.configuration).getGroup(group_oid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getGroups(options?: any) {
        return UserApiFp(this.configuration).getGroups(options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a single user using the specified user id. 
     * @summary Retrieve a user
     * @param {number} user_id The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(user_id: number, options?: any) {
        return UserApiFp(this.configuration).getUser(user_id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves logins for a single user using the specified user id. 
     * @summary Retrieve a user's login history
     * @param {number} user_id The user id to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserLogins(user_id: number, options?: any) {
        return UserApiFp(this.configuration).getUserLogins(user_id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(options?: any) {
        return UserApiFp(this.configuration).getUsers(options)(this.fetch, this.basePath);
    }

    /**
     * Insert a group on the UltraCart account. 
     * @summary Insert a group
     * @param {Group} group Group to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public insertGroup(group: Group, options?: any) {
        return UserApiFp(this.configuration).insertGroup(group, options)(this.fetch, this.basePath);
    }

    /**
     * Insert a user on the UltraCart account. 
     * @summary Insert a user
     * @param {User} user User to insert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public insertUser(user: User, options?: any) {
        return UserApiFp(this.configuration).insertUser(user, options)(this.fetch, this.basePath);
    }

    /**
     * Update a group on the UltraCart account. 
     * @summary Update a group
     * @param {Group} group Group to update
     * @param {number} group_oid The group_oid to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateGroup(group: Group, group_oid: number, options?: any) {
        return UserApiFp(this.configuration).updateGroup(group, group_oid, options)(this.fetch, this.basePath);
    }

    /**
     * Update a user on the UltraCart account. 
     * @summary Update a user
     * @param {User} user User to update
     * @param {number} user_id The user_id to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(user: User, user_id: number, options?: any) {
        return UserApiFp(this.configuration).updateUser(user, user_id, options)(this.fetch, this.basePath);
    }

}

/**
 * WebhookApi - fetch parameter creator
 * @export
 */
export const WebhookApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a webhook on the UltraCart account. 
         * @summary Delete a webhook
         * @param {number} webhookOid The webhook oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookOid: number, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
         * @summary Delete a webhook by URL
         * @param {Webhook} webhook Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByUrl(webhook: Webhook, options: any = {}): FetchArgs {
            // verify required parameter 'webhook' is not null or undefined
            if (webhook === null || webhook === undefined) {
                throw new RequiredError('webhook','Required parameter webhook was null or undefined when calling deleteWebhookByUrl.');
            }
            const localVarPath = `/webhook/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Webhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhook || {}) : (webhook || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an individual log for a webhook given the webhook oid the request id. 
         * @summary Retrieve an individual log
         * @param {number} webhookOid The webhook oid that owns the log.
         * @param {string} requestId The request id associated with the log to view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLog(webhookOid: number, requestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling getWebhookLog.');
            }
            // verify required parameter 'requestId' is not null or undefined
            if (requestId === null || requestId === undefined) {
                throw new RequiredError('requestId','Required parameter requestId was null or undefined when calling getWebhookLog.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}/logs/{requestId}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
         * @summary Retrieve the log summaries
         * @param {number} webhookOid The webhook oid to retrieve log summaries for.
         * @param {number} [_limit] The maximum number of records to return on this one API call.
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch log summaries that have been delivered since this date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLogSummaries(webhookOid: number, _limit?: number, _offset?: number, _since?: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling getWebhookLogSummaries.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}/logs`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_since !== undefined) {
                localVarQueryParameter['_since'] = _since;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the webhooks associated with this application. 
         * @summary Retrieve webhooks
         * @param {number} [_limit] The maximum number of records to return on this one API call.
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the webhooks.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(_limit?: number, _offset?: number, _sort?: string, _placeholders?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/webhook/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_read"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_limit !== undefined) {
                localVarQueryParameter['_limit'] = _limit;
            }

            if (_offset !== undefined) {
                localVarQueryParameter['_offset'] = _offset;
            }

            if (_sort !== undefined) {
                localVarQueryParameter['_sort'] = _sort;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
         * @summary Add a webhook
         * @param {Webhook} webhook Webhook to create
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertWebhook(webhook: Webhook, _placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'webhook' is not null or undefined
            if (webhook === null || webhook === undefined) {
                throw new RequiredError('webhook','Required parameter webhook was null or undefined when calling insertWebhook.');
            }
            const localVarPath = `/webhook/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Webhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhook || {}) : (webhook || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
         * @summary Resend events to the webhook endpoint.
         * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
         * @param {string} eventName The event to reflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEvent(webhookOid: number, eventName: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling resendEvent.');
            }
            // verify required parameter 'eventName' is not null or undefined
            if (eventName === null || eventName === undefined) {
                throw new RequiredError('eventName','Required parameter eventName was null or undefined when calling resendEvent.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}/reflow/{eventName}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)))
                .replace(`{${"eventName"}}`, encodeURIComponent(String(eventName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook on the account 
         * @summary Update a webhook
         * @param {Webhook} webhook Webhook to update
         * @param {number} webhookOid The webhook oid to update.
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhook: Webhook, webhookOid: number, _placeholders?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'webhook' is not null or undefined
            if (webhook === null || webhook === undefined) {
                throw new RequiredError('webhook','Required parameter webhook was null or undefined when calling updateWebhook.');
            }
            // verify required parameter 'webhookOid' is not null or undefined
            if (webhookOid === null || webhookOid === undefined) {
                throw new RequiredError('webhookOid','Required parameter webhookOid was null or undefined when calling updateWebhook.');
            }
            const localVarPath = `/webhook/webhooks/{webhookOid}`
                .replace(`{${"webhookOid"}}`, encodeURIComponent(String(webhookOid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

    if(configuration && configuration.apiVersion) {
      localVarHeaderParameter["X-UltraCart-Api-Version"] = configuration.apiVersion;
    }



            // authentication ultraCartOauth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("ultraCartOauth", ["webhook_write"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            // authentication ultraCartSimpleApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-ultracart-simple-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-ultracart-simple-key"] = localVarApiKeyValue;
            }

            if (_placeholders !== undefined) {
                localVarQueryParameter['_placeholders'] = _placeholders;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Webhook" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(webhook || {}) : (webhook || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a webhook on the UltraCart account. 
         * @summary Delete a webhook
         * @param {number} webhookOid The webhook oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookOid: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).deleteWebhook(webhookOid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response;
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
         * @summary Delete a webhook by URL
         * @param {Webhook} webhook Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByUrl(webhook: Webhook, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).deleteWebhookByUrl(webhook, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves an individual log for a webhook given the webhook oid the request id. 
         * @summary Retrieve an individual log
         * @param {number} webhookOid The webhook oid that owns the log.
         * @param {string} requestId The request id associated with the log to view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLog(webhookOid: number, requestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookLogResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhookLog(webhookOid, requestId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
         * @summary Retrieve the log summaries
         * @param {number} webhookOid The webhook oid to retrieve log summaries for.
         * @param {number} [_limit] The maximum number of records to return on this one API call.
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch log summaries that have been delivered since this date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLogSummaries(webhookOid: number, _limit?: number, _offset?: number, _since?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookLogSummariesResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhookLogSummaries(webhookOid, _limit, _offset, _since, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the webhooks associated with this application. 
         * @summary Retrieve webhooks
         * @param {number} [_limit] The maximum number of records to return on this one API call.
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the webhooks.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(_limit?: number, _offset?: number, _sort?: string, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhooksResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhooks(_limit, _offset, _sort, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
         * @summary Add a webhook
         * @param {Webhook} webhook Webhook to create
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertWebhook(webhook: Webhook, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).insertWebhook(webhook, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
         * @summary Resend events to the webhook endpoint.
         * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
         * @param {string} eventName The event to reflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEvent(webhookOid: number, eventName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookSampleRequestResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).resendEvent(webhookOid, eventName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a webhook on the account 
         * @summary Update a webhook
         * @param {Webhook} webhook Webhook to update
         * @param {number} webhookOid The webhook oid to update.
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhook: Webhook, webhookOid: number, _placeholders?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponse> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).updateWebhook(webhook, webhookOid, _placeholders, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {

                    if (response.status >= 200 && response.status < 300) {
                      return response.json();
                      
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a webhook on the UltraCart account. 
         * @summary Delete a webhook
         * @param {number} webhookOid The webhook oid to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookOid: number, options?: any) {
            return WebhookApiFp(configuration).deleteWebhook(webhookOid, options)(fetch, basePath);
        },
        /**
         * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
         * @summary Delete a webhook by URL
         * @param {Webhook} webhook Webhook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookByUrl(webhook: Webhook, options?: any) {
            return WebhookApiFp(configuration).deleteWebhookByUrl(webhook, options)(fetch, basePath);
        },
        /**
         * Retrieves an individual log for a webhook given the webhook oid the request id. 
         * @summary Retrieve an individual log
         * @param {number} webhookOid The webhook oid that owns the log.
         * @param {string} requestId The request id associated with the log to view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLog(webhookOid: number, requestId: string, options?: any) {
            return WebhookApiFp(configuration).getWebhookLog(webhookOid, requestId, options)(fetch, basePath);
        },
        /**
         * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
         * @summary Retrieve the log summaries
         * @param {number} webhookOid The webhook oid to retrieve log summaries for.
         * @param {number} [_limit] The maximum number of records to return on this one API call.
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_since] Fetch log summaries that have been delivered since this date/time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookLogSummaries(webhookOid: number, _limit?: number, _offset?: number, _since?: string, options?: any) {
            return WebhookApiFp(configuration).getWebhookLogSummaries(webhookOid, _limit, _offset, _since, options)(fetch, basePath);
        },
        /**
         * Retrieves the webhooks associated with this application. 
         * @summary Retrieve webhooks
         * @param {number} [_limit] The maximum number of records to return on this one API call.
         * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
         * @param {string} [_sort] The sort order of the webhooks.  See documentation for examples
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(_limit?: number, _offset?: number, _sort?: string, _placeholders?: boolean, options?: any) {
            return WebhookApiFp(configuration).getWebhooks(_limit, _offset, _sort, _placeholders, options)(fetch, basePath);
        },
        /**
         * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
         * @summary Add a webhook
         * @param {Webhook} webhook Webhook to create
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertWebhook(webhook: Webhook, _placeholders?: boolean, options?: any) {
            return WebhookApiFp(configuration).insertWebhook(webhook, _placeholders, options)(fetch, basePath);
        },
        /**
         * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
         * @summary Resend events to the webhook endpoint.
         * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
         * @param {string} eventName The event to reflow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendEvent(webhookOid: number, eventName: string, options?: any) {
            return WebhookApiFp(configuration).resendEvent(webhookOid, eventName, options)(fetch, basePath);
        },
        /**
         * Update a webhook on the account 
         * @summary Update a webhook
         * @param {Webhook} webhook Webhook to update
         * @param {number} webhookOid The webhook oid to update.
         * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhook: Webhook, webhookOid: number, _placeholders?: boolean, options?: any) {
            return WebhookApiFp(configuration).updateWebhook(webhook, webhookOid, _placeholders, options)(fetch, basePath);
        },
    };
};

/**
 * WebhookApi - interface
 * @export
 * @interface WebhookApi
 */
export interface WebhookApiInterface {
    /**
     * Delete a webhook on the UltraCart account. 
     * @summary Delete a webhook
     * @param {number} webhookOid The webhook oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    deleteWebhook(webhookOid: number, options?: any): Promise<{}>;

    /**
     * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
     * @summary Delete a webhook by URL
     * @param {Webhook} webhook Webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    deleteWebhookByUrl(webhook: Webhook, options?: any): Promise<WebhookResponse>;

    /**
     * Retrieves an individual log for a webhook given the webhook oid the request id. 
     * @summary Retrieve an individual log
     * @param {number} webhookOid The webhook oid that owns the log.
     * @param {string} requestId The request id associated with the log to view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getWebhookLog(webhookOid: number, requestId: string, options?: any): Promise<WebhookLogResponse>;

    /**
     * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
     * @summary Retrieve the log summaries
     * @param {number} webhookOid The webhook oid to retrieve log summaries for.
     * @param {number} [_limit] The maximum number of records to return on this one API call.
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch log summaries that have been delivered since this date/time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getWebhookLogSummaries(webhookOid: number, _limit?: number, _offset?: number, _since?: string, options?: any): Promise<WebhookLogSummariesResponse>;

    /**
     * Retrieves the webhooks associated with this application. 
     * @summary Retrieve webhooks
     * @param {number} [_limit] The maximum number of records to return on this one API call.
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the webhooks.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getWebhooks(_limit?: number, _offset?: number, _sort?: string, _placeholders?: boolean, options?: any): Promise<WebhooksResponse>;

    /**
     * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
     * @summary Add a webhook
     * @param {Webhook} webhook Webhook to create
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    insertWebhook(webhook: Webhook, _placeholders?: boolean, options?: any): Promise<WebhookResponse>;

    /**
     * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
     * @summary Resend events to the webhook endpoint.
     * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
     * @param {string} eventName The event to reflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    resendEvent(webhookOid: number, eventName: string, options?: any): Promise<WebhookSampleRequestResponse>;

    /**
     * Update a webhook on the account 
     * @summary Update a webhook
     * @param {Webhook} webhook Webhook to update
     * @param {number} webhookOid The webhook oid to update.
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    updateWebhook(webhook: Webhook, webhookOid: number, _placeholders?: boolean, options?: any): Promise<WebhookResponse>;

}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI implements WebhookApiInterface {
    /**
     * Delete a webhook on the UltraCart account. 
     * @summary Delete a webhook
     * @param {number} webhookOid The webhook oid to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public deleteWebhook(webhookOid: number, options?: any) {
        return WebhookApiFp(this.configuration).deleteWebhook(webhookOid, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
     * @summary Delete a webhook by URL
     * @param {Webhook} webhook Webhook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public deleteWebhookByUrl(webhook: Webhook, options?: any) {
        return WebhookApiFp(this.configuration).deleteWebhookByUrl(webhook, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves an individual log for a webhook given the webhook oid the request id. 
     * @summary Retrieve an individual log
     * @param {number} webhookOid The webhook oid that owns the log.
     * @param {string} requestId The request id associated with the log to view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhookLog(webhookOid: number, requestId: string, options?: any) {
        return WebhookApiFp(this.configuration).getWebhookLog(webhookOid, requestId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
     * @summary Retrieve the log summaries
     * @param {number} webhookOid The webhook oid to retrieve log summaries for.
     * @param {number} [_limit] The maximum number of records to return on this one API call.
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_since] Fetch log summaries that have been delivered since this date/time.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhookLogSummaries(webhookOid: number, _limit?: number, _offset?: number, _since?: string, options?: any) {
        return WebhookApiFp(this.configuration).getWebhookLogSummaries(webhookOid, _limit, _offset, _since, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the webhooks associated with this application. 
     * @summary Retrieve webhooks
     * @param {number} [_limit] The maximum number of records to return on this one API call.
     * @param {number} [_offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [_sort] The sort order of the webhooks.  See documentation for examples
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhooks(_limit?: number, _offset?: number, _sort?: string, _placeholders?: boolean, options?: any) {
        return WebhookApiFp(this.configuration).getWebhooks(_limit, _offset, _sort, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
     * @summary Add a webhook
     * @param {Webhook} webhook Webhook to create
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public insertWebhook(webhook: Webhook, _placeholders?: boolean, options?: any) {
        return WebhookApiFp(this.configuration).insertWebhook(webhook, _placeholders, options)(this.fetch, this.basePath);
    }

    /**
     * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
     * @summary Resend events to the webhook endpoint.
     * @param {number} webhookOid The webhook oid that is receiving the reflowed events.
     * @param {string} eventName The event to reflow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public resendEvent(webhookOid: number, eventName: string, options?: any) {
        return WebhookApiFp(this.configuration).resendEvent(webhookOid, eventName, options)(this.fetch, this.basePath);
    }

    /**
     * Update a webhook on the account 
     * @summary Update a webhook
     * @param {Webhook} webhook Webhook to update
     * @param {number} webhookOid The webhook oid to update.
     * @param {boolean} [_placeholders] Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public updateWebhook(webhook: Webhook, webhookOid: number, _placeholders?: boolean, options?: any) {
        return WebhookApiFp(this.configuration).updateWebhook(webhook, webhookOid, _placeholders, options)(this.fetch, this.basePath);
    }

}

