/**
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://secure.ultracart.com/rest/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AccountsReceivableRetryConfig {
    /**
    * True if the retry should run daily.  False puts the retry service into an inactive state for this merchant.
    */
    'active': boolean;
    /**
    * True if this account has linked accounts that it can process.
    */
    'allowProcessLinkedAccounts': boolean;
    /**
    * The current service plan that the account is on.
    */
    'currentServicePlan': string;
    /**
    * A list of days and what actions should take place on those days after an order reaches accounts receivable
    */
    'dailyActivityList': Array<AccountsReceivableRetryDayActivity>;
    /**
    * If not null, this account is managed by the specified parent merchant id.
    */
    'managedByLinkedAccountMerchantId': boolean;
    /**
    * UltraCart merchant ID
    */
    'merchantId': string;
    /**
    * A list of email addresses to receive summary notifications from the retry service.
    */
    'notifyEmails': Array<string>;
    /**
    * If true, email addresses are notified of rejections.
    */
    'notifyRejections': boolean;
    /**
    * If true, email addresses are notified of successful charges.
    */
    'notifySuccesses': boolean;
    /**
    * If true, all linked accounts are also processed using the same rules.
    */
    'processLinkedAccounts': boolean;
    /**
    * The percentage rate charged for the service.
    */
    'processingPercentage': string;
    /**
    * If true, the order is rejected the day after the last configured activity day
    */
    'rejectAtEnd': boolean;
    /**
    * True if the account is currently in trial mode.  Set to false to exit trial mode.
    */
    'trialMode': boolean;
    /**
    * The date when trial mode expires.  If this date is reached without exiting trial mode, the service will de-activate.
    */
    'trialModeExpirationDts': string;
}

export class AccountsReceivableRetryConfigResponse {
    'config': AccountsReceivableRetryConfig;
    'couponCodes': Array<string>;
    'emails': Array<string>;
    'error': Error;
    'hasLinkedAccounts': boolean;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class AccountsReceivableRetryDayActivity {
    /**
    * True if a charge attempt should be made on this day.  False means the order should be rejected on this day.
    */
    'charge': boolean;
    /**
    * The coupon code that should be applied to this order.
    */
    'couponCode': string;
    /**
    * The number of days since the order placed in Accounts Receivable
    */
    'day': number;
}

export class AccountsReceivableRetryStatAccount {
    'days': Array<AccountsReceivableRetryStatMetrics>;
    'merchantId': string;
    'overall': AccountsReceivableRetryStatMetrics;
    'revenueForPeriod': Array<AccountsReceivableRetryStatRevenue>;
}

export class AccountsReceivableRetryStatMetrics {
    'attempts': number;
    'attemptsFormatted': string;
    'conversionRate': number;
    'conversionRateFormatted': string;
    'day': number;
    'discounts': number;
    'discountsFormatted': string;
    'revenue': number;
    'revenueFormatted': string;
    'successes': number;
    'successesFormatted': string;
}

export class AccountsReceivableRetryStatRevenue {
    'label': string;
    'revenue': number;
}

export class AccountsReceivableRetryStatsResponse {
    'error': Error;
    'linkedAccounts': Array<AccountsReceivableRetryStatAccount>;
    'metadata': ResponseMetadata;
    'overall': AccountsReceivableRetryStatAccount;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Activity {
    'action': string;
    'metric': string;
    'subject': string;
    'ts': number;
    'type': string;
    'uuid': string;
}

export class AffiliateClick {
    /**
    * Unique object identifier for this click
    */
    'affiliateClickOid': number;
    /**
    * Unique object identifier for for the link that this click is associated with
    */
    'affiliateLinkOid': number;
    /**
    * Affiliate object ID associated with this click
    */
    'affiliateOid': number;
    /**
    * Date/time that the click was made
    */
    'clickDts': string;
    /**
    * IP address that generated the click
    */
    'ipAddress': string;
    /**
    * URL of the landing page the customer was sent to.
    */
    'landingPage': string;
    /**
    * Query string on the landing page URL the customer was sent to.
    */
    'landingPageQueryString': string;
    'link': AffiliateLink;
    /**
    * URL that referred the click (Browser Header Referer)
    */
    'referrer': string;
    /**
    * Query string that was on the referrer URL.
    */
    'referrerQueryString': string;
    /**
    * Sub ID value passed on the click
    */
    'subId': string;
}

export class AffiliateClickQuery {
    /**
    * Unique object identifier for for the link that this click is associated with
    */
    'affiliateLinkOid': number;
    /**
    * Affiliate ID associated with the click
    */
    'affiliateOid': number;
    /**
    * Minimum click date/time to return
    */
    'clickDtsBegin': string;
    /**
    * Maximum click date/time to return
    */
    'clickDtsEnd': string;
    /**
    * IP address that generated the click
    */
    'ipAddress': string;
    /**
    * Sub ID value passed on the click
    */
    'subId': string;
}

export class AffiliateClicksResponse {
    /**
    * clicks
    */
    'clicks': Array<AffiliateClick>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class AffiliateLedger {
    /**
    * Unique object identifier for the click associated with this ledger entry
    */
    'affiliateClickOid': number;
    /**
    * Unique object identifier for the link that this click is associated with
    */
    'affiliateLinkOid': number;
    /**
    * Affiliate object ID associated with this transaction
    */
    'affiliateOid': number;
    /**
    * User that assigned the transaction if it was done manually
    */
    'assignedByUser': string;
    'click': AffiliateClick;
    /**
    * Item ID associated with this transaction
    */
    'itemId': string;
    'link': AffiliateLink;
    'order': Order;
    /**
    * Order ID associated with this transaction
    */
    'orderId': string;
    /**
    * Date/time of the original transaction for reversals
    */
    'originalTransactionDts': string;
    /**
    * Sub ID associated with transaction (from the click)
    */
    'subId': string;
    /**
    * Tier number that this transaction earned
    */
    'tierNumber': string;
    /**
    * Transaction amount
    */
    'transactionAmount': number;
    /**
    * Amount of the transaction that has been paid out.
    */
    'transactionAmountPaid': number;
    /**
    * Date/time that the transaction was made
    */
    'transactionDts': string;
    /**
    * Memo explaining the transaction
    */
    'transactionMemo': string;
    /**
    * Percentage associated with this transaction
    */
    'transactionPercentage': string;
    /**
    * Transaction state
    */
    'transactionState': AffiliateLedger.TransactionStateEnum;
}

export namespace AffiliateLedger {
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}
export class AffiliateLedgerQuery {
    /**
    * Affiliate ID associated with the ledger
    */
    'affiliateOid': number;
    /**
    * Item id associated with the ledger entry
    */
    'itemId': string;
    /**
    * Order ID associated with the ledger entries
    */
    'orderId': string;
    /**
    * Sub ID value passed on the click that generated the ledger
    */
    'subId': string;
    /**
    * Minimum transaction date/time to return
    */
    'transactionDtsBegin': string;
    /**
    * Maximum transaction date/time to return
    */
    'transactionDtsEnd': string;
}

export class AffiliateLedgersResponse {
    'error': Error;
    /**
    * ledgers
    */
    'ledgers': Array<AffiliateLedger>;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class AffiliateLink {
    /**
    * Unique object identifier associated with this link
    */
    'affiliateLinkOid': number;
    /**
    * Managed link OID that this link object was generated from
    */
    'affiliateManagedLinkOid': number;
    /**
    * Affiliate object ID associated with this link
    */
    'affiliateOid': number;
    /**
    * The affiliate program item this managed link is associated with
    */
    'affiliateProgramItemOid': number;
    /**
    * Code associated with the link
    */
    'code': string;
    /**
    * Creative (image or text) associated with this link
    */
    'creativeOid': number;
    /**
    * Custom HTML associated with this link
    */
    'customHtml': string;
    /**
    * Approved status of the custom html
    */
    'customHtmlApprovalStatus': AffiliateLink.CustomHtmlApprovalStatusEnum;
    /**
    * Custom landing page URL if configured
    */
    'customLandingUrl': string;
    /**
    * True if the link has been deleted
    */
    'deleted': boolean;
    /**
    * Invisible link approval status
    */
    'invisibleLinkApprovalStatus': AffiliateLink.InvisibleLinkApprovalStatusEnum;
    /**
    * Invisible link URL prefix
    */
    'invisibleLinkUrlPrefix': string;
    /**
    * Name of the link
    */
    'name': string;
    /**
    * Type of link
    */
    'type': AffiliateLink.TypeEnum;
}

export namespace AffiliateLink {
    export enum CustomHtmlApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    export enum InvisibleLinkApprovalStatusEnum {
        Pending = <any> 'Pending',
        Approved = <any> 'Approved',
        Rejected = <any> 'Rejected'
    }
    export enum TypeEnum {
        Image = <any> 'image',
        Text = <any> 'text',
        Invisible = <any> 'invisible',
        Direct = <any> 'direct'
    }
}
export class ApiUserApplicationProfile {
    /**
    * Application logo URL
    */
    'apiApplicationLogoUrl': string;
    /**
    * Application description
    */
    'applicationDescription': string;
    /**
    * Application name
    */
    'applicationName': string;
    /**
    * Developer name
    */
    'developerName': string;
    /**
    * Developer website
    */
    'developerWebsite': string;
}

export class AutoOrder {
    /**
    * Unique code assigned to this auto order
    */
    'autoOrderCode': string;
    /**
    * Auto order object identifier
    */
    'autoOrderOid': number;
    /**
    * Cancel this auto order after X additional rebills
    */
    'cancelAfterNextXOrders': number;
    /**
    * True if the auto order was canceled because the customer purchased a downgrade item
    */
    'cancelDowngrade': boolean;
    /**
    * True if the auto order was canceled because the customer purchased an upgrade item
    */
    'cancelUpgrade': boolean;
    /**
    * The user that canceled the auto order
    */
    'canceledByUser': string;
    /**
    * The date/time that the auto order was canceled
    */
    'canceledDts': string;
    /**
    * True if the auto order ran successfully to completion
    */
    'completed': boolean;
    /**
    * The number of credit card attempts that have taken place
    */
    'creditCardAttempt': number;
    /**
    * The date/time the auto order was disabled due to failed rebills
    */
    'disabledDts': string;
    /**
    * True if this auto order is enabled
    */
    'enabled': boolean;
    /**
    * The reason this auto order failed during the last rebill attempt
    */
    'failureReason': string;
    /**
    * The items that are setup to rebill
    */
    'items': Array<AutoOrderItem>;
    /**
    * The next time that the auto order will be attempted for processing
    */
    'nextAttempt': string;
    'originalOrder': Order;
    /**
    * The original order id that this auto order is associated with.
    */
    'originalOrderId': string;
    /**
    * Override the affiliate id given credit for rebills of this auto order
    */
    'overrideAffiliateId': number;
    /**
    * Rebill orders that have taken place on this auto order
    */
    'rebillOrders': Array<Order>;
    /**
    * The RTG code associated with this order for future rebills
    */
    'rotatingTransactionGatewayCode': string;
}

export class AutoOrderItem {
    /**
    * Arbitrary item id that should be rebilled instead of the normal schedule
    */
    'arbitraryItemId': string;
    /**
    * An arbitrary percentage discount to provide on future rebills
    */
    'arbitraryPercentageDiscount': number;
    /**
    * Arbitrary quantity to rebill
    */
    'arbitraryQuantity': number;
    /**
    * The number of days to rebill if the frequency is set to an arbitrary number of days
    */
    'arbitraryScheduleDays': number;
    /**
    * Arbitrary unit cost that rebills of this item should occur at
    */
    'arbitraryUnitCost': number;
    /**
    * The number of rebills to give the arbitrary unit cost on before reverting to normal pricing.
    */
    'arbitraryUnitCostRemainingOrders': number;
    /**
    * Primary key of AutoOrderItem
    */
    'autoOrderItemOid': number;
    /**
    * Frequency of the rebill if not a fixed schedule
    */
    'frequency': AutoOrderItem.FrequencyEnum;
    /**
    * The future rebill schedule for this item up to the next ten rebills
    */
    'futureSchedules': Array<AutoOrderItemFutureSchedule>;
    /**
    * Date/time of the last order of this item
    */
    'lastOrderDts': string;
    /**
    * The life time value of this item including the original purchase
    */
    'lifeTimeValue': number;
    /**
    * The date/time of when the next pre-shipment notice should be sent
    */
    'nextPreshipmentNoticeDts': string;
    /**
    * Date/time that this item is scheduled to rebill
    */
    'nextShipmentDts': string;
    /**
    * Date/time after which no additional rebills of this item should occur
    */
    'noOrderAfterDts': string;
    /**
    * The number of times this item has rebilled
    */
    'numberOfRebills': number;
    /**
    * Options associated with this item
    */
    'options': Array<AutoOrderItemOption>;
    /**
    * The original item id purchased.  This item controls scheduling.  If you wish to modify a schedule, for example, from monthly to yearly, change this item from your monthly item to your yearly item, and then change the next_shipment_dts to your desired date.
    */
    'originalItemId': string;
    /**
    * The original quantity purchased
    */
    'originalQuantity': number;
    /**
    * The PayPal Payer ID tied to this item
    */
    'paypalPayerId': string;
    /**
    * The PayPal Profile ID tied to this item
    */
    'paypalRecurringPaymentProfileId': string;
    /**
    * True if the preshipment notice associated with the next rebill has been sent
    */
    'preshipmentNoticeSent': boolean;
    /**
    * The value of the rebills of this item
    */
    'rebillValue': number;
    /**
    * The number of rebills remaining before this item is complete
    */
    'remainingRepeatCount': number;
}

export namespace AutoOrderItem {
    export enum FrequencyEnum {
        Weekly = <any> 'Weekly',
        Biweekly = <any> 'Biweekly',
        Every_ = <any> 'Every...',
        Every10Days = <any> 'Every 10 Days',
        Every24Days = <any> 'Every 24 Days',
        Every28Days = <any> 'Every 28 Days',
        Monthly = <any> 'Monthly',
        Every45Days = <any> 'Every 45 Days',
        Every2Months = <any> 'Every 2 Months',
        Every3Months = <any> 'Every 3 Months',
        Every4Months = <any> 'Every 4 Months',
        Every6Months = <any> 'Every 6 Months',
        Yearly = <any> 'Yearly'
    }
}
export class AutoOrderItemFutureSchedule {
    /**
    * Item ID that should rebill
    */
    'itemId': string;
    /**
    * The number of times this rebill represents
    */
    'rebillCount': number;
    /**
    * Date/time that this item is scheduled to rebill
    */
    'shipmentDts': string;
    /**
    * The unit cost of the item rebilling
    */
    'unitCost': number;
}

export class AutoOrderItemOption {
    /**
    * Label
    */
    'label': string;
    /**
    * Value
    */
    'value': string;
}

export class AutoOrderQuery {
    /**
    * Auto order code
    */
    'autoOrderCode': string;
    /**
    * Card type
    */
    'cardType': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * Email
    */
    'email': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Item ID
    */
    'itemId': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Next shipment date begin
    */
    'nextShipmentDateBegin': string;
    /**
    * Next shipment date end
    */
    'nextShipmentDateEnd': string;
    /**
    * Original order date begin
    */
    'originalOrderDateBegin': string;
    /**
    * Original order date end
    */
    'originalOrderDateEnd': string;
    /**
    * Original order ID
    */
    'originalOrderId': string;
    /**
    * Phone
    */
    'phone': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State
    */
    'state': string;
    /**
    * Status
    */
    'status': string;
}

export class AutoOrderResponse {
    'autoOrder': AutoOrder;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class AutoOrdersResponse {
    'autoOrders': Array<AutoOrder>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class AvalaraConfig {
    /**
    * Avalara account ID
    */
    'accountId': string;
    /**
    * True if Avalara is active for this merchant
    */
    'active': boolean;
    /**
    * Unique identifier for this avalara config object
    */
    'avalaraOid': number;
    /**
    * Avalara company ID
    */
    'companyId': string;
    /**
    * True if this Avalara configuration is set to enable tax valuation by UPC
    */
    'enableUpc': boolean;
    /**
    * True if this Avalara configuration is to estimate taxes only and not report placed orders to Avalara
    */
    'estimateOnly': boolean;
    /**
    * Optional customer code for customers without profiles, defaults to GuestCustomer
    */
    'guestCustomerCode': string;
    /**
    * Date/time of the connection test to Avalara
    */
    'lastTestDts': string;
    /**
    * Avalara license key
    */
    'licenseKey': string;
    /**
    * True if this Avalara instance is pointed at the Avalara Sandbox
    */
    'sandbox': boolean;
    /**
    * Send test orders through to Avalara.  The default is to not transmit test orders to Avalara.
    */
    'sendTestOrders': boolean;
    /**
    * Avalara service URL
    */
    'serviceUrl': string;
    /**
    * Test results of the last connection test to Avalara
    */
    'testResults': string;
}

export class BaseResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Cart {
    'affiliate': CartAffiliate;
    /**
    * The ISO-4217 three letter base currency code of the account
    */
    'baseCurrencyCode': string;
    'billing': CartBilling;
    'buysafe': CartBuysafe;
    /**
    * Unique identifier for this cart
    */
    'cartId': string;
    'checkout': CartCheckout;
    /**
    * Coupons
    */
    'coupons': Array<CartCoupon>;
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    'currencyConversion': CartCurrencyConversion;
    'customerProfile': CartCustomerProfile;
    /**
    * The exchange rate if the customer is viewing a different currency than the base
    */
    'exchangeRate': number;
    'gift': CartGift;
    'giftCertificate': CartGiftCertificate;
    /**
    * Items
    */
    'items': Array<CartItem>;
    /**
    * The ISO-631 three letter code the customer would like to checkout with
    */
    'languageIsoCode': string;
    /**
    * True if the customer is logged into their profile
    */
    'loggedIn': boolean;
    'marketing': CartMarketing;
    /**
    * Merchant ID this cart is associated with
    */
    'merchantId': string;
    'payment': CartPayment;
    'settings': CartSettings;
    'shipping': CartShipping;
    'summary': CartSummary;
    'taxes': CartTaxes;
    'upsellAfter': CartUpsellAfter;
}

export class CartAffiliate {
    /**
    * Affiliate id associated with the cart
    */
    'affiliateId': number;
    /**
    * Affiliate sub id associated with the cart
    */
    'affiliateSubId': string;
}

export class CartAffirmCheckoutResponse {
    /**
    * Checkout JSON object
    */
    'checkoutJson': string;
    /**
    * Errors that should be displayed to the customer
    */
    'errors': Array<string>;
}

export class CartBilling {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
    */
    'ccEmails': Array<string>;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Email
    */
    'email': string;
    /**
    * Email entered for confirmation
    */
    'emailConfirm': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
}

export class CartBuysafe {
    /**
    * True if buySAFE is willing to bond the order
    */
    'bondAvailable': boolean;
    'bondCost': Currency;
    /**
    * True if the bond is free (merchant paying for it)
    */
    'bondFree': boolean;
    /**
    * True if the customer wants the bond
    */
    'bondWanted': boolean;
    /**
    * Recommend text to display to the customer
    */
    'cartDisplayText': string;
    /**
    * URL associated with the recommended text
    */
    'cartDisplayUrl': string;
}

export class CartCheckout {
    /**
    * Comments from the customer.  Rarely used on the single page checkout.
    */
    'comments': string;
    /**
    * Custom field 1
    */
    'customField1': string;
    /**
    * Custom field 2
    */
    'customField2': string;
    /**
    * Custom field 3
    */
    'customField3': string;
    /**
    * Custom field 4
    */
    'customField4': string;
    /**
    * Custom field 5
    */
    'customField5': string;
    /**
    * Custom field 6
    */
    'customField6': string;
    /**
    * Custom field 7
    */
    'customField7': string;
    /**
    * IP Address (read only unless non-browser key authenticated)
    */
    'ipAddress': string;
    /**
    * Return code assigned for send return email operation
    */
    'returnCode': string;
    /**
    * Screen branding theme code
    */
    'screenBrandingThemeCode': string;
}

export class CartCoupon {
    /**
    * Coupon code
    */
    'couponCode': string;
}

export class CartCurrencyConversion {
    /**
    * Base currency code for this merchant
    */
    'baseCurrencyCode': string;
    /**
    * Conversion information for 1 unit of base currency to target currencies
    */
    'currencies': Array<Currency>;
}

export class CartCustomerProfile {
    /**
    * True if profile is allowed to bill to their 3rd party shipping account
    */
    'allow3rdPartyBilling': boolean;
    /**
    * True if this profile is allowed to use a COD
    */
    'allowCod': boolean;
    /**
    * True if this profile is allowed to use a purchase order
    */
    'allowPurchaseOrder': boolean;
    /**
    * Billing addresses on file for this profile
    */
    'billingAddresses': Array<CartCustomerProfileAddress>;
    /**
    * Credit cards on file for this profile (masked)
    */
    'creditCards': Array<CartCustomerProfileCreditCard>;
    /**
    * Unique identifier
    */
    'customerProfileOid': number;
    /**
    * DHL account number on file
    */
    'dhlAccountNumber': string;
    /**
    * DHL duty account number on file
    */
    'dhlDutyAccountNumber': string;
    /**
    * Email
    */
    'email': string;
    /**
    * FedEx account number on file
    */
    'fedexAccountNumber': string;
    /**
    * True if this profile always qualifies for free shipping
    */
    'freeShipping': boolean;
    /**
    * The minimum aount that this profile has to purchase to qualify for free shipping
    */
    'freeShippingMinimum': number;
    /**
    * Maximum item count this profile can purchase
    */
    'maximumItemCount': number;
    /**
    * Minimum item count this profile must purchase
    */
    'minimumItemCount': number;
    /**
    * Minimum subtotal this profile must purchase
    */
    'minimumSubtotal': number;
    /**
    * True if this profile is prevented from using coupons
    */
    'noCoupons': boolean;
    /**
    * True if this profile is never given free shipping
    */
    'noFreeShipping': boolean;
    /**
    * True if this customers orders are not charged in real-time
    */
    'noRealtimeCharge': boolean;
    /**
    * Pricing tier names this profile qualifies for
    */
    'pricingTiers': Array<string>;
    /**
    * Shipping addresses on file for this profile
    */
    'shippingAddresses': Array<CartCustomerProfileAddress>;
    /**
    * True if this profile is exempt from sales tax
    */
    'taxExempt': boolean;
    /**
    * UPS account number on file
    */
    'upsAccountNumber': string;
}

export class CartCustomerProfileAddress {
    /**
    * Address 1
    */
    'address1': string;
    /**
    * Address 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 Country code
    */
    'countryCode': string;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Unique identifier for this address
    */
    'oid': number;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Tax county if a billing address
    */
    'taxCounty': string;
    /**
    * Title
    */
    'title': string;
}

export class CartCustomerProfileCreditCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (four digit)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked last 4 digits)
    */
    'cardNumber': string;
    /**
    * Card type
    */
    'cardType': CartCustomerProfileCreditCard.CardTypeEnum;
    /**
    * Unique identifier for this stored card
    */
    'customerProfileCreditCardId': number;
    /**
    * Last used
    */
    'lastUsedDate': string;
}

export namespace CartCustomerProfileCreditCard {
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        MasterCard = <any> 'MasterCard',
        JCB = <any> 'JCB',
        VISA = <any> 'VISA'
    }
}
export class CartFinalizeOrderRequest {
    'cart': Cart;
    'options': CartFinalizeOrderRequestOptions;
}

export class CartFinalizeOrderRequestOptions {
    /**
    * Automatically approve the purchase order
    */
    'autoApprovePurchaseOrder': boolean;
    /**
    * Channel partner code to associate this order with
    */
    'channelPartnerCode': string;
    /**
    * Channel partner oid to associate this order with
    */
    'channelPartnerOid': number;
    /**
    * Channel partner order id for reference
    */
    'channelPartnerOrderId': string;
    /**
    * Consider this order a recurring order for the purposes of payment gateway recurring flag
    */
    'considerRecurring': boolean;
    /**
    * If the order was authorized outside of UltraCart, this is the amount of the authorization
    */
    'creditCardAuthorizationAmount': number;
    /**
    * If the order was authorized outside of UltraCart, this is the date/time of the authorization
    */
    'creditCardAuthorizationDate': string;
    /**
    * If the order was authorized outside of UltraCart, this is the authorization reference number
    */
    'creditCardAuthorizationReferenceNumber': string;
    /**
    * Prevents normal real-time processing of the payment and sends the order to Accounts Receivable
    */
    'noRealtimePaymentProcessing': boolean;
    /**
    * True if the system should create another cart automatically if the current cart was logged into a profile
    */
    'setupNextCart': boolean;
    /**
    * Skip payment processing and move the order on to shipping (or completed if no shipping required)
    */
    'skipPaymentProcessing': boolean;
    /**
    * True the order in the completed stage
    */
    'storeCompleted': boolean;
    /**
    * Store the order in accounts receivable if the payment declines
    */
    'storeIfPaymentDeclines': boolean;
}

export class CartFinalizeOrderResponse {
    /**
    * Error messages if the order could not be completed
    */
    'errors': Array<string>;
    'nextCart': Cart;
    'order': Order;
    /**
    * Order ID assigned to the order
    */
    'orderId': string;
    /**
    * True if the cart was converted successfully to an order
    */
    'successful': boolean;
}

export class CartGift {
    /**
    * True if this order is a gift
    */
    'gift': boolean;
    'giftCharge': Currency;
    /**
    * Email address of the gift recipient
    */
    'giftEmail': string;
    /**
    * Message to the gift recipient
    */
    'giftMessage': string;
    'giftWrapCost': Currency;
    /**
    * Title of the selected gift wrap
    */
    'giftWrapTitle': string;
}

export class CartGiftCertificate {
    'giftCertificateAmount': Currency;
    /**
    * Gift certificate code
    */
    'giftCertificateCode': string;
    'giftCertificateRemainingBalanceAfterOrder': Currency;
}

export class CartItem {
    'arbitraryUnitCost': Currency;
    /**
    * Attributes
    */
    'attributes': Array<CartItemAttribute>;
    /**
    * Auto order schedule the customer selected
    */
    'autoOrderSchedule': string;
    /**
    * URL to the default multimedia image
    */
    'defaultImageUrl': string;
    /**
    * URL to the default multimedia thumbnail
    */
    'defaultThumbnailUrl': string;
    /**
    * Description of the item
    */
    'description': string;
    'discount': Currency;
    /**
    * Extended description of the item
    */
    'extendedDescription': string;
    /**
    * Item ID
    */
    'itemId': string;
    /**
    * Item object identifier
    */
    'itemOid': number;
    /**
    * True if this item is a kit
    */
    'kit': boolean;
    /**
    * Options associated with the kit components
    */
    'kitComponentOptions': Array<CartKitComponentOption>;
    'manufacturerSuggestedRetailPrice': Currency;
    /**
    * Maximum quantity the customer can purchase
    */
    'maximumQuantity': number;
    /**
    * Minimum quantity the customer can purchase
    */
    'minimumQuantity': number;
    /**
    * Multimedia
    */
    'multimedia': Array<CartItemMultimedia>;
    /**
    * Options
    */
    'options': Array<CartItemOption>;
    'phsyical': CartItemPhysical;
    /**
    * Position of the item in the cart
    */
    'position': number;
    /**
    * True if this item is on pre-order
    */
    'preorder': boolean;
    /**
    * quantity
    */
    'quantity': number;
    /**
    * Customer selectable auto order schedules
    */
    'schedules': Array<string>;
    'totalCost': Currency;
    'totalCostWithDiscount': Currency;
    'unitCost': Currency;
    'unitCostWithDiscount': Currency;
    /**
    * True if this item was added to the cart as part of an upsell
    */
    'upsell': boolean;
    /**
    * Variations
    */
    'variations': Array<CartItemVariationSelection>;
    /**
    * URL to view the product on the site
    */
    'viewUrl': string;
}

export class CartItemAttribute {
    /**
    * Name of the attribute
    */
    'name': string;
    /**
    * Type of attribute
    */
    'type': string;
    /**
    * Value of the attribute
    */
    'value': string;
}

export class CartItemMultimedia {
    /**
    * Code assigned to the multimedia
    */
    'code': string;
    /**
    * Description
    */
    'description': string;
    /**
    * True if the image should be excluded from galleries
    */
    'excludeFromGallery': boolean;
    /**
    * Image height
    */
    'imageHeight': number;
    /**
    * Image width
    */
    'imageWidth': number;
    /**
    * True if the multimedia is the default for this type
    */
    'isDefault': boolean;
    /**
    * Thumbnails of the images
    */
    'thumbnails': Array<CartItemMultimediaThumbnail>;
    /**
    * Type of multimedia
    */
    'type': CartItemMultimedia.TypeEnum;
    /**
    * URL to view multimedia at
    */
    'url': string;
}

export namespace CartItemMultimedia {
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}
export class CartItemMultimediaThumbnail {
    /**
    * Height in pixels
    */
    'height': number;
    /**
    * True if thumbnail is a PNG, otherwise its a JPEG
    */
    'png': boolean;
    /**
    * True if the thumbnail is square
    */
    'square': boolean;
    /**
    * URL for the thumbnail
    */
    'url': string;
    /**
    * Width in pixels
    */
    'width': number;
}

export class CartItemOption {
    'costIfSpecified': Currency;
    'costPerLetter': Currency;
    'costPerLine': Currency;
    /**
    * True if the default answer is ignored
    */
    'ignoreIfDefault': boolean;
    /**
    * Display label for the option
    */
    'label': string;
    /**
    * Name of the option
    */
    'name': string;
    /**
    * Charge the fee a single time instead of multiplying by the quantity
    */
    'oneTimeFee': boolean;
    /**
    * Unique identifier for the option
    */
    'optionOid': number;
    /**
    * True if the customer is required to select a value
    */
    'required': boolean;
    /**
    * The value of the option specified by the customer
    */
    'selectedValue': string;
    /**
    * Type of option
    */
    'type': CartItemOption.TypeEnum;
    /**
    * Values that the customer can select from for radio or select type options
    */
    'values': Array<CartItemOptionValue>;
}

export namespace CartItemOption {
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}
export class CartItemOptionValue {
    'additionalCost': Currency;
    'additionalWeight': Weight;
    /**
    * True if this is the default value
    */
    'defaultValue': boolean;
    /**
    * Display order of the option value
    */
    'displayOrder': number;
    /**
    * Value of the option the customer can select
    */
    'value': string;
}

export class CartItemPhysical {
    'height': Distance;
    'length': Distance;
    'weight': Weight;
    'width': Distance;
}

export class CartItemVariationSelection {
    /**
    * Variation name
    */
    'variationName': string;
    /**
    * Variation value
    */
    'variationValue': string;
}

export class CartKitComponentOption {
    'costIfSpecified': Currency;
    'costPerLetter': Currency;
    'costPerLine': Currency;
    /**
    * True if the default answer is ignored
    */
    'ignoreIfDefault': boolean;
    /**
    * Kit component item id
    */
    'itemId': string;
    /**
    * Unique identifier for the kit component item
    */
    'itemOid': number;
    /**
    * Display label for the option
    */
    'label': string;
    /**
    * Name of the option
    */
    'name': string;
    /**
    * Charge the fee a single time instead of multiplying by the quantity
    */
    'oneTimeFee': boolean;
    /**
    * Unique identifier for the option
    */
    'optionOid': number;
    /**
    * True if the customer is required to select a value
    */
    'required': boolean;
    /**
    * The value of the option specified by the customer
    */
    'selectedValue': string;
    /**
    * Type of option
    */
    'type': CartKitComponentOption.TypeEnum;
    /**
    * Values that the customer can select from for radio or select type options
    */
    'values': Array<CartItemOptionValue>;
}

export namespace CartKitComponentOption {
    export enum TypeEnum {
        Single = <any> 'single',
        Multiline = <any> 'multiline',
        Dropdown = <any> 'dropdown',
        Hidden = <any> 'hidden',
        Radio = <any> 'radio',
        Fixed = <any> 'fixed'
    }
}
export class CartMarketing {
    /**
    * The advertising source the customer indicated
    */
    'advertisingSource': string;
    /**
    * True if the customer agrees to receiving marketing emails
    */
    'mailingListOptIn': boolean;
}

export class CartPayment {
    'affirm': CartPaymentAffirm;
    'amazon': CartPaymentAmazon;
    'check': CartPaymentCheck;
    'creditCard': CartPaymentCreditCard;
    /**
    * Payment method
    */
    'paymentMethod': string;
    'purchaseOrder': CartPaymentPurchaseOrder;
    /**
    * Rotating transaction gateway code
    */
    'rtgCode': string;
}

export class CartPaymentAffirm {
    /**
    * Affirm checkout token
    */
    'affirmCheckoutToken': string;
}

export class CartPaymentAmazon {
    /**
    * Amazon order reference id
    */
    'amazonOrderReferenceId': string;
}

export class CartPaymentCheck {
    /**
    * Check number they are paying with
    */
    'checkNumber': number;
}

export class CartPaymentCreditCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (four digit year)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked to the last 4)
    */
    'cardNumber': string;
    /**
    * Hosted field token for the card number
    */
    'cardNumberToken': string;
    /**
    * Card type
    */
    'cardType': string;
    /**
    * Card verification number (masked)
    */
    'cardVerificationNumber': string;
    /**
    * Hosted field token for the card verification number
    */
    'cardVerificationNumberToken': string;
    /**
    * ID of the stored credit card to use
    */
    'customerProfileCreditCardId': number;
    /**
    * True if the customer wants to store the card on their profile for future re-use
    */
    'storeCreditCard': boolean;
}

export class CartPaymentPurchaseOrder {
    /**
    * Purchase order number
    */
    'purchaseOrderNumber': string;
}

export class CartProfileLoginRequest {
    'cart': Cart;
    /**
    * Unique identifier for customer profile.  Can not be used with browser key authentication type.
    */
    'customerProfileOid': number;
    /**
    * Password for the profile
    */
    'password': string;
}

export class CartProfileLoginResponse {
    'cart': Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors': Array<string>;
}

export class CartProfileRegisterRequest {
    'cart': Cart;
    /**
    * Password for the profile
    */
    'password': string;
}

export class CartProfileRegisterResponse {
    'cart': Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors': Array<string>;
}

export class CartResponse {
    'cart': Cart;
    /**
    * Errors that should be displayed to the customer
    */
    'errors': Array<string>;
}

export class CartSettings {
    'billing': CartSettingsBilling;
    'gift': CartSettingsGift;
    'payment': CartSettingsPayment;
    'shipping': CartSettingsShipping;
    'taxes': CartSettingsTaxes;
    'terms': CartSettingsTerms;
}

export class CartSettingsBilling {
    /**
    * Provinces
    */
    'provinces': Array<CartSettingsProvince>;
}

export class CartSettingsGift {
    /**
    * True if this checkout supports gift giving
    */
    'allowGifts': boolean;
    'giftCharge': Currency;
    /**
    * The gift wraps available for the customer to select from
    */
    'giftWraps': Array<CartSettingsGiftWrap>;
    /**
    * The maximum length of the gift message the giver can enter
    */
    'maxMessageLength': number;
}

export class CartSettingsGiftWrap {
    'cost': Currency;
    /**
    * Title of the gift wrap
    */
    'title': string;
    /**
    * URL for the sample of the gift wrap
    */
    'url': string;
}

export class CartSettingsPayment {
    'amazon': CartSettingsPaymentAmazon;
    'creditCard': CartSettingsPaymentCreditCard;
    /**
    * True if this card requires a payment from the customer
    */
    'needPayment': boolean;
    'paypal': CartSettingsPaymentPayPal;
    /**
    * True if Amazon payments are available on this order
    */
    'supportsAmazon': boolean;
    /**
    * True if check payments are available on this order
    */
    'supportsCheck': boolean;
    /**
    * True if COD payments are available on this order
    */
    'supportsCod': boolean;
    /**
    * True if credit card payments are available on this order
    */
    'supportsCreditCard': boolean;
    /**
    * True if money order payments are available on this order
    */
    'supportsMoneyOrder': boolean;
    /**
    * True if PayPal payments are available on this order
    */
    'supportsPaypal': boolean;
    /**
    * True if purchase order payments are available on this order
    */
    'supportsPurchaseOrder': boolean;
    /**
    * True if quote requests payments are available on this order
    */
    'supportsQuoteRequest': boolean;
    /**
    * True if wire transfer payments are available on this order
    */
    'supportsWireTransfer': boolean;
}

export class CartSettingsPaymentAmazon {
    /**
    * Amazon button URL
    */
    'amazonButtonUrl': string;
    /**
    * Amazon merchant ID
    */
    'amazonMerchantId': string;
    /**
    * Amazon widget URL
    */
    'amazonWidgetUrl': string;
}

export class CartSettingsPaymentCreditCard {
    /**
    * True if the credit card verification number should be collected
    */
    'collectCreditCardVerificationNumber': boolean;
    /**
    * Available credit card types
    */
    'creditCardTypes': Array<string>;
    /**
    * The shoppingCartToken needed for proper initialization of hosted fields collection
    */
    'hostedFieldsShoppingCartToken': string;
}

export class CartSettingsPaymentPayPal {
    /**
    * PayPal button alt text
    */
    'paypalButtonAltText': string;
    /**
    * PayPal button URL
    */
    'paypalButtonUrl': string;
    /**
    * PayPal Credit button URL
    */
    'paypalCreditButtonUrl': string;
    /**
    * PayPal Credit legal image URL
    */
    'paypalCreditLegalImageUrl': string;
    /**
    * PayPal Credit legal URL
    */
    'paypalCreditLegalUrl': string;
}

export class CartSettingsProvince {
    'code': string;
    'province': string;
}

export class CartSettingsShipping {
    'deliverOnDate': CartSettingsShippingCalendar;
    /**
    * Estimates for this cart
    */
    'estimates': Array<CartSettingsShippingEstimate>;
    /**
    * True if this order needs shipping
    */
    'needShipping': boolean;
    /**
    * Provinces
    */
    'provinces': Array<CartSettingsProvince>;
    'shipOnDate': CartSettingsShippingCalendar;
}

export class CartSettingsShippingCalendar {
    /**
    * Specified dates that are blacked out on the calendar in ISO8601 format
    */
    'blackouts': Array<string>;
    /**
    * Days of week that should be enabled on the calendar (0 - Sunday through 6 - Saturday)
    */
    'daysOfWeek': Array<boolean>;
    /**
    * The earliest date that can be selected on the calendar
    */
    'earliest': string;
    /**
    * True if the customer is required to select a date
    */
    'require': boolean;
    /**
    * True if this calendar should be shown to the customer
    */
    'show': boolean;
}

export class CartSettingsShippingEstimate {
    /**
    * True if this method allows the customer to use their own shipper account number
    */
    'allow3rdPartyBilling': boolean;
    /**
    * Comment to display to the customer about this method
    */
    'comment': string;
    'cost': Currency;
    'costBeforeDiscount': Currency;
    /**
    * True if this is the default method
    */
    'defaultMethod': boolean;
    'discount': Currency;
    /**
    * True if this method is discounted because of a coupon
    */
    'discounted': boolean;
    /**
    * The name to display to the customer
    */
    'displayName': string;
    /**
    * Date of the estimated delivery (or range)
    */
    'estimatedDelivery': string;
    /**
    * True if a lift gate option for this method should be offered to the customer
    */
    'liftGateOption': boolean;
    /**
    * Shipping method name
    */
    'name': string;
    'tax': Currency;
    'totalTax': Currency;
}

export class CartSettingsTaxes {
    'counties': Array<string>;
}

export class CartSettingsTerms {
    /**
    * HTML version of the terms
    */
    'html': string;
    /**
    * Text version of the terms.
    */
    'text': string;
}

export class CartShipping {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day time phone
    */
    'dayPhone': string;
    /**
    * Date the customer is requesting delivery on. Typically used for perishable product delivery.
    */
    'deliveryDate': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Lift gate requested (LTL shipping methods only)
    */
    'liftGate': boolean;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
    */
    'shipOnDate': string;
    /**
    * True if the shipping adress is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
    */
    'shipToResidential': boolean;
    /**
    * 3rd party account number to ship against for UPS or FedEx
    */
    'shipping3rdPartyAccountNumber': string;
    /**
    * Shipping method
    */
    'shippingMethod': string;
    /**
    * Special instructions from the customer regarding shipping
    */
    'specialInstructions': string;
    /**
    * State/Region
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
}

export class CartSummary {
    'arbitraryShippingHandlingTotal': Currency;
    'arbitraryTax': Currency;
    'arbitraryTaxRate': Currency;
    'arbitraryTaxableSubtotal': Currency;
    'shippingHandling': Currency;
    'shippingHandlingDiscount': Currency;
    'shippingHandlingWithDiscount': Currency;
    'subtotal': Currency;
    'subtotalDiscount': Currency;
    'subtotalWithDiscount': Currency;
    'surcharge': Currency;
    'tax': Currency;
    'taxableSubtotal': Currency;
    'taxableSubtotalDiscount': Currency;
    'taxableSubtotalWithDiscount': Currency;
    'total': Currency;
}

export class CartTaxes {
    /**
    * Tax county if the state requires it.
    */
    'county': string;
    /**
    * True if tax exempt
    */
    'exempt': boolean;
    /**
    * Tax rate
    */
    'rate': number;
}

export class CartUpsellAfter {
    /**
    * The date/time after which the cart will finalize into an order.
    */
    'finalizeAfterDts': string;
    /**
    * The amount of inactivity in minutes after which the cart should be finalized into an order.  This will calculate the finalize_after_dts field.
    */
    'finalizeAfterMinutes': number;
    /**
    * Upsell path code
    */
    'upsellPathCode': string;
}

export class CartValidationRequest {
    'cart': Cart;
    /**
    * Checks to perform
    */
    'checks': Array<string>;
}

export class CartValidationResponse {
    'cart': Cart;
    /**
    * Errors to display to the customer if they failed any of the validations checked
    */
    'errors': Array<string>;
}

export class ChargebackDispute {
    /**
    * Account number
    */
    'accountNumber': string;
    /**
    * Adjustment request text
    */
    'adjustmentRequestText': string;
    /**
    * Amount
    */
    'amount': number;
    /**
    * Auth code
    */
    'authCode': string;
    /**
    * Case number
    */
    'caseNumber': string;
    /**
    * Chargeback Dispute Oid
    */
    'chargebackDisputeOid': number;
    /**
    * Chargeback dts
    */
    'chargebackDts': string;
    /**
    * Currency
    */
    'currency': string;
    /**
    * Customer care notes
    */
    'customerCareNotes': string;
    /**
    * Encryption key
    */
    'encryptionKey': string;
    /**
    * Expiration Dts
    */
    'expirationDts': string;
    /**
    * Fax failure reason
    */
    'faxFailureReason': string;
    /**
    * Fax number
    */
    'faxNumber': string;
    /**
    * Fax transaction id
    */
    'faxTransactionId': number;
    /**
    * icsid
    */
    'icsid': string;
    /**
    * Merchant account profile oid
    */
    'merchantAccountProfileOid': number;
    'order': Order;
    /**
    * Order Id
    */
    'orderId': string;
    /**
    * Partial card number
    */
    'partialCardNumber': string;
    /**
    * PDF file oid
    */
    'pdfFileOid': string;
    /**
    * Reason code
    */
    'reasonCode': string;
    /**
    * Status
    */
    'status': string;
    /**
    * Website URL
    */
    'websiteUrl': string;
}

export class ChargebackDisputeResponse {
    'chargeback': ChargebackDispute;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class ChargebackDisputesResponse {
    'chargebacks': Array<ChargebackDispute>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class CheckoutAllowedCountriesResponse {
    'countries': Array<Country>;
}

export class CheckoutHandoffRequest {
    'cart': Cart;
    /**
    * If any error happen during the processing on the UltraCart side, the browser will be redirected to your error_return_url with the error passed in this parameter name.
    */
    'errorParameterName': string;
    /**
    * The URL to return the browser to if there are processing errors on the UltraCart side.
    */
    'errorReturnUrl': string;
    /**
    * The type of handoff operation to perform
    */
    'operation': CheckoutHandoffRequest.OperationEnum;
    /**
    * The maximum amount of revenue that you think the customer could add during a custom upsell after sequence on your checkout.
    */
    'paypalMaximumUpsellRevenue': number;
    /**
    * The URl to return the customers browser to after they have completed the PayPal process.
    */
    'paypalReturnUrl': string;
    /**
    * The desired secure host name to perform the handoff on.  This should match the desired StoreFront.
    */
    'secureHostName': string;
}

export namespace CheckoutHandoffRequest {
    export enum OperationEnum {
        Checkout = <any> 'checkout',
        PayPal = <any> 'payPal',
        PayPalCredit = <any> 'payPalCredit',
        View = <any> 'view',
        Affirm = <any> 'affirm'
    }
}
export class CheckoutHandoffResponse {
    'cart': Cart;
    /**
    * Errors that occurred which are preventing the handoff operation.  Display these to the customer.
    */
    'errors': Array<string>;
    /**
    * The URL that you should redirect the customers browser to
    */
    'redirectToUrl': string;
}

export class CheckoutSetupBrowserKeyRequest {
    /**
    * Allowed referrers.  If URLs are specified, automatic translation will convert them to proper allowed referrer maskes.
    */
    'allowedReferrers': Array<string>;
}

export class CheckoutSetupBrowserKeyResponse {
    /**
    * Browser key that is used to authenticate against the new linked application.
    */
    'browserKey': string;
}

export class CheckoutStateProvinceResponse {
    'stateProvinces': Array<StateProvince>;
}

export class CityStateZip {
    'city': string;
    'error': string;
    'state': string;
    'validZip': boolean;
    'zip': string;
}

export class CountriesResponse {
    'countries': Array<Country>;
}

export class Country {
    /**
    * iso_2_code
    */
    'iso2Code': string;
    /**
    * name
    */
    'name': string;
}

export class Coupon {
    /**
    * Associates an order with an affiliate when this value is set.
    */
    'affiliateOid': number;
    'amountOffItems': CouponAmountOffItems;
    'amountOffShipping': CouponAmountOffShipping;
    'amountOffShippingWithItemsPurchase': CouponAmountOffShippingWithItemsPurchase;
    'amountOffSubtotal': CouponAmountOffSubtotal;
    'amountOffSubtotalAndFreeShipping': CouponAmountOffSubtotalFreeShippingWithPurchase;
    'amountOffSubtotalAndShipping': CouponAmountOffSubtotalAndShipping;
    'amountOffSubtotalWithBlockPurchase': CouponAmountOffSubtotalWithBlockPurchase;
    'amountOffSubtotalWithItemsPurchase': CouponAmountOffSubtotalWithItemsPurchase;
    'automaticallyApplyCouponCodes': CouponAutomaticallyApplyCouponCodes;
    /**
    * Calculated description displayed to the customer if no description is specified.
    */
    'calculated)description': string;
    /**
    * True if this coupon can be used with other coupons in a single order.
    */
    'canBeUsedWithOtherCoupons': boolean;
    /**
    * Coupon oid.
    */
    'couponOid': number;
    /**
    * Coupon type.
    */
    'couponType': string;
    /**
    * Description of the coupon up to 50 characters.
    */
    'description': string;
    'discountItemWithItemPurchase': CouponDiscountItemWithItemPurchase;
    'discountItems': CouponDiscountItems;
    /**
    * Date/time when coupon expires
    */
    'expirationDts': string;
    'freeItemAndShippingWithSubtotal': CouponFreeItemAndShippingWithSubtotal;
    'freeItemWithItemPurchase': CouponFreeItemWithItemPurchase;
    'freeItemWithSubtotal': CouponFreeItemWithSubtotal;
    'freeItemsWithItemPurchase': CouponFreeItemsWithItemPurchase;
    'freeItemsWithMixmatchPurchase': CouponFreeItemsWithMixMatchPurchase;
    'freeShipping': CouponFreeShipping;
    'freeShippingSpecificItems': CouponFreeShippingSpecificItems;
    'freeShippingWithItemsPurchase': CouponFreeShippingWithItemsPurchase;
    'freeShippingWithSubtotal': CouponFreeShippingWithSubtotal;
    /**
    * Merchant code of coupon up to 20 characters.
    */
    'merchantCode': string;
    'multipleAmountsOffItems': CouponMultipleAmountsOffItems;
    'noDiscount': CouponNoDiscount;
    'percentOffItemWithItemsQuantityPurchase': CouponPercentOffItemWithItemsQuantityPurchase;
    'percentOffItems': CouponPercentOffItems;
    'percentOffItemsAndFreeShipping': CouponPercentOffItemsAndFreeShipping;
    'percentOffItemsWithItemsPurchase': CouponPercentOffItemsWithItemsPurchase;
    'percentOffRetailPriceItems': CouponPercentOffRetailPriceItems;
    'percentOffShipping': CouponPercentOffShipping;
    'percentOffSubtotal': CouponPercentOffSubtotal;
    'percentOffSubtotalAndFreeShipping': CouponPercentOffSubtotalAndFreeShipping;
    'percentOffSubtotalLimit': CouponPercentOffSubtotalLimit;
    'percentOffSubtotalWithItems purchase': CouponPercentOffSubtotalWithItemsPurchase;
    'percentOffSubtotalWithSubtotal': CouponPercentOffSubtotalWithSubtotal;
    /**
    * Quickbooks accounting code.
    */
    'quickbooksCode': string;
    /**
    * Date/time when coupon is valid
    */
    'startDts': string;
    'tieredAmountOffItem': CouponTieredAmountOffItem;
    'tieredAmountOffSubtotal': CouponTieredAmountOffSubtotal;
    'tieredPercentOffItems': CouponTieredPercentOffItems;
    'tieredPercentOffShipping': CouponTieredPercentOffShipping;
    'tieredPercentOffSubtotal': CouponTieredPercentOffSubtotal;
    /**
    * Who may use this coupon.
    */
    'usableBy': string;
}

export class CouponAmountOffItems {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of shipping discount
    */
    'discountAmount': number;
    /**
    * A list of items which are eligible for the discount amount.
    */
    'items': Array<string>;
}

export class CouponAmountOffShipping {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount': number;
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods': Array<string>;
}

export class CouponAmountOffShippingWithItemsPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of shipping discount
    */
    'discountAmount': number;
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items': Array<string>;
    /**
    * One or more shipping methods that may receive this discount
    */
    'shippingMethods': Array<string>;
}

export class CouponAmountOffSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount': number;
}

export class CouponAmountOffSubtotalAndShipping {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount': number;
}

export class CouponAmountOffSubtotalFreeShippingWithPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount': number;
    /**
    * The purchase amount to qualify for subtotal discount and free shipping
    */
    'purchaseAmount': number;
    /**
    * One or more shipping methods that may be free
    */
    'shippingMethods': Array<string>;
}

export class CouponAmountOffSubtotalWithBlockPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of subtotal discount
    */
    'discountAmount': number;
    /**
    * Required item that must be purchased for coupon to be valid
    */
    'requiredPurchaseItem': string;
    /**
    * Discount amount is multiplied by the number of blocks.  A block is this many quantity of the required item.
    */
    'requiredPurchaseQuantity': number;
}

export class CouponAmountOffSubtotalWithItemsPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The amount of shipping discount
    */
    'discountAmount': number;
    /**
    * A list of items of which a quantity of one or many must be purchased for coupon to be valid.
    */
    'items': Array<string>;
    /**
    * The quantity of items that must be purchased for the discount to be applied.
    */
    'requiredPurchaseQuantity': number;
}

export class CouponAutomaticallyApplyCouponCodes {
    /**
    * The coupon codes to automatically apply if this coupon is applied
    */
    'couponCodes': Array<string>;
}

export class CouponCodesRequest {
    'error': Error;
    /**
    * Expiration Date
    */
    'expirationDts': string;
    /**
    * Expiration seconds
    */
    'expirationSeconds': number;
    'metadata': ResponseMetadata;
    /**
    * Quantity
    */
    'quantity': number;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class CouponCodesResponse {
    /**
    * Coupon codes
    */
    'couponCodes': Array<string>;
    'error': Error;
    /**
    * Expiration date
    */
    'expirationDts': string;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class CouponDiscountItemWithItemPurchase {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The item that will be sold at the discount_price when required_purchase_item is purchased.
    */
    'discountItem': string;
    /**
    * The price (unit cost) of the discounted item
    */
    'discountPrice': number;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit': number;
    /**
    * The item that must be purchased for the discount to be applied to the discount item.
    */
    'requiredPurchaseItem': string;
}

export class CouponDiscountItems {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The price (unit cost) of the discounted item
    */
    'discountPrice': number;
    /**
    * A list of items that are eligible for this discount_price.
    */
    'items': Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit': number;
}

export class CouponEditorValues {
    /**
    * coupon_types
    */
    'couponTypes': Array<string>;
}

export class CouponFreeItemAndShippingWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * A list of items that are eligible for this discount_price.
    */
    'items': Array<string>;
    /**
    * The limit of free items that may be received when purchasing multiple items
    */
    'limit': number;
    /**
    * One or more shipping methods that may be free
    */
    'shippingMethods': Array<string>;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount': number;
}

export class CouponFreeItemWithItemPurchase {
    /**
    * A list of free items which will receive a discount if one of the required purchase items is purchased.
    */
    'items': Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit': number;
    /**
    * Required items (at least one from the list) that must be purchased for coupon to be valid
    */
    'requiredPurchaseItems': Array<string>;
}

export class CouponFreeItemWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * A list of items that are eligible for this discount_price.
    */
    'items': Array<string>;
    /**
    * The limit of free items that may be received when purchasing multiple items
    */
    'limit': number;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount': number;
}

export class CouponFreeItemsWithItemPurchase {
    /**
    * The item id of the free item that will be received when the required mix and match group quantity is purchased.
    */
    'freeItem': string;
    /**
    * The quantity of free item that will be received.
    */
    'freeQuantity': number;
    /**
    * The limit of free items that may be received when purchasing multiple items
    */
    'limit': number;
    /**
    * Required item that must be purchased for coupon to be valid
    */
    'requiredPurchaseItem': string;
    /**
    * Required quantity of mix and match group items that must be purchased for coupon to be valid
    */
    'requiredPurchaseQuantity': number;
}

export class CouponFreeItemsWithMixMatchPurchase {
    /**
    * The item id of the free item that will be received when the required mix and match group quantity is purchased.
    */
    'freeItem': string;
    /**
    * The quantity of free item that will be received.
    */
    'freeQuantity': number;
    /**
    * The limit of free items that may be received when purchasing multiple mix and match group items
    */
    'limit': number;
    /**
    * Required mix and match group that must be purchased for coupon to be valid
    */
    'requiredPurchaseMixAndMatchGroup': string;
    /**
    * Required quantity of mix and match group items that must be purchased for coupon to be valid
    */
    'requiredPurchaseQuantity': number;
}

export class CouponFreeShipping {
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods': Array<string>;
}

export class CouponFreeShippingSpecificItems {
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items': Array<string>;
}

export class CouponFreeShippingWithItemsPurchase {
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items': Array<string>;
    /**
    * One or more shipping methods that may receive this discount
    */
    'shippingMethods': Array<string>;
}

export class CouponFreeShippingWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The purchase amount to qualify for subtotal discount and free shipping
    */
    'purchaseAmount': number;
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods': Array<string>;
}

export class CouponMultipleAmountsOffItems {
    /**
    * A list of item discounts.
    */
    'discounts': Array<CouponTierItemDiscount>;
    /**
    * The (optional) maximum quantity of items that may receive a discount.
    */
    'limit': number;
}

export class CouponNoDiscount {
}

export class CouponPercentOffItemWithItemsQuantityPurchase {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * A list of items which will receive a discount if one of the required purchase items is purchased.
    */
    'items': Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit': number;
    /**
    * Required items (at least one from the list) that must be purchased for coupon to be valid
    */
    'requiredPurchaseItems': Array<string>;
    /**
    * The quantity of items that must be purchased for the discount to be applied.
    */
    'requiredPurchaseQuantity': number;
}

export class CouponPercentOffItems {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * A list of items which cannot be discounted.
    */
    'excludedItems': Array<string>;
    /**
    * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
    */
    'items': Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit': number;
}

export class CouponPercentOffItemsAndFreeShipping {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * A list of items which cannot be discounted.
    */
    'excludedItems': Array<string>;
    /**
    * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
    */
    'items': Array<string>;
}

export class CouponPercentOffItemsWithItemsPurchase {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * A list of items which will receive a discount if one of the required purchase items is purchased.
    */
    'items': Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit': number;
    /**
    * Required items (at least one from the list) that must be purchased for coupon to be valid
    */
    'requiredPurchaseItems': Array<string>;
}

export class CouponPercentOffRetailPriceItems {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * A list of items which cannot be discounted.
    */
    'excludedItems': Array<string>;
    /**
    * An optional list of items which will receive a discount.  If blank, discount applies to all items except excluded items.
    */
    'items': Array<string>;
    /**
    * The (optional) maximum quantity of discounted items.
    */
    'limit': number;
}

export class CouponPercentOffShipping {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * One or more shipping methods that may be used with this coupon
    */
    'shippingMethods': Array<string>;
}

export class CouponPercentOffSubtotal {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
}

export class CouponPercentOffSubtotalAndFreeShipping {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * One or more shipping methods that may be free
    */
    'shippingMethods': Array<string>;
}

export class CouponPercentOffSubtotalLimit {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * The maximum amount of subtotal used to determine discount.
    */
    'limit': number;
}

export class CouponPercentOffSubtotalWithItemsPurchase {
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items': Array<string>;
}

export class CouponPercentOffSubtotalWithSubtotal {
    /**
    * The ISO-4217 three letter currency code the customer is viewing prices in
    */
    'currencyCode': string;
    /**
    * The percentage of subtotal discount
    */
    'discountPercent': number;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount': number;
}

export class CouponQuery {
    /**
    * Affiliate oid
    */
    'affiliateOid': number;
    /**
    * The type of coupon.
    */
    'couponType': string;
    /**
    * Description of this coupon
    */
    'description': string;
    /**
    * Exclude expired coupons if true
    */
    'excludeExpired': boolean;
    /**
    * Expiration date begin
    */
    'expirationDtsBegin': string;
    /**
    * Expiration date begin
    */
    'expirationDtsEnd': string;
    /**
    * Merchant code is a unique character string for this coupon.
    */
    'merchantCode': string;
    /**
    * Start date begin
    */
    'startDtsBegin': string;
    /**
    * Start date end
    */
    'startDtsEnd': string;
}

export class CouponResponse {
    'coupon': Coupon;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class CouponTierAmount {
    /**
    * The amount of subtotal discount
    */
    'discountAmount': number;
    /**
    * The amount of subtotal required to receive the discount amount
    */
    'subtotalAmount': number;
}

export class CouponTierItemDiscount {
    /**
    * The amount of subtotal discount
    */
    'discountAmount': number;
    /**
    * A list of items which will receive this discount.
    */
    'items': Array<string>;
}

export class CouponTierPercent {
    /**
    * The percent of subtotal discount
    */
    'discountPercent': number;
    /**
    * The amount of subtotal required to receive the discount percent
    */
    'subtotalAmount': number;
}

export class CouponTierQuantityAmount {
    /**
    * The amount of discount per item.
    */
    'discountAmount': number;
    /**
    * The quantity of item purchased (in units)
    */
    'itemQuantity': number;
}

export class CouponTierQuantityPercent {
    /**
    * The percent of discount per item.
    */
    'discountPercent': number;
    /**
    * The quantity of item purchased (in units)
    */
    'itemQuantity': number;
}

export class CouponTieredAmountOffItem {
    /**
    * The item being discounted by this coupon.
    */
    'item': string;
    /**
    * The maximum amount of total discount by this coupon.
    */
    'limit': number;
    /**
    * A list of discount tiers.
    */
    'tiers': Array<CouponTierQuantityAmount>;
}

export class CouponTieredAmountOffSubtotal {
    /**
    * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
    */
    'items': Array<string>;
    /**
    * A list of discount tiers.
    */
    'tiers': Array<CouponTierAmount>;
}

export class CouponTieredPercentOffItems {
    /**
    * A list of items of which at least one must be purchased for coupon to be valid.
    */
    'items': Array<string>;
    /**
    * The maximum amount of total discount by this coupon.
    */
    'limit': number;
    /**
    * A list of discount tiers.
    */
    'tiers': Array<CouponTierQuantityPercent>;
}

export class CouponTieredPercentOffShipping {
    /**
    * One or more shipping methods that may receive this discount
    */
    'shippingMethods': Array<string>;
    /**
    * A list of discount tiers.
    */
    'tiers': Array<CouponTierPercent>;
}

export class CouponTieredPercentOffSubtotal {
    /**
    * An optional list of items of which a quantity of one or many must be purchased for coupon to be valid.  If empty, all items apply toward subtotal amount.
    */
    'items': Array<string>;
    /**
    * A list of discount tiers.
    */
    'tiers': Array<CouponTierPercent>;
}

export class CouponsResponse {
    'coupons': Array<Coupon>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Currency {
    /**
    * Currency code of the localized value
    */
    'currencyCode': string;
    /**
    * Exchange rate used to localize
    */
    'exchangeRate': number;
    /**
    * Value localized to the customer
    */
    'localized': number;
    /**
    * Value localized and formatted for the customer
    */
    'localizedFormatted': string;
    /**
    * Value in base currency
    */
    'value': number;
}

export class Customer {
    'activity': CustomerActivity;
    /**
    * Affiliate oid
    */
    'affiliateOid': number;
    /**
    * Allow 3rd party billing
    */
    'allow3rdPartyBilling': boolean;
    /**
    * Allow COD
    */
    'allowCod': boolean;
    /**
    * Allow purchase orders by this customer
    */
    'allowPurchaseOrder': boolean;
    /**
    * Allow quote request
    */
    'allowQuoteRequest': boolean;
    /**
    * Allow selection of residential or business address type
    */
    'allowSelectionOfAddressType': boolean;
    /**
    * Attachments
    */
    'attachments': Array<CustomerAttachment>;
    /**
    * Auto approve COD
    */
    'autoApproveCod': boolean;
    /**
    * Auto approve purchase orders by this customer
    */
    'autoApprovePurchaseOrder': boolean;
    /**
    * Automatic merchant notes are added to every order placed
    */
    'automaticMerchantNotes': string;
    /**
    * Billing addresses for this customer
    */
    'billing': Array<CustomerBilling>;
    /**
    * Business notes (internally visible only)
    */
    'businessNotes': string;
    /**
    * Credit Cards for this customer
    */
    'cards': Array<CustomerCard>;
    /**
    * Additional emails to CC notification
    */
    'ccEmails': Array<CustomerEmail>;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * DHL account number
    */
    'dhlAccountNumber': string;
    /**
    * DHL duty account number
    */
    'dhlDutyAccountNumber': string;
    /**
    * Email address of this customer profile
    */
    'email': string;
    /**
    * Exempt shipping handling charge
    */
    'exemptShippingHandlingCharge': boolean;
    /**
    * FedEx account number
    */
    'fedexAccountNumber': string;
    /**
    * This customer always receives free shipping
    */
    'freeShipping': boolean;
    /**
    * If free_shipping is true, this is the minimum subtotal required for free shipping
    */
    'freeShippingMinimum': number;
    /**
    * Last modified by
    */
    'lastModifiedBy': string;
    /**
    * Last modified date
    */
    'lastModifiedDts': string;
    /**
    * Maximum item count
    */
    'maximumItemCount': number;
    /**
    * Minimum item count
    */
    'minimumItemCount': number;
    /**
    * Minimum subtotal
    */
    'minimumSubtotal': number;
    /**
    * No coupons
    */
    'noCoupons': boolean;
    /**
    * No free shipping regardless of coupons or item level settings
    */
    'noFreeShipping': boolean;
    /**
    * No realtime charge
    */
    'noRealtimeCharge': boolean;
    /**
    * Orders associated with this customer profile
    */
    'orders': Array<Order>;
    'ordersSummary': CustomerOrdersSummary;
    /**
    * Password (may only be set, never read)
    */
    'password': string;
    /**
    * Pricing tiers for this customer
    */
    'pricingTiers': Array<CustomerPricingTier>;
    'privacy': CustomerPrivacy;
    /**
    * QuickBooks class to import this customer as
    */
    'qbClass': string;
    /**
    * QuickBooks name to import this customer as
    */
    'qbCode': string;
    /**
    * Quotes associated with this customer profile
    */
    'quotes': Array<Order>;
    'quotesSummary': CustomerQuotesSummary;
    /**
    * Referral Source
    */
    'referralSource': string;
    'reviewer': CustomerReviewer;
    /**
    * Sales rep code
    */
    'salesRepCode': string;
    /**
    * Send signup notification, if true during customer creation, will send a notification.
    */
    'sendSignupNotification': boolean;
    /**
    * Shipping addresses for this customer
    */
    'shipping': Array<CustomerShipping>;
    /**
    * Signup date
    */
    'signupDts': string;
    /**
    * Software entitlements owned by this customer
    */
    'softwareEntitlements': Array<CustomerSoftwareEntitlement>;
    /**
    * Suppress buySAFE
    */
    'suppressBuysafe': boolean;
    'taxCodes': CustomerTaxCodes;
    /**
    * True if the customer is tax exempt
    */
    'taxExempt': boolean;
    /**
    * Tax ID
    */
    'taxId': string;
    /**
    * Terms for this customer
    */
    'terms': string;
    /**
    * True if the customer should be tracked separately in QuickBooks
    */
    'trackSeparately': boolean;
    /**
    * Unapproved
    */
    'unapproved': boolean;
    /**
    * UPS account number
    */
    'upsAccountNumber': string;
    /**
    * Website url
    */
    'websiteUrl': string;
}

export class CustomerActivity {
    'activities': Array<Activity>;
    'memberships': Array<ListSegmentMembership>;
    'metrics': Array<Metric>;
    'propertiesList': Array<Property>;
}

export class CustomerAffiliate {
    /**
    * Affiliate object identifier
    */
    'affiliateOid': number;
    /**
    * email
    */
    'email': string;
}

export class CustomerAttachment {
    /**
    * Attachment identifier
    */
    'customerProfileAttachmentOid': number;
    /**
    * Description
    */
    'description': string;
    /**
    * File name
    */
    'fileName': string;
    /**
    * Mime typoe
    */
    'mimeType': string;
    /**
    * Upload date/time
    */
    'uploadDts': string;
}

export class CustomerBilling {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Customer profile billing object identifier
    */
    'customerBillingOid': number;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Default billing
    */
    'defaultBilling': boolean;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Last used date
    */
    'lastUsedDts': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Tax County
    */
    'taxCounty': string;
    /**
    * Title
    */
    'title': string;
}

export class CustomerCard {
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (four digit year)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked to the last 4)
    */
    'cardNumber': string;
    /**
    * Hosted field token for the card number
    */
    'cardNumberToken': string;
    /**
    * Card type
    */
    'cardType': string;
    /**
    * ID of the stored credit card to use
    */
    'customerProfileCreditCardId': number;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * Last used date
    */
    'lastUsedDts': string;
}

export class CustomerEditorValues {
    /**
    * affiliates
    */
    'affiliates': Array<CustomerAffiliate>;
    /**
    * card_exp_months
    */
    'cardExpMonths': Array<string>;
    /**
    * card_exp_years
    */
    'cardExpYears': Array<string>;
    /**
    * card_types
    */
    'cardTypes': Array<string>;
    /**
    * countries
    */
    'countries': Array<Country>;
    /**
    * qb_classes
    */
    'qbClasses': Array<string>;
    /**
    * sales_rep_codes
    */
    'salesRepCodes': Array<string>;
    /**
    * terms
    */
    'terms': Array<string>;
}

export class CustomerEmail {
    /**
    * ID of the email
    */
    'customerProfileEmailOid': number;
    /**
    * Email
    */
    'email': string;
    /**
    * Label
    */
    'label': string;
    /**
    * CC this email on receipt notifications
    */
    'receiptNotification': boolean;
    /**
    * CC this email on refund notifications
    */
    'refundNotification': boolean;
    /**
    * CC this email on shipment notifications
    */
    'shipmentNotification': boolean;
}

export class CustomerEmailListChanges {
    /**
    * Add this customer to these email lists
    */
    'addToLists': Array<string>;
    /**
    * Remove this customer from these email lists
    */
    'removeFromLists': Array<string>;
}

export class CustomerOrdersSummary {
    /**
    * First order date
    */
    'firstOrderDts': string;
    /**
    * Last order date
    */
    'lastOrderDts': string;
    /**
    * Total number of orders
    */
    'orderCount': number;
    /**
    * Total amount associated with the orders
    */
    'total': number;
}

export class CustomerPricingTier {
    /**
    * Name
    */
    'name': string;
    /**
    * Pricing Tier Oid
    */
    'pricingTierOid': number;
}

export class CustomerPrivacy {
    /**
    * Last update date
    */
    'lastUpdateDts': string;
    /**
    * The customer has opted in to marketing
    */
    'marketing': boolean;
    /**
    * The customer has opted in to preference tracking
    */
    'preference': boolean;
    /**
    * The customer has opted in to statistics collection
    */
    'statistics': boolean;
}

export class CustomerQuery {
    /**
    * Billing city
    */
    'billingCity': string;
    /**
    * Billing company
    */
    'billingCompany': string;
    /**
    * Billing country code
    */
    'billingCountryCode': string;
    /**
    * Billing day phone
    */
    'billingDayPhone': string;
    /**
    * Billing evening phone
    */
    'billingEveningPhone': string;
    /**
    * Billing first name
    */
    'billingFirstName': string;
    /**
    * Billing last name
    */
    'billingLastName': string;
    /**
    * Billing postal code
    */
    'billingPostalCode': string;
    /**
    * Billing state
    */
    'billingState': string;
    /**
    * Email address of this customer profile
    */
    'email': string;
    /**
    * Last modified date end
    */
    'lastModifiedDtsEnd': string;
    /**
    * Last modified date start
    */
    'lastModifiedDtsStart': string;
    /**
    * Pricing tier name
    */
    'pricingTierName': string;
    /**
    * Pricing tier oid
    */
    'pricingTierOid': number;
    /**
    * QuickBooks class to import this customer as
    */
    'qbClass': string;
    /**
    * QuickBooks name to import this customer as
    */
    'quickbooksCode': string;
    /**
    * Billing city
    */
    'shippingCity': string;
    /**
    * Billing company
    */
    'shippingCompany': string;
    /**
    * Billing country code
    */
    'shippingCountryCode': string;
    /**
    * Billing day phone
    */
    'shippingDayPhone': string;
    /**
    * Billing evening phone
    */
    'shippingEveningPhone': string;
    /**
    * Billing first name
    */
    'shippingFirstName': string;
    /**
    * Billing last name
    */
    'shippingLastName': string;
    /**
    * Billing postal code
    */
    'shippingPostalCode': string;
    /**
    * Billing state
    */
    'shippingState': string;
    /**
    * Signup date end
    */
    'signupDtsEnd': string;
    /**
    * Signup date start
    */
    'signupDtsStart': string;
}

export class CustomerQuotesSummary {
    /**
    * First quote date
    */
    'firstQuoteDts': string;
    /**
    * Last quote date
    */
    'lastQuoteDts': string;
    /**
    * Total number of quote
    */
    'quoteCount': number;
    /**
    * Total amount associated with the quotes
    */
    'total': number;
}

export class CustomerResponse {
    'customer': Customer;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class CustomerReviewer {
    /**
    * True if reviewes from this customer profile should automatically be approved
    */
    'autoApprove': boolean;
    /**
    * Average overall rating of items reviewed
    */
    'averageOverallRating': number;
    /**
    * True if the customer is an expert
    */
    'expert': boolean;
    /**
    * First review
    */
    'firstReview': string;
    /**
    * Last review
    */
    'lastReview': string;
    /**
    * Location of the reviewer
    */
    'location': string;
    /**
    * Nickname of the reviewer
    */
    'nickname': string;
    /**
    * Number of helpful review votes
    */
    'numberHelpfulReviewVotes': number;
    /**
    * Rank of this reviewer
    */
    'rank': number;
    /**
    * Number of reviews contributed
    */
    'reviewsContributed': number;
}

export class CustomerShipping {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Customer profile object identifier
    */
    'customerProfileOid': number;
    /**
    * Customer profile shipping object identifier
    */
    'customerShippingOid': number;
    /**
    * Day phone
    */
    'dayPhone': string;
    /**
    * Default shipping
    */
    'defaultShipping': boolean;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Last used date
    */
    'lastUsedDts': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Tax County
    */
    'taxCounty': string;
    /**
    * Title
    */
    'title': string;
}

export class CustomerSoftwareEntitlement {
    /**
    * Activation Code Associated with the software
    */
    'activationCode': string;
    /**
    * Date/time when the activation code was created
    */
    'activationDts': string;
    /**
    * Customer profile software entitlement object identifier
    */
    'customerSoftwareEntitlementOid': number;
    /**
    * Date/time when the activation code will expire
    */
    'expirationDts': string;
    /**
    * Item description used to purchase this software.
    */
    'purchasedViaItemDescription': string;
    /**
    * Item ID used to purchase this software.
    */
    'purchasedViaItemId': string;
    /**
    * Order ID used to purchase this software.
    */
    'purchasedViaOrderId': string;
    /**
    * SKU of the software
    */
    'softwareSku': string;
}

export class CustomerTaxCodes {
    /**
    * Avalara customer code
    */
    'avalaraCustomerCode': string;
    /**
    * Avalara entity use code
    */
    'avalaraEntityUseCode': string;
    /**
    * TaxJar customer id
    */
    'taxjarCustomerId': string;
}

export class CustomersResponse {
    'customers': Array<Customer>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class DataTablesServerSideResponse {
    'draw': number;
    'recordsFiltered': number;
    'recordsTotal': number;
}

export class Distance {
    /**
    * Unit of measure
    */
    'uom': Distance.UomEnum;
    /**
    * The distance measured in UOM
    */
    'value': number;
}

export namespace Distance {
    export enum UomEnum {
        IN = <any> 'IN',
        CM = <any> 'CM'
    }
}
export class DistributionCenter {
    /**
    * Address line 1 of the distribution center
    */
    'address1': string;
    /**
    * Address line 2 of the distribution center
    */
    'address2': string;
    /**
    * City of the distribution center
    */
    'city': string;
    /**
    * Unique code for this distribution center
    */
    'code': string;
    /**
    * Country code of the distribution center
    */
    'countryCode': string;
    /**
    * True if this is the default distribution center on the account
    */
    'defaultCenter': boolean;
    /**
    * True if this distribution center handles all new items by default
    */
    'defaultHandlesAllItems': boolean;
    /**
    * Distribution center object identifier
    */
    'distributionCenterOid': number;
    /**
    * DUNS number assigned to this distribution center (EDI)
    */
    'duns': string;
    /**
    * Estimate shipments for this distribution center as if they came from the other distribution center
    */
    'estimateFromDistributionCenterOid': number;
    /**
    * Password associated with the virtual FTP
    */
    'ftpPassword': string;
    /**
    * The number of minutes to hold a shipment
    */
    'holdBeforeShipmentMinutes': number;
    /**
    * True if the shipment should be held before transmission and require a manual release
    */
    'holdBeforeTransmission': boolean;
    'holdAutoOrderBeforeShipmentMinutes': number;
    /**
    * Latitude where the distribution center is located
    */
    'latitude': number;
    /**
    * Longitude where the distribution center is located
    */
    'longitude': number;
    /**
    * Name of this distribution center
    */
    'name': string;
    /**
    * True if this distribution center does not handle customer direct shipments
    */
    'noCustomerDirectShipments': boolean;
    /**
    * True if this distribution center is not allowed to participate in a split shipment.
    */
    'noSplitShipment': boolean;
    /**
    * Postal code of the distribution center
    */
    'postalCode': string;
    /**
    * The number of processing days required before an order ships
    */
    'processDays': number;
    /**
    * The time (EST) after which inventory updates will be processed
    */
    'processInventoryStartTime': string;
    /**
    * The time (EST) before which inventory updates will be processed
    */
    'processInventoryStopTime': string;
    /**
    * True if ASNs are required for this distribution center (EDI)
    */
    'requireAsn': boolean;
    /**
    * True if we should send the kit instead of the components
    */
    'sendKitInsteadOfComponents': boolean;
    /**
    * The time (EST) after which shipments will not be processed on Friday
    */
    'shipmentCutoffTimeFriday': string;
    /**
    * The time (EST) after which shipments will not be processed on Monday
    */
    'shipmentCutoffTimeMonday': string;
    /**
    * The time (EST) after which shipments will not be processed on Saturday
    */
    'shipmentCutoffTimeSaturday': string;
    /**
    * The time (EST) after which shipments will not be processed on Sunday
    */
    'shipmentCutoffTimeSunday': string;
    /**
    * The time (EST) after which shipments will not be processed on Thursday
    */
    'shipmentCutoffTimeThursday': string;
    /**
    * The time (EST) after which shipments will not be processed on Tuesday
    */
    'shipmentCutoffTimeTuesday': string;
    /**
    * The time (EST) after which shipments will not be processed on Wednesday
    */
    'shipmentCutoffTimeWednesday': string;
    /**
    * State of the distribution center
    */
    'state': string;
    /**
    * Transport mechanism for this distribution center
    */
    'transport': string;
}

export class DistributionCentersResponse {
    'distributionCenters': Array<DistributionCenter>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailBaseTemplateListResponse {
    'templatePaths': Array<string>;
}

export class EmailCampaign {
    /**
    * Click rate of emails
    */
    'clickRateFormatted': string;
    /**
    * Created date
    */
    'createdDts': string;
    /**
    * True if this campaign was deleted
    */
    'deleted': boolean;
    /**
    * Email campaign UUID
    */
    'emailCampaignUuid': string;
    /**
    * Email communication sequence UUID
    */
    'emailCommunicationSequenceUuid': string;
    /**
    * List and segment memberships
    */
    'memberships': Array<EmailListSegmentMembership>;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Name of email campaign
    */
    'name': string;
    /**
    * Open rate of emails
    */
    'openRateFormatted': string;
    /**
    * Revenue associated with campaign
    */
    'revenueFormatted': string;
    /**
    * Scheduled date
    */
    'scheduledDts': string;
    /**
    * Status of the campaign of draft, archived, and sent
    */
    'status': string;
    /**
    * Timestamp when the last status change happened
    */
    'statusDts': string;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
}

export class EmailCampaignResponse {
    'campaign': EmailCampaign;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCampaignsResponse {
    'campaigns': Array<EmailCampaign>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCommseq {
    /**
    * Array of steps
    */
    'emailCommunicationSequenceSteps': Array<EmailCommseqStep>;
    /**
    * Email commseq UUID
    */
    'emailCommunicationSequenceUuid': string;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
}

export class EmailCommseqEmail {
    /**
    * Deleted
    */
    'deleted': boolean;
    /**
    * Edited by user
    */
    'editedByUser': string;
    /**
    * Email communication sequence email uuid
    */
    'emailCommunicationSequenceEmailUuid': string;
    /**
    * Email container cjson
    */
    'emailContainerCjson': string;
    /**
    * Email template virtual path
    */
    'emailTemplateVmPath': string;
    /**
    * Filter profile equation json
    */
    'filterProfileEquationJson': string;
    /**
    * Individually render
    */
    'individuallyRender': boolean;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Preview text
    */
    'previewText': string;
    /**
    * Smart sending
    */
    'smartSending': boolean;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
    /**
    * Subject
    */
    'subject': string;
    /**
    * Transactional email
    */
    'transactionalEmail': boolean;
    /**
    * Version
    */
    'version': number;
}

export class EmailCommseqEmailResponse {
    'email': EmailCommseqEmail;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCommseqEmailsRequest {
    'error': Error;
    'espCommseqEmailUuids': Array<string>;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCommseqEmailsResponse {
    'emails': Array<EmailCommseqEmail>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCommseqResponse {
    'communicationSequence': EmailCommseq;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCommseqStat {
    /**
    * Count of clicked emails
    */
    'clickCount': number;
    /**
    * Count of clicked emails, formatted
    */
    'clickCountFormatted': string;
    /**
    * Count of delivered emails
    */
    'deliveredCount': number;
    /**
    * Count of delivered emails, formatted
    */
    'deliveredCountFormatted': string;
    /**
    * UUID associated with the communication sequence
    */
    'emailCommunicationSequenceUuid': string;
    /**
    * Count of customers that finished the sequence
    */
    'finishedCount': number;
    /**
    * Count of customers that finished the sequence, formatted
    */
    'finishedCountFormatted': string;
    /**
    * Count of customers in progress
    */
    'inProgressCount': number;
    /**
    * Count of customers in progress, formatted
    */
    'inProgressCountFormatted': string;
    /**
    * Count of emails kicked
    */
    'kickboxCount': number;
    /**
    * Count of emails kicked, formatted
    */
    'kickboxCountFormatted': string;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Count of opened emails
    */
    'openCount': number;
    /**
    * Count of opened emails, formatted
    */
    'openCountFormatted': string;
    /**
    * Count of emails permanently bounced
    */
    'permanentBounceCount': number;
    /**
    * Count of emails permanently bounced, formatted
    */
    'permanentBounceCountFormatted': string;
    /**
    * Profit
    */
    'profit': number;
    /**
    * Profit, formatted
    */
    'profitFormatted': string;
    /**
    * Revenue
    */
    'revenue': number;
    /**
    * Revenue, formatted
    */
    'revenueFormatted': string;
    /**
    * Count of emails sent
    */
    'sendCount': number;
    /**
    * Count of emails sent, formatted
    */
    'sendCountFormatted': string;
    /**
    * Count of skipped emails
    */
    'skippedCount': number;
    /**
    * Count of skipped emails, formatted
    */
    'skippedCountFormatted': string;
    /**
    * Count of emails classified as spam
    */
    'spamCount': number;
    /**
    * Count of emails classified as spam, formatted
    */
    'spamCountFormatted': string;
    /**
    * Count of customers that started the sequence
    */
    'startedCount': number;
    /**
    * Count of customers that started the sequence, formatted
    */
    'startedCountFormatted': string;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
    /**
    * Count of views
    */
    'viewCount': number;
    /**
    * Count of views, formatted
    */
    'viewCountFormatted': string;
}

export class EmailCommseqStatResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'stats': EmailCommseqStat;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCommseqStep {
    /**
    * Array of child steps for the alternate path
    */
    'altChildEmailCommunicationSequenceSteps': Array<EmailCommseqStep>;
    /**
    * Array of child steps
    */
    'childEmailCommunicationSequenceSteps': Array<EmailCommseqStep>;
    /**
    * Email commseq step UUID
    */
    'emailCommunicationSequenceStepUuid': string;
    /**
    * Filter profile equation JSON
    */
    'filterProfileEquationJson': string;
    /**
    * Arbitrary Configuration for a step
    */
    'stepConfigJson': string;
    /**
    * Type of step
    */
    'type': EmailCommseqStep.TypeEnum;
}

export namespace EmailCommseqStep {
    export enum TypeEnum {
        Begin = <any> 'begin',
        Wait = <any> 'wait',
        Email = <any> 'email',
        Merge = <any> 'merge',
        Condition = <any> 'condition',
        End = <any> 'end'
    }
}
export class EmailCommseqsResponse {
    'communicationSequences': Array<EmailCommseq>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailCustomer {
    'email': string;
    'espCustomerUuid': string;
    'firstName': string;
    'lastName': string;
}

export class EmailCustomerEditorUrlResponse {
    'editorUrl': string;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailDashboardActivity {
    /**
    * Type of action such as add, remove, subscribe, unsubscribe
    */
    'action': string;
    /**
    * Date/time of the activity
    */
    'activityDts': string;
    /**
    * List or segment name
    */
    'destinationName': string;
    /**
    * List or segment uuid
    */
    'destinationUuid': string;
    /**
    * Email address
    */
    'email': string;
    /**
    * true if activity is related to list
    */
    'isList': boolean;
    /**
    * true if activity is related to segment
    */
    'isSegment': boolean;
}

export class EmailDashboardActivityResponse {
    'activity': Array<EmailDashboardActivity>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailDashboardStatsResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'stats': Array<EmailStat>;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailDomain {
    'comment': string;
    'dkim': Array<VerificationRecord>;
    'dkimStatus': string;
    'domain': string;
    'espDomainUuid': string;
    'identityStatus': string;
    'merchantId': string;
    'provider': string;
    'startDkimDts': string;
    'startIdentityDts': string;
    'verification': VerificationRecord;
}

export class EmailFlow {
    /**
    * True if a customer may be enrolled in this flow multiple times
    */
    'allowMultipleConcurrentEnrollments': boolean;
    /**
    * Created date
    */
    'createdDts': string;
    /**
    * True if this campaign was deleted
    */
    'deleted': boolean;
    /**
    * Email communication sequence UUID
    */
    'emailCommunicationSequenceUuid': string;
    /**
    * Email flow UUID
    */
    'emailFlowUuid': string;
    /**
    * File profile equation json
    */
    'filterProfileEquationJson': string;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Name of email flow
    */
    'name': string;
    /**
    * Status of the campaign of draft, archived, active, and inactive
    */
    'status': string;
    /**
    * Timestamp when the last status change happened
    */
    'statusDts': string;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
    /**
    * Trigger parameter
    */
    'triggerParameter': string;
    /**
    * Trigger parameter name
    */
    'triggerParameterName': string;
    /**
    * Trigger type
    */
    'triggerType': string;
}

export class EmailFlowResponse {
    'error': Error;
    'flow': EmailFlow;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailFlowsResponse {
    'error': Error;
    'flows': Array<EmailFlow>;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailHistogramPropertyNamesResponse {
    'propertyNames': Array<string>;
}

export class EmailHistogramPropertyValuesResponse {
    'propertyValues': Array<string>;
}

export class EmailList {
    /**
    * Created date
    */
    'createdDts': string;
    /**
    * True if this campaign was deleted
    */
    'deleted': boolean;
    /**
    * Email list UUID
    */
    'emailListUuid': string;
    /**
    * Count of members in this list
    */
    'memberCount': number;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Name of email list
    */
    'name': string;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
}

export class EmailListArchiveResponse {
    'error': Error;
    'listInUse': boolean;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailListCustomer {
    /**
    * Added timestamp
    */
    'addDts': string;
    /**
    * Email
    */
    'email': string;
    /**
    * Email customer UUID
    */
    'emailCustomerUuid': string;
    /**
    * Email list member UUID
    */
    'emailListMemberUuid': string;
}

export class EmailListCustomersResponse {
    /**
    * Customers on the page
    */
    'customers': Array<EmailListCustomer>;
    /**
    * Page number (one based offset)
    */
    'pageNumber': number;
    /**
    * Number of records per page
    */
    'pageSize': number;
    /**
    * Total customers
    */
    'totalCustomers': number;
    /**
    * Total number of pages
    */
    'totalPages': number;
}

export class EmailListResponse {
    'error': Error;
    'list': EmailList;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailListSegmentMembership {
    /**
    * UUID identifying this email list or null if this is a segment
    */
    'emailListUuid': string;
    /**
    * UUID identifying this email segment or null if this is a list
    */
    'emailSegmentUuid': string;
    /**
    * true if customers from this list/segment is excluded from membership
    */
    'exclude': boolean;
    /**
    * Name of this email list or segment
    */
    'name': string;
}

export class EmailListSubscribeResponse {
    'added': number;
    'memberCount': number;
}

export class EmailListsResponse {
    'error': Error;
    'lists': Array<EmailList>;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailSegment {
    /**
    * Created date
    */
    'createdDts': string;
    /**
    * True if this campaign was deleted
    */
    'deleted': boolean;
    /**
    * Email segment UUID
    */
    'emailSegmentUuid': string;
    /**
    * File profile equation json
    */
    'filterProfileEquationJson': string;
    /**
    * Count of members in this segment
    */
    'memberCount': number;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Name of email segment
    */
    'name': string;
    /**
    * True if a rebuild is required because some part of the segment has changed
    */
    'rebuildRequired': boolean;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
}

export class EmailSegmentArchiveResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'segmentInUse': boolean;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailSegmentCustomer {
    /**
    * Added timestamp
    */
    'addDts': string;
    /**
    * Email
    */
    'email': string;
    /**
    * Email customer UUID
    */
    'emailCustomerUuid': string;
    /**
    * Email segment member UUID
    */
    'emailSegmentMemberUuid': string;
}

export class EmailSegmentCustomersResponse {
    /**
    * Customers on the page
    */
    'customers': Array<EmailSegmentCustomer>;
    /**
    * Page number (one based offset)
    */
    'pageNumber': number;
    /**
    * Number of records per page
    */
    'pageSize': number;
    /**
    * Total customers
    */
    'totalCustomers': number;
    /**
    * Total number of pages
    */
    'totalPages': number;
}

export class EmailSegmentResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'segment': EmailSegment;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailSegmentsResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'segments': Array<EmailSegment>;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailSendingDomainResponse {
    'domain': EmailDomain;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailSendingDomainsResponse {
    'domains': Array<EmailDomain>;
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailStat {
    /**
    * Count of clicked emails
    */
    'clickCount': number;
    /**
    * Count of clicked emails, formatted
    */
    'clickCountFormatted': string;
    /**
    * Count of delivered emails
    */
    'deliveredCount': number;
    /**
    * Count of delivered emails, formatted
    */
    'deliveredCountFormatted': string;
    /**
    * Count of emails kicked
    */
    'kickboxCount': number;
    /**
    * Count of emails kicked, formatted
    */
    'kickboxCountFormatted': string;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * List or segment name
    */
    'name': string;
    /**
    * Count of opened emails
    */
    'openCount': number;
    /**
    * Count of opened emails, formatted
    */
    'openCountFormatted': string;
    /**
    * Count of emails permanently bounced
    */
    'permanentBounceCount': number;
    /**
    * Count of emails permanently bounced, formatted
    */
    'permanentBounceCountFormatted': string;
    /**
    * Profit
    */
    'profit': number;
    /**
    * Profit, formatted
    */
    'profitFormatted': string;
    /**
    * Revenue
    */
    'revenue': number;
    /**
    * Revenue, formatted
    */
    'revenueFormatted': string;
    /**
    * Count of emails sent
    */
    'sendCount': number;
    /**
    * Count of emails sent, formatted
    */
    'sendCountFormatted': string;
    /**
    * Count of skipped emails
    */
    'skippedCount': number;
    /**
    * Count of skipped emails, formatted
    */
    'skippedCountFormatted': string;
    /**
    * Count of emails classified as spam
    */
    'spamCount': number;
    /**
    * Count of emails classified as spam, formatted
    */
    'spamCountFormatted': string;
    /**
    * Campaign, Flow or None (for anything else)
    */
    'statType': string;
    /**
    * Status of campaign or flow
    */
    'status': string;
    /**
    * Status dts of campaign or flow
    */
    'statusDts': string;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
    /**
    * List or segment uuid
    */
    'uuid': string;
    /**
    * Count of views
    */
    'viewCount': number;
    /**
    * Count of views, formatted
    */
    'viewCountFormatted': string;
}

export class EmailStatSummaryRequest {
    'commseqEmailUuids': Array<string>;
    'days': number;
}

export class EmailStatSummaryResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'stats': Array<EmailStat>;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class EmailStepWaitingRequest {
    'commseqStepUuids': Array<string>;
}

export class EmailStepWaitingResponse {
    'stepWaitings': Array<StepWaiting>;
}

export class EmailTemplate {
    /**
    * Container cjson
    */
    'containerCjson': string;
    /**
    * Description of email template
    */
    'description': string;
    /**
    * Email template oid
    */
    'emailTemplateOid': number;
    /**
    * Email Template VM Path
    */
    'emailTemplateVmPath': string;
    /**
    * Merchant ID
    */
    'merchantId': string;
    /**
    * Name of email template
    */
    'name': string;
    /**
    * Amazon key for preview png image
    */
    'previewAmazonListingKey': string;
    /**
    * Sort order (optional)
    */
    'sortOrder': number;
    /**
    * StoreFront oid
    */
    'storefrontOid': number;
    /**
    * True if this email template is system-wide,false if merchant specific
    */
    'system': boolean;
    /**
    * Trigger type
    */
    'triggerType': string;
}

export class EmailTemplatesResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'templates': Array<EmailTemplate>;
}

export class EmailThirdPartyList {
    /**
    * id
    */
    'id': string;
    /**
    * name
    */
    'name': string;
}

export class EmailThirdPartyListImportRequest {
    /**
    * providers
    */
    'providers': Array<EmailThirdPartyProvider>;
}

export class EmailThirdPartyProvider {
    /**
    * URL to the settings screen to connect.  Null if the provider is already connected.
    */
    'connectUrl': string;
    /**
    * list_count
    */
    'listCount': number;
    /**
    * lists
    */
    'lists': Array<EmailThirdPartyList>;
    /**
    * logo_url
    */
    'logoUrl': string;
    /**
    * name
    */
    'name': string;
}

export class EmailThirdPartyProvidersResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'providers': Array<EmailThirdPartyProvider>;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Error {
    /**
    * A technical message meant to be read by a developer
    */
    'developerMessage': string;
    /**
    * HTTP status code
    */
    'errorCode': string;
    /**
    * Additional information often a link to additional documentation
    */
    'moreInfo': string;
    /**
    * An end-user friendly message suitable for display to the customer
    */
    'userMessage': string;
}

export class ErrorResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Experiment {
    /**
    * Contained ID where the experiment element was located
    */
    'containerId': string;
    /**
    * Duration in days
    */
    'durationDays': number;
    /**
    * End date/time
    */
    'endDts': string;
    /**
    * Whether or not traffic is equally weighted or shifts over time during the experiment
    */
    'equalWeighting': boolean;
    /**
    * Experiment id
    */
    'id': string;
    /**
    * Experiment name
    */
    'name': string;
    /**
    * Notes about the experiment
    */
    'notes': string;
    /**
    * Objective that is being optimized
    */
    'objective': string;
    /**
    * Type of optimization
    */
    'optimizationType': string;
    /**
    * Total number of sessions in the experiment
    */
    'sessionCount': number;
    /**
    * Start date/time
    */
    'startDts': string;
    /**
    * Status of the experiment
    */
    'status': Experiment.StatusEnum;
    /**
    * Storefront Experiment Oid
    */
    'storefrontExperimentOid': number;
    /**
    * Storefront oid
    */
    'storefrontOid': number;
    /**
    * URI the experiment was started on
    */
    'uri': string;
    /**
    * Variations being tested in the experiment
    */
    'variations': Array<ExperimentVariation>;
}

export namespace Experiment {
    export enum StatusEnum {
        Running = <any> 'Running',
        Ended = <any> 'Ended',
        Deleted = <any> 'Deleted'
    }
}
export class ExperimentResponse {
    'error': Error;
    'experiment': Experiment;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class ExperimentVariation {
    /**
    * Total add to cart count for this variation
    */
    'addToCartCount': number;
    /**
    * Average duration seconds per session for this variation
    */
    'averageDurationSeconds': number;
    /**
    * Average objective value per session for this variation
    */
    'averageObjectivePerSession': number;
    /**
    * Total bounce count for this variation
    */
    'bounceCount': number;
    /**
    * Conversion rate for this variation
    */
    'conversionRate': number;
    /**
    * Total number of seconds spent on the site for this variation
    */
    'durationSecondsSum': number;
    /**
    * Total initiate checkout count for this variation
    */
    'initiateCheckoutCount': number;
    /**
    * Total order count for this variation
    */
    'orderCount': number;
    /**
    * Percentage of the traffic the variation originally started out with
    */
    'originalTrafficPercentage': number;
    /**
    * Total page view count for this variation
    */
    'pageViewCount': number;
    /**
    * Total revenue for this variation
    */
    'revenue': number;
    /**
    * Total sessions for this variation
    */
    'sessionCount': number;
    /**
    * Percentage of the traffic this variation is currently receiving
    */
    'trafficPercentage': number;
    /**
    * Name of the variation
    */
    'variationName': string;
    /**
    * Variation number
    */
    'variationNumber': number;
    /**
    * True if this variation has been declared the winner
    */
    'winner': boolean;
}

export class ExperimentsResponse {
    'error': Error;
    'experiments': Array<Experiment>;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class FulfillmentInventory {
    'itemId': string;
    'quantity': number;
}

export class FulfillmentShipment {
    /**
    * Fees charged by the fulfillment company other than the shipping cost to process the order.
    */
    'fulfillmentFee': number;
    /**
    * Order ID that was shipped
    */
    'orderId': string;
    /**
    * The cost of the packaging used to sent this shipment
    */
    'packageCost': number;
    /**
    * The actual total cost of shipping this order
    */
    'shippingCost': number;
    /**
    * Tracking numbers associated with the shipment
    */
    'trackingNumbers': Array<string>;
}

export class GeocodeRequest {
    /**
    * address
    */
    'address': string;
    /**
    * city
    */
    'city': string;
    /**
    * country_code
    */
    'countryCode': string;
    /**
    * postal_code
    */
    'postalCode': string;
    /**
    * state
    */
    'state': string;
}

export class GeocodeResponse {
    'error': Error;
    'latitude': number;
    'longitude': number;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class HTTPHeader {
    /**
    * Name of the HTTP header
    */
    'name': string;
    /**
    * Value of the HTTP header
    */
    'value': string;
}

export class Item {
    'accounting': ItemAccounting;
    'amember': ItemAmember;
    'autoOrder': ItemAutoOrder;
    'ccbill': ItemCCBill;
    /**
    * Channel Partner Item Mapping
    */
    'channelPartnerMappings': Array<ItemChannelPartnerMapping>;
    'chargeback': ItemChargeback;
    'checkout': ItemCheckout;
    'content': ItemContent;
    /**
    * Date/time of creation
    */
    'creationDts': string;
    /**
    * Description of the item up to 500 characters.
    */
    'description': string;
    /**
    * Description translated text instance id
    */
    'descriptionTranslatedTextInstanceOid': number;
    'digitalDelivery': ItemDigitalDelivery;
    'ebay': ItemEbay;
    'emailNotifications': ItemEmailNotifications;
    'enrollment123': ItemEnrollment123;
    'giftCertificate': ItemGiftCertificate;
    'googleProductSearch': ItemGoogleProductSearch;
    'identifiers': ItemIdentifiers;
    /**
    * True if this item is inactive and can not be purchased
    */
    'inactive': boolean;
    'instantPaymentNotifications': ItemInstantPaymentNotifications;
    'internal': ItemInternal;
    /**
    * True if this item is a kit
    */
    'kit': boolean;
    'kitDefinition': ItemKitDefinition;
    /**
    * Date/time of last modification
    */
    'lastModifiedDts': string;
    /**
    * UltraCart merchant ID owning item
    */
    'merchantId': string;
    /**
    * Unique item id assigned to this item
    */
    'merchantItemId': string;
    /**
    * Unique object identifier for this item
    */
    'merchantItemOid': number;
    /**
    * Options
    */
    'options': Array<ItemOption>;
    /**
    * Parent category of the item.  Zero indicates the root folder.
    */
    'parentCategoryId': number;
    /**
    * Parent category path.  / indicates the root folder.
    */
    'parentCategoryPath': string;
    'paymentProcessing': ItemPaymentProcessing;
    'physical': ItemPhysical;
    'pricing': ItemPricing;
    'realtimePricing': ItemRealtimePricing;
    'related': ItemRelated;
    'reporting': ItemReporting;
    'restriction': ItemRestriction;
    'revguard': ItemRevguard;
    'reviews': ItemReviews;
    'salesforce': ItemSalesforce;
    'shipping': ItemShipping;
    'tax': ItemTax;
    /**
    * 3rd Party Email Marketing
    */
    'thirdPartyEmailMarketing': Array<ItemThirdPartyEmailMarketing>;
    /**
    * Variant Items
    */
    'variantItems': Array<ItemVariantItem>;
    /**
    * Variations
    */
    'variations': Array<ItemVariation>;
    'wishlistMember': ItemWishlistMember;
}

export class ItemAccounting {
    /**
    * QuickBooks item name if different than the item id
    */
    'accountingCode': string;
    /**
    * QuickBooks class if you are classifying items on your invoices/receipts
    */
    'qbClass': string;
}

export class ItemAmember {
    /**
    * The number of days that the customer should be given access to the item
    */
    'amemberPaymentDurationDays': number;
    /**
    * A-member product id give customer access to when they purchase this item
    */
    'amemberProductId': string;
}

export class ItemAutoOrder {
    /**
    * Amount to try and authorize for the future rebill
    */
    'authFutureAmount': number;
    /**
    * Amount to try and test authorize
    */
    'authTestAmount': number;
    /**
    * Item id to attempt charging the customer for if they cancel
    */
    'autoOrderCancelItemId': string;
    /**
    * Item object identifier to attempt charging the customer for if they cancel
    */
    'autoOrderCancelItemOid': number;
    /**
    * List of downgrade items presented to customer service representatives
    */
    'autoOrderDowngradeItems': Array<string>;
    /**
    * True if the rebill processing of this item is paused
    */
    'autoOrderPaused': boolean;
    /**
    * The user selectable schedules that are available
    */
    'autoOrderSchedules': Array<string>;
    /**
    * List of upgrade items presented to customer service representatives
    */
    'autoOrderUpgradeItems': Array<string>;
    /**
    * True if this item uses a fixed upsell step schedule
    */
    'autoOrderUpsell': boolean;
    /**
    * Do not send the easy cancel email to the customer
    */
    'autoOrderUpsellNoEasyCancel': boolean;
    /**
    * Limit the purchase of this item to one per customer
    */
    'autoOrderUpsellOnePerCustomer': boolean;
    /**
    * True if this item can be automatically ordered by the customer
    */
    'autoOrderable': boolean;
    /**
    * True if other auto orders for this customer should be canceled when this item is ordered
    */
    'cancelOtherAutoOrders': boolean;
    /**
    * True if the customer should be given free shipping
    */
    'freeShippingAutoOrder': boolean;
    /**
    * True if other auto orders for this customer should refunded if this item is refunded.
    */
    'refundOtherAutoOrders': boolean;
    /**
    * The rebill steps if this auto order is an upsell
    */
    'steps': Array<ItemAutoOrderStep>;
}

export class ItemAutoOrderStep {
    /**
    * If the schedule is arbitrary, then this is the number of days
    */
    'arbitraryScheduleDays': number;
    /**
    * Arbitrary unit cost used to override the regular item cost
    */
    'arbitraryUnitCost': number;
    /**
    * Arbitrary unit costs schedules for more advanced discounting by rebill attempt
    */
    'arbitraryUnitCostSchedules': Array<ItemAutoOrderStepArbitraryUnitCostSchedule>;
    /**
    * Grand-father pricing configuration if the rebill schedule has changed over time
    */
    'grandfatherPricing': Array<ItemAutoOrderStepGrandfatherPricing>;
    /**
    * Managed by (defaults to UltraCart)
    */
    'managedBy': string;
    /**
    * Number of days to pause
    */
    'pauseDays': number;
    /**
    * Wait for this step to happen until the specified date
    */
    'pauseUntilDate': string;
    /**
    * If set, a pre-shipment notice is sent to the customer this many days in advance
    */
    'preshipmentNoticeDays': number;
    /**
    * Item id to rebill
    */
    'recurringMerchantItemId': string;
    /**
    * Item object identifier to rebill
    */
    'recurringMerchantItemOid': number;
    /**
    * Number of times to rebill.  Last step can be null for infinite
    */
    'repeatCount': number;
    /**
    * Frequency of the rebill
    */
    'schedule': string;
    /**
    * Email list name to subscribe the customer to when the rebill occurs
    */
    'subscribeEmailListName': string;
    /**
    * Email list identifier to subscribe the customer to when this rebill occurs
    */
    'subscribeEmailListOid': number;
    /**
    * Type of step (item or pause)
    */
    'type': ItemAutoOrderStep.TypeEnum;
}

export namespace ItemAutoOrderStep {
    export enum TypeEnum {
        Item = <any> 'item',
        Pause = <any> 'pause'
    }
}
export class ItemAutoOrderStepArbitraryUnitCostSchedule {
    /**
    * Arbitrary unit cost
    */
    'arbitraryUnitCost': number;
    /**
    * Retry days
    */
    'retryDays': number;
}

export class ItemAutoOrderStepGrandfatherPricing {
    /**
    * On or before date
    */
    'onOrBeforeDate': string;
    /**
    * Unit cost
    */
    'unitCost': number;
}

export class ItemCCBill {
    /**
    * Allowed currencies
    */
    'ccbillAllowedCurrencies': string;
    /**
    * Allowed types
    */
    'ccbillAllowedTypes': string;
    /**
    * Currency code
    */
    'ccbillCurrencyCode': string;
    /**
    * Form name
    */
    'ccbillFormName': string;
    /**
    * Sub-account id
    */
    'ccbillSubaccountId': string;
    /**
    * Subscription type id
    */
    'ccbillSubscriptionTypeId': string;
}

export class ItemChannelPartnerMapping {
    /**
    * Barcode UA (EDI only)
    */
    'barcodeUa': string;
    /**
    * Barcode UC (EDI only)
    */
    'barcodeUc': string;
    /**
    * Barcode UI (EDI only)
    */
    'barcodeUi': string;
    /**
    * Barcode UK (EDI only)
    */
    'barcodeUk': string;
    /**
    * Buyer catalog number (EDI only)
    */
    'buyerCatalogNumber': string;
    /**
    * Buyer DPCI (EDI only)
    */
    'buyerDpci': string;
    /**
    * Buyer item number (EDI only)
    */
    'buyerItemNumber': string;
    /**
    * Channel partner code
    */
    'channelPartnerCode': string;
    /**
    * Channel partner object identifier
    */
    'channelPartnerOid': number;
    /**
    * From Item ID
    */
    'fromItemId': string;
    /**
    * From SKU
    */
    'fromSku': string;
    /**
    * Mutually defined number (EDI only)
    */
    'mutuallyDefinedNumber': string;
    /**
    * Ratio (Channel Partner)
    */
    'quantityRatioCp': number;
    /**
    * Ratio (UltraCart)
    */
    'quantityRatioUc': number;
    /**
    * SKU
    */
    'sku': string;
    /**
    * Unit of measure
    */
    'unitOfMeasure': string;
    /**
    * Vendor number (EDI only)
    */
    'vendorNumber': string;
    /**
    * Vendor style number (EDI only)
    */
    'vendorStyleNumber': string;
}

export class ItemChargeback {
    /**
    * Addendums
    */
    'addendums': Array<ItemChargebackAddendum>;
    /**
    * Adjustment requests
    */
    'adjustmentRequests': Array<ItemChargebackAdjustmentRequest>;
}

export class ItemChargebackAddendum {
    /**
    * Chargeback addendum object identifier
    */
    'chargebackAddendumOid': number;
    /**
    * Description
    */
    'description': string;
    /**
    * Size of the file
    */
    'fileSize': number;
    /**
    * Number of pages
    */
    'pages': number;
}

export class ItemChargebackAdjustmentRequest {
    /**
    * Chargeback adjustment request object identifier
    */
    'chargebackAdjustmentRequestOid': number;
    /**
    * Description
    */
    'description': string;
    /**
    * Reason code
    */
    'reasonCode': string;
}

export class ItemCheckout {
    /**
    * True to suppress buySAFE
    */
    'suppressBuysafe': boolean;
    /**
    * Terms for purchasing this item
    */
    'terms': string;
    /**
    * Terms translated text instance identifier
    */
    'termsTranslatedTextInstanceOid': number;
}

export class ItemContent {
    /**
    * StoreFront assignments
    */
    'assignments': Array<ItemContentAssignment>;
    /**
    * StoreFront attributes
    */
    'attributes': Array<ItemContentAttribute>;
    /**
    * Exclude from search
    */
    'excludeFromSearch': boolean;
    /**
    * Exclude from the top sellers list in the StoreFront
    */
    'excludeFromTopSellers': boolean;
    /**
    * Extended description (max 2000 characters)
    */
    'extendedDescription': string;
    /**
    * Extneded description text translation instance identifier
    */
    'extendedDescriptionTranslatedTextInstanceOid': number;
    /**
    * Multimedia
    */
    'multimedia': Array<ItemContentMultimedia>;
    /**
    * True if the item is new
    */
    'newItem': boolean;
    /**
    * The date the item should no longer be considered new
    */
    'newItemEnd': string;
    /**
    * The date the item should start being considered new
    */
    'newItemStart': string;
    /**
    * Legacy view URL (not used by StoreFronts)
    */
    'viewUrl': string;
}

export class ItemContentAssignment {
    /**
    * Page (group) object identifier
    */
    'groupOid': number;
    /**
    * Page (group) path
    */
    'groupPath': string;
    /**
    * StoreFront host name
    */
    'host': string;
    /**
    * Sort order (optional)
    */
    'sortOrder': number;
    /**
    * URL part if the item id is not used
    */
    'urlPart': string;
}

export class ItemContentAttribute {
    /**
    * Attribute name
    */
    'name': string;
    /**
    * Attribute translated text instance identifier
    */
    'translatedTextInstanceOid': number;
    /**
    * Attribute type
    */
    'type': string;
    /**
    * Attribute value
    */
    'value': string;
}

export class ItemContentMultimedia {
    /**
    * URL where the image can be downloaded from the cloud
    */
    'cloudUrl': string;
    /**
    * Expiration date of the cloud URL
    */
    'cloudUrlExpiration': string;
    /**
    * Code assigned to the file
    */
    'code': string;
    /**
    * Description
    */
    'description': string;
    /**
    * True to exclude from multimedia gallery
    */
    'excludeFromGallery': boolean;
    /**
    * File name
    */
    'fileName': string;
    /**
    * Height of the image
    */
    'height': number;
    /**
    * Item multimedia object identifier
    */
    'merchantItemMultimediaOid': number;
    /**
    * True if the multimedia is an orphan of the active StoreFront themes
    */
    'orphan': boolean;
    /**
    * True if the object is a place holder that can be populated
    */
    'placeholder': boolean;
    /**
    * Temporary multimedia object identifier assigned if uploading new multimedia
    */
    'tempMultimediaOid': number;
    /**
    * Thumbnails of this image
    */
    'thumbnails': Array<ItemContentMultimediaThumbnail>;
    /**
    * Type of file
    */
    'type': ItemContentMultimedia.TypeEnum;
    /**
    * URL to download file (on new multimedia record this can be a URL for UltraCart to fetch)
    */
    'url': string;
    /**
    * Width of the image
    */
    'width': number;
}

export namespace ItemContentMultimedia {
    export enum TypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Unknown = <any> 'Unknown',
        Video = <any> 'Video'
    }
}
export class ItemContentMultimediaThumbnail {
    /**
    * Height of the thumbnail
    */
    'height': number;
    /**
    * HTTP URL to view the thumbnail
    */
    'httpUrl': string;
    /**
    * HTTPS URL to view the thumbnail
    */
    'httpsUrl': string;
    /**
    * True if PNG, false if JPEG
    */
    'pngFormat': boolean;
    /**
    * True if the thumbnail is square
    */
    'square': boolean;
    /**
    * Width of the thumbnail
    */
    'width': number;
}

export class ItemDigitalDelivery {
    /**
    * Description of the activation code
    */
    'activationCodeDescription': string;
    /**
    * The number of activation codes whcih should generate a warning email
    */
    'activationCodeLowWarning': number;
    /**
    * The URL to retrieve activation codes from in real-time
    */
    'activationCodeRealtimeUrl': string;
    /**
    * Shared secret used when communicating with the real-time URL
    */
    'activationCodeSharedSecret': string;
    /**
    * Type of activation code
    */
    'activationCodeType': string;
    /**
    * Digital items that customer can download when this item is purchased
    */
    'digitalItems': Array<ItemDigitalItem>;
}

export class ItemDigitalItem {
    /**
    * File creation date
    */
    'creationDts': string;
    /**
    * Description of the digital item
    */
    'description': string;
    /**
    * File size
    */
    'fileSize': number;
    /**
    * Mime type associated with the file
    */
    'mimeType': string;
    /**
    * Original filename
    */
    'originalFilename': string;
}

export class ItemEbay {
    /**
    * True if the item is active for listing
    */
    'active': boolean;
    /**
    * e-Bay category ID
    */
    'categoryId': number;
    /**
    * Answers to category specific questions
    */
    'categorySpecifics': Array<ItemEbayCategorySpecific>;
    /**
    * Description of the condition (e-Bay constant)
    */
    'conditionDescription': string;
    /**
    * Numerical ID of the condition (e-Bay constant)
    */
    'conditionId': number;
    /**
    * Number of consecutive failures trying to list this item
    */
    'consecutiveFailures': number;
    /**
    * e-Bay Store category 1
    */
    'customCategory1': number;
    /**
    * e-Bay Store category 2
    */
    'customCategory2': number;
    /**
    * Maximum number of days it will take to ship the item
    */
    'dispatchTimeMax': number;
    /**
    * Domestic 1 method additional item cost
    */
    'domestic1AdditionalCost': number;
    /**
    * Domestic 1 method first item cost
    */
    'domestic1FirstCost': number;
    /**
    * Domestic 2 method additional item cost
    */
    'domestic2AdditionalCost': number;
    /**
    * Domestic 2 method first item cost
    */
    'domestic2FirstCost': number;
    /**
    * Domestic 3 method additional item cost
    */
    'domestic3AdditionalCost': number;
    /**
    * Domestic 3 method first item cost
    */
    'domestic3FirstCost': number;
    /**
    * Domestic 4 method additional item cost
    */
    'domestic4AdditionalCost': number;
    /**
    * Domestic 4 method first item cost
    */
    'domestic4FirstCost': number;
    /**
    * If listed, this is the e-Bay auction id
    */
    'ebayAuctionId': string;
    /**
    * e-Bay specific inventory
    */
    'ebaySpecificInventory': number;
    /**
    * The template name to use hwen rendering the e-Bay listing
    */
    'ebayTemplateName': string;
    /**
    * The template object identifier to use when rendering the e-Bay listing
    */
    'ebayTemplateOid': number;
    /**
    * Date/time of the auction end
    */
    'endTime': string;
    /**
    * True if item receives free shipping
    */
    'freeShipping': boolean;
    /**
    * The method that is free for free shipping
    */
    'freeShippingMethod': string;
    /**
    * International 1 method additional item cost
    */
    'international1AdditionalCost': number;
    /**
    * International 1 method first item cost
    */
    'international1FirstCost': number;
    /**
    * International 2 method additional item cost
    */
    'international2AdditionalCost': number;
    /**
    * International 2 method first item cost
    */
    'international2FirstCost': number;
    /**
    * International 3 method additional item cost
    */
    'international3AdditionalCost': number;
    /**
    * International 3 method first item cost
    */
    'international3FirstCost': number;
    /**
    * International 4 method additional item cost
    */
    'international4AdditionalCost': number;
    /**
    * International 4 method first item cost
    */
    'international4FirstCost': number;
    /**
    * Date/time of the last status check
    */
    'lastStatusDts': string;
    /**
    * Current listing dispatch time maximum
    */
    'listedDispatchTimeMax': number;
    /**
    * The template object identifier used for the listing
    */
    'listedEbayTemplateOid': number;
    /**
    * Date/time of the listing
    */
    'listingDts': string;
    /**
    * The duration of the listing
    */
    'listingDuration': string;
    /**
    * Price to list the item at
    */
    'listingPrice': number;
    /**
    * The price to list the item at if different than the regular UltraCart item price
    */
    'listingPriceOverride': number;
    /**
    * The type of e-Bay listing
    */
    'listingType': string;
    'marketplaceAnalysis': ItemEbayMarketPlaceAnalysis;
    /**
    * True if marketplace analysis should be performed
    */
    'marketplaceAnalysisPerform': boolean;
    /**
    * Marketplace FVF percentage
    */
    'marketplaceFinalValueFeePercentage': number;
    /**
    * Date/time of the marketplace analysis last check
    */
    'marketplaceLastCheckDts': string;
    /**
    * True if we are the lowest offer in the marketplace
    */
    'marketplaceLowest': boolean;
    /**
    * True if another seller is violating MAP
    */
    'marketplaceMapViolation': boolean;
    /**
    * Marketplace multiplier
    */
    'marketplaceMultiplier': number;
    /**
    * Marketplace other price
    */
    'marketplaceOtherPrice': number;
    /**
    * Marketplace other seller
    */
    'marketplaceOtherSeller': string;
    /**
    * Marketplace other shipping
    */
    'marketplaceOtherShipping': number;
    /**
    * Marketplace other total
    */
    'marketplaceOtherTotal': number;
    /**
    * Marketplace our additional profit potential
    */
    'marketplaceOurAdditionalProfitPotential': number;
    /**
    * Marketplace our price
    */
    'marketplaceOurPrice': number;
    /**
    * Marketplace our profit
    */
    'marketplaceOurProfit': number;
    /**
    * Marketplace our shipping
    */
    'marketplaceOurShipping': number;
    /**
    * Marketplace our total
    */
    'marketplaceOurTotal': number;
    /**
    * Marketplace overhead
    */
    'marketplaceOverhead': number;
    /**
    * True if our listing is profitable to sell
    */
    'marketplaceProfitable': boolean;
    /**
    * Date/time for the next attempt to list
    */
    'nextAttemptDts': string;
    /**
    * The next listing duration to use when the current listing ends.
    */
    'nextListingDuration': string;
    /**
    * True if the item should not qualify for promotional shipping
    */
    'noPromotionalShipping': boolean;
    /**
    * Packaging and handling costs
    */
    'packagingHandlingCosts': number;
    /**
    * Previous e-Bay auction id
    */
    'previousEbayAuctionId': string;
    /**
    * Quantity available of the item
    */
    'quantity': number;
    /**
    * Reserve price
    */
    'reservePrice': number;
    /**
    * How to send the item dimensions and weights to e-Bay
    */
    'sendDimensionsAndWeight': string;
    /**
    * Date/time of the auction start
    */
    'startTime': string;
    /**
    * Status of the item's listing
    */
    'status': string;
    /**
    * Typical number of days it will take to ship the item
    */
    'targetDispatchTimeMax': number;
}

export class ItemEbayCategorySpecific {
    /**
    * Name of the category specification field
    */
    'name': string;
    /**
    * Value
    */
    'value': string;
}

export class ItemEbayMarketListing {
    /**
    * Auction ID
    */
    'auctionId': string;
    /**
    * Price
    */
    'price': number;
    /**
    * Seller
    */
    'seller': string;
    /**
    * Shipping
    */
    'shipping': number;
    /**
    * Total
    */
    'total': number;
}

export class ItemEbayMarketPlaceAnalysis {
    /**
    * Adjusted price
    */
    'adjustedPrice': number;
    /**
    * Adjusted shipping
    */
    'adjustedShipping': number;
    /**
    * Adjusted total
    */
    'adjustedTotal': number;
    /**
    * Cost of goods sold
    */
    'cogs': number;
    /**
    * Final value fee
    */
    'finalValueFee': number;
    /**
    * Minimum advertised price
    */
    'minimumAdvertisedPrice': number;
    /**
    * Other listings
    */
    'otherListings': Array<ItemEbayMarketListing>;
    'ourListing': ItemEbayMarketListing;
    /**
    * Overhead
    */
    'overhead': number;
    /**
    * Profit potential
    */
    'profitPotential': number;
}

export class ItemEmailNotifications {
    /**
    * Skip receipt email to customer
    */
    'skipReceipt': boolean;
    /**
    * Skip shipment notification to customer
    */
    'skipShipmentNotification': boolean;
}

export class ItemEnrollment123 {
    /**
    * Enrolment 123 product code
    */
    'enrollment123ProductCode': string;
}

export class ItemGiftCertificate {
    /**
    * True if the purchase of this item generates a gift certificate
    */
    'giftCertificate': boolean;
    /**
    * The number of days that the gift certificate is good for (optional)
    */
    'giftCertificateExpirationDays': number;
}

export class ItemGoogleProductSearch {
    /**
    * Adwords grouping
    */
    'adwordsGrouping': string;
    /**
    * Adwords label 1
    */
    'adwordsLabel1': string;
    /**
    * Adwords label 2
    */
    'adwordsLabel2': string;
    /**
    * Adwords label 3
    */
    'adwordsLabel3': string;
    /**
    * Adwords label 4
    */
    'adwordsLabel4': string;
    /**
    * Adwords label 5
    */
    'adwordsLabel5': string;
    /**
    * Age group
    */
    'ageGroup': string;
    /**
    * Available at physical store
    */
    'availableAtPhysicalStore': boolean;
    /**
    * Book - author
    */
    'bookAuthor': string;
    /**
    * Book - format
    */
    'bookFormat': string;
    /**
    * Bood - ISBN
    */
    'bookIsbn': string;
    /**
    * Book - publisher
    */
    'bookPublisher': string;
    /**
    * Category description
    */
    'categoryDescription': string;
    /**
    * Color
    */
    'color': string;
    /**
    * Condition
    */
    'condition': string;
    /**
    * Custom label 0
    */
    'customLabel0': string;
    /**
    * Custom label 1
    */
    'customLabel1': string;
    /**
    * Custom label 2
    */
    'customLabel2': string;
    /**
    * Custom label 3
    */
    'customLabel3': string;
    /**
    * Custom label 4
    */
    'customLabel4': string;
    /**
    * Gender
    */
    'gender': string;
    /**
    * Google product category
    */
    'googleProductCategory': string;
    /**
    * Music - artist
    */
    'musicArtist': string;
    /**
    * Music - format
    */
    'musicFormat': string;
    /**
    * Music - release date
    */
    'musicReleaseDate': string;
    /**
    * Omit from feed
    */
    'omitFromFeed': boolean;
    /**
    * Product type
    */
    'productType': string;
    /**
    * Promotion ID 1
    */
    'promotionId1': string;
    /**
    * Promotion ID 10
    */
    'promotionId10': string;
    /**
    * Promotion ID 2
    */
    'promotionId2': string;
    /**
    * Promotion ID 3
    */
    'promotionId3': string;
    /**
    * Promotion ID 4
    */
    'promotionId4': string;
    /**
    * Promotion ID 5
    */
    'promotionId5': string;
    /**
    * Promotion ID 6
    */
    'promotionId6': string;
    /**
    * Promotion ID 7
    */
    'promotionId7': string;
    /**
    * Promotion ID 8
    */
    'promotionId8': string;
    /**
    * Promotion ID 9
    */
    'promotionId9': string;
    /**
    * Search date/time
    */
    'searchDts': string;
    /**
    * Search lowest price
    */
    'searchLowestPrice': number;
    /**
    * Search lowest URL
    */
    'searchLowestUrl': string;
    /**
    * Search position
    */
    'searchPosition': number;
    'shippingLabel': string;
    /**
    * Size
    */
    'size': string;
    /**
    * Video - director
    */
    'videoDirector': string;
    /**
    * Video - format
    */
    'videoFormat': string;
    /**
    * Video - rating
    */
    'videoRating': string;
    /**
    * Video - release date
    */
    'videoReleaseDate': string;
    /**
    * Video - starring
    */
    'videoStarring': string;
}

export class ItemIdentifiers {
    /**
    * Barcode
    */
    'barcode': string;
    /**
    * Manufacturer Name
    */
    'manufacturerName': string;
    /**
    * Manufacturer SKU
    */
    'manufacturerSku': string;
    /**
    * UNSPSC
    */
    'unspsc': string;
}

export class ItemInstantPaymentNotification {
    /**
    * True for HTTP POST instead of GET
    */
    'postOperation': boolean;
    /**
    * Successful response text
    */
    'successfulResponseText': string;
    /**
    * URL
    */
    'url': string;
}

export class ItemInstantPaymentNotifications {
    /**
    * Notifications
    */
    'notifications': Array<ItemInstantPaymentNotification>;
}

export class ItemInternal {
    /**
    * Memo
    */
    'memo': string;
}

export class ItemKitComponent {
    /**
    * Component item cost
    */
    'componentCost': number;
    /**
    * Component item description
    */
    'componentDescription': string;
    /**
    * Component item ID
    */
    'componentMerchantItemId': string;
    /**
    * Component item object identifier
    */
    'componentMerchantItemOid': number;
    /**
    * Quantity
    */
    'quantity': number;
}

export class ItemKitDefinition {
    /**
    * Components
    */
    'components': Array<ItemKitComponent>;
}

export class ItemOption {
    /**
    * Cost if specified
    */
    'costIfSpecified': number;
    /**
    * Cost per letter
    */
    'costPerLetter': number;
    /**
    * Cost per line
    */
    'costPerLine': number;
    /**
    * Ignore this option on the order if the default value is selected
    */
    'ignoreIfDefault': boolean;
    /**
    * Label
    */
    'label': string;
    /**
    * Label translated text instance ID
    */
    'labelTranslatedTextInstanceOid': number;
    /**
    * Name
    */
    'name': string;
    /**
    * Name translated text instance ID
    */
    'nameTranslatedTextInstanceOid': number;
    /**
    * One time fee
    */
    'oneTimeFee': boolean;
    /**
    * Option object identifier
    */
    'optionOid': number;
    /**
    * True if the customer is required to specify an answer
    */
    'required': boolean;
    /**
    * True if this is a system option
    */
    'systemOption': boolean;
    /**
    * Type of option
    */
    'type': ItemOption.TypeEnum;
    /**
    * Values
    */
    'values': Array<ItemOptionValue>;
}

export namespace ItemOption {
    export enum TypeEnum {
        Dropdown = <any> 'dropdown',
        FileAttachment = <any> 'file attachment',
        Fixed = <any> 'fixed',
        Hidden = <any> 'hidden',
        Multiline = <any> 'multiline',
        Radio = <any> 'radio',
        Single = <any> 'single'
    }
}
export class ItemOptionValue {
    /**
    * Additional dimensions application
    */
    'additionalDimensionApplication': ItemOptionValue.AdditionalDimensionApplicationEnum;
    /**
    * Additional items to add to the order if this value is selected
    */
    'additionalItems': Array<ItemOptionValueAdditionalItem>;
    /**
    * Cost change
    */
    'costChange': number;
    /**
    * True if default value
    */
    'defaultValue': boolean;
    /**
    * Digital items to allow the customer to download if this option value is selected
    */
    'digitalItems': Array<ItemOptionValueDigitalItem>;
    'height': Distance;
    'length': Distance;
    /**
    * Multimedia object identifier associated with this option value
    */
    'merchantItemMultimediaOid': number;
    /**
    * Option value object identifier
    */
    'optionValueOid': number;
    /**
    * Percentage cost change
    */
    'percentCostChange': number;
    /**
    * Translated text instance id
    */
    'translatedTextInstanceOid': number;
    /**
    * Value
    */
    'value': string;
    'weightChange': Weight;
    /**
    * Percentage weight change
    */
    'weightChangePercent': number;
    'width': Distance;
}

export namespace ItemOptionValue {
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}
export class ItemOptionValueAdditionalItem {
    /**
    * Additional item id
    */
    'additionalMerchantItemId': string;
    /**
    * Additional item object identifier
    */
    'additionalMerchantItemOid': number;
}

export class ItemOptionValueDigitalItem {
    /**
    * Digital item object identifier
    */
    'digitalItemOid': number;
    /**
    * Original filename
    */
    'originalFilename': string;
}

export class ItemPaymentProcessing {
    /**
    * True if prepaid cards should be blocked from buying this item
    */
    'blockPrepaid': boolean;
    /**
    * Credit card transaction type
    */
    'creditCardTransactionType': string;
    /**
    * True if no real-time charge should be performed on this item.
    */
    'noRealtimeCharge': boolean;
    /**
    * Payment method validity
    */
    'paymentMethodValidity': Array<string>;
    /**
    * Rotating transaction gateway codes
    */
    'rotatingTransactionGatewayCodes': Array<string>;
}

export class ItemPhysical {
    'height': Distance;
    'length': Distance;
    'weight': Weight;
    'width': Distance;
}

export class ItemPricing {
    /**
    * Allow arbitrary cost
    */
    'allowArbitraryCost': boolean;
    /**
    * Arbitrary cost velocity code
    */
    'arbitraryCostVelocityCode': string;
    /**
    * Automatic pricing tier name
    */
    'automaticPricingTierName': string;
    /**
    * Automatic pricing tier object identifier
    */
    'automaticPricingTierOid': number;
    /**
    * Cost of goods sold
    */
    'cogs': number;
    /**
    * Cost
    */
    'cost': number;
    /**
    * Currency code
    */
    'currencyCode': string;
    /**
    * Manufacturer suggested retail price
    */
    'manufacturerSuggestedRetailPrice': number;
    /**
    * Maximum arbitrary cost
    */
    'maximumArbitraryCost': number;
    /**
    * Minimum advertised price
    */
    'minimumAdvertisedPrice': number;
    /**
    * Minimum arbitrary cost
    */
    'minimumArbitraryCost': number;
    /**
    * Mix and match group
    */
    'mixAndMatchGroup': string;
    /**
    * Mix and match group object identifier
    */
    'mixAndMatchGroupOid': number;
    /**
    * Sale cost
    */
    'saleCost': number;
    /**
    * Sale end
    */
    'saleEnd': string;
    /**
    * Sale start
    */
    'saleStart': string;
    /**
    * Tiers
    */
    'tiers': Array<ItemPricingTier>;
}

export class ItemPricingTier {
    /**
    * True if this is the default tier
    */
    'defaultTier': boolean;
    /**
    * Discounts
    */
    'discounts': Array<ItemPricingTierDiscount>;
    'limit': ItemPricingTierLimit;
    /**
    * Pricing tier name
    */
    'name': string;
    /**
    * Pricing tier object identifier
    */
    'pricingTierOid': number;
}

export class ItemPricingTierDiscount {
    /**
    * Cost
    */
    'cost': number;
    /**
    * Quantity
    */
    'quantity': number;
}

export class ItemPricingTierLimit {
    /**
    * Cumulative order limit
    */
    'cumulativeOrderLimit': number;
    /**
    * Individual order limit
    */
    'individualOrderLimit': number;
    /**
    * Multiple quantity
    */
    'multipleQuantity': number;
}

export class ItemRealtimePricing {
    /**
    * Real-time pricing provider parameters
    */
    'realtimePricingParameter': string;
    /**
    * Real-time pricing provider name
    */
    'realtimePricingProvider': string;
    /**
    * Real-time pricing provide object identifier
    */
    'realtimePricingProviderOid': number;
}

export class ItemRelated {
    /**
    * True to suppress system calculated relationships
    */
    'noSystemCalculatedRelatedItems': boolean;
    /**
    * Not relatable
    */
    'notRelatable': boolean;
    /**
    * Related items
    */
    'relatedItems': Array<ItemRelatedItem>;
}

export class ItemRelatedItem {
    /**
    * Related item id
    */
    'relatedMerchantItemId': string;
    /**
    * Related item object identifier
    */
    'relatedMerchantItemOid': number;
    /**
    * Relationship type
    */
    'type': ItemRelatedItem.TypeEnum;
}

export namespace ItemRelatedItem {
    export enum TypeEnum {
        System = <any> 'System',
        UserDefined = <any> 'UserDefined'
    }
}
export class ItemReporting {
    /**
    * Report as an upsell
    */
    'reportAsUpsell': boolean;
    /**
    * Report pickable quantities
    */
    'reportPickableQuantities': Array<number>;
}

export class ItemResponse {
    'error': Error;
    'item': Item;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class ItemRestriction {
    /**
    * Exclude coupons
    */
    'excludeCoupon': boolean;
    /**
    * Exclude from free promotion
    */
    'excludeFromFreePromotion': boolean;
    /**
    * Items
    */
    'items': Array<ItemRestrictionItem>;
    /**
    * Maximum quantity
    */
    'maximumQuantity': number;
    /**
    * Minimum quantity (defaults to 1)
    */
    'minimumQuantity': number;
    /**
    * Multiple of quantity
    */
    'multipleQuantity': number;
    /**
    * One per customer
    */
    'onePerCustomer': boolean;
    /**
    * Purchase separately
    */
    'purchaseSeparately': boolean;
}

export class ItemRestrictionItem {
    /**
    * Restrict item id
    */
    'restrictMerchantItemId': string;
    /**
    * Restrict item object identifier
    */
    'restrictMerchantItemOid': number;
    /**
    * Restriction type
    */
    'type': ItemRestrictionItem.TypeEnum;
}

export namespace ItemRestrictionItem {
    export enum TypeEnum {
        CanNotBePurchasedWith = <any> 'can not be purchased with',
        CanOnlyBePurchasedWith = <any> 'can only be purchased with',
        MustBePurchasedWith = <any> 'must be purchased with'
    }
}
export class ItemRevguard {
    /**
    * Canceled CSR prompt group
    */
    'revguardCanceledCsrPromptGroup': number;
    /**
    * IVR prompt group
    */
    'revguardCanceledIvrPromptGroup': number;
    /**
    * Canceled web prompt group
    */
    'revguardCanceledWebPromptGroup': number;
    /**
    * Client brand
    */
    'revguardClientBrand': number;
    /**
    * CSR prompt group
    */
    'revguardCsrPromptGroup': number;
    /**
    * IVR prompt group
    */
    'revguardIvrPromptGroup': number;
    /**
    * Web prompt group
    */
    'revguardWebPromptGroup': number;
}

export class ItemReviews {
    /**
    * True if the item has an approved review
    */
    'hasApprovedReview': boolean;
    /**
    * True if the item has a review
    */
    'hasReview': boolean;
    /**
    * Number of approved reviews
    */
    'reviewCount': number;
    /**
    * Overall score of reviews
    */
    'reviewOverall': number;
    /**
    * Review template name
    */
    'reviewTemplateName': string;
    /**
    * Review template object identifier
    */
    'reviewTemplateOid': number;
    /**
    * True if the item is reviewable
    */
    'reviewable': boolean;
}

export class ItemSalesforce {
    /**
    * Salesforce.com pricebook id
    */
    'sfdcPricebookId': string;
    /**
    * Salesforce.com product id
    */
    'sfdcProductId': string;
}

export class ItemShipping {
    /**
    * Allow back order
    */
    'allowBackOrder': boolean;
    /**
    * Fulfillment by Amazon.com
    */
    'amazonFba': boolean;
    /**
    * Case inner packs
    */
    'caseInnerPacks': number;
    /**
    * Case units
    */
    'caseUnits': number;
    /**
    * Cases
    */
    'cases': Array<ItemShippingCase>;
    /**
    * This item is on pre-order
    */
    'collectSerialNumbers': boolean;
    /**
    * Country code of origin for customs forms.  (ISO-3166 two letter code)
    */
    'countryCodeOfOrigin': string;
    /**
    * Customs description
    */
    'customsDescription': string;
    /**
    * Customs value
    */
    'customsValue': number;
    /**
    * Delivery on Friday
    */
    'deliveryOnFriday': boolean;
    /**
    * Delivery on Monday
    */
    'deliveryOnMonday': boolean;
    /**
    * Delivery on Saturday
    */
    'deliveryOnSaturday': boolean;
    /**
    * Delivery on Sunday
    */
    'deliveryOnSunday': boolean;
    /**
    * Delivery on Thursday
    */
    'deliveryOnThursday': boolean;
    /**
    * Delivery on Tuesday
    */
    'deliveryOnTuesday': boolean;
    /**
    * Delivery on Wednesday
    */
    'deliveryOnWednesday': boolean;
    /**
    * Destination markups
    */
    'destinationMarkups': Array<ItemShippingDestinationMarkup>;
    /**
    * Destination restrictions
    */
    'destinationRestrictions': Array<ItemShippingDestinationRestriction>;
    /**
    * Distribution centers
    */
    'distributionCenters': Array<ItemShippingDistributionCenter>;
    /**
    * Estimated time of arrival
    */
    'eta': string;
    /**
    * Qualifies for free shipping
    */
    'freeShipping': boolean;
    /**
    * Freight class
    */
    'freightClass': string;
    /**
    * Hazardous material
    */
    'hazmat': boolean;
    /**
    * True if this item is made to order
    */
    'madeToOrder': boolean;
    /**
    * Number of days lead time it takes to make the item before ite can ship
    */
    'madeToOrderLeadTime': number;
    /**
    * Maximum days allowed in transit
    */
    'maxDaysTimeInTransit': number;
    /**
    * Methods
    */
    'methods': Array<ItemShippingMethod>;
    /**
    * No shipping discounts
    */
    'noShippingDiscount': boolean;
    /**
    * Package requirements
    */
    'packageRequirements': Array<ItemShippingPackageRequirement>;
    /**
    * Perishable class name
    */
    'perishableClassName': string;
    /**
    * Perishable class object identifier
    */
    'perishableClassOid': number;
    /**
    * This item is on pre-order
    */
    'preorder': boolean;
    /**
    * True to require customer to select a delivery date
    */
    'requireDeliveryDate': boolean;
    /**
    * Restrict shipment on Friday
    */
    'restrictShipmentOnFriday': boolean;
    /**
    * Restrict shipment on Monday
    */
    'restrictShipmentOnMonday': boolean;
    /**
    * Restrict shipment on Saturday
    */
    'restrictShipmentOnSaturday': boolean;
    /**
    * Restrict shipment on Sunday
    */
    'restrictShipmentOnSunday': boolean;
    /**
    * Restrict shipment on Thursday
    */
    'restrictShipmentOnThursday': boolean;
    /**
    * Restrict shipment on Tuesday
    */
    'restrictShipmentOnTuesday': boolean;
    /**
    * Restrict shipment on Wednesday
    */
    'restrictShipmentOnWednesday': boolean;
    /**
    * Ship this item in a separate box
    */
    'shipSeparately': boolean;
    'shipSeparatelyAdditionalWeight': Weight;
    'shipSeparatelyHeight': Distance;
    'shipSeparatelyLength': Distance;
    /**
    * Ship separately package special type
    */
    'shipSeparatelyPackageSpecialType': string;
    'shipSeparatelyWidth': Distance;
    /**
    * Special product type (USPS Media Mail)
    */
    'specialProductType': string;
    /**
    * Track inventory
    */
    'trackInventory': boolean;
}

export class ItemShippingCase {
    /**
    * Case label
    */
    'caseLabel': string;
    /**
    * Case item id
    */
    'caseMerchantItemId': string;
    /**
    * Case item object identifier
    */
    'caseMerchantItemOid': number;
    /**
    * Case quantity
    */
    'quantity': number;
}

export class ItemShippingDestinationMarkup {
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode': string;
    /**
    * Flat fee
    */
    'flatFee': number;
    /**
    * Per item
    */
    'perItem': number;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * Shipping method
    */
    'shippingMethod': string;
    /**
    * State
    */
    'state': string;
}

export class ItemShippingDestinationRestriction {
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode': string;
    /**
    * State
    */
    'state': string;
    /**
    * Validity
    */
    'validity': ItemShippingDestinationRestriction.ValidityEnum;
}

export namespace ItemShippingDestinationRestriction {
    export enum ValidityEnum {
        ValidOnlyFor = <any> 'valid only for',
        InvalidFor = <any> 'invalid for'
    }
}
export class ItemShippingDistributionCenter {
    /**
    * Allocated to placed orders
    */
    'allocatedToPlacedOrders': number;
    /**
    * Allocated to shopping carts
    */
    'allocatedToShoppingCarts': number;
    /**
    * Available to allocate
    */
    'availableToAllocate': number;
    /**
    * Desired inventory level
    */
    'desiredInventoryLevel': number;
    /**
    * Distribution center code
    */
    'distributionCenterCode': string;
    /**
    * Distribution center object identifier
    */
    'distributionCenterOid': number;
    /**
    * Estimated time of arrival
    */
    'eta': string;
    /**
    * True if this distribution center handles this item
    */
    'handles': boolean;
    /**
    * Inventory level
    */
    'inventoryLevel': number;
    /**
    * Maximum back-order
    */
    'maximumBackorder': number;
    /**
    * Reorder inventory level (triggers notification)
    */
    'reorderInventoryLevel': number;
    /**
    * SKU
    */
    'sku': string;
    /**
    * Stock picking location
    */
    'stockPickingLocation': string;
}

export class ItemShippingMethod {
    /**
    * Cost
    */
    'cost': number;
    /**
    * Each additional item markup
    */
    'eachAdditionalItemMarkup': number;
    /**
    * Filter to this method if available
    */
    'filterToIfAvailable': boolean;
    /**
    * First item markup
    */
    'firstItemMarkup': number;
    /**
    * Fixed shipping cost
    */
    'fixedShippingCost': number;
    /**
    * Flat fee markup
    */
    'flatFeeMarkup': number;
    /**
    * Free shipping
    */
    'freeShipping': boolean;
    /**
    * Per item fee markup
    */
    'perItemFeeMarkup': number;
    /**
    * Percentage markup
    */
    'percentageMarkup': number;
    /**
    * Percentage of item markup
    */
    'percentageOfItemMarkup': number;
    /**
    * Relax restrictions on upsell
    */
    'relaxRestrictionsOnUpsell': boolean;
    /**
    * Shipping method name
    */
    'shippingMethod': string;
    /**
    * Shipping method object identifier
    */
    'shippingMethodOid': number;
    /**
    * Shipping method validity
    */
    'shippingMethodValidity': ItemShippingMethod.ShippingMethodValidityEnum;
    /**
    * Signature required
    */
    'signatureRequired': boolean;
}

export namespace ItemShippingMethod {
    export enum ShippingMethodValidityEnum {
        InvalidFor = <any> 'invalid for',
        ValidFor = <any> 'valid for',
        ValidOnlyFor = <any> 'valid only for'
    }
}
export class ItemShippingPackageRequirement {
    /**
    * Package name
    */
    'packageName': string;
    /**
    * Package object identifier
    */
    'packageOid': number;
}

export class ItemTax {
    /**
    * Exemptions
    */
    'exemptions': Array<ItemTaxExemption>;
    /**
    * True if tax free
    */
    'taxFree': boolean;
    /**
    * Taxable cost if different than regular cost
    */
    'taxableCost': number;
}

export class ItemTaxExemption {
    /**
    * City
    */
    'city': string;
    /**
    * Country code (ISO-3166 two letter)
    */
    'countryCode': string;
    /**
    * County
    */
    'county': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State code
    */
    'stateCode': string;
}

export class ItemThirdPartyEmailMarketing {
    /**
    * Add tags
    */
    'addTags': Array<string>;
    /**
    * Provider name
    */
    'providerName': ItemThirdPartyEmailMarketing.ProviderNameEnum;
    /**
    * Remove tags
    */
    'removeTags': Array<string>;
    /**
    * Subscribe to lists
    */
    'subscribeLists': Array<string>;
    /**
    * Unsubscribe from lists
    */
    'unsubscribeLists': Array<string>;
}

export namespace ItemThirdPartyEmailMarketing {
    export enum ProviderNameEnum {
        ActiveCampaign = <any> 'ActiveCampaign',
        AWeber = <any> 'AWeber',
        CampaignMonitor = <any> 'Campaign Monitor',
        ConstantContact = <any> 'ConstantContact',
        Emma = <any> 'Emma',
        GetResponse = <any> 'GetResponse',
        IContact = <any> 'iContact',
        Klaviyo = <any> 'Klaviyo',
        Lyris = <any> 'Lyris',
        LyrisHQ = <any> 'LyrisHQ',
        MailChimp = <any> 'MailChimp',
        SilverPop = <any> 'SilverPop'
    }
}
export class ItemVariantItem {
    /**
    * Description
    */
    'description': string;
    /**
    * Multimedia object identifier
    */
    'merchantItemMultimediaOid': number;
    /**
    * Variant item id
    */
    'variantMerchantItemId': string;
    /**
    * Variant item object identifier
    */
    'variantMerchantItemOid': number;
    /**
    * Variation options
    */
    'variationOptions': Array<string>;
    /**
    * Variations
    */
    'variations': Array<string>;
}

export class ItemVariation {
    /**
    * Default text
    */
    'defaultText': string;
    /**
    * Default text translated text instance id
    */
    'defaultTextTranslatedTextInstanceOid': number;
    /**
    * Name
    */
    'name': string;
    /**
    * Name translated text instance id
    */
    'nameTranslatedTextInstanceOid': number;
    /**
    * Options
    */
    'options': Array<ItemVariationOption>;
}

export class ItemVariationOption {
    /**
    * True if default option
    */
    'defaultOption': boolean;
    /**
    * Multimedia object identifier
    */
    'merchantItemMultimediaOid': number;
    /**
    * Translated text instance id
    */
    'translatedTextInstanceOid': number;
    /**
    * Value
    */
    'value': string;
}

export class ItemWishlistMember {
    /**
    * WishList Member instance description
    */
    'wishlistMemberInstanceDescription': string;
    /**
    * WishList Member instance object identifier
    */
    'wishlistMemberInstanceOid': number;
    /**
    * WishList Member SKU
    */
    'wishlistMemberSku': string;
}

export class ItemsRequest {
    /**
    * items
    */
    'items': Array<Item>;
}

export class ItemsResponse {
    'error': Error;
    /**
    * items
    */
    'items': Array<Item>;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class KeyValue {
    /**
    * Optional description of the lookup value
    */
    'description': string;
    /**
    * The key or id of this lookup value
    */
    'key': string;
    /**
    * The value of this lookup value
    */
    'value': string;
}

export class ListSegmentMembership {
    'name': string;
    'type': string;
    'uuid': string;
}

export class LookupResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'values': Array<KeyValue>;
}

export class Metric {
    'allTime': number;
    'allTimeFormatted': string;
    'last30': number;
    'last30Formatted': string;
    'name': string;
    'prior30': number;
    'prior30Formatted': string;
    'type': string;
}

export class OauthRevokeSuccessResponse {
    /**
    * Message confirming revocation of credentials
    */
    'message': string;
    /**
    * True if revoke was successful
    */
    'successful': boolean;
}

export class OauthTokenResponse {
    /**
    * Access token to use in OAuth authenticated API call
    */
    'accessToken': string;
    'error': string;
    'errorDescription': string;
    'errorUri': string;
    /**
    * The number of seconds since issuance when the access token will expire and need to be refreshed using the refresh token
    */
    'expiresIn': string;
    /**
    * The refresh token that should be used to fetch a new access token when the expiration occurs
    */
    'refreshToken': string;
    /**
    * The scope of permissions associated with teh access token
    */
    'scope': string;
    /**
    * Type of token
    */
    'tokenType': OauthTokenResponse.TokenTypeEnum;
}

export namespace OauthTokenResponse {
    export enum TokenTypeEnum {
        Bearer = <any> 'bearer'
    }
}
export class Order {
    /**
    * Affiliates if any were associated with the order.  The first one in the array sent the order and each subsequent affiliate is the recruiter that earns a downline commission.
    */
    'affiliates': Array<OrderAffiliate>;
    'autoOrder': OrderAutoOrder;
    'billing': OrderBilling;
    'buysafe': OrderBuysafe;
    'channelPartner': OrderChannelPartner;
    'checkout': OrderCheckout;
    /**
    * Coupons
    */
    'coupons': Array<OrderCoupon>;
    /**
    * Date/time that the order was created
    */
    'creationDts': string;
    /**
    * Currency code that the customer used if different than the merchant's base currency code
    */
    'currencyCode': string;
    /**
    * Current stage that the order is in.
    */
    'currentStage': Order.CurrentStageEnum;
    'customerProfile': Customer;
    'digitalOrder': OrderDigitalOrder;
    'edi': OrderEdi;
    /**
    * Exchange rate at the time the order was placed if currency code is different than the base currency
    */
    'exchangeRate': number;
    'fraudScore': OrderFraudScore;
    'gift': OrderGift;
    'giftCertificate': OrderGiftCertificate;
    'internal': OrderInternal;
    /**
    * Items
    */
    'items': Array<OrderItem>;
    /**
    * Three letter ISO-639 language code used by the customer during the checkout if different than the default language
    */
    'languageIsoCode': string;
    'linkedShipment': OrderLinkedShipment;
    'marketing': OrderMarketing;
    /**
    * UltraCart merchant ID owning this order
    */
    'merchantId': string;
    /**
    * Order ID
    */
    'orderId': string;
    'payment': OrderPayment;
    /**
    * Properties, available only through update, not through insert due to the nature of how properties are handled internally
    */
    'properties': Array<OrderProperty>;
    'quote': OrderQuote;
    /**
    * If the order was refunded, the date/time that the last refund occurred
    */
    'refundDts': string;
    /**
    * If the order was rejected, the date/time that the rejection occurred
    */
    'rejectDts': string;
    'salesforce': OrderSalesforce;
    'shipping': OrderShipping;
    'summary': OrderSummary;
    'taxes': OrderTaxes;
}

export namespace Order {
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown'
    }
}
export class OrderAffiliate {
    /**
    * Affiliate ID
    */
    'affiliateOid': number;
    /**
    * Ledger entries associated with all the commissions earned on this order
    */
    'ledgerEntries': Array<OrderAffiliateLedger>;
    /**
    * Sub identifier provided by the affiliate on the click that generated this order
    */
    'subId': string;
}

export class OrderAffiliateLedger {
    /**
    * UltraCart user name that assigned this commission if manually assigned
    */
    'assignedByUser': string;
    /**
    * Item ID that this ledger record is associated with
    */
    'itemId': string;
    /**
    * Tier number of this affiliate in the commission calculation
    */
    'tierNumber': number;
    /**
    * Amount of the transaction
    */
    'transactionAmount': number;
    /**
    * The amount that has been paid so far on the transaction
    */
    'transactionAmountPaid': number;
    /**
    * The date/time that the affiliate ledger was generated for the transaction
    */
    'transactionDts': string;
    /**
    * Details of the transaction suitable for display to the affiliate
    */
    'transactionMemo': string;
    /**
    * The percentage earned on the transaction
    */
    'transactionPercentage': number;
    /**
    * The state of the transaction
    */
    'transactionState': OrderAffiliateLedger.TransactionStateEnum;
}

export namespace OrderAffiliateLedger {
    export enum TransactionStateEnum {
        Pending = <any> 'Pending',
        Posted = <any> 'Posted',
        Approved = <any> 'Approved',
        Paid = <any> 'Paid',
        Rejected = <any> 'Rejected',
        PartiallyPaid = <any> 'Partially Paid'
    }
}
export class OrderAutoOrder {
    /**
    * Unique code assigned to the auto order
    */
    'autoOrderCode': string;
    /**
    * Unique identifier assigned to the auto order
    */
    'autoOrderOid': number;
    /**
    * Orignal order id that started this auto order sequence
    */
    'originalOrderId': string;
    /**
    * The status of the auto order
    */
    'status': OrderAutoOrder.StatusEnum;
}

export namespace OrderAutoOrder {
    export enum StatusEnum {
        Active = <any> 'active',
        Canceled = <any> 'canceled',
        Disabled = <any> 'disabled'
    }
}
export class OrderBilling {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * CC emails.  Multiple allowed, but total length of all emails can not exceed 100 characters.
    */
    'ccEmails': Array<string>;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day time phone
    */
    'dayPhone': string;
    /**
    * Day time phone (E164 format)
    */
    'dayPhoneE164': string;
    /**
    * Email
    */
    'email': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
}

export class OrderBuysafe {
    /**
    * True if a buySAFE bond was available for purchase on this order
    */
    'buysafeBondAvailable': boolean;
    'buysafeBondCost': Currency;
    /**
    * True if the buySAFE bond was free for this order
    */
    'buysafeBondFree': boolean;
    'buysafeBondRefunded': Currency;
    /**
    * True if the buySAFE bond was wanted by the customer
    */
    'buysafeBondWanted': boolean;
    /**
    * Shopping cart ID associated with the buySAFE bond
    */
    'buysafeShoppingCartId': string;
}

export class OrderChannelPartner {
    /**
    * If true, any purchase order submitted is automatically approved
    */
    'autoApprovePurchaseOrder': boolean;
    /**
    * The code of the channel partner
    */
    'channelPartnerCode': string;
    /**
    * Additional data provided by the channel partner, read-only
    */
    'channelPartnerData': string;
    /**
    * Channel partner object identifier, read-only and available on existing channel orders only.
    */
    'channelPartnerOid': number;
    /**
    * The order ID assigned by the channel partner for this order
    */
    'channelPartnerOrderId': string;
    /**
    * Indicates this order should be placed in Account Receivable for later payment processing
    */
    'noRealtimePaymentProcessing': boolean;
    /**
    * Indicates this order was already paid for via a channel purchase and no payment collection should be attempted
    */
    'skipPaymentProcessing': boolean;
    /**
    * Instructs UltraCart to skip shipping department and mark this order as fully complete.  Set this flag if you have already shipped product for this order.
    */
    'storeCompleted': boolean;
    /**
    * If true, any failed payment will place the order in Accounts Receivable rather than rejecting it.
    */
    'storeIfPaymentDeclines': boolean;
    /**
    * Any warnings are raised as errors and halt the import of the order
    */
    'treatWarningsAsErrors': boolean;
}

export class OrderCheckout {
    /**
    * Comments from the customer.  Rarely used on the single page checkout.
    */
    'comments': string;
    /**
    * Custom field 1
    */
    'customField1': string;
    /**
    * Custom field 2
    */
    'customField2': string;
    /**
    * Custom field 3
    */
    'customField3': string;
    /**
    * Custom field 4
    */
    'customField4': string;
    /**
    * Custom field 5
    */
    'customField5': string;
    /**
    * Custom field 6
    */
    'customField6': string;
    /**
    * Custom field 7
    */
    'customField7': string;
    /**
    * IP address of the customer when placing the order
    */
    'customerIpAddress': string;
    /**
    * Screen branding theme code associated with the order (legacy checkout)
    */
    'screenBrandingThemeCode': string;
    /**
    * StoreFront host name associated with the order
    */
    'storefrontHostName': string;
    /**
    * Upsell path code assigned during the checkout that the customer went through
    */
    'upsellPathCode': string;
}

export class OrderCoupon {
    /**
    * QuickBooks accounting code for this coupon
    */
    'accountingCode': string;
    /**
    * Whether or not the coupon was automatically applied to the order
    */
    'automaticallyApplied': boolean;
    /**
    * Coupon code configured by the merchant.  Will differ if the customer used a one time coupon code generated off this base coupon
    */
    'baseCouponCode': string;
    /**
    * Coupon code entered by the customer
    */
    'couponCode': string;
}

export class OrderDigitalItem {
    /**
    * File size
    */
    'fileSize': number;
    /**
    * Last download
    */
    'lastDownload': string;
    /**
    * IP address that performed the last download
    */
    'lastDownloadIpAddress': string;
    /**
    * Original file name
    */
    'originalFilename': string;
    /**
    * Item id associated with this item
    */
    'productCode': string;
    /**
    * Item description associated with this item
    */
    'productDescription': string;
    /**
    * Remaining number of downloads
    */
    'remainingDownloads': number;
    /**
    * URL that the customer can click to download the specific digital item
    */
    'url': string;
}

export class OrderDigitalOrder {
    /**
    * Date/time that the digital order was created
    */
    'creationDts': string;
    /**
    * Expiration date/time of the digital order
    */
    'expirationDts': string;
    /**
    * Digital items associated with the digital order
    */
    'items': Array<OrderDigitalItem>;
    /**
    * URL where the customer can go to and download their digital order content
    */
    'url': string;
    /**
    * URL ID is a unique code that is part of the URLs
    */
    'urlId': string;
}

export class OrderEdi {
    /**
    * Billing address identification code from the EDI order.  Typically DUNS or DUNS+4
    */
    'billToEdiCode': string;
    /**
    * Department number associated with this EDI order
    */
    'ediDepartment': string;
    /**
    * Internal vendor number associated with this EDI order
    */
    'ediInternalVendorNumber': string;
    /**
    * Shipping address identification code from the EDI order.  Typically DUNS or DUNS+4
    */
    'shipToEdiCode': string;
}

export class OrderFormat {
    /**
    * The context to generate the order view for.
    */
    'context': string;
    /**
    * True to not link the email address to the order search
    */
    'dontLinkEmailToSearch': boolean;
    /**
    * True to make the email address a clickable mailto link
    */
    'emailAsLink': boolean;
    /**
    * Specify a distribution center oid to filter the items displayed to that particular distribution center.
    */
    'filterDistributionCenterOid': number;
    /**
    * The container oid to filter items to.
    */
    'filterToItemsInContactOid': number;
    /**
    * The desired format.
    */
    'format': OrderFormat.FormatEnum;
    /**
    * True to ide the bill to address
    */
    'hideBillToAddress': boolean;
    /**
    * True to hide price information
    */
    'hidePriceInformation': boolean;
    /**
    * True to link file attachments for download
    */
    'linkFileAttachments': boolean;
    /**
    * True to show contact information
    */
    'showContactInfo': boolean;
    /**
    * True to show the order in the merchant currency
    */
    'showInMerchantCurrency': boolean;
    /**
    * True to show internal information about the order
    */
    'showInternalInformation': boolean;
    /**
    * True to show merchant notes
    */
    'showMerchantNotes': boolean;
    /**
    * True to show non-sensitive payment information
    */
    'showNonSensitivePaymentInfo': boolean;
    /**
    * True to show payment information
    */
    'showPaymentInfo': boolean;
    /**
    * True to translate the order into the native language of the customer
    */
    'translate': boolean;
}

export namespace OrderFormat {
    export enum FormatEnum {
        Text = <any> 'text',
        Div = <any> 'div',
        Table = <any> 'table',
        Email = <any> 'email'
    }
}
export class OrderFormatResponse {
    /**
    * The URLs to any stylesheets that need to be included to properly view the markup.
    */
    'cssLinks': Array<string>;
    /**
    * The formatted result of the order.  This will be HTML or text depending upon the requested format.
    */
    'formattedResult': string;
}

export class OrderFraudScore {
    /**
    * True if the IP address is a known anonymous proxy server
    */
    'anonymousProxy': boolean;
    /**
    * Whether the BIN (first six digits) matched the country
    */
    'binMatch': OrderFraudScore.BinMatchEnum;
    /**
    * True if the email address belongs to a known credit card fraudster
    */
    'carderEmail': boolean;
    /**
    * Country code
    */
    'countryCode': string;
    /**
    * Country code matches BIN country
    */
    'countryMatch': boolean;
    /**
    * Whether the customer's phone number is located in the area of the billing address
    */
    'customerPhoneInBillingLocation': string;
    /**
    * Distance in kilometers between the IP address and the BIN
    */
    'distanceKm': number;
    /**
    * True if the email address is for a free service like gmail.com
    */
    'freeEmail': boolean;
    /**
    * True if the customer is in a high risk country known for internet fraud
    */
    'highRiskCountry': boolean;
    /**
    * City associated with the IP address
    */
    'ipCity': string;
    /**
    * ISP that owns the IP address
    */
    'ipIsp': string;
    /**
    * Approximate latitude associated with the IP address
    */
    'ipLatitude': string;
    /**
    * Approximate longitude associated with the IP address
    */
    'ipLongitude': string;
    /**
    * Organization that owns the IP address
    */
    'ipOrg': string;
    /**
    * State/region associated with the IP address
    */
    'ipRegion': string;
    /**
    * Likelihood of the IP address being a proxy server
    */
    'proxyScore': number;
    /**
    * Overall score.  This is the score that is compared to see if the order is rejected or held for review by the fraud filter rules.
    */
    'score': number;
    /**
    * True if the address is a known ship forwarding company
    */
    'shipForwarder': boolean;
    /**
    * Likelihood of the email address being associated with a spammer
    */
    'spamScore': number;
    /**
    * True if the IP address that placed the order is a transparent proxy server
    */
    'transparentProxy': boolean;
}

export namespace OrderFraudScore {
    export enum BinMatchEnum {
        NA = <any> 'NA',
        No = <any> 'No',
        NotFound = <any> 'NotFound',
        Yes = <any> 'Yes'
    }
}
export class OrderGift {
    /**
    * True if the order is a gift
    */
    'gift': boolean;
    'giftCharge': Currency;
    /**
    * QuickBooks code for the gift charge
    */
    'giftChargeAccountingCode': string;
    'giftChargeRefunded': Currency;
    /**
    * Email address of the gift recipient
    */
    'giftEmail': string;
    /**
    * Message to the gift recipient
    */
    'giftMessage': string;
    /**
    * QuickBooks code for the gift wrap charge
    */
    'giftWrapAccountingCode': string;
    'giftWrapCost': Currency;
    'giftWrapRefunded': Currency;
    /**
    * Title of the gift wrap that the customer wants used
    */
    'giftWrapTitle': string;
}

export class OrderGiftCertificate {
    'giftCertificateAmount': Currency;
    /**
    * Gift certificate code used on the order
    */
    'giftCertificateCode': string;
    /**
    * Gift certificate object identifier
    */
    'giftCertificateOid': number;
}

export class OrderInternal {
    /**
    * True if the order has been exported to QuickBooks. If QuickBooks is not configured, then this will already be true
    */
    'exportedToAccounting': boolean;
    /**
    * Merchant notes
    */
    'merchantNotes': string;
    /**
    * If placed via the BEOE, this is the user that placed the order
    */
    'placedByUser': string;
    /**
    * User that issued the refund
    */
    'refundByUser': string;
    /**
    * Sales rep code associated with the order
    */
    'salesRepCode': string;
}

export class OrderItem {
    /**
    * QuickBooks code
    */
    'accountingCode': string;
    /**
    * Activation codes assigned to this item
    */
    'activationCodes': Array<string>;
    'arbitraryUnitCost': Currency;
    /**
    * Date/time of the last rebill, used only during order insert to help project future rebills
    */
    'autoOrderLastRebillDts': string;
    /**
    * Auto order schedule, used only during inserts supplying the recurring schedule
    */
    'autoOrderSchedule': string;
    /**
    * Barcode
    */
    'barcode': string;
    /**
    * Channel partner item id if this order came through a channel partner and the channel partner item id was mapped to an internal item id
    */
    'channelPartnerItemId': string;
    /**
    * Cost of goods sold
    */
    'cogs': number;
    /**
    * Value of the kit component item
    */
    'componentUnitValue': number;
    'cost': Currency;
    /**
    * Country of origin (ISO-3166 two letter code)
    */
    'countryCodeOfOrigin': string;
    /**
    * Customs description
    */
    'customsDescription': string;
    /**
    * Description
    */
    'description': string;
    'discount': Currency;
    /**
    * Discount quantity
    */
    'discountQuantity': number;
    'discountShippingWeight': Weight;
    /**
    * Distribution center code responsible for shipping this item
    */
    'distributionCenterCode': string;
    'edi': OrderItemEdi;
    /**
    * True if this item is excluded from coupons
    */
    'excludeCoupon': boolean;
    /**
    * True if the item receives free shipping
    */
    'freeShipping': boolean;
    /**
    * Hazardous materials indicator
    */
    'hazmat': boolean;
    'height': Distance;
    /**
    * Item reference object identifier used to linked to auto order item record
    */
    'itemReferenceOid': number;
    /**
    * True if this item is a kit
    */
    'kit': boolean;
    /**
    * True if this item is a kit component
    */
    'kitComponent': boolean;
    'length': Distance;
    /**
    * Manufacturer SKU
    */
    'manufacturerSku': string;
    /**
    * Maximum days that the item can be in transit before spoilage (perishable products)
    */
    'maxDaysTimeInTransit': number;
    /**
    * Item ID
    */
    'merchantItemId': string;
    /**
    * Mix and match group name
    */
    'mixAndMatchGroupName': string;
    /**
    * Mix and match group object identifier
    */
    'mixAndMatchGroupOid': number;
    /**
    * True if this item is excluded from shipping discounts
    */
    'noShippingDiscount': boolean;
    /**
    * Options
    */
    'options': Array<OrderItemOption>;
    /**
    * Packed by user
    */
    'packedByUser': string;
    /**
    * Perishable class of the item
    */
    'perishableClass': string;
    /**
    * Pricing tier that granted the particular price for this item if the customer profile had pricing tiers assigned
    */
    'pricingTierName': string;
    /**
    * Properties
    */
    'properties': Array<OrderItemProperty>;
    /**
    * Quantity
    */
    'quantity': number;
    /**
    * Quantity refunded on this item (read only except refund operation)
    */
    'quantityRefunded': number;
    /**
    * QuickBooks class
    */
    'quickbooksClass': string;
    /**
    * True if this item ships in a separate box
    */
    'shipSeparately': boolean;
    /**
    * Shipped by user
    */
    'shippedByUser': string;
    /**
    * Date/time that this item was marked shipped
    */
    'shippedDts': string;
    /**
    * Special product type (USPS Media Mail)
    */
    'specialProductType': string;
    /**
    * True if the item is tax free
    */
    'taxFree': boolean;
    'taxableCost': Currency;
    'totalCostWithDiscount': Currency;
    'totalRefunded': Currency;
    /**
    * Date/time that this item was transmitted to the distribution center
    */
    'transmittedToDistributionCenterDts': string;
    'unitCostWithDiscount': Currency;
    /**
    * True if this item was added to the order as part of an upsell
    */
    'upsell': boolean;
    'weight': Weight;
    'width': Distance;
}

export class OrderItemEdi {
    /**
    * Identification information receives on the EDI purchase order
    */
    'identifications': Array<OrderItemEdiIdentification>;
    /**
    * Lot information
    */
    'lots': Array<OrderItemEdiLot>;
}

export class OrderItemEdiIdentification {
    /**
    * Identification value
    */
    'identification': string;
    /**
    * Quantity associated with this identifier
    */
    'quantity': number;
}

export class OrderItemEdiLot {
    /**
    * Log expiration
    */
    'lotExpiration': string;
    /**
    * Lot number
    */
    'lotNumber': string;
    /**
    * Lot quantity
    */
    'lotQuantity': number;
}

export class OrderItemOption {
    /**
    * How the additional dimensions are applied to the item.
    */
    'additionalDimensionApplication': OrderItemOption.AdditionalDimensionApplicationEnum;
    'costChange': Currency;
    'fileAttachment': OrderItemOptionFileAttachment;
    'height': Distance;
    /**
    * True if this option is hidden from display on the order
    */
    'hidden': boolean;
    /**
    * Label
    */
    'label': string;
    'length': Distance;
    /**
    * True if the cost associated with this option is a one time fee or multiplied by the quantity of the item
    */
    'oneTimeFee': boolean;
    /**
    * Value
    */
    'value': string;
    'weightChange': Weight;
    'width': Distance;
}

export namespace OrderItemOption {
    export enum AdditionalDimensionApplicationEnum {
        None = <any> 'none',
        SetItemTo = <any> 'set item to',
        AddItem = <any> 'add item'
    }
}
export class OrderItemOptionFileAttachment {
    /**
    * Expiration date/time
    */
    'expirationDts': string;
    /**
    * File name
    */
    'fileName': string;
    /**
    * Mime type
    */
    'mimeType': string;
    /**
    * Size
    */
    'size': number;
}

export class OrderItemProperty {
    /**
    * True if this property is displayed to the customer
    */
    'display': boolean;
    /**
    * The date/time that the property expires and is deleted
    */
    'expirationDts': string;
    /**
    * Name
    */
    'name': string;
    /**
    * Value
    */
    'value': string;
}

export class OrderLinkedShipment {
    /**
    * True if this order has child linked shipments
    */
    'hasLinkedShipment': boolean;
    /**
    * True if this order is linked to another parent order
    */
    'linkedShipment': boolean;
    /**
    * The child linked shipment channel partner order ids
    */
    'linkedShipmentChannelPartnerOrderIds': Array<string>;
    /**
    * The child linked shipment order ids
    */
    'linkedShipmentOrderIds': Array<string>;
    /**
    * The parent order id that this one is linked to
    */
    'linkedShipmentToOrderId': string;
}

export class OrderMarketing {
    /**
    * Advertising source
    */
    'advertisingSource': string;
    /**
    * True if the customer has opted into mailing list subscription
    */
    'mailingList': boolean;
    /**
    * Referral code
    */
    'referralCode': string;
}

export class OrderPayment {
    'check': OrderPaymentCheck;
    'creditCard': OrderPaymentCreditCard;
    'echeck': OrderPaymentECheck;
    /**
    * True if order has been held for fraud review
    */
    'holdForFraudReview': boolean;
    /**
    * Date/time that the payment was successfully processed, for new orders, this field is only considered if channel_partner.skip_payment_processing is true
    */
    'paymentDts': string;
    /**
    * Payment method
    */
    'paymentMethod': OrderPayment.PaymentMethodEnum;
    /**
    * Payment method QuickBooks code
    */
    'paymentMethodAccountingCode': string;
    /**
    * Payment method QuickBooks deposit account
    */
    'paymentMethodDepositToAccount': string;
    /**
    * Payment status
    */
    'paymentStatus': OrderPayment.PaymentStatusEnum;
    'purchaseOrder': OrderPaymentPurchaseOrder;
    /**
    * Rotating transaction gateway code used to process this order
    */
    'rotatingTransactionGatewayCode': string;
    'surcharge': Currency;
    /**
    * Surcharge accounting code
    */
    'surchargeAccountingCode': string;
    /**
    * Surcharge transaction fee
    */
    'surchargeTransactionFee': number;
    /**
    * Surcharge transaction percentage
    */
    'surchargeTransactionPercentage': number;
    /**
    * True if this is a test order
    */
    'testOrder': boolean;
    /**
    * Transactions associated with processing this payment
    */
    'transactions': Array<OrderPaymentTransaction>;
}

export namespace OrderPayment {
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        EBay = <any> 'eBay',
        ECheck = <any> 'eCheck',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer',
        Walmart = <any> 'Walmart'
    }
    export enum PaymentStatusEnum {
        Unprocessed = <any> 'Unprocessed',
        Authorized = <any> 'Authorized',
        CaptureFailed = <any> 'Capture Failed',
        Processed = <any> 'Processed',
        Declined = <any> 'Declined',
        Voided = <any> 'Voided',
        Refunded = <any> 'Refunded',
        Skipped = <any> 'Skipped'
    }
}
export class OrderPaymentCheck {
    /**
    * Check number
    */
    'checkNumber': string;
}

export class OrderPaymentCreditCard {
    /**
    * Card authorization ticket
    */
    'cardAuthTicket': string;
    /**
    * Card authorization amount
    */
    'cardAuthorizationAmount': number;
    /**
    * Card authorization date/time
    */
    'cardAuthorizationDts': string;
    /**
    * Card authorization reference number
    */
    'cardAuthorizationReferenceNumber': string;
    /**
    * Card expiration month (1-12)
    */
    'cardExpirationMonth': number;
    /**
    * Card expiration year (Four digit year)
    */
    'cardExpirationYear': number;
    /**
    * Card number (masked to last 4)
    */
    'cardNumber': string;
    /**
    * Card number token from hosted fields used to update the cart number
    */
    'cardNumberToken': string;
    /**
    * True if the card has been truncated
    */
    'cardNumberTruncated': boolean;
    /**
    * Card type
    */
    'cardType': OrderPaymentCreditCard.CardTypeEnum;
    /**
    * Card verification number token from hosted fields, only for import/insert of new orders, completely ignored for updates, and always null/empty for queries
    */
    'cardVerificationNumberToken': string;
}

export namespace OrderPaymentCreditCard {
    export enum CardTypeEnum {
        AMEX = <any> 'AMEX',
        DinersClub = <any> 'Diners Club',
        Discover = <any> 'Discover',
        JCB = <any> 'JCB',
        MasterCard = <any> 'MasterCard',
        VISA = <any> 'VISA'
    }
}
export class OrderPaymentECheck {
    /**
    * Bank routing code
    */
    'bankAbaCode': string;
    /**
    * Bank account name
    */
    'bankAccountName': string;
    /**
    * Bank account number (masked to last 4)
    */
    'bankAccountNumber': string;
    /**
    * Bank account type
    */
    'bankAccountType': OrderPaymentECheck.BankAccountTypeEnum;
    /**
    * Bank name
    */
    'bankName': string;
    /**
    * Bank owner type
    */
    'bankOwnerType': OrderPaymentECheck.BankOwnerTypeEnum;
    /**
    * Customer tax id (masked to last 4)
    */
    'customerTaxId': string;
    /**
    * Driver license date of birth
    */
    'driversLicenseDob': string;
    /**
    * Driver license number (masked to last 4)
    */
    'driversLicenseNumber': string;
    /**
    * Driver license state
    */
    'driversLicenseState': string;
}

export namespace OrderPaymentECheck {
    export enum BankAccountTypeEnum {
        Checking = <any> 'Checking',
        Savings = <any> 'Savings'
    }
    export enum BankOwnerTypeEnum {
        Personal = <any> 'Personal',
        Business = <any> 'Business'
    }
}
export class OrderPaymentPurchaseOrder {
    /**
    * Purchase order number
    */
    'purchaseOrderNumber': string;
}

export class OrderPaymentTransaction {
    /**
    * Details
    */
    'details': Array<OrderPaymentTransactionDetail>;
    /**
    * True if the transaction was successful
    */
    'successful': boolean;
    /**
    * Transaction gateway
    */
    'transactionGateway': string;
    /**
    * Transaction date/time
    */
    'transactionTimestamp': string;
}

export class OrderPaymentTransactionDetail {
    /**
    * Name
    */
    'name': string;
    /**
    * Type
    */
    'type': string;
    /**
    * Value
    */
    'value': string;
}

export class OrderProperty {
    /**
    * True if this property is displayed to the customer
    */
    'display': boolean;
    /**
    * The date/time that the property expires and is deleted
    */
    'expirationDts': string;
    /**
    * Name
    */
    'name': string;
    /**
    * Value
    */
    'value': string;
}

export class OrderQuery {
    /**
    * CC Email
    */
    'ccEmail': string;
    /**
    * The code of the channel partner
    */
    'channelPartnerCode': string;
    /**
    * The order ID assigned by the channel partner for this order
    */
    'channelPartnerOrderId': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Date/time that the order was created
    */
    'creationDateBegin': string;
    /**
    * Date/time that the order was created
    */
    'creationDateEnd': string;
    /**
    * Current stage that the order is in.
    */
    'currentStage': OrderQuery.CurrentStageEnum;
    /**
    * The customer profile to find associated orders for
    */
    'customerProfileOid': number;
    /**
    * Email
    */
    'email': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Item ID
    */
    'itemId': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * Order ID
    */
    'orderId': string;
    /**
    * Date/time that the order was successfully processed
    */
    'paymentDateBegin': string;
    /**
    * Date/time that the order was successfully processed
    */
    'paymentDateEnd': string;
    /**
    * Payment method
    */
    'paymentMethod': OrderQuery.PaymentMethodEnum;
    /**
    * Phone
    */
    'phone': string;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * Purchase order number
    */
    'purchaseOrderNumber': string;
    /**
    * Date/time that the order was refunded
    */
    'refundDateBegin': string;
    /**
    * Date/time that the order was refunded
    */
    'refundDateEnd': string;
    /**
    * RMA number
    */
    'rma': string;
    /**
    * Screen branding theme code associated with the order (legacy checkout)
    */
    'screenBrandingThemeCode': string;
    /**
    * Date/time that the order was shipping
    */
    'shipmentDateBegin': string;
    /**
    * Date/time that the order was shipped
    */
    'shipmentDateEnd': string;
    /**
    * State for United States otherwise region or province for other countries
    */
    'stateRegion': string;
    /**
    * StoreFront host name associated with the order
    */
    'storefrontHostName': string;
    /**
    * Total
    */
    'total': number;
}

export namespace OrderQuery {
    export enum CurrentStageEnum {
        AccountsReceivable = <any> 'Accounts Receivable',
        PendingClearance = <any> 'Pending Clearance',
        FraudReview = <any> 'Fraud Review',
        Rejected = <any> 'Rejected',
        ShippingDepartment = <any> 'Shipping Department',
        CompletedOrder = <any> 'Completed Order',
        QuoteRequest = <any> 'Quote Request',
        QuoteSent = <any> 'Quote Sent',
        LeastCostRouting = <any> 'Least Cost Routing',
        Unknown = <any> 'Unknown'
    }
    export enum PaymentMethodEnum {
        Affirm = <any> 'Affirm',
        Amazon = <any> 'Amazon',
        AmazonSC = <any> 'Amazon SC',
        Cash = <any> 'Cash',
        Check = <any> 'Check',
        COD = <any> 'COD',
        CreditCard = <any> 'Credit Card',
        ECheck = <any> 'eCheck',
        LoanHero = <any> 'LoanHero',
        MoneyOrder = <any> 'Money Order',
        PayPal = <any> 'PayPal',
        PurchaseOrder = <any> 'Purchase Order',
        QuoteRequest = <any> 'Quote Request',
        Unknown = <any> 'Unknown',
        WireTransfer = <any> 'Wire Transfer'
    }
}
export class OrderQueryBatch {
    /**
    * Order IDs
    */
    'orderIds': Array<string>;
}

export class OrderQuote {
    /**
    * Expiration of quote at date/time
    */
    'quoteExpirationDts': string;
    /**
    * Quoted by user
    */
    'quotedBy': string;
    /**
    * Quoted on date/time
    */
    'quotedDts': string;
}

export class OrderReplacement {
    /**
    * Additional merchant notes to append to the new order
    */
    'additionalMerchantNotesNewOrder': string;
    /**
    * Additional merchant notes to append to the original order
    */
    'additionalMerchantNotesOriginalOrder': string;
    /**
    * Custom field 1
    */
    'customField1': string;
    /**
    * Custom field 2
    */
    'customField2': string;
    /**
    * Custom field 3
    */
    'customField3': string;
    /**
    * Custom field 4
    */
    'customField4': string;
    /**
    * Custom field 5
    */
    'customField5': string;
    /**
    * Custom field 6
    */
    'customField6': string;
    /**
    * Custom field 7
    */
    'customField7': string;
    /**
    * Set to true if this replacement shipment should be free for the customer.
    */
    'free': boolean;
    /**
    * Set to true if you want to immediately charge the payment on this order, otherwise it will go to Accounts Receivable.
    */
    'immediateCharge': boolean;
    /**
    * Items to include in the replacement order
    */
    'items': Array<OrderReplacementItem>;
    /**
    * Original order id
    */
    'originalOrderId': string;
    /**
    * Shipping method to use.  If not specified or invalid then least cost shipping will take place.
    */
    'shippingMethod': string;
    /**
    * Set to true if you want to skip the payment as if it was successful.
    */
    'skipPayment': boolean;
}

export class OrderReplacementItem {
    /**
    * Cost to charge the customer if specified.  If not specified then the default item cost is used.
    */
    'arbitraryUnitCost': number;
    /**
    * Item ID
    */
    'merchantItemId': string;
    /**
    * Quantity
    */
    'quantity': number;
}

export class OrderReplacementResponse {
    'chargeSuccessful': boolean;
    'errorMessage': string;
    'feedback': string;
    'free': boolean;
    'orderId': string;
    'successful': boolean;
}

export class OrderResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    'order': Order;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class OrderSalesforce {
    /**
    * Salesforce.com opportunity id
    */
    'salesforceOpportunityId': string;
}

export class OrderShipping {
    /**
    * Address line 1
    */
    'address1': string;
    /**
    * Address line 2
    */
    'address2': string;
    /**
    * City
    */
    'city': string;
    /**
    * Company
    */
    'company': string;
    /**
    * ISO-3166 two letter country code
    */
    'countryCode': string;
    /**
    * Day time phone
    */
    'dayPhone': string;
    /**
    * Day time phone (E164 format)
    */
    'dayPhoneE164': string;
    /**
    * Date the customer is requesting delivery on.  Typically used for perishable product delivery.
    */
    'deliveryDate': string;
    /**
    * Evening phone
    */
    'eveningPhone': string;
    /**
    * First name
    */
    'firstName': string;
    /**
    * Last name
    */
    'lastName': string;
    /**
    * If true, instructs UltraCart to apply the cheapest shipping method to this order.  Used only for channel partner order inserts.
    */
    'leastCostRoute': boolean;
    /**
    * List of shipping methods to consider if least_code_route is true. Used only for channel parter order inserts.
    */
    'leastCostRouteShippingMethods': Array<string>;
    /**
    * Lift gate requested (LTL shipping methods only)
    */
    'liftGate': boolean;
    /**
    * Postal code
    */
    'postalCode': string;
    /**
    * RMA number
    */
    'rma': string;
    /**
    * Date the customer is requesting that the order ship on.  Typically used for perishable product delivery.
    */
    'shipOnDate': string;
    /**
    * True if the shipping address is residential.  Effects the methods that are available to the customer as well as the price of the shipping method.
    */
    'shipToResidential': boolean;
    /**
    * Shipping 3rd party account number
    */
    'shipping3rdPartyAccountNumber': string;
    /**
    * Date/time the order shipped on.  This date is set once the first shipment is sent to the customer.
    */
    'shippingDate': string;
    /**
    * Shipping department status
    */
    'shippingDepartmentStatus': string;
    /**
    * Shipping method
    */
    'shippingMethod': string;
    /**
    * Shipping method accounting code
    */
    'shippingMethodAccountingCode': string;
    /**
    * Special instructions from the customer regarding shipping
    */
    'specialInstructions': string;
    /**
    * State
    */
    'stateRegion': string;
    /**
    * Title
    */
    'title': string;
    /**
    * Tracking numbers
    */
    'trackingNumbers': Array<string>;
    'weight': Weight;
}

export class OrderSummary {
    'arbitraryShippingHandlingTotal': Currency;
    'otherRefunded': Currency;
    'shippingHandlingRefunded': Currency;
    'shippingHandlingTotal': Currency;
    'shippingHandlingTotalDiscount': Currency;
    'subtotal': Currency;
    'subtotalDiscount': Currency;
    'subtotalDiscountRefunded': Currency;
    'subtotalRefunded': Currency;
    'tax': Currency;
    'taxRefunded': Currency;
    'taxableSubtotal': Currency;
    'taxableSubtotalDiscount': Currency;
    'total': Currency;
    'totalRefunded': Currency;
}

export class OrderTaxes {
    /**
    * Arbitrary Tax, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
    */
    'arbitraryTax': number;
    /**
    * Arbitrary tax rate, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
    */
    'arbitraryTaxRate': number;
    /**
    * Arbitrary taxable subtotal, this is meaningless for updating an order.  For inserting a new order, this will override any internal tax calculations and should only be used for orders completed outside the system.
    */
    'arbitraryTaxableSubtotal': number;
    /**
    * QuickBooks tax city code
    */
    'taxCityAccountingCode': string;
    /**
    * QuickBooks tax country code
    */
    'taxCountryAccountingCode': string;
    /**
    * County used for tax calculation purposes (only in the United States)
    */
    'taxCounty': string;
    /**
    * QuickBooks tax county code
    */
    'taxCountyAccountingCode': string;
    /**
    * True if gift charge is taxed
    */
    'taxGiftCharge': boolean;
    /**
    * QuickBooks tax postal code code
    */
    'taxPostalCodeAccountingCode': string;
    /**
    * Tax rate, this is meaningless for updating an order.  For inserting a new order, if you need to override internal tax calculations, use the arbitrary fields.
    */
    'taxRate': number;
    /**
    * Tax rate at the city level
    */
    'taxRateCity': number;
    /**
    * Tax rate at the country level
    */
    'taxRateCountry': number;
    /**
    * Tax rate at the county level
    */
    'taxRateCounty': number;
    /**
    * Tax rate at the postal code level
    */
    'taxRatePostalCode': number;
    /**
    * Tax rate at the state level
    */
    'taxRateState': number;
    /**
    * True if shipping is taxed
    */
    'taxShipping': boolean;
    /**
    * QuickBooks tax state code
    */
    'taxStateAccountingCode': string;
}

export class OrdersResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * orders
    */
    'orders': Array<Order>;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class PricingTier {
    /**
    * Allow 3rd party billing
    */
    'allow3rdPartyBilling': boolean;
    /**
    * Allow COD
    */
    'allowCod': boolean;
    /**
    * Allow purchase order
    */
    'allowPurchaseOrder': boolean;
    /**
    * Allow quote request
    */
    'allowQuoteRequest': boolean;
    'approvalNotification': PricingTierNotification;
    /**
    * Auto approve COD
    */
    'autoApproveCod': boolean;
    /**
    * Auto approve purchase order
    */
    'autoApprovePurchaseOrder': boolean;
    /**
    * Default on wholesale signup
    */
    'defaultOnWholesaleSignup': boolean;
    /**
    * Default percentage discount
    */
    'defaultPercentageDiscount': number;
    /**
    * Default shipping method oid
    */
    'defaultShippingMethodOid': number;
    /**
    * Default tier
    */
    'defaultTier': boolean;
    /**
    * Display on wholesale signup
    */
    'displayOnWholesaleSignup': boolean;
    /**
    * Exclude from free promotion
    */
    'excludeFromFreePromotion': boolean;
    /**
    * Exempt shipping handling charge
    */
    'exemptShippingHandlingCharge': boolean;
    /**
    * Free shipping
    */
    'freeShipping': boolean;
    /**
    * Free shipping minimum
    */
    'freeShippingMinimum': number;
    /**
    * Maximum item count
    */
    'maximumItemCount': number;
    /**
    * Minimum item count
    */
    'minimumItemCount': number;
    /**
    * Minimum subtotal
    */
    'minimumSubtotal': number;
    /**
    * Name
    */
    'name': string;
    /**
    * No coupons
    */
    'noCoupons': boolean;
    /**
    * No free shipping
    */
    'noFreeShipping': boolean;
    /**
    * No realtime charge
    */
    'noRealtimeCharge': boolean;
    /**
    * Not valid when coupon present
    */
    'notValidWhenCouponPresent': boolean;
    /**
    * Pricing Tier Oid
    */
    'pricingTierOid': number;
    /**
    * Realtime percentage discount
    */
    'realtimePercentageDiscount': number;
    'signupNotification': PricingTierNotification;
    /**
    * Suppress buySAFE
    */
    'suppressBuysafe': boolean;
    /**
    * Suppress mailing list
    */
    'suppressMailingList': boolean;
    /**
    * Tax Exempt
    */
    'taxExempt': boolean;
    /**
    * Track separately
    */
    'trackSeparately': boolean;
}

export class PricingTierNotification {
    /**
    * Notification format
    */
    'format': string;
    /**
    * Notification subject
    */
    'subject': string;
    /**
    * Notification text
    */
    'text': string;
}

export class PricingTiersResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * pricing_tiers
    */
    'pricingTiers': Array<PricingTier>;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
}

export class Property {
    'name': string;
    'value': string;
}

export class ResponseMetadata {
    /**
    * Payload name
    */
    'payloadName': string;
    'resultSet': ResultSet;
}

export class ResultSet {
    /**
    * Number of results in this set
    */
    'count': number;
    /**
    * Maximum number of results that can be returned in a set
    */
    'limit': number;
    /**
    * True if there are more results to query
    */
    'more': boolean;
    /**
    * The next offset that you should query to retrieve more results
    */
    'nextOffset': number;
    /**
    * Offset of this result set (zero based)
    */
    'offset': number;
    /**
    * The total number of records in the result set.  May be null if the number is not known and the client should continue iterating as long as more is true.
    */
    'totalRecords': number;
}

export class SelfConfig {
    /**
    * True if sales tax should be collected based on billing address instead of shipping address
    */
    'taxBilling': boolean;
}

export class StateProvince {
    /**
    * abbreviation
    */
    'abbreviation': string;
    /**
    * name
    */
    'name': string;
}

export class StepWaiting {
    'commseqStepUuid': string;
    'numberWaiting': number;
}

export class TaxCity {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode': string;
    /**
    * City
    */
    'city': string;
    /**
    * Tax record object identifier used internally by database
    */
    'cityOid': number;
    /**
    * Tax record object identifier used internally by database
    */
    'countyOid': number;
    /**
    * Flag instructing engine to not collect city tax for this city
    */
    'dontCollectCity': boolean;
    /**
    * Flag instructing engine to not collect postal code tax for this city
    */
    'dontCollectPostalCode': boolean;
    /**
    * Postal Codes within this city
    */
    'postalCodes': Array<TaxPostalCode>;
    /**
    * Tax Rate
    */
    'taxRate': number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted': string;
}

export class TaxCountry {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode': string;
    /**
    * Country code (2 characters
    */
    'countryCode': string;
    /**
    * Tax record object identifier used internally by database
    */
    'countryOid': number;
    /**
    * States (or regions or territories) within this country
    */
    'states': Array<TaxState>;
    /**
    * True if taxation within this jurisdiction should charge tax on gift charge
    */
    'taxGiftCharge': boolean;
    /**
    * True if taxation within this jurisdiction should charge tax on gift wrap
    */
    'taxGiftWrap': boolean;
    /**
    * Tax Rate
    */
    'taxRate': number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted': string;
    /**
    * True if taxation within this jurisdiction should charge tax on shipping
    */
    'taxShipping': boolean;
}

export class TaxCountryCode {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode': string;
    /**
    * Country code (2 characters
    */
    'countryCode': string;
    /**
    * Country name
    */
    'countryName': string;
    /**
    * Tax Rate
    */
    'taxRate': number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted': string;
}

export class TaxCounty {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode': string;
    /**
    * Cities within this city
    */
    'cities': Array<TaxCity>;
    /**
    * County
    */
    'county': string;
    /**
    * Tax record object identifier used internally by database
    */
    'countyOid': number;
    /**
    * Flag instructing engine to not collect city tax for this county
    */
    'dontCollectCity': boolean;
    /**
    * Flag instructing engine to not collect county tax for this county
    */
    'dontCollectCounty': boolean;
    /**
    * Flag instructing engine to not collect postal code tax for this county
    */
    'dontCollectPostalCode': boolean;
    /**
    * Tax record object identifier used internally by database
    */
    'stateOid': number;
    /**
    * Tax Rate
    */
    'taxRate': number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted': string;
}

export class TaxJarConfig {
    /**
    * True if TaxJar is active for this merchant
    */
    'active': boolean;
    /**
    * TaxJar API key
    */
    'apiKey': string;
    /**
    * True if this TaxJar configuration is to estimate taxes only and not report placed orders to TaxJar
    */
    'estimateOnly': boolean;
    /**
    * Send test orders through to TaxJar.  The default is to not transmit test orders to TaxJar.
    */
    'sendTestOrders': boolean;
    /**
    * Use distribution center from address
    */
    'useDistributionCenterFrom': boolean;
}

export class TaxPostalCode {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode': string;
    /**
    * Tax record object identifier used internally by database
    */
    'cityOid': number;
    /**
    * Flag instructing engine to not collect postal code tax for this postal code
    */
    'dontCollectPostalCode': boolean;
    /**
    * Postal Code (5 digits)
    */
    'postalCode': string;
    /**
    * Tax record object identifier used internally by database
    */
    'postalCodeOid': number;
    /**
    * Tax Rate
    */
    'taxRate': number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted': string;
}

export class TaxProviderActivateResult {
    'details': string;
    /**
    * True if the connection was successful
    */
    'success': boolean;
}

export class TaxProviderAvalara {
    'configuration': AvalaraConfig;
    /**
    * Description
    */
    'description': string;
    /**
    * Selected
    */
    'selected': boolean;
    /**
    * Title
    */
    'title': string;
}

export class TaxProviderAvalaraCompaniesResult {
    /**
    * Tax companies configured by the merchant
    */
    'companies': Array<TaxProviderAvalaraCompany>;
}

export class TaxProviderAvalaraCompany {
    /**
    * Company code
    */
    'companyCode': string;
    /**
    * Company name
    */
    'companyName': string;
    /**
    * Description
    */
    'description': string;
    /**
    * Selected
    */
    'selected': boolean;
    /**
    * Title
    */
    'title': string;
}

export class TaxProviderSelf {
    'configuration': SelfConfig;
    /**
    * Countries that collect sales tax
    */
    'countries': Array<TaxCountry>;
    /**
    * Description
    */
    'description': string;
    /**
    * Selected
    */
    'selected': boolean;
    /**
    * Title
    */
    'title': string;
}

export class TaxProviderSelfCountriesResponse {
    /**
    * countries
    */
    'countries': Array<TaxCountryCode>;
}

export class TaxProviderSelfRegionsResponse {
    /**
    * regions
    */
    'regions': Array<TaxStateCode>;
}

export class TaxProviderTaxJar {
    'configuration': TaxJarConfig;
    /**
    * Description
    */
    'description': string;
    /**
    * Selected
    */
    'selected': boolean;
    /**
    * Title
    */
    'title': string;
}

export class TaxProviderTestResult {
    'details': string;
    /**
    * True if the connection was successful
    */
    'success': boolean;
}

export class TaxProviderUltraCart {
    'configuration': UltraCartConfig;
    /**
    * Description
    */
    'description': string;
    /**
    * Selected
    */
    'selected': boolean;
    /**
    * States in the union showing their management status
    */
    'states': Array<TaxProviderUltraCartState>;
    /**
    * Title
    */
    'title': string;
}

export class TaxProviderUltraCartState {
    /**
    * True if this state taxes are managed by UltraCart
    */
    'enabled': boolean;
    /**
    * State Code (2 digits)
    */
    'stateCode': string;
    /**
    * Fully spelled out state name
    */
    'stateName': string;
    /**
    * True if gift charges should be taxed in this state.
    */
    'taxGiftCharge': boolean;
    /**
    * True if gift wrap should be taxed in this state.
    */
    'taxGiftWrap': boolean;
    /**
    * State tax rate formatted for display
    */
    'taxRateFormatted': string;
    /**
    * True if shipping should be taxed in this state.
    */
    'taxShipping': boolean;
}

export class TaxProvidersResponse {
    'avalara': TaxProviderAvalara;
    'error': Error;
    'metadata': ResponseMetadata;
    'self': TaxProviderSelf;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'taxjar': TaxProviderTaxJar;
    'ultracart': TaxProviderUltraCart;
}

export class TaxState {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode': string;
    /**
    * Counties within this state
    */
    'counties': Array<TaxCounty>;
    /**
    * Tax record object identifier used internally by database
    */
    'countryOid': number;
    /**
    * Flag instructing engine to not collect city tax for this state
    */
    'dontCollectCity': boolean;
    /**
    * Flag instructing engine to not collect county tax for this state
    */
    'dontCollectCounty': boolean;
    /**
    * Flag instructing engine to not collect postal code tax for this state
    */
    'dontCollectPostalCode': boolean;
    /**
    * Flag instructing engine to not collect state tax for this state
    */
    'dontCollectState': boolean;
    /**
    * State code
    */
    'stateCode': string;
    /**
    * Tax record object identifier used internally by database
    */
    'stateOid': number;
    /**
    * True if taxation within this jurisdiction should charge tax on gift charge
    */
    'taxGiftCharge': boolean;
    /**
    * True if taxation within this jurisdiction should charge tax on gift wrap
    */
    'taxGiftWrap': boolean;
    /**
    * Tax Rate
    */
    'taxRate': number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted': string;
    /**
    * True if taxation within this jurisdiction should charge tax on shipping
    */
    'taxShipping': boolean;
    /**
    * If true, use UltraCart managed rates for this state
    */
    'useUltracartManagedRates': boolean;
}

export class TaxStateCode {
    /**
    * Accounting code for programs such as QuickBooks
    */
    'accountingCode': string;
    /**
    * State code (2 characters
    */
    'stateCode': string;
    /**
    * State name
    */
    'stateName': string;
    /**
    * Tax Rate
    */
    'taxRate': number;
    /**
    * Tax rate formatted
    */
    'taxRateFormatted': string;
}

export class TempMultimedia {
    /**
    * Filename
    */
    'filename': string;
    /**
    * Height
    */
    'height': number;
    /**
    * Multimedia type
    */
    'multimediaType': TempMultimedia.MultimediaTypeEnum;
    /**
    * Size
    */
    'size': number;
    /**
    * Temporary multimedia object identifier
    */
    'tempMultimediaOid': number;
    /**
    * URL
    */
    'url': string;
    /**
    * Width
    */
    'width': number;
}

export namespace TempMultimedia {
    export enum MultimediaTypeEnum {
        Image = <any> 'Image',
        PDF = <any> 'PDF',
        Text = <any> 'Text',
        Video = <any> 'Video'
    }
}
export class TempMultimediaResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'tempMultimedia': TempMultimedia;
}

export class UltraCartConfig {
    /**
    * True if sales tax should be collected based on billing address instead of shipping address
    */
    'taxBilling': boolean;
}

export class VerificationRecord {
    'name': string;
    'type': string;
    'value': string;
}

export class Webhook {
    /**
    * Populated if webhook associated with an API user
    */
    'apiUserOid': number;
    /**
    * Version of the API objects that are sent in notifications
    */
    'apiVersion': Webhook.ApiVersionEnum;
    'applicationProfile': ApiUserApplicationProfile;
    /**
    * The type of authentication this webhook will use when communicating with your server
    */
    'authenticationType': Webhook.AuthenticationTypeEnum;
    /**
    * Basic authentication password
    */
    'basicPassword': string;
    /**
    * Basic authentication user name
    */
    'basicUsername': string;
    /**
    * The number of consecutive failures that have occurred trying to deliver notifications to the target server
    */
    'consecutiveFailures': number;
    /**
    * True if the webhook has been disabled
    */
    'disabled': boolean;
    /**
    * The categories of events.  Individual events and subscriptions are handled in the child objects.  _placeholders parameter effects the population of this on a retrieval.
    */
    'eventCategories': Array<WebhookEventCategory>;
    /**
    * The maximum number of events in the payload that UltraCart will deliver
    */
    'maximumEvents': number;
    /**
    * The maximum size of the payload that UltraCart will deliver
    */
    'maximumSize': number;
    /**
    * The UltraCart merchant ID that owns this webhook
    */
    'merchantId': string;
    /**
    * The next time UltraCart will attempt delivery if failures have been occurring
    */
    'nextRetryAfter': string;
    /**
    * The number of pending events for this webhook
    */
    'pending': number;
    /**
    * The object identifier for this webhook
    */
    'webhookOid': number;
    /**
    * The URL to deliver events to.  Must be HTTPS for customer related information.
    */
    'webhookUrl': string;
}

export namespace Webhook {
    export enum ApiVersionEnum {
        _01 = <any> '2017-03-01'
    }
    export enum AuthenticationTypeEnum {
        None = <any> 'none',
        Basic = <any> 'basic'
    }
}
export class WebhookEventCategory {
    /**
    * Name of the event category
    */
    'eventCategory': string;
    /**
    * The events within the category.  Individual subscription flags contained within the child object.
    */
    'events': Array<WebhookEventSubscription>;
    /**
    * True if all the events within this category are subscribed.  This is a convenience flag to make user interfaces easier.
    */
    'subscribed': boolean;
}

export class WebhookEventSubscription {
    /**
    * Comment about the event to provide further clarification to the end user
    */
    'comments': string;
    /**
    * True if the event is deprecated.  See the API change log for details on when it will be discontinued.
    */
    'deprecatedFlag': boolean;
    /**
    * True if the event is discontinued.  See the API change log for details on migration details.
    */
    'discontinuedFlag': boolean;
    /**
    * Description of the event
    */
    'eventDescription': string;
    /**
    * Event name
    */
    'eventName': string;
    /**
    * The expand string for the notification object.  See the individual resource _expand documentation for valid values.
    */
    'expansion': string;
    /**
    * True if this is event is subscribed to
    */
    'subscribed': boolean;
    /**
    * True if the event can be triggered to reflow existing records
    */
    'supportsReflow': boolean;
    /**
    * The webhook event object identifier
    */
    'webhookEventOid': number;
}

export class WebhookLog {
    /**
    * Date/time of delivery
    */
    'deliveryDts': string;
    /**
    * Number of milliseconds to process the notification
    */
    'duration': number;
    /**
    * Request payload (first 100,000 characters)
    */
    'request': string;
    /**
    * Request headers sent to the server
    */
    'requestHeaders': Array<HTTPHeader>;
    /**
    * Request id is a unique string that you can look up in the logs
    */
    'requestId': string;
    /**
    * Response payload (first 100,000 characters)
    */
    'response': string;
    /**
    * Response headers received from the server
    */
    'responseHeaders': Array<HTTPHeader>;
    /**
    * HTTP status code received from the server
    */
    'statusCode': number;
    /**
    * True if the delivery was successful
    */
    'success': boolean;
    /**
    * URI of the webhook delivered to
    */
    'uri': string;
}

export class WebhookLogResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhookLog': WebhookLog;
}

export class WebhookLogSummariesResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    /**
    * Webhook log summaries
    */
    'webhookLogSummaries': Array<WebhookLogSummary>;
}

export class WebhookLogSummary {
    /**
    * Date/time of the delivery
    */
    'deliveryDts': string;
    /**
    * Request id
    */
    'requestId': string;
    /**
    * True if the notification was successful
    */
    'success': boolean;
}

export class WebhookResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhook': Webhook;
}

export class WebhookSampleRequest {
    /**
    * Request
    */
    'request': string;
    /**
    * Request headers
    */
    'requestHeaders': Array<HTTPHeader>;
    /**
    * Request id
    */
    'requestId': string;
    /**
    * URI to send request to
    */
    'uri': string;
}

export class WebhookSampleRequestResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhookSampleRequest': WebhookSampleRequest;
}

export class WebhooksResponse {
    'error': Error;
    'metadata': ResponseMetadata;
    /**
    * Indicates if API call was successful
    */
    'success': boolean;
    'webhooks': Array<Webhook>;
}

export class Weight {
    /**
    * Unit of measure
    */
    'uom': Weight.UomEnum;
    /**
    * Weight
    */
    'value': number;
}

export namespace Weight {
    export enum UomEnum {
        KG = <any> 'KG',
        LB = <any> 'LB',
        OZ = <any> 'OZ'
    }
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum AffiliateApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class AffiliateApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AffiliateApiApiKeys, value: string) {
        this.authentications[AffiliateApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve clicks
     * Retrieves a group of clicks from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the clicks returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param clickQuery Click query
     * @param limit The maximum number of records to return on this one API call. (Maximum 10000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param expand The object expansion to perform on the result.  Only option is link.
     */
    public getClicksByQuery (clickQuery: AffiliateClickQuery, limit?: number, offset?: number, expand?: string) : Promise<{ response: http.ClientResponse; body: AffiliateClicksResponse;  }> {
        const localVarPath = this.basePath + '/affiliate/clicks/query';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clickQuery' is not null or undefined
        if (clickQuery === null || clickQuery === undefined) {
            throw new Error('Required parameter clickQuery was null or undefined when calling getClicksByQuery.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: clickQuery,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AffiliateClicksResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve ledger entries
     * Retrieves a group of ledger entries from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the ledgers returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param ledgerQuery Ledger query
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param expand The object expansion to perform on the result.  Only option is link.
     */
    public getLedgersByQuery (ledgerQuery: AffiliateLedgerQuery, limit?: number, offset?: number, expand?: string) : Promise<{ response: http.ClientResponse; body: AffiliateLedgersResponse;  }> {
        const localVarPath = this.basePath + '/affiliate/ledgers/query';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'ledgerQuery' is not null or undefined
        if (ledgerQuery === null || ledgerQuery === undefined) {
            throw new Error('Required parameter ledgerQuery was null or undefined when calling getLedgersByQuery.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ledgerQuery,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AffiliateLedgersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AutoorderApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class AutoorderApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AutoorderApiApiKeys, value: string) {
        this.authentications[AutoorderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve an auto order
     * Retrieves a single auto order using the specified auto order oid. 
     * @param autoOrderOid The auto order oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getAutoOrder (autoOrderOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/{auto_order_oid}'
            .replace('{' + 'auto_order_oid' + '}', String(autoOrderOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'autoOrderOid' is not null or undefined
        if (autoOrderOid === null || autoOrderOid === undefined) {
            throw new Error('Required parameter autoOrderOid was null or undefined when calling getAutoOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an auto order
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @param autoOrderCode The auto order oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getAutoOrderByCode (autoOrderCode: string, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/code/{auto_order_code}'
            .replace('{' + 'auto_order_code' + '}', String(autoOrderCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'autoOrderCode' is not null or undefined
        if (autoOrderCode === null || autoOrderCode === undefined) {
            throw new Error('Required parameter autoOrderCode was null or undefined when calling getAutoOrderByCode.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an auto order
     * Retrieves a single auto order using the specified reference (original) order id. 
     * @param referenceOrderId The auto order oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getAutoOrderByReferenceOrderId (referenceOrderId: string, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/reference_order_id/{reference_order_id}'
            .replace('{' + 'reference_order_id' + '}', String(referenceOrderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'referenceOrderId' is not null or undefined
        if (referenceOrderId === null || referenceOrderId === undefined) {
            throw new Error('Required parameter referenceOrderId was null or undefined when calling getAutoOrderByReferenceOrderId.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve auto orders
     * Retrieves auto orders from the account.  If no parameters are specified, all auto orders will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param autoOrderCode Auto order code
     * @param originalOrderId Original order id
     * @param firstName First name
     * @param lastName Last name
     * @param company Company
     * @param city City
     * @param state State
     * @param postalCode Postal code
     * @param countryCode Country code (ISO-3166 two letter)
     * @param phone Phone
     * @param email Email
     * @param originalOrderDateBegin Original order date begin
     * @param originalOrderDateEnd Original order date end
     * @param nextShipmentDateBegin Next shipment date begin
     * @param nextShipmentDateEnd Next shipment date end
     * @param cardType Card type
     * @param itemId Item ID
     * @param status Status
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch auto orders that have been created/modified since this date/time.
     * @param sort The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getAutoOrders (autoOrderCode?: string, originalOrderId?: string, firstName?: string, lastName?: string, company?: string, city?: string, state?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, originalOrderDateBegin?: string, originalOrderDateEnd?: string, nextShipmentDateBegin?: string, nextShipmentDateEnd?: string, cardType?: string, itemId?: string, status?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (autoOrderCode !== undefined) {
            queryParameters['auto_order_code'] = autoOrderCode;
        }

        if (originalOrderId !== undefined) {
            queryParameters['original_order_id'] = originalOrderId;
        }

        if (firstName !== undefined) {
            queryParameters['first_name'] = firstName;
        }

        if (lastName !== undefined) {
            queryParameters['last_name'] = lastName;
        }

        if (company !== undefined) {
            queryParameters['company'] = company;
        }

        if (city !== undefined) {
            queryParameters['city'] = city;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (postalCode !== undefined) {
            queryParameters['postal_code'] = postalCode;
        }

        if (countryCode !== undefined) {
            queryParameters['country_code'] = countryCode;
        }

        if (phone !== undefined) {
            queryParameters['phone'] = phone;
        }

        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (originalOrderDateBegin !== undefined) {
            queryParameters['original_order_date_begin'] = originalOrderDateBegin;
        }

        if (originalOrderDateEnd !== undefined) {
            queryParameters['original_order_date_end'] = originalOrderDateEnd;
        }

        if (nextShipmentDateBegin !== undefined) {
            queryParameters['next_shipment_date_begin'] = nextShipmentDateBegin;
        }

        if (nextShipmentDateEnd !== undefined) {
            queryParameters['next_shipment_date_end'] = nextShipmentDateEnd;
        }

        if (cardType !== undefined) {
            queryParameters['card_type'] = cardType;
        }

        if (itemId !== undefined) {
            queryParameters['item_id'] = itemId;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve auto orders
     * Retrieves a group of auto orders from the account based on a query object.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param autoOrderQuery Auto order query
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the auto orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.
     */
    public getAutoOrdersByQuery (autoOrderQuery: AutoOrderQuery, limit?: number, offset?: number, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/query';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'autoOrderQuery' is not null or undefined
        if (autoOrderQuery === null || autoOrderQuery === undefined) {
            throw new Error('Required parameter autoOrderQuery was null or undefined when calling getAutoOrdersByQuery.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: autoOrderQuery,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an auto order
     * Update an auto order on the UltraCart account. 
     * @param autoOrder Auto order to update
     * @param autoOrderOid The auto order oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateAutoOrder (autoOrder: AutoOrder, autoOrderOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }> {
        const localVarPath = this.basePath + '/auto_order/auto_orders/{auto_order_oid}'
            .replace('{' + 'auto_order_oid' + '}', String(autoOrderOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'autoOrder' is not null or undefined
        if (autoOrder === null || autoOrder === undefined) {
            throw new Error('Required parameter autoOrder was null or undefined when calling updateAutoOrder.');
        }

        // verify required parameter 'autoOrderOid' is not null or undefined
        if (autoOrderOid === null || autoOrderOid === undefined) {
            throw new Error('Required parameter autoOrderOid was null or undefined when calling updateAutoOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: autoOrder,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AutoOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChargebackApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class ChargebackApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ChargebackApiApiKeys, value: string) {
        this.authentications[ChargebackApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a chargeback
     * Delete a chargeback on the UltraCart account. 
     * @param chargebackDisputeOid The chargeback_dispute_oid to delete.
     */
    public deleteChargeback (chargebackDisputeOid: number) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', String(chargebackDisputeOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling deleteChargeback.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a chargeback
     * Retrieves a single chargeback using the specified chargeback dispute oid. 
     * @param chargebackDisputeOid The chargeback dispute oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getChargebackDispute (chargebackDisputeOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', String(chargebackDisputeOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling getChargebackDispute.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve chargebacks
     * Retrieves chargebacks from the account.  If no parameters are specified, all chargebacks will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param orderId Order Id
     * @param caseNumber Case number
     * @param status Status
     * @param expirationDtsStart Expiration dts start
     * @param expirationDtsEnd Expiration dts end
     * @param chargebackDtsStart Chargeback dts start
     * @param chargebackDtsEnd Chargeback dts end
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch chargebacks that have been created/modified since this date/time.
     * @param sort The sort order of the chargebacks.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getChargebackDisputes (orderId?: string, caseNumber?: string, status?: string, expirationDtsStart?: string, expirationDtsEnd?: string, chargebackDtsStart?: string, chargebackDtsEnd?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputesResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (orderId !== undefined) {
            queryParameters['order_id'] = orderId;
        }

        if (caseNumber !== undefined) {
            queryParameters['case_number'] = caseNumber;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (expirationDtsStart !== undefined) {
            queryParameters['expiration_dts_start'] = expirationDtsStart;
        }

        if (expirationDtsEnd !== undefined) {
            queryParameters['expiration_dts_end'] = expirationDtsEnd;
        }

        if (chargebackDtsStart !== undefined) {
            queryParameters['chargeback_dts_start'] = chargebackDtsStart;
        }

        if (chargebackDtsEnd !== undefined) {
            queryParameters['chargeback_dts_end'] = chargebackDtsEnd;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a chargeback
     * Insert a chargeback on the UltraCart account. 
     * @param chargeback Chargeback to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public insertChargeback (chargeback: ChargebackDispute, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargeback' is not null or undefined
        if (chargeback === null || chargeback === undefined) {
            throw new Error('Required parameter chargeback was null or undefined when calling insertChargeback.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: chargeback,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a chargeback
     * Update a chargeback on the UltraCart account. 
     * @param chargeback Chargeback to update
     * @param chargebackDisputeOid The chargeback_dispute_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateChargeback (chargeback: ChargebackDispute, chargebackDisputeOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }> {
        const localVarPath = this.basePath + '/chargeback/chargebacks/{chargeback_dispute_oid}'
            .replace('{' + 'chargeback_dispute_oid' + '}', String(chargebackDisputeOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'chargeback' is not null or undefined
        if (chargeback === null || chargeback === undefined) {
            throw new Error('Required parameter chargeback was null or undefined when calling updateChargeback.');
        }

        // verify required parameter 'chargebackDisputeOid' is not null or undefined
        if (chargebackDisputeOid === null || chargebackDisputeOid === undefined) {
            throw new Error('Required parameter chargebackDisputeOid was null or undefined when calling updateChargeback.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: chargeback,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ChargebackDisputeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CheckoutApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CheckoutApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CheckoutApiApiKeys, value: string) {
        this.authentications[CheckoutApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * City/State for Zip
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @param cart Cart
     */
    public cityState (cart: Cart) : Promise<{ response: http.ClientResponse; body: CityStateZip;  }> {
        const localVarPath = this.basePath + '/checkout/city_state';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling cityState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CityStateZip;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Finalize Order
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @param finalizeRequest Finalize request
     */
    public finalizeOrder (finalizeRequest: CartFinalizeOrderRequest) : Promise<{ response: http.ClientResponse; body: CartFinalizeOrderResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/finalizeOrder';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'finalizeRequest' is not null or undefined
        if (finalizeRequest === null || finalizeRequest === undefined) {
            throw new Error('Required parameter finalizeRequest was null or undefined when calling finalizeOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: finalizeRequest,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartFinalizeOrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get affirm checkout (by cart id)
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * @param cartId Cart ID to retrieve
     */
    public getAffirmCheckout (cartId: string) : Promise<{ response: http.ClientResponse; body: CartAffirmCheckoutResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/{cart_id}/affirmCheckout'
            .replace('{' + 'cart_id' + '}', String(cartId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cartId' is not null or undefined
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getAffirmCheckout.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartAffirmCheckoutResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Allowed countries
     * Lookup the allowed countries for this merchant id 
     */
    public getAllowedCountries () : Promise<{ response: http.ClientResponse; body: CheckoutAllowedCountriesResponse;  }> {
        const localVarPath = this.basePath + '/checkout/allowedCountries';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutAllowedCountriesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get cart
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCart (expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get cart (by cart id)
     * Get a cart specified by the cart_id parameter. 
     * @param cartId Cart ID to retrieve
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCartByCartId (cartId: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/{cart_id}'
            .replace('{' + 'cart_id' + '}', String(cartId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cartId' is not null or undefined
        if (cartId === null || cartId === undefined) {
            throw new Error('Required parameter cartId was null or undefined when calling getCartByCartId.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get cart (by return code)
     * Get a cart specified by the return code parameter. 
     * @param returnCode Return code to lookup cart ID by
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCartByReturnCode (returnCode: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/return/{return_code}'
            .replace('{' + 'return_code' + '}', String(returnCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'returnCode' is not null or undefined
        if (returnCode === null || returnCode === undefined) {
            throw new Error('Required parameter returnCode was null or undefined when calling getCartByReturnCode.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get state/province list for a country code
     * Lookup a state/province list for a given country code 
     * @param countryCode Two letter ISO country code
     */
    public getStateProvincesForCountry (countryCode: string) : Promise<{ response: http.ClientResponse; body: CheckoutStateProvinceResponse;  }> {
        const localVarPath = this.basePath + '/checkout/stateProvincesForCountry/{country_code}'
            .replace('{' + 'country_code' + '}', String(countryCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling getStateProvincesForCountry.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutStateProvinceResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Handoff cart
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm or finalization of the order (including upsell processing). 
     * @param handoffRequest Handoff request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public handoffCart (handoffRequest: CheckoutHandoffRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CheckoutHandoffResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/handoff';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'handoffRequest' is not null or undefined
        if (handoffRequest === null || handoffRequest === undefined) {
            throw new Error('Required parameter handoffRequest was null or undefined when calling handoffCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: handoffRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutHandoffResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Profile login
     * Login in to the customer profile specified by cart.billing.email and password 
     * @param loginRequest Login request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public login (loginRequest: CartProfileLoginRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CartProfileLoginResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/login';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'loginRequest' is not null or undefined
        if (loginRequest === null || loginRequest === undefined) {
            throw new Error('Required parameter loginRequest was null or undefined when calling login.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: loginRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartProfileLoginResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Profile logout
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public logout (cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/logout';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling logout.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Profile registration
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @param registerRequest Register request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public register (registerRequest: CartProfileRegisterRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CartProfileRegisterResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/profile/register';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'registerRequest' is not null or undefined
        if (registerRequest === null || registerRequest === undefined) {
            throw new Error('Required parameter registerRequest was null or undefined when calling register.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: registerRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartProfileRegisterResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Related items
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See item resource documentation for examples
     */
    public relatedItemsForCart (cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/checkout/related_items';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling relatedItemsForCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Related items (specific item)
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @param itemId Item ID to retrieve related items for
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See item resource documentation for examples
     */
    public relatedItemsForItem (itemId: string, cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/checkout/relatedItems/{item_id}'
            .replace('{' + 'item_id' + '}', String(itemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling relatedItemsForItem.');
        }

        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling relatedItemsForItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Setup Browser Application
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth applicaiton, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @param browserKeyRequest Setup browser key request
     */
    public setupBrowserKey (browserKeyRequest: CheckoutSetupBrowserKeyRequest) : Promise<{ response: http.ClientResponse; body: CheckoutSetupBrowserKeyResponse;  }> {
        const localVarPath = this.basePath + '/checkout/browser_key';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'browserKeyRequest' is not null or undefined
        if (browserKeyRequest === null || browserKeyRequest === undefined) {
            throw new Error('Required parameter browserKeyRequest was null or undefined when calling setupBrowserKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: browserKeyRequest,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CheckoutSetupBrowserKeyResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update cart
     * Update the cart. 
     * @param cart Cart
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateCart (cart: Cart, expand?: string) : Promise<{ response: http.ClientResponse; body: CartResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cart' is not null or undefined
        if (cart === null || cart === undefined) {
            throw new Error('Required parameter cart was null or undefined when calling updateCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: cart,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Validate
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @param validationRequest Validation request
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public validateCart (validationRequest: CartValidationRequest, expand?: string) : Promise<{ response: http.ClientResponse; body: CartValidationResponse;  }> {
        const localVarPath = this.basePath + '/checkout/cart/validate';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'validationRequest' is not null or undefined
        if (validationRequest === null || validationRequest === undefined) {
            throw new Error('Required parameter validationRequest was null or undefined when calling validateCart.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: validationRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CartValidationResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CouponApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CouponApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CouponApiApiKeys, value: string) {
        this.authentications[CouponApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a coupon
     * Delete a coupon on the UltraCart account. 
     * @param couponOid The coupon_oid to delete.
     */
    public deleteCoupon (couponOid: number) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}'
            .replace('{' + 'coupon_oid' + '}', String(couponOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling deleteCoupon.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Generates one time codes for a coupon
     * Generate one time codes for a coupon 
     * @param couponOid The coupon oid to generate codes.
     * @param couponCodesRequest Coupon code generation parameters
     */
    public generateCouponCodes (couponOid: number, couponCodesRequest: CouponCodesRequest) : Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}/generate_codes'
            .replace('{' + 'coupon_oid' + '}', String(couponOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling generateCouponCodes.');
        }

        // verify required parameter 'couponCodesRequest' is not null or undefined
        if (couponCodesRequest === null || couponCodesRequest === undefined) {
            throw new Error('Required parameter couponCodesRequest was null or undefined when calling generateCouponCodes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: couponCodesRequest,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Generates one time codes by merchant code
     * Generate one time codes by merchant code 
     * @param merchantCode The merchant code to generate one time codes.
     * @param couponCodesRequest Coupon code generation parameters
     */
    public generateOneTimeCodesByMerchantCode (merchantCode: string, couponCodesRequest: CouponCodesRequest) : Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/merchant_code/{merchant_code}/generate_codes'
            .replace('{' + 'merchant_code' + '}', String(merchantCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'merchantCode' is not null or undefined
        if (merchantCode === null || merchantCode === undefined) {
            throw new Error('Required parameter merchantCode was null or undefined when calling generateOneTimeCodesByMerchantCode.');
        }

        // verify required parameter 'couponCodesRequest' is not null or undefined
        if (couponCodesRequest === null || couponCodesRequest === undefined) {
            throw new Error('Required parameter couponCodesRequest was null or undefined when calling generateOneTimeCodesByMerchantCode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: couponCodesRequest,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponCodesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a coupon
     * Retrieves a single coupon using the specified coupon profile oid. 
     * @param couponOid The coupon oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCoupon (couponOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}'
            .replace('{' + 'coupon_oid' + '}', String(couponOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling getCoupon.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a coupon by merchant code
     * Retrieves a single coupon using the specified merchant code. 
     * @param merchantCode The coupon merchant code to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCouponByMerchantCode (merchantCode: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/merchant_code/{merchant_code}'
            .replace('{' + 'merchant_code' + '}', String(merchantCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'merchantCode' is not null or undefined
        if (merchantCode === null || merchantCode === undefined) {
            throw new Error('Required parameter merchantCode was null or undefined when calling getCouponByMerchantCode.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve coupons
     * Retrieves coupons for this account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param merchantCode Merchant code
     * @param description Description
     * @param couponType Coupon type
     * @param startDateBegin Start date begin
     * @param startDateEnd Start date end
     * @param expirationDateBegin Expiration date begin
     * @param expirationDateEnd Expiration date end
     * @param affiliateOid Affiliate oid
     * @param excludeExpired Exclude expired
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCoupons (merchantCode?: string, description?: string, couponType?: string, startDateBegin?: string, startDateEnd?: string, expirationDateBegin?: string, expirationDateEnd?: string, affiliateOid?: number, excludeExpired?: boolean, limit?: number, offset?: number, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CouponsResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (merchantCode !== undefined) {
            queryParameters['merchant_code'] = merchantCode;
        }

        if (description !== undefined) {
            queryParameters['description'] = description;
        }

        if (couponType !== undefined) {
            queryParameters['coupon_type'] = couponType;
        }

        if (startDateBegin !== undefined) {
            queryParameters['start_date_begin'] = startDateBegin;
        }

        if (startDateEnd !== undefined) {
            queryParameters['start_date_end'] = startDateEnd;
        }

        if (expirationDateBegin !== undefined) {
            queryParameters['expiration_date_begin'] = expirationDateBegin;
        }

        if (expirationDateEnd !== undefined) {
            queryParameters['expiration_date_end'] = expirationDateEnd;
        }

        if (affiliateOid !== undefined) {
            queryParameters['affiliate_oid'] = affiliateOid;
        }

        if (excludeExpired !== undefined) {
            queryParameters['exclude_expired'] = excludeExpired;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve coupons by query
     * Retrieves coupons from the account.  If no parameters are specified, all coupons will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param couponQuery Coupon query
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the coupons.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCouponsByQuery (couponQuery: CouponQuery, limit?: number, offset?: number, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CouponsResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/query';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'couponQuery' is not null or undefined
        if (couponQuery === null || couponQuery === undefined) {
            throw new Error('Required parameter couponQuery was null or undefined when calling getCouponsByQuery.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: couponQuery,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve values needed for a coupon editor
     * Retrieve values needed for a coupon editor 
     */
    public getEditorValues () : Promise<{ response: http.ClientResponse; body: CouponEditorValues;  }> {
        const localVarPath = this.basePath + '/coupon/editor_values';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponEditorValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a coupon
     * Insert a coupon on the UltraCart account. 
     * @param coupon Coupon to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public insertCoupon (coupon: Coupon, expand?: string) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling insertCoupon.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: coupon,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a coupon
     * Update a coupon on the UltraCart account. 
     * @param coupon Coupon to update
     * @param couponOid The coupon_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateCoupon (coupon: Coupon, couponOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: CouponResponse;  }> {
        const localVarPath = this.basePath + '/coupon/coupons/{coupon_oid}'
            .replace('{' + 'coupon_oid' + '}', String(couponOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling updateCoupon.');
        }

        // verify required parameter 'couponOid' is not null or undefined
        if (couponOid === null || couponOid === undefined) {
            throw new Error('Required parameter couponOid was null or undefined when calling updateCoupon.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: coupon,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CouponResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class CustomerApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CustomerApiApiKeys, value: string) {
        this.authentications[CustomerApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a customer
     * Delete a customer on the UltraCart account. 
     * @param customerProfileOid The customer_profile_oid to delete.
     */
    public deleteCustomer (customerProfileOid: number) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', String(customerProfileOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling deleteCustomer.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a customer
     * Retrieves a single customer using the specified customer profile oid. 
     * @param customerProfileOid The customer oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCustomer (customerProfileOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', String(customerProfileOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling getCustomer.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve customers
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param email Email
     * @param qbClass Quickbooks class
     * @param quickbooksCode Quickbooks code
     * @param lastModifiedDtsStart Last modified date start
     * @param lastModifiedDtsEnd Last modified date end
     * @param signupDtsStart Signup date start
     * @param signupDtsEnd Signup date end
     * @param billingFirstName Billing first name
     * @param billingLastName Billing last name
     * @param billingCompany Billing company
     * @param billingCity Billing city
     * @param billingState Billing state
     * @param billingPostalCode Billing postal code
     * @param billingCountryCode Billing country code
     * @param billingDayPhone Billing day phone
     * @param billingEveningPhone Billing evening phone
     * @param shippingFirstName Shipping first name
     * @param shippingLastName Shipping last name
     * @param shippingCompany Shipping company
     * @param shippingCity Shipping city
     * @param shippingState Shipping state
     * @param shippingPostalCode Shipping postal code
     * @param shippingCountryCode Shipping country code
     * @param shippingDayPhone Shipping day phone
     * @param shippingEveningPhone Shipping evening phone
     * @param pricingTierOid Pricing tier oid
     * @param pricingTierName Pricing tier name
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch customers that have been created/modified since this date/time.
     * @param sort The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCustomers (email?: string, qbClass?: string, quickbooksCode?: string, lastModifiedDtsStart?: string, lastModifiedDtsEnd?: string, signupDtsStart?: string, signupDtsEnd?: string, billingFirstName?: string, billingLastName?: string, billingCompany?: string, billingCity?: string, billingState?: string, billingPostalCode?: string, billingCountryCode?: string, billingDayPhone?: string, billingEveningPhone?: string, shippingFirstName?: string, shippingLastName?: string, shippingCompany?: string, shippingCity?: string, shippingState?: string, shippingPostalCode?: string, shippingCountryCode?: string, shippingDayPhone?: string, shippingEveningPhone?: string, pricingTierOid?: number, pricingTierName?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomersResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (qbClass !== undefined) {
            queryParameters['qb_class'] = qbClass;
        }

        if (quickbooksCode !== undefined) {
            queryParameters['quickbooks_code'] = quickbooksCode;
        }

        if (lastModifiedDtsStart !== undefined) {
            queryParameters['last_modified_dts_start'] = lastModifiedDtsStart;
        }

        if (lastModifiedDtsEnd !== undefined) {
            queryParameters['last_modified_dts_end'] = lastModifiedDtsEnd;
        }

        if (signupDtsStart !== undefined) {
            queryParameters['signup_dts_start'] = signupDtsStart;
        }

        if (signupDtsEnd !== undefined) {
            queryParameters['signup_dts_end'] = signupDtsEnd;
        }

        if (billingFirstName !== undefined) {
            queryParameters['billing_first_name'] = billingFirstName;
        }

        if (billingLastName !== undefined) {
            queryParameters['billing_last_name'] = billingLastName;
        }

        if (billingCompany !== undefined) {
            queryParameters['billing_company'] = billingCompany;
        }

        if (billingCity !== undefined) {
            queryParameters['billing_city'] = billingCity;
        }

        if (billingState !== undefined) {
            queryParameters['billing_state'] = billingState;
        }

        if (billingPostalCode !== undefined) {
            queryParameters['billing_postal_code'] = billingPostalCode;
        }

        if (billingCountryCode !== undefined) {
            queryParameters['billing_country_code'] = billingCountryCode;
        }

        if (billingDayPhone !== undefined) {
            queryParameters['billing_day_phone'] = billingDayPhone;
        }

        if (billingEveningPhone !== undefined) {
            queryParameters['billing_evening_phone'] = billingEveningPhone;
        }

        if (shippingFirstName !== undefined) {
            queryParameters['shipping_first_name'] = shippingFirstName;
        }

        if (shippingLastName !== undefined) {
            queryParameters['shipping_last_name'] = shippingLastName;
        }

        if (shippingCompany !== undefined) {
            queryParameters['shipping_company'] = shippingCompany;
        }

        if (shippingCity !== undefined) {
            queryParameters['shipping_city'] = shippingCity;
        }

        if (shippingState !== undefined) {
            queryParameters['shipping_state'] = shippingState;
        }

        if (shippingPostalCode !== undefined) {
            queryParameters['shipping_postal_code'] = shippingPostalCode;
        }

        if (shippingCountryCode !== undefined) {
            queryParameters['shipping_country_code'] = shippingCountryCode;
        }

        if (shippingDayPhone !== undefined) {
            queryParameters['shipping_day_phone'] = shippingDayPhone;
        }

        if (shippingEveningPhone !== undefined) {
            queryParameters['shipping_evening_phone'] = shippingEveningPhone;
        }

        if (pricingTierOid !== undefined) {
            queryParameters['pricing_tier_oid'] = pricingTierOid;
        }

        if (pricingTierName !== undefined) {
            queryParameters['pricing_tier_name'] = pricingTierName;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve customers by query
     * Retrieves customers from the account.  If no parameters are specified, all customers will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param customerQuery Customer query
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch customers that have been created/modified since this date/time.
     * @param sort The sort order of the customers.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCustomersByQuery (customerQuery: CustomerQuery, limit?: number, offset?: number, since?: string, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomersResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/query';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerQuery' is not null or undefined
        if (customerQuery === null || customerQuery === undefined) {
            throw new Error('Required parameter customerQuery was null or undefined when calling getCustomersByQuery.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customerQuery,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve customers for DataTables plugin
     * Retrieves customers from the account.  If no searches are specified, all customers will be returned. 
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getCustomersForDataTables (expand?: string) : Promise<{ response: http.ClientResponse; body: DataTablesServerSideResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/dataTables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataTablesServerSideResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve values needed for a customer profile editor
     * Retrieve values needed for a customer profile editor. 
     */
    public getEditorValues () : Promise<{ response: http.ClientResponse; body: CustomerEditorValues;  }> {
        const localVarPath = this.basePath + '/customer/editor_values';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerEditorValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all email lists across all storefronts
     * Retrieve all email lists across all storefronts 
     */
    public getEmailLists () : Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }> {
        const localVarPath = this.basePath + '/customer/email_lists';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert a customer
     * Insert a customer on the UltraCart account. 
     * @param customer Customer to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public insertCustomer (customer: Customer, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling insertCustomer.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customer,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a customer
     * Update a customer on the UltraCart account. 
     * @param customer Customer to update
     * @param customerProfileOid The customer_profile_oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateCustomer (customer: Customer, customerProfileOid: number, expand?: string) : Promise<{ response: http.ClientResponse; body: CustomerResponse;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}'
            .replace('{' + 'customer_profile_oid' + '}', String(customerProfileOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling updateCustomer.');
        }

        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling updateCustomer.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customer,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email list subscriptions for a customer
     * Update email list subscriptions for a customer 
     * @param customerProfileOid The customer profile oid
     * @param listChanges List changes
     */
    public updateCustomerEmailLists (customerProfileOid: number, listChanges: CustomerEmailListChanges) : Promise<{ response: http.ClientResponse; body: CustomerEmailListChanges;  }> {
        const localVarPath = this.basePath + '/customer/customers/{customer_profile_oid}/email_lists'
            .replace('{' + 'customer_profile_oid' + '}', String(customerProfileOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'customerProfileOid' is not null or undefined
        if (customerProfileOid === null || customerProfileOid === undefined) {
            throw new Error('Required parameter customerProfileOid was null or undefined when calling updateCustomerEmailLists.');
        }

        // verify required parameter 'listChanges' is not null or undefined
        if (listChanges === null || listChanges === undefined) {
            throw new Error('Required parameter listChanges was null or undefined when calling updateCustomerEmailLists.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: listChanges,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomerEmailListChanges;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FulfillmentApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class FulfillmentApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: FulfillmentApiApiKeys, value: string) {
        this.authentications[FulfillmentApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Acknowledge receipt of orders.
     * Acknowledge receipt of orders so that they are removed from the fulfillment queue.  This method must be called after receiving and order (via webhook) or retrieving (via retrieve orders method). 
     * @param distributionCenterCode Distribution center code
     * @param orderIds Orders to acknowledge receipt of (limit 100)
     */
    public acknowledgeOrders (distributionCenterCode: string, orderIds: Array<string>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/acknowledgements'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling acknowledgeOrders.');
        }

        // verify required parameter 'orderIds' is not null or undefined
        if (orderIds === null || orderIds === undefined) {
            throw new Error('Required parameter orderIds was null or undefined when calling acknowledgeOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: orderIds,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve orders queued up for this distribution center.
     * Retrieves up to 100 orders that are queued up in this distribution center.  You must acknowledge them before additional new orders will be returned.  There is NO record chunking.  You&#39;ll get the same 100 records again and again until you acknowledge orders.  The orders that are returned contain only items for this distribution center and are by default completely expanded with billing, buysafe, channel_partner, checkout, coupons, customer_profile, edi, gift, gift_certificate, internal, items, payment, shipping, summary, taxes. 
     * @param distributionCenterCode Distribution center code
     */
    public getDistributionCenterOrders (distributionCenterCode: string) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/orders'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling getDistributionCenterOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve distribution centers
     * Retrieves the distribution centers that this user has access to. 
     */
    public getDistributionCenters () : Promise<{ response: http.ClientResponse; body: DistributionCentersResponse;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DistributionCentersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark orders as shipped
     * Store the tracking information and mark the order shipped for this distribution center. 
     * @param distributionCenterCode Distribution center code
     * @param shipments Orders to mark shipped
     */
    public shipOrders (distributionCenterCode: string, shipments: Array<FulfillmentShipment>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/shipments'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling shipOrders.');
        }

        // verify required parameter 'shipments' is not null or undefined
        if (shipments === null || shipments === undefined) {
            throw new Error('Required parameter shipments was null or undefined when calling shipOrders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: shipments,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update inventory
     * Update the inventory for items associated with this distribution center 
     * @param distributionCenterCode Distribution center code
     * @param inventories Inventory updates (limit 500)
     */
    public updateInventory (distributionCenterCode: string, inventories: Array<FulfillmentInventory>) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/fulfillment/distribution_centers/{distribution_center_code}/inventory'
            .replace('{' + 'distribution_center_code' + '}', String(distributionCenterCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'distributionCenterCode' is not null or undefined
        if (distributionCenterCode === null || distributionCenterCode === undefined) {
            throw new Error('Required parameter distributionCenterCode was null or undefined when calling updateInventory.');
        }

        // verify required parameter 'inventories' is not null or undefined
        if (inventories === null || inventories === undefined) {
            throw new Error('Required parameter inventories was null or undefined when calling updateInventory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: inventories,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ItemApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class ItemApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ItemApiApiKeys, value: string) {
        this.authentications[ItemApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete an item
     * Delete an item on the UltraCart account. 
     * @param merchantItemOid The item oid to delete.
     */
    public deleteItem (merchantItemOid: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', String(merchantItemOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling deleteItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an item
     * Retrieves a single item using the specified item oid. 
     * @param merchantItemOid The item oid to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public getItem (merchantItemOid: number, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', String(merchantItemOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling getItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an item by item id
     * Retrieves a single item using the specified item id. 
     * @param merchantItemId The item id to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public getItemByMerchantItemId (merchantItemId: string, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/merchant_item_id/{merchant_item_id}'
            .replace('{' + 'merchant_item_id' + '}', String(merchantItemId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'merchantItemId' is not null or undefined
        if (merchantItemId === null || merchantItemId === undefined) {
            throw new Error('Required parameter merchantItemId was null or undefined when calling getItemByMerchantItemId.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve items
     * Retrieves a group of items from the account.  If no parameters are specified, all items will be returned.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param parentCategoryId The parent category object id to retrieve items for.  Unspecified means all items on the account.  0 &#x3D; root
     * @param parentCategoryPath The parent category path to retrieve items for.  Unspecified means all items on the account.  / &#x3D; root
     * @param limit The maximum number of records to return on this one API call. (Default 100, Max 2000)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch items that have been created/modified since this date/time.
     * @param sort The sort order of the items.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public getItems (parentCategoryId?: number, parentCategoryPath?: string, limit?: number, offset?: number, since?: string, sort?: string, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/item/items';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (parentCategoryId !== undefined) {
            queryParameters['parent_category_id'] = parentCategoryId;
        }

        if (parentCategoryPath !== undefined) {
            queryParameters['parent_category_path'] = parentCategoryPath;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve pricing tiers
     * Retrieves the pricing tiers 
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getPricingTiers (expand?: string) : Promise<{ response: http.ClientResponse; body: PricingTiersResponse;  }> {
        const localVarPath = this.basePath + '/item/pricing_tiers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PricingTiersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an item
     * Create a new item on the UltraCart account. 
     * @param item Item to create
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public insertItem (item: Item, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling insertItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: item,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an item
     * Update a new item on the UltraCart account. 
     * @param item Item to update
     * @param merchantItemOid The item oid to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public updateItem (item: Item, merchantItemOid: number, expand?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: ItemResponse;  }> {
        const localVarPath = this.basePath + '/item/items/{merchant_item_oid}'
            .replace('{' + 'merchant_item_oid' + '}', String(merchantItemOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling updateItem.');
        }

        // verify required parameter 'merchantItemOid' is not null or undefined
        if (merchantItemOid === null || merchantItemOid === undefined) {
            throw new Error('Required parameter merchantItemOid was null or undefined when calling updateItem.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: item,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update multiple items
     * Update multiple item on the UltraCart account. 
     * @param itemsRequest Items to update (synchronous maximum 20 / asynchronous maximum 100)
     * @param expand The object expansion to perform on the result.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     * @param async True if the operation should be run async.  No result returned
     */
    public updateItems (itemsRequest: ItemsRequest, expand?: string, placeholders?: boolean, async?: boolean) : Promise<{ response: http.ClientResponse; body: ItemsResponse;  }> {
        const localVarPath = this.basePath + '/item/items/batch';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'itemsRequest' is not null or undefined
        if (itemsRequest === null || itemsRequest === undefined) {
            throw new Error('Required parameter itemsRequest was null or undefined when calling updateItems.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        if (async !== undefined) {
            queryParameters['_async'] = async;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: itemsRequest,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Upload an image to the temporary multimedia.
     * Uploads an image and returns back meta information about the image as well as the identifier needed for the item update. 
     * @param file File to upload
     */
    public uploadTemporaryMultimedia (file: any) : Promise<{ response: http.ClientResponse; body: TempMultimediaResponse;  }> {
        const localVarPath = this.basePath + '/item/temp_multimedia';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling uploadTemporaryMultimedia.');
        }

        let useFormData = false;

        if (file !== undefined) {
            formParams['file'] = file;
        }
        useFormData = true;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TempMultimediaResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OauthApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class OauthApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OauthApiApiKeys, value: string) {
        this.authentications[OauthApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Exchange authorization code for access token.
     * The final leg in the OAuth process which exchanges the specified access token for the access code needed to make API calls. 
     * @param clientId The OAuth application client_id.
     * @param grantType Type of grant
     * @param code Authorization code received back from the browser redirect
     * @param redirectUri The URI that you redirect the browser to to start the authorization process
     * @param refreshToken The refresh token received during the original grant_type&#x3D;authorization_code that can be used to return a new access token
     */
    public oauthAccessToken (clientId: string, grantType: string, code?: string, redirectUri?: string, refreshToken?: string) : Promise<{ response: http.ClientResponse; body: OauthTokenResponse;  }> {
        const localVarPath = this.basePath + '/oauth/token';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling oauthAccessToken.');
        }

        // verify required parameter 'grantType' is not null or undefined
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling oauthAccessToken.');
        }

        let useFormData = false;

        if (clientId !== undefined) {
            formParams['client_id'] = clientId;
        }

        if (grantType !== undefined) {
            formParams['grant_type'] = grantType;
        }

        if (code !== undefined) {
            formParams['code'] = code;
        }

        if (redirectUri !== undefined) {
            formParams['redirect_uri'] = redirectUri;
        }

        if (refreshToken !== undefined) {
            formParams['refresh_token'] = refreshToken;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthTokenResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revoke this OAuth application.
     * Revokes the OAuth application associated with the specified client_id and token. 
     * @param clientId The OAuth application client_id.
     * @param token The OAuth access token that is to be revoked..
     */
    public oauthRevoke (clientId: string, token: string) : Promise<{ response: http.ClientResponse; body: OauthRevokeSuccessResponse;  }> {
        const localVarPath = this.basePath + '/oauth/revoke';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling oauthRevoke.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling oauthRevoke.');
        }

        let useFormData = false;

        if (clientId !== undefined) {
            formParams['client_id'] = clientId;
        }

        if (token !== undefined) {
            formParams['token'] = token;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OauthRevokeSuccessResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrderApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class OrderApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: OrderApiApiKeys, value: string) {
        this.authentications[OrderApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Cancel an order
     * Cancel an order on the UltraCart account.  If the success flag is false, then consult the error message for why it failed. 
     * @param orderId The order id to cancel.
     */
    public cancelOrder (orderId: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/cancel'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an order
     * Delete an order on the UltraCart account. 
     * @param orderId The order id to delete.
     */
    public deleteOrder (orderId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling deleteOrder.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Format order
     * Format the order for display at text or html 
     * @param orderId The order id to format
     * @param formatOptions Format options
     */
    public format (orderId: string, formatOptions: OrderFormat) : Promise<{ response: http.ClientResponse; body: OrderFormatResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/format'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling format.');
        }

        // verify required parameter 'formatOptions' is not null or undefined
        if (formatOptions === null || formatOptions === undefined) {
            throw new Error('Required parameter formatOptions was null or undefined when calling format.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: formatOptions,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderFormatResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve A/R Retry Configuration
     * Retrieve A/R Retry Configuration. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     */
    public getAccountsReceivableRetryConfig () : Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryConfigResponse;  }> {
        const localVarPath = this.basePath + '/order/accountsReceivableRetryConfig';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryConfigResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve A/R Retry Statistics
     * Retrieve A/R Retry Statistics. This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @param from null
     * @param to null
     */
    public getAccountsReceivableRetryStats (from?: string, to?: string) : Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryStatsResponse;  }> {
        const localVarPath = this.basePath + '/order/accountsReceivableRetryConfig/stats';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AccountsReceivableRetryStatsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an order
     * Retrieves a single order using the specified order id. 
     * @param orderId The order id to retrieve.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getOrder (orderId: string, expand?: string) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve orders
     * Retrieves a group of orders from the account.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param orderId Order Id
     * @param paymentMethod Payment Method
     * @param company Company
     * @param firstName First Name
     * @param lastName Last Name
     * @param city City
     * @param stateRegion State/Region
     * @param postalCode Postal Code
     * @param countryCode Country Code (ISO-3166 two letter)
     * @param phone Phone
     * @param email Email
     * @param ccEmail CC Email
     * @param total Total
     * @param screenBrandingThemeCode Screen Branding Theme Code
     * @param storefrontHostName StoreFront Host Name
     * @param creationDateBegin Creation Date Begin
     * @param creationDateEnd Creation Date End
     * @param paymentDateBegin Payment Date Begin
     * @param paymentDateEnd Payment Date End
     * @param shipmentDateBegin Shipment Date Begin
     * @param shipmentDateEnd Shipment Date End
     * @param rma RMA
     * @param purchaseOrderNumber Purchase Order Number
     * @param itemId Item Id
     * @param currentStage Current Stage
     * @param channelPartnerCode Channel Partner Code
     * @param channelPartnerOrderId Channel Partner Order ID
     * @param customerProfileOid null
     * @param refund Date Begin null
     * @param refund Date End null
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.
     */
    public getOrders (orderId?: string, paymentMethod?: string, company?: string, firstName?: string, lastName?: string, city?: string, stateRegion?: string, postalCode?: string, countryCode?: string, phone?: string, email?: string, ccEmail?: string, total?: number, screenBrandingThemeCode?: string, storefrontHostName?: string, creationDateBegin?: string, creationDateEnd?: string, paymentDateBegin?: string, paymentDateEnd?: string, shipmentDateBegin?: string, shipmentDateEnd?: string, rma?: string, purchaseOrderNumber?: string, itemId?: string, currentStage?: string, channelPartnerCode?: string, channelPartnerOrderId?: string, customerProfileOid?: number, refund Date Begin?: string, refund Date End?: string, limit?: number, offset?: number, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/order/orders';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (orderId !== undefined) {
            queryParameters['order_id'] = orderId;
        }

        if (paymentMethod !== undefined) {
            queryParameters['payment_method'] = paymentMethod;
        }

        if (company !== undefined) {
            queryParameters['company'] = company;
        }

        if (firstName !== undefined) {
            queryParameters['first_name'] = firstName;
        }

        if (lastName !== undefined) {
            queryParameters['last_name'] = lastName;
        }

        if (city !== undefined) {
            queryParameters['city'] = city;
        }

        if (stateRegion !== undefined) {
            queryParameters['state_region'] = stateRegion;
        }

        if (postalCode !== undefined) {
            queryParameters['postal_code'] = postalCode;
        }

        if (countryCode !== undefined) {
            queryParameters['country_code'] = countryCode;
        }

        if (phone !== undefined) {
            queryParameters['phone'] = phone;
        }

        if (email !== undefined) {
            queryParameters['email'] = email;
        }

        if (ccEmail !== undefined) {
            queryParameters['cc_email'] = ccEmail;
        }

        if (total !== undefined) {
            queryParameters['total'] = total;
        }

        if (screenBrandingThemeCode !== undefined) {
            queryParameters['screen_branding_theme_code'] = screenBrandingThemeCode;
        }

        if (storefrontHostName !== undefined) {
            queryParameters['storefront_host_name'] = storefrontHostName;
        }

        if (creationDateBegin !== undefined) {
            queryParameters['creation_date_begin'] = creationDateBegin;
        }

        if (creationDateEnd !== undefined) {
            queryParameters['creation_date_end'] = creationDateEnd;
        }

        if (paymentDateBegin !== undefined) {
            queryParameters['payment_date_begin'] = paymentDateBegin;
        }

        if (paymentDateEnd !== undefined) {
            queryParameters['payment_date_end'] = paymentDateEnd;
        }

        if (shipmentDateBegin !== undefined) {
            queryParameters['shipment_date_begin'] = shipmentDateBegin;
        }

        if (shipmentDateEnd !== undefined) {
            queryParameters['shipment_date_end'] = shipmentDateEnd;
        }

        if (rma !== undefined) {
            queryParameters['rma'] = rma;
        }

        if (purchaseOrderNumber !== undefined) {
            queryParameters['purchase_order_number'] = purchaseOrderNumber;
        }

        if (itemId !== undefined) {
            queryParameters['item_id'] = itemId;
        }

        if (currentStage !== undefined) {
            queryParameters['current_stage'] = currentStage;
        }

        if (channelPartnerCode !== undefined) {
            queryParameters['channel_partner_code'] = channelPartnerCode;
        }

        if (channelPartnerOrderId !== undefined) {
            queryParameters['channel_partner_order_id'] = channelPartnerOrderId;
        }

        if (customerProfileOid !== undefined) {
            queryParameters['customer_profile_oid'] = customerProfileOid;
        }

        if (refund Date Begin !== undefined) {
            queryParameters['Refund Date Begin'] = refund Date Begin;
        }

        if (refund Date End !== undefined) {
            queryParameters['Refund Date End'] = refund Date End;
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve order batch
     * Retrieves a group of orders from the account based on an array of order ids.  If more than 500 order ids are specified, the API call will fail with a bad request error. 
     * @param orderBatch Order batch
     * @param expand The object expansion to perform on the result.
     */
    public getOrdersBatch (orderBatch: OrderQueryBatch, expand?: string) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/batch';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderBatch' is not null or undefined
        if (orderBatch === null || orderBatch === undefined) {
            throw new Error('Required parameter orderBatch was null or undefined when calling getOrdersBatch.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: orderBatch,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve orders
     * Retrieves a group of orders from the account based on a query object.  If no parameters are specified, the API call will fail with a bad request error.  Always specify some parameters to limit the scope of the orders returned to ones you are truly interested in.  You will need to make multiple API calls in order to retrieve the entire result set since this API performs result set pagination. 
     * @param orderQuery Order query
     * @param limit The maximum number of records to return on this one API call. (Maximum 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the orders.  See Sorting documentation for examples of using multiple values and sorting by ascending and descending.
     * @param expand The object expansion to perform on the result.
     */
    public getOrdersByQuery (orderQuery: OrderQuery, limit?: number, offset?: number, sort?: string, expand?: string) : Promise<{ response: http.ClientResponse; body: OrdersResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/query';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderQuery' is not null or undefined
        if (orderQuery === null || orderQuery === undefined) {
            throw new Error('Required parameter orderQuery was null or undefined when calling getOrdersByQuery.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: orderQuery,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrdersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert an order
     * Inserts a new order on the UltraCart account.  This is probably NOT the method you want.  This is for channel orders.  For regular orders the customer is entering, use the CheckoutApi.  It has many, many more features, checks, and validations. 
     * @param order Order to insert
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public insertOrder (order: Order, expand?: string) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling insertOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: order,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Refund an order
     * Perform a refund operation on an order and then update the order if successful 
     * @param order Order to refund
     * @param orderId The order id to refund.
     * @param rejectAfterRefund Reject order after refund
     * @param skipCustomerNotification Skip customer email notification
     * @param autoOrderCancel Cancel associated auto orders
     * @param manualRefund Consider a manual refund done externally
     * @param reverseAffiliateTransactions Reverse affiliate transactions
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public refundOrder (order: Order, orderId: string, rejectAfterRefund?: boolean, skipCustomerNotification?: boolean, autoOrderCancel?: boolean, manualRefund?: boolean, reverseAffiliateTransactions?: boolean, expand?: string) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/refund'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling refundOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling refundOrder.');
        }

        if (rejectAfterRefund !== undefined) {
            queryParameters['reject_after_refund'] = rejectAfterRefund;
        }

        if (skipCustomerNotification !== undefined) {
            queryParameters['skip_customer_notification'] = skipCustomerNotification;
        }

        if (autoOrderCancel !== undefined) {
            queryParameters['auto_order_cancel'] = autoOrderCancel;
        }

        if (manualRefund !== undefined) {
            queryParameters['manual_refund'] = manualRefund;
        }

        if (reverseAffiliateTransactions !== undefined) {
            queryParameters['reverse_affiliate_transactions'] = reverseAffiliateTransactions;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: order,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replacement order
     * Create a replacement order based upon a previous order 
     * @param orderId The order id to generate a replacement for.
     * @param replacement Replacement order details
     */
    public replacement (orderId: string, replacement: OrderReplacement) : Promise<{ response: http.ClientResponse; body: OrderReplacementResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/replacement'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling replacement.');
        }

        // verify required parameter 'replacement' is not null or undefined
        if (replacement === null || replacement === undefined) {
            throw new Error('Required parameter replacement was null or undefined when calling replacement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: replacement,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderReplacementResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend receipt
     * Resend the receipt for an order on the UltraCart account. 
     * @param orderId The order id to resend the receipt for.
     */
    public resendReceipt (orderId: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/resend_receipt'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling resendReceipt.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend shipment confirmation
     * Resend shipment confirmation for an order on the UltraCart account. 
     * @param orderId The order id to resend the shipment notification for.
     */
    public resendShipmentConfirmation (orderId: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}/resend_shipment_confirmation'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling resendShipmentConfirmation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update A/R Retry Configuration
     * Update A/R Retry Configuration.  This is primarily an internal API call.  It is doubtful you would ever need to use it. 
     * @param retryConfig AccountsReceivableRetryConfig object
     */
    public updateAccountsReceivableRetryConfig (retryConfig: AccountsReceivableRetryConfig) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/order/accountsReceivableRetryConfig';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'retryConfig' is not null or undefined
        if (retryConfig === null || retryConfig === undefined) {
            throw new Error('Required parameter retryConfig was null or undefined when calling updateAccountsReceivableRetryConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: retryConfig,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an order
     * Update a new order on the UltraCart account.  This is probably NOT the method you want.  It is rare to update a completed order.  This will not trigger charges, emails, or any other automation. 
     * @param order Order to update
     * @param orderId The order id to update.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public updateOrder (order: Order, orderId: string, expand?: string) : Promise<{ response: http.ClientResponse; body: OrderResponse;  }> {
        const localVarPath = this.basePath + '/order/orders/{order_id}'
            .replace('{' + 'order_id' + '}', String(orderId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'order' is not null or undefined
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling updateOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updateOrder.');
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: order,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OrderResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StorefrontApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class StorefrontApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: StorefrontApiApiKeys, value: string) {
        this.authentications[StorefrontApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Archive email list
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     */
    public archiveEmailList (storefrontOid: string, emailListUuid: string) : Promise<{ response: http.ClientResponse; body: EmailListArchiveResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/archive'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling archiveEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling archiveEmailList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListArchiveResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Archive email segment
     * 
     * @param storefrontOid null
     * @param emailSegmentUuid null
     */
    public archiveEmailSegment (storefrontOid: string, emailSegmentUuid: string) : Promise<{ response: http.ClientResponse; body: EmailSegmentArchiveResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/archive'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_segment_uuid' + '}', String(emailSegmentUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling archiveEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling archiveEmailSegment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentArchiveResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clone email campaign
     * 
     * @param storefrontOid null
     * @param emailCampaignUuid null
     */
    public cloneEmailCampaign (storefrontOid: string, emailCampaignUuid: string) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/clone'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_campaign_uuid' + '}', String(emailCampaignUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling cloneEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling cloneEmailCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Clone email flow
     * 
     * @param storefrontOid null
     * @param emailFlowUuid null
     */
    public cloneEmailFlow (storefrontOid: string, emailFlowUuid: string) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}/clone'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_flow_uuid' + '}', String(emailFlowUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling cloneEmailFlow.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling cloneEmailFlow.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create email campaign
     * 
     * @param domain null
     */
    public createEmailSendingDomain (domain: string) : Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains/{domain}/create'
            .replace('{' + 'domain' + '}', String(domain));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling createEmailSendingDomain.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete email email
     * 
     * @param storefrontOid null
     * @param commseqEmailUuid null
     */
    public deleteEmailEmail (storefrontOid: string, commseqEmailUuid: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_email_uuid' + '}', String(commseqEmailUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteEmailEmail.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling deleteEmailEmail.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete email list customer
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     * @param emailCustomerUuid null
     */
    public deleteEmailListCustomer (storefrontOid: string, emailListUuid: string, emailCustomerUuid: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid))
            .replace('{' + 'email_customer_uuid' + '}', String(emailCustomerUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteEmailListCustomer.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling deleteEmailListCustomer.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling deleteEmailListCustomer.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete email campaign
     * 
     * @param domain null
     */
    public deleteEmailSendingDomain (domain: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains/{domain}'
            .replace('{' + 'domain' + '}', String(domain));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling deleteEmailSendingDomain.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete experiment
     * 
     * @param storefrontOid null
     * @param storefrontExperimentOid null
     */
    public deleteExperiment (storefrontOid: string, storefrontExperimentOid: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'storefront_experiment_oid' + '}', String(storefrontExperimentOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling deleteExperiment.');
        }

        // verify required parameter 'storefrontExperimentOid' is not null or undefined
        if (storefrontExperimentOid === null || storefrontExperimentOid === undefined) {
            throw new Error('Required parameter storefrontExperimentOid was null or undefined when calling deleteExperiment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Obtain lat/long for an address
     * 
     * @param storefrontOid null
     * @param geocodeRequest geocode request
     */
    public geocodeAddress (storefrontOid: string, geocodeRequest: GeocodeRequest) : Promise<{ response: http.ClientResponse; body: GeocodeResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/geocode'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling geocodeAddress.');
        }

        // verify required parameter 'geocodeRequest' is not null or undefined
        if (geocodeRequest === null || geocodeRequest === undefined) {
            throw new Error('Required parameter geocodeRequest was null or undefined when calling geocodeAddress.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: geocodeRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GeocodeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get countries
     * Obtain a list of all the countries 
     * @param storefrontOid null
     */
    public getCountries (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: CountriesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/countries'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getCountries.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CountriesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email communication base templates
     * 
     * @param storefrontOid null
     */
    public getEmailBaseTemplates (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailBaseTemplateListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/baseTemplates'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailBaseTemplates.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailBaseTemplateListResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email campaign
     * 
     * @param storefrontOid null
     * @param emailCampaignUuid null
     */
    public getEmailCampaign (storefrontOid: string, emailCampaignUuid: string) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_campaign_uuid' + '}', String(emailCampaignUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling getEmailCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email campaigns
     * 
     * @param storefrontOid null
     */
    public getEmailCampaigns (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCampaigns.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email campaigns with stats
     * 
     * @param storefrontOid null
     * @param statDays null
     */
    public getEmailCampaignsWithStats (storefrontOid: string, statDays: string) : Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaignsWithStats/{stat_days}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'stat_days' + '}', String(statDays));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCampaignsWithStats.');
        }

        // verify required parameter 'statDays' is not null or undefined
        if (statDays === null || statDays === undefined) {
            throw new Error('Required parameter statDays was null or undefined when calling getEmailCampaignsWithStats.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email commseq
     * 
     * @param storefrontOid null
     * @param commseqUuid null
     */
    public getEmailCommseq (storefrontOid: string, commseqUuid: string) : Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_uuid' + '}', String(commseqUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseq.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseq.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email communication sequence emails stats
     * 
     * @param storefrontOid null
     * @param commseqUuid null
     * @param statsRequest StatsRequest
     */
    public getEmailCommseqEmailStats (storefrontOid: string, commseqUuid: string, statsRequest: EmailStatSummaryRequest) : Promise<{ response: http.ClientResponse; body: EmailStatSummaryResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/emailStats'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_uuid' + '}', String(commseqUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqEmailStats.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqEmailStats.');
        }

        // verify required parameter 'statsRequest' is not null or undefined
        if (statsRequest === null || statsRequest === undefined) {
            throw new Error('Required parameter statsRequest was null or undefined when calling getEmailCommseqEmailStats.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: statsRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailStatSummaryResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get communication sequence stats overall
     * 
     * @param storefrontOid null
     * @param commseqUuid null
     */
    public getEmailCommseqStatOverall (storefrontOid: string, commseqUuid: string) : Promise<{ response: http.ClientResponse; body: EmailCommseqStatResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/stat'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_uuid' + '}', String(commseqUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqStatOverall.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqStatOverall.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqStatResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email communication sequence customers waiting at each requested step
     * 
     * @param storefrontOid null
     * @param commseqUuid null
     * @param waitingRequest WaitingRequest
     */
    public getEmailCommseqStepWaiting (storefrontOid: string, commseqUuid: string, waitingRequest: EmailStepWaitingRequest) : Promise<{ response: http.ClientResponse; body: EmailStepWaitingResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}/waiting'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_uuid' + '}', String(commseqUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqStepWaiting.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling getEmailCommseqStepWaiting.');
        }

        // verify required parameter 'waitingRequest' is not null or undefined
        if (waitingRequest === null || waitingRequest === undefined) {
            throw new Error('Required parameter waitingRequest was null or undefined when calling getEmailCommseqStepWaiting.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: waitingRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailStepWaitingResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email commseqs
     * 
     * @param storefrontOid null
     */
    public getEmailCommseqs (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailCommseqsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailCommseqs.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email dashboard activity
     * 
     * @param storefrontOid null
     * @param lastRecords null
     */
    public getEmailDashboardActivity (storefrontOid: string, lastRecords?: number) : Promise<{ response: http.ClientResponse; body: EmailDashboardActivityResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/dashboard_activity'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailDashboardActivity.');
        }

        if (lastRecords !== undefined) {
            queryParameters['last_records'] = lastRecords;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailDashboardActivityResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get dashboard stats
     * 
     * @param storefrontOid null
     * @param days null
     */
    public getEmailDashboardStats (storefrontOid: string, days?: number) : Promise<{ response: http.ClientResponse; body: EmailDashboardStatsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/dashboard_stats'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailDashboardStats.');
        }

        if (days !== undefined) {
            queryParameters['days'] = days;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailDashboardStatsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email email
     * 
     * @param storefrontOid null
     * @param commseqEmailUuid null
     */
    public getEmailEmail (storefrontOid: string, commseqEmailUuid: string) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_email_uuid' + '}', String(commseqEmailUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmail.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling getEmailEmail.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email emails
     * 
     * @param storefrontOid null
     */
    public getEmailEmails (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmails.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email emails multiple
     * 
     * @param storefrontOid null
     * @param emailCommseqEmailsRequest Request of email uuids
     */
    public getEmailEmailsMultiple (storefrontOid: string, emailCommseqEmailsRequest: EmailCommseqEmailsRequest) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/multiple'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailEmailsMultiple.');
        }

        // verify required parameter 'emailCommseqEmailsRequest' is not null or undefined
        if (emailCommseqEmailsRequest === null || emailCommseqEmailsRequest === undefined) {
            throw new Error('Required parameter emailCommseqEmailsRequest was null or undefined when calling getEmailEmailsMultiple.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailCommseqEmailsRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email flow
     * 
     * @param storefrontOid null
     * @param emailFlowUuid null
     */
    public getEmailFlow (storefrontOid: string, emailFlowUuid: string) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_flow_uuid' + '}', String(emailFlowUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailFlow.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling getEmailFlow.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email flows
     * 
     * @param storefrontOid null
     */
    public getEmailFlows (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailFlowsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailFlows.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email list
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     */
    public getEmailList (storefrontOid: string, emailListUuid: string) : Promise<{ response: http.ClientResponse; body: EmailListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling getEmailList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email list customers
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     * @param emailCustomerUuid null
     */
    public getEmailListCustomerEditorUrl (storefrontOid: string, emailListUuid: string, emailCustomerUuid: string) : Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers/{email_customer_uuid}/editor_url'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid))
            .replace('{' + 'email_customer_uuid' + '}', String(emailCustomerUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailListCustomerEditorUrl.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling getEmailListCustomerEditorUrl.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling getEmailListCustomerEditorUrl.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email list customers
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     * @param pageNumber null
     * @param pageSize null
     */
    public getEmailListCustomers (storefrontOid: string, emailListUuid: string, pageNumber?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/customers'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailListCustomers.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling getEmailListCustomers.');
        }

        if (pageNumber !== undefined) {
            queryParameters['pageNumber'] = pageNumber;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email lists
     * 
     * @param storefrontOid null
     */
    public getEmailLists (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailLists.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email segment
     * 
     * @param storefrontOid null
     * @param emailSegmentUuid null
     */
    public getEmailSegment (storefrontOid: string, emailSegmentUuid: string) : Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_segment_uuid' + '}', String(emailSegmentUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling getEmailSegment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email segment customers editor URL
     * 
     * @param storefrontOid null
     * @param emailSegmentUuid null
     * @param emailCustomerUuid null
     */
    public getEmailSegmentCustomerEditorUrl (storefrontOid: string, emailSegmentUuid: string, emailCustomerUuid: string) : Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers/{email_customer_uuid}/editor_url'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_segment_uuid' + '}', String(emailSegmentUuid))
            .replace('{' + 'email_customer_uuid' + '}', String(emailCustomerUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
        }

        // verify required parameter 'emailCustomerUuid' is not null or undefined
        if (emailCustomerUuid === null || emailCustomerUuid === undefined) {
            throw new Error('Required parameter emailCustomerUuid was null or undefined when calling getEmailSegmentCustomerEditorUrl.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCustomerEditorUrlResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email segment customers
     * 
     * @param storefrontOid null
     * @param emailSegmentUuid null
     * @param pageNumber null
     * @param pageSize null
     */
    public getEmailSegmentCustomers (storefrontOid: string, emailSegmentUuid: string, pageNumber?: number, pageSize?: number) : Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/customers'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_segment_uuid' + '}', String(emailSegmentUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegmentCustomers.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling getEmailSegmentCustomers.');
        }

        if (pageNumber !== undefined) {
            queryParameters['pageNumber'] = pageNumber;
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = pageSize;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email segments
     * 
     * @param storefrontOid null
     */
    public getEmailSegments (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailSegmentsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailSegments.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email sending domain
     * 
     * @param domain null
     */
    public getEmailSendingDomain (domain: string) : Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domain/{domain}'
            .replace('{' + 'domain' + '}', String(domain));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getEmailSendingDomain.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email sending domain status
     * 
     * @param domain null
     */
    public getEmailSendingDomainStatus (domain: string) : Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains/{domain}/status'
            .replace('{' + 'domain' + '}', String(domain));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getEmailSendingDomainStatus.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email sending domains
     * 
     */
    public getEmailSendingDomains () : Promise<{ response: http.ClientResponse; body: EmailSendingDomainsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/email/sending_domains';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSendingDomainsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email template
     * 
     * @param storefrontOid null
     * @param emailTemplateOid null
     */
    public getEmailTemplate (storefrontOid: string, emailTemplateOid: number) : Promise<{ response: http.ClientResponse; body: EmailTemplate;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/templates/{email_template_oid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_template_oid' + '}', String(emailTemplateOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailTemplate.');
        }

        // verify required parameter 'emailTemplateOid' is not null or undefined
        if (emailTemplateOid === null || emailTemplateOid === undefined) {
            throw new Error('Required parameter emailTemplateOid was null or undefined when calling getEmailTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get email templates
     * 
     * @param storefrontOid null
     * @param triggerType null
     */
    public getEmailTemplates (storefrontOid: string, triggerType?: string) : Promise<{ response: http.ClientResponse; body: EmailTemplatesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/templates'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailTemplates.');
        }

        if (triggerType !== undefined) {
            queryParameters['trigger_type'] = triggerType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailTemplatesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of third party email providers
     * 
     * @param storefrontOid null
     */
    public getEmailThirdPartyProviders (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: EmailThirdPartyProvidersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/third_party_providers'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getEmailThirdPartyProviders.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailThirdPartyProvidersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get experiments
     * 
     * @param storefrontOid null
     */
    public getExperiments (storefrontOid: string) : Promise<{ response: http.ClientResponse; body: ExperimentsResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/experiments'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getExperiments.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExperimentsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get histogram property names
     * Obtain a list of property names for a given property type 
     * @param storefrontOid null
     * @param propertyType null
     */
    public getHistogramPropertyNames (storefrontOid: string, propertyType?: string) : Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyNamesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/histogram/property_names'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getHistogramPropertyNames.');
        }

        if (propertyType !== undefined) {
            queryParameters['property_type'] = propertyType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyNamesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get histogram property values
     * Obtain a list of property values for a given property name and type 
     * @param storefrontOid null
     * @param propertyName null
     * @param propertyType null
     * @param limit null
     */
    public getHistogramPropertyValues (storefrontOid: string, propertyName?: string, propertyType?: string, limit?: number) : Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyValuesResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/histogram/property_values'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling getHistogramPropertyValues.');
        }

        if (propertyName !== undefined) {
            queryParameters['property_name'] = propertyName;
        }

        if (propertyType !== undefined) {
            queryParameters['property_type'] = propertyType;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailHistogramPropertyValuesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Import a third party provider list
     * 
     * @param storefrontOid null
     * @param importRequest lists to import
     */
    public importEmailThirdPartyProviderList (storefrontOid: string, importRequest: EmailThirdPartyListImportRequest) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/third_party_providers/import'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling importEmailThirdPartyProviderList.');
        }

        // verify required parameter 'importRequest' is not null or undefined
        if (importRequest === null || importRequest === undefined) {
            throw new Error('Required parameter importRequest was null or undefined when calling importEmailThirdPartyProviderList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: importRequest,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert email campaign
     * 
     * @param storefrontOid null
     * @param emailCampaign Email campaign
     */
    public insertEmailCampaign (storefrontOid: string, emailCampaign: EmailCampaign) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailCampaign.');
        }

        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling insertEmailCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailCampaign,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert email commseq
     * 
     * @param storefrontOid null
     * @param emailCommseq Email commseq
     */
    public insertEmailCommseq (storefrontOid: string, emailCommseq: EmailCommseq) : Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailCommseq.');
        }

        // verify required parameter 'emailCommseq' is not null or undefined
        if (emailCommseq === null || emailCommseq === undefined) {
            throw new Error('Required parameter emailCommseq was null or undefined when calling insertEmailCommseq.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailCommseq,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert email email
     * 
     * @param storefrontOid null
     * @param emailCommseqEmail Email email
     */
    public insertEmailEmail (storefrontOid: string, emailCommseqEmail: EmailCommseqEmail) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailEmail.');
        }

        // verify required parameter 'emailCommseqEmail' is not null or undefined
        if (emailCommseqEmail === null || emailCommseqEmail === undefined) {
            throw new Error('Required parameter emailCommseqEmail was null or undefined when calling insertEmailEmail.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailCommseqEmail,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert email flow
     * 
     * @param storefrontOid null
     * @param emailFlow Email flow
     */
    public insertEmailFlow (storefrontOid: string, emailFlow: EmailFlow) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailFlow.');
        }

        // verify required parameter 'emailFlow' is not null or undefined
        if (emailFlow === null || emailFlow === undefined) {
            throw new Error('Required parameter emailFlow was null or undefined when calling insertEmailFlow.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailFlow,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert email list
     * 
     * @param storefrontOid null
     * @param emailList Email list
     */
    public insertEmailList (storefrontOid: string, emailList: EmailList) : Promise<{ response: http.ClientResponse; body: EmailListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailList.');
        }

        // verify required parameter 'emailList' is not null or undefined
        if (emailList === null || emailList === undefined) {
            throw new Error('Required parameter emailList was null or undefined when calling insertEmailList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailList,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Insert email segment
     * 
     * @param storefrontOid null
     * @param emailSegment Email segment
     */
    public insertEmailSegment (storefrontOid: string, emailSegment: EmailSegment) : Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling insertEmailSegment.');
        }

        // verify required parameter 'emailSegment' is not null or undefined
        if (emailSegment === null || emailSegment === undefined) {
            throw new Error('Required parameter emailSegment was null or undefined when calling insertEmailSegment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailSegment,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Searches for all matching values
     * 
     * @param category null
     * @param matches null
     * @param maxHits null
     */
    public search (category?: string, matches?: string, maxHits?: number) : Promise<{ response: http.ClientResponse; body: LookupResponse;  }> {
        const localVarPath = this.basePath + '/storefront/search';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (category !== undefined) {
            queryParameters['category'] = category;
        }

        if (matches !== undefined) {
            queryParameters['matches'] = matches;
        }

        if (maxHits !== undefined) {
            queryParameters['max_hits'] = maxHits;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: LookupResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search email list customers
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     * @param startsWith null
     */
    public searchEmailListCustomers (storefrontOid: string, emailListUuid: string, startsWith?: string) : Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/search'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling searchEmailListCustomers.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling searchEmailListCustomers.');
        }

        if (startsWith !== undefined) {
            queryParameters['startsWith'] = startsWith;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListCustomersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search email segment customers
     * 
     * @param storefrontOid null
     * @param emailSegmentUuid null
     * @param startsWith null
     */
    public searchEmailSegmentCustomers (storefrontOid: string, emailSegmentUuid: string, startsWith?: string) : Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}/search'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_segment_uuid' + '}', String(emailSegmentUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling searchEmailSegmentCustomers.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling searchEmailSegmentCustomers.');
        }

        if (startsWith !== undefined) {
            queryParameters['startsWith'] = startsWith;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentCustomersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Start email campaign
     * 
     * @param storefrontOid null
     * @param emailCampaignUuid null
     */
    public startEmailCampaign (storefrontOid: string, emailCampaignUuid: string) : Promise<{ response: http.ClientResponse; body: BaseResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}/start'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_campaign_uuid' + '}', String(emailCampaignUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling startEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling startEmailCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BaseResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Subscribe customers to email list
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     * @param customers Customers
     */
    public subscribeToEmailList (storefrontOid: string, emailListUuid: string, customers: Array<EmailCustomer>) : Promise<{ response: http.ClientResponse; body: EmailListSubscribeResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}/subscribe'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling subscribeToEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling subscribeToEmailList.');
        }

        // verify required parameter 'customers' is not null or undefined
        if (customers === null || customers === undefined) {
            throw new Error('Required parameter customers was null or undefined when calling subscribeToEmailList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customers,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListSubscribeResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email campaign
     * 
     * @param storefrontOid null
     * @param emailCampaignUuid null
     * @param emailCampaign Email campaign
     */
    public updateEmailCampaign (storefrontOid: string, emailCampaignUuid: string, emailCampaign: EmailCampaign) : Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/campaigns/{email_campaign_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_campaign_uuid' + '}', String(emailCampaignUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailCampaign.');
        }

        // verify required parameter 'emailCampaignUuid' is not null or undefined
        if (emailCampaignUuid === null || emailCampaignUuid === undefined) {
            throw new Error('Required parameter emailCampaignUuid was null or undefined when calling updateEmailCampaign.');
        }

        // verify required parameter 'emailCampaign' is not null or undefined
        if (emailCampaign === null || emailCampaign === undefined) {
            throw new Error('Required parameter emailCampaign was null or undefined when calling updateEmailCampaign.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailCampaign,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCampaignResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email commseq
     * 
     * @param storefrontOid null
     * @param commseqUuid null
     * @param emailCommseq Email commseq
     */
    public updateEmailCommseq (storefrontOid: string, commseqUuid: string, emailCommseq: EmailCommseq) : Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/commseqs/{commseq_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_uuid' + '}', String(commseqUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailCommseq.');
        }

        // verify required parameter 'commseqUuid' is not null or undefined
        if (commseqUuid === null || commseqUuid === undefined) {
            throw new Error('Required parameter commseqUuid was null or undefined when calling updateEmailCommseq.');
        }

        // verify required parameter 'emailCommseq' is not null or undefined
        if (emailCommseq === null || emailCommseq === undefined) {
            throw new Error('Required parameter emailCommseq was null or undefined when calling updateEmailCommseq.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailCommseq,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email email
     * 
     * @param storefrontOid null
     * @param commseqEmailUuid null
     * @param emailCommseqEmail Email commseq email
     */
    public updateEmailEmail (storefrontOid: string, commseqEmailUuid: string, emailCommseqEmail: EmailCommseqEmail) : Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/emails/{commseq_email_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'commseq_email_uuid' + '}', String(commseqEmailUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailEmail.');
        }

        // verify required parameter 'commseqEmailUuid' is not null or undefined
        if (commseqEmailUuid === null || commseqEmailUuid === undefined) {
            throw new Error('Required parameter commseqEmailUuid was null or undefined when calling updateEmailEmail.');
        }

        // verify required parameter 'emailCommseqEmail' is not null or undefined
        if (emailCommseqEmail === null || emailCommseqEmail === undefined) {
            throw new Error('Required parameter emailCommseqEmail was null or undefined when calling updateEmailEmail.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailCommseqEmail,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailCommseqEmailResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email flow
     * 
     * @param storefrontOid null
     * @param emailFlowUuid null
     * @param emailFlow Email flow
     */
    public updateEmailFlow (storefrontOid: string, emailFlowUuid: string, emailFlow: EmailFlow) : Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/flows/{email_flow_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_flow_uuid' + '}', String(emailFlowUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailFlow.');
        }

        // verify required parameter 'emailFlowUuid' is not null or undefined
        if (emailFlowUuid === null || emailFlowUuid === undefined) {
            throw new Error('Required parameter emailFlowUuid was null or undefined when calling updateEmailFlow.');
        }

        // verify required parameter 'emailFlow' is not null or undefined
        if (emailFlow === null || emailFlow === undefined) {
            throw new Error('Required parameter emailFlow was null or undefined when calling updateEmailFlow.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailFlow,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailFlowResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email list
     * 
     * @param storefrontOid null
     * @param emailListUuid null
     * @param emailList Email list
     */
    public updateEmailList (storefrontOid: string, emailListUuid: string, emailList: EmailList) : Promise<{ response: http.ClientResponse; body: EmailListResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/lists/{email_list_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_list_uuid' + '}', String(emailListUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailList.');
        }

        // verify required parameter 'emailListUuid' is not null or undefined
        if (emailListUuid === null || emailListUuid === undefined) {
            throw new Error('Required parameter emailListUuid was null or undefined when calling updateEmailList.');
        }

        // verify required parameter 'emailList' is not null or undefined
        if (emailList === null || emailList === undefined) {
            throw new Error('Required parameter emailList was null or undefined when calling updateEmailList.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailList,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailListResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update email segment
     * 
     * @param storefrontOid null
     * @param emailSegmentUuid null
     * @param emailSegment Email segment
     */
    public updateEmailSegment (storefrontOid: string, emailSegmentUuid: string, emailSegment: EmailSegment) : Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/email/segments/{email_segment_uuid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'email_segment_uuid' + '}', String(emailSegmentUuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateEmailSegment.');
        }

        // verify required parameter 'emailSegmentUuid' is not null or undefined
        if (emailSegmentUuid === null || emailSegmentUuid === undefined) {
            throw new Error('Required parameter emailSegmentUuid was null or undefined when calling updateEmailSegment.');
        }

        // verify required parameter 'emailSegment' is not null or undefined
        if (emailSegment === null || emailSegment === undefined) {
            throw new Error('Required parameter emailSegment was null or undefined when calling updateEmailSegment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: emailSegment,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: EmailSegmentResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update experiment
     * 
     * @param storefrontOid null
     * @param storefrontExperimentOid null
     * @param experiment Experiment
     */
    public updateExperiment (storefrontOid: string, storefrontExperimentOid: number, experiment: Experiment) : Promise<{ response: http.ClientResponse; body: ExperimentResponse;  }> {
        const localVarPath = this.basePath + '/storefront/{storefront_oid}/experiments/{storefront_experiment_oid}'
            .replace('{' + 'storefront_oid' + '}', String(storefrontOid))
            .replace('{' + 'storefront_experiment_oid' + '}', String(storefrontExperimentOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'storefrontOid' is not null or undefined
        if (storefrontOid === null || storefrontOid === undefined) {
            throw new Error('Required parameter storefrontOid was null or undefined when calling updateExperiment.');
        }

        // verify required parameter 'storefrontExperimentOid' is not null or undefined
        if (storefrontExperimentOid === null || storefrontExperimentOid === undefined) {
            throw new Error('Required parameter storefrontExperimentOid was null or undefined when calling updateExperiment.');
        }

        // verify required parameter 'experiment' is not null or undefined
        if (experiment === null || experiment === undefined) {
            throw new Error('Required parameter experiment was null or undefined when calling updateExperiment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: experiment,
        };

        this.authentications.ultraCartBrowserApiKey.applyToRequest(requestOptions);

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExperimentResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class TaxApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxApiApiKeys, value: string) {
        this.authentications[TaxApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Deletes a Self tax provider city
     * Deletes a Self tax provider city. 
     * @param city The city being deleted.
     * @param taxCity tax city to be deleted
     */
    public deleteTaxProviderSelfCity (city: string, taxCity: TaxCity) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/city/{city}'
            .replace('{' + 'city' + '}', String(city));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'city' is not null or undefined
        if (city === null || city === undefined) {
            throw new Error('Required parameter city was null or undefined when calling deleteTaxProviderSelfCity.');
        }

        // verify required parameter 'taxCity' is not null or undefined
        if (taxCity === null || taxCity === undefined) {
            throw new Error('Required parameter taxCity was null or undefined when calling deleteTaxProviderSelfCity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxCity,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider country
     * Deletes a Self tax provider country. 
     * @param countryCode The country code being deleted.
     * @param taxCountry tax country to be deleted
     */
    public deleteTaxProviderSelfCountry (countryCode: string, taxCountry: TaxCountry) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/country/{countryCode}'
            .replace('{' + 'countryCode' + '}', String(countryCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling deleteTaxProviderSelfCountry.');
        }

        // verify required parameter 'taxCountry' is not null or undefined
        if (taxCountry === null || taxCountry === undefined) {
            throw new Error('Required parameter taxCountry was null or undefined when calling deleteTaxProviderSelfCountry.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxCountry,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider county
     * Deletes a Self tax provider county. 
     * @param county The county being deleted.
     * @param taxCounty tax county to be deleted
     */
    public deleteTaxProviderSelfCounty (county: string, taxCounty: TaxCounty) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/county/{county}'
            .replace('{' + 'county' + '}', String(county));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'county' is not null or undefined
        if (county === null || county === undefined) {
            throw new Error('Required parameter county was null or undefined when calling deleteTaxProviderSelfCounty.');
        }

        // verify required parameter 'taxCounty' is not null or undefined
        if (taxCounty === null || taxCounty === undefined) {
            throw new Error('Required parameter taxCounty was null or undefined when calling deleteTaxProviderSelfCounty.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxCounty,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider postalCode
     * Deletes a Self tax provider postalCode. 
     * @param postalCode The postal code being deleted.
     * @param taxPostalCode tax postal code to be deleted
     */
    public deleteTaxProviderSelfPostalCode (postalCode: string, taxPostalCode: TaxPostalCode) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/postalCode/{postal_code}'
            .replace('{' + 'postal_code' + '}', String(postalCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'postalCode' is not null or undefined
        if (postalCode === null || postalCode === undefined) {
            throw new Error('Required parameter postalCode was null or undefined when calling deleteTaxProviderSelfPostalCode.');
        }

        // verify required parameter 'taxPostalCode' is not null or undefined
        if (taxPostalCode === null || taxPostalCode === undefined) {
            throw new Error('Required parameter taxPostalCode was null or undefined when calling deleteTaxProviderSelfPostalCode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxPostalCode,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes a Self tax provider state
     * Deletes a Self tax provider state. 
     * @param stateCode The state code being deleted.
     * @param taxState tax state to be deleted
     */
    public deleteTaxProviderSelfState (stateCode: string, taxState: TaxState) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/state/{stateCode}'
            .replace('{' + 'stateCode' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling deleteTaxProviderSelfState.');
        }

        // verify required parameter 'taxState' is not null or undefined
        if (taxState === null || taxState === undefined) {
            throw new Error('Required parameter taxState was null or undefined when calling deleteTaxProviderSelfState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxState,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the Avalara tax provider
     * Retrieves the Avalara tax provider. 
     */
    public getTaxProviderAvalara () : Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns Avalara Tax companies configured by the merchant
     * Returns Avalara Tax companies configured by the merchant 
     * @param taxProviderAvalara TaxProviderAvalara object
     */
    public getTaxProviderAvalaraCompanies (taxProviderAvalara: TaxProviderAvalara) : Promise<{ response: http.ClientResponse; body: TaxProviderAvalaraCompaniesResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara/companies';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taxProviderAvalara' is not null or undefined
        if (taxProviderAvalara === null || taxProviderAvalara === undefined) {
            throw new Error('Required parameter taxProviderAvalara was null or undefined when calling getTaxProviderAvalaraCompanies.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxProviderAvalara,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderAvalaraCompaniesResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Attempts to connect to Avalara and returns back the response
     * Attempts to connect to Avalara and returns back the response. 
     */
    public getTaxProviderAvalaraTest () : Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara/test';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the Self tax provider
     * Retrieves the Self tax provider. 
     */
    public getTaxProviderSelf () : Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }> {
        const localVarPath = this.basePath + '/tax/providers/self';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the Self tax provider countries
     * Retrieves the Self tax provider countries. 
     */
    public getTaxProviderSelfCountries () : Promise<{ response: http.ClientResponse; body: TaxProviderSelfCountriesResponse;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/countries';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelfCountriesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the Self tax provider regions for a given country code
     * Retrieves the Self tax provider regions for a given country code. 
     * @param countryCode The country code regions desired.
     */
    public getTaxProviderSelfRegionsByCountryCode (countryCode: string) : Promise<{ response: http.ClientResponse; body: TaxProviderSelfRegionsResponse;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/regions/{countryCode}'
            .replace('{' + 'countryCode' + '}', String(countryCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling getTaxProviderSelfRegionsByCountryCode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelfRegionsResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the TaxJar tax provider
     * Retrieves the TaxJar tax provider. 
     */
    public getTaxProviderTaxJar () : Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }> {
        const localVarPath = this.basePath + '/tax/providers/taxjar';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Attempts to connect to TaxJar and returns back the response
     * Attempts to connect to TaxJar and returns back the response. 
     */
    public getTaxProviderTaxJarTest () : Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/taxjar/test';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTestResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the UltraCart tax provider
     * Retrieves the UltraCart tax provider. 
     */
    public getTaxProviderUltraCart () : Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }> {
        const localVarPath = this.basePath + '/tax/providers/ultracart';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve tax methods
     * Retrieves tax methods for this account. 
     * @param limit The maximum number of records to return on this one API call. (Max 200)
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param expand The object expansion to perform on the result.  See documentation for examples
     */
    public getTaxProviders (limit?: number, offset?: number, expand?: string) : Promise<{ response: http.ClientResponse; body: TaxProvidersResponse;  }> {
        const localVarPath = this.basePath + '/tax/providers';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (expand !== undefined) {
            queryParameters['_expand'] = expand;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProvidersResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Toggle a tax provider to active
     * Toggle a tax provider to active. 
     * @param providerName The tax provider to set active.
     */
    public setActiveTaxProvider (providerName: string) : Promise<{ response: http.ClientResponse; body: TaxProviderActivateResult;  }> {
        const localVarPath = this.basePath + '/tax/providers/setActive/{providerName}'
            .replace('{' + 'providerName' + '}', String(providerName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'providerName' is not null or undefined
        if (providerName === null || providerName === undefined) {
            throw new Error('Required parameter providerName was null or undefined when calling setActiveTaxProvider.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderActivateResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the Avalara tax provider
     * Update the Avalara tax provider. 
     * @param taxProviderAvalara TaxProviderAvalara object
     */
    public updateTaxProviderAvalara (taxProviderAvalara: TaxProviderAvalara) : Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }> {
        const localVarPath = this.basePath + '/tax/providers/avalara';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taxProviderAvalara' is not null or undefined
        if (taxProviderAvalara === null || taxProviderAvalara === undefined) {
            throw new Error('Required parameter taxProviderAvalara was null or undefined when calling updateTaxProviderAvalara.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxProviderAvalara,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderAvalara;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the Self tax provider
     * Update the Self tax provider. 
     * @param taxProviderSelf TaxProviderSelf object
     */
    public updateTaxProviderSelf (taxProviderSelf: TaxProviderSelf) : Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }> {
        const localVarPath = this.basePath + '/tax/providers/self';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taxProviderSelf' is not null or undefined
        if (taxProviderSelf === null || taxProviderSelf === undefined) {
            throw new Error('Required parameter taxProviderSelf was null or undefined when calling updateTaxProviderSelf.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxProviderSelf,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderSelf;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider city
     * Updates a Self tax provider city. 
     * @param city The city being updated.
     * @param taxCity tax city to be updated
     */
    public updateTaxProviderSelfCity (city: string, taxCity: TaxCity) : Promise<{ response: http.ClientResponse; body: TaxCity;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/city/{city}'
            .replace('{' + 'city' + '}', String(city));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'city' is not null or undefined
        if (city === null || city === undefined) {
            throw new Error('Required parameter city was null or undefined when calling updateTaxProviderSelfCity.');
        }

        // verify required parameter 'taxCity' is not null or undefined
        if (taxCity === null || taxCity === undefined) {
            throw new Error('Required parameter taxCity was null or undefined when calling updateTaxProviderSelfCity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxCity,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxCity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider country
     * Updates a Self tax provider country. 
     * @param countryCode The country code being updated.
     * @param taxCountry tax country to be updated
     */
    public updateTaxProviderSelfCountry (countryCode: string, taxCountry: TaxCountry) : Promise<{ response: http.ClientResponse; body: TaxCountry;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/country/{countryCode}'
            .replace('{' + 'countryCode' + '}', String(countryCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'countryCode' is not null or undefined
        if (countryCode === null || countryCode === undefined) {
            throw new Error('Required parameter countryCode was null or undefined when calling updateTaxProviderSelfCountry.');
        }

        // verify required parameter 'taxCountry' is not null or undefined
        if (taxCountry === null || taxCountry === undefined) {
            throw new Error('Required parameter taxCountry was null or undefined when calling updateTaxProviderSelfCountry.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxCountry,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxCountry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider county
     * Updates a Self tax provider county. 
     * @param county The county being updated.
     * @param taxCounty tax county to be updated
     */
    public updateTaxProviderSelfCounty (county: string, taxCounty: TaxCounty) : Promise<{ response: http.ClientResponse; body: TaxCounty;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/county/{county}'
            .replace('{' + 'county' + '}', String(county));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'county' is not null or undefined
        if (county === null || county === undefined) {
            throw new Error('Required parameter county was null or undefined when calling updateTaxProviderSelfCounty.');
        }

        // verify required parameter 'taxCounty' is not null or undefined
        if (taxCounty === null || taxCounty === undefined) {
            throw new Error('Required parameter taxCounty was null or undefined when calling updateTaxProviderSelfCounty.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxCounty,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxCounty;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider postalCode
     * Updates a Self tax provider postalCode. 
     * @param postalCode The postal code being updated.
     * @param taxPostalCode tax postal code to be updated
     */
    public updateTaxProviderSelfPostalCode (postalCode: string, taxPostalCode: TaxPostalCode) : Promise<{ response: http.ClientResponse; body: TaxPostalCode;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/postalCode/{postal_code}'
            .replace('{' + 'postal_code' + '}', String(postalCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'postalCode' is not null or undefined
        if (postalCode === null || postalCode === undefined) {
            throw new Error('Required parameter postalCode was null or undefined when calling updateTaxProviderSelfPostalCode.');
        }

        // verify required parameter 'taxPostalCode' is not null or undefined
        if (taxPostalCode === null || taxPostalCode === undefined) {
            throw new Error('Required parameter taxPostalCode was null or undefined when calling updateTaxProviderSelfPostalCode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxPostalCode,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxPostalCode;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a Self tax provider state
     * Updates a Self tax provider state. 
     * @param stateCode The state code being updated.
     * @param taxState tax state to be updated
     */
    public updateTaxProviderSelfState (stateCode: string, taxState: TaxState) : Promise<{ response: http.ClientResponse; body: TaxState;  }> {
        const localVarPath = this.basePath + '/tax/providers/self/state/{stateCode}'
            .replace('{' + 'stateCode' + '}', String(stateCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'stateCode' is not null or undefined
        if (stateCode === null || stateCode === undefined) {
            throw new Error('Required parameter stateCode was null or undefined when calling updateTaxProviderSelfState.');
        }

        // verify required parameter 'taxState' is not null or undefined
        if (taxState === null || taxState === undefined) {
            throw new Error('Required parameter taxState was null or undefined when calling updateTaxProviderSelfState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxState,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxState;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the TaxJar tax provider
     * Update the TaxJar tax provider. 
     * @param taxProviderTaxJar TaxProviderTaxJar object
     */
    public updateTaxProviderTaxJar (taxProviderTaxJar: TaxProviderTaxJar) : Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }> {
        const localVarPath = this.basePath + '/tax/providers/taxjar';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taxProviderTaxJar' is not null or undefined
        if (taxProviderTaxJar === null || taxProviderTaxJar === undefined) {
            throw new Error('Required parameter taxProviderTaxJar was null or undefined when calling updateTaxProviderTaxJar.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxProviderTaxJar,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderTaxJar;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the UltraCart tax provider
     * Update the UltraCart tax provider. 
     * @param taxProviderUltracart TaxProviderUltraCart object
     */
    public updateTaxProviderUltraCart (taxProviderUltracart: TaxProviderUltraCart) : Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }> {
        const localVarPath = this.basePath + '/tax/providers/ultracart';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taxProviderUltracart' is not null or undefined
        if (taxProviderUltracart === null || taxProviderUltracart === undefined) {
            throw new Error('Required parameter taxProviderUltracart was null or undefined when calling updateTaxProviderUltraCart.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxProviderUltracart,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TaxProviderUltraCart;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhookApiApiKeys {
    ultraCartBrowserApiKey,
    ultraCartSimpleApiKey,
}

export class WebhookApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'ultraCartBrowserApiKey': new ApiKeyAuth('header', 'x-ultracart-browser-key'),
        'ultraCartOauth': new OAuth(),
        'ultraCartSimpleApiKey': new ApiKeyAuth('header', 'x-ultracart-simple-key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WebhookApiApiKeys, value: string) {
        this.authentications[WebhookApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.ultraCartOauth.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a webhook
     * Delete a webhook on the UltraCart account. 
     * @param webhookOid The webhook oid to delete.
     */
    public deleteWebhook (webhookOid: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling deleteWebhook.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a webhook by URL
     * Delete a webhook based upon the URL on the webhook_url matching an existing webhook. 
     * @param webhook Webhook to delete
     */
    public deleteWebhookByUrl (webhook: Webhook) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling deleteWebhookByUrl.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhook,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an individual log
     * Retrieves an individual log for a webhook given the webhook oid the request id. 
     * @param webhookOid The webhook oid that owns the log.
     * @param requestId The request id associated with the log to view.
     */
    public getWebhookLog (webhookOid: number, requestId: string) : Promise<{ response: http.ClientResponse; body: WebhookLogResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/logs/{requestId}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid))
            .replace('{' + 'requestId' + '}', String(requestId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling getWebhookLog.');
        }

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getWebhookLog.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookLogResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the log summaries
     * Retrieves the log summary information for a given webhook.  This is useful for displaying all the various logs that can be viewed. 
     * @param webhookOid The webhook oid to retrieve log summaries for.
     * @param limit The maximum number of records to return on this one API call.
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param since Fetch log summaries that have been delivered since this date/time.
     */
    public getWebhookLogSummaries (webhookOid: number, limit?: number, offset?: number, since?: string) : Promise<{ response: http.ClientResponse; body: WebhookLogSummariesResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/logs'
            .replace('{' + 'webhookOid' + '}', String(webhookOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling getWebhookLogSummaries.');
        }

        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (since !== undefined) {
            queryParameters['_since'] = since;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookLogSummariesResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve webhooks
     * Retrieves the webhooks associated with this application. 
     * @param limit The maximum number of records to return on this one API call.
     * @param offset Pagination of the record set.  Offset is a zero based index.
     * @param sort The sort order of the webhooks.  See documentation for examples
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public getWebhooks (limit?: number, offset?: number, sort?: string, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: WebhooksResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['_limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['_offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['_sort'] = sort;
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhooksResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a webhook
     * Adds a new webhook on the account.  If you add a new webhook with the authentication_type set to basic, but do not specify the basic_username and basic_password, UltraCart will automatically generate random ones and return them.  This allows your application to have simpler logic on the setup of a secure webhook. 
     * @param webhook Webhook to create
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public insertWebhook (webhook: Webhook, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling insertWebhook.');
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhook,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Resend events to the webhook endpoint.
     * This method will resend events to the webhook endpoint.  This method can be used for example to send all the existing items on an account to a webhook. 
     * @param webhookOid The webhook oid that is receiving the reflowed events.
     * @param eventName The event to reflow.
     */
    public resendEvent (webhookOid: number, eventName: string) : Promise<{ response: http.ClientResponse; body: WebhookSampleRequestResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}/reflow/{eventName}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid))
            .replace('{' + 'eventName' + '}', String(eventName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling resendEvent.');
        }

        // verify required parameter 'eventName' is not null or undefined
        if (eventName === null || eventName === undefined) {
            throw new Error('Required parameter eventName was null or undefined when calling resendEvent.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookSampleRequestResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a webhook
     * Update a webhook on the account 
     * @param webhook Webhook to update
     * @param webhookOid The webhook oid to update.
     * @param placeholders Whether or not placeholder values should be returned in the result.  Useful for UIs that consume this REST API.
     */
    public updateWebhook (webhook: Webhook, webhookOid: number, placeholders?: boolean) : Promise<{ response: http.ClientResponse; body: WebhookResponse;  }> {
        const localVarPath = this.basePath + '/webhook/webhooks/{webhookOid}'
            .replace('{' + 'webhookOid' + '}', String(webhookOid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling updateWebhook.');
        }

        // verify required parameter 'webhookOid' is not null or undefined
        if (webhookOid === null || webhookOid === undefined) {
            throw new Error('Required parameter webhookOid was null or undefined when calling updateWebhook.');
        }

        if (placeholders !== undefined) {
            queryParameters['_placeholders'] = placeholders;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhook,
        };

        this.authentications.ultraCartOauth.applyToRequest(requestOptions);

        this.authentications.ultraCartSimpleApiKey.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: WebhookResponse;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
