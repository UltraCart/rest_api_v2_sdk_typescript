/* tslint:disable */
/* eslint-disable */
/**
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Cart,
    CartFromJSON,
    CartToJSON,
    CartAffirmCheckoutResponse,
    CartAffirmCheckoutResponseFromJSON,
    CartAffirmCheckoutResponseToJSON,
    CartFinalizeOrderRequest,
    CartFinalizeOrderRequestFromJSON,
    CartFinalizeOrderRequestToJSON,
    CartFinalizeOrderResponse,
    CartFinalizeOrderResponseFromJSON,
    CartFinalizeOrderResponseToJSON,
    CartProfileLoginRequest,
    CartProfileLoginRequestFromJSON,
    CartProfileLoginRequestToJSON,
    CartProfileLoginResponse,
    CartProfileLoginResponseFromJSON,
    CartProfileLoginResponseToJSON,
    CartProfileRegisterRequest,
    CartProfileRegisterRequestFromJSON,
    CartProfileRegisterRequestToJSON,
    CartProfileRegisterResponse,
    CartProfileRegisterResponseFromJSON,
    CartProfileRegisterResponseToJSON,
    CartResponse,
    CartResponseFromJSON,
    CartResponseToJSON,
    CartValidationRequest,
    CartValidationRequestFromJSON,
    CartValidationRequestToJSON,
    CartValidationResponse,
    CartValidationResponseFromJSON,
    CartValidationResponseToJSON,
    CheckoutAllowedCountriesResponse,
    CheckoutAllowedCountriesResponseFromJSON,
    CheckoutAllowedCountriesResponseToJSON,
    CheckoutHandoffRequest,
    CheckoutHandoffRequestFromJSON,
    CheckoutHandoffRequestToJSON,
    CheckoutHandoffResponse,
    CheckoutHandoffResponseFromJSON,
    CheckoutHandoffResponseToJSON,
    CheckoutSetupBrowserKeyRequest,
    CheckoutSetupBrowserKeyRequestFromJSON,
    CheckoutSetupBrowserKeyRequestToJSON,
    CheckoutSetupBrowserKeyResponse,
    CheckoutSetupBrowserKeyResponseFromJSON,
    CheckoutSetupBrowserKeyResponseToJSON,
    CheckoutStateProvinceResponse,
    CheckoutStateProvinceResponseFromJSON,
    CheckoutStateProvinceResponseToJSON,
    CityStateZip,
    CityStateZipFromJSON,
    CityStateZipToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    ItemsResponse,
    ItemsResponseFromJSON,
    ItemsResponseToJSON,
    RegisterAffiliateClickRequest,
    RegisterAffiliateClickRequestFromJSON,
    RegisterAffiliateClickRequestToJSON,
    RegisterAffiliateClickResponse,
    RegisterAffiliateClickResponseFromJSON,
    RegisterAffiliateClickResponseToJSON,
} from '../models';

export interface CityStateRequest {
    cart: Cart;
}

export interface FinalizeOrderRequest {
    finalizeRequest: CartFinalizeOrderRequest;
}

export interface GetAffirmCheckoutRequest {
    cartId: string;
}

export interface GetCartRequest {
    expand?: string;
}

export interface GetCartByCartIdRequest {
    cartId: string;
    expand?: string;
}

export interface GetCartByReturnCodeRequest {
    returnCode: string;
    expand?: string;
}

export interface GetCartByReturnTokenRequest {
    returnToken?: string;
    expand?: string;
}

export interface GetStateProvincesForCountryRequest {
    countryCode: string;
}

export interface HandoffCartRequest {
    handoffRequest: CheckoutHandoffRequest;
    expand?: string;
}

export interface LoginRequest {
    loginRequest: CartProfileLoginRequest;
    expand?: string;
}

export interface LogoutRequest {
    cart: Cart;
    expand?: string;
}

export interface RegisterRequest {
    registerRequest: CartProfileRegisterRequest;
    expand?: string;
}

export interface RegisterAffiliateClickOperationRequest {
    registerAffiliateClickRequest: RegisterAffiliateClickRequest;
    expand?: string;
}

export interface RelatedItemsForCartRequest {
    cart: Cart;
    expand?: string;
}

export interface RelatedItemsForItemRequest {
    itemId: string;
    cart: Cart;
    expand?: string;
}

export interface SetupBrowserKeyRequest {
    browserKeyRequest: CheckoutSetupBrowserKeyRequest;
}

export interface UpdateCartRequest {
    cart: Cart;
    expand?: string;
}

export interface ValidateCartRequest {
    validationRequest: CartValidationRequest;
    expand?: string;
}

/**
 * CheckoutApi - interface
 * 
 * @export
 * @interface CheckoutApiInterface
 */
export interface CheckoutApiInterface {
    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * @summary City/State for Zip
     * @param {Cart} cart Cart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    cityStateRaw(requestParameters: CityStateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CityStateZip>>;

    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * City/State for Zip
     */
    cityState(requestParameters: CityStateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CityStateZip>;

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * @summary Finalize Order
     * @param {CartFinalizeOrderRequest} finalizeRequest Finalize request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    finalizeOrderRaw(requestParameters: FinalizeOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartFinalizeOrderResponse>>;

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * Finalize Order
     */
    finalizeOrder(requestParameters: FinalizeOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartFinalizeOrderResponse>;

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * @summary Get affirm checkout (by cart id)
     * @param {string} cartId Cart ID to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getAffirmCheckoutRaw(requestParameters: GetAffirmCheckoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartAffirmCheckoutResponse>>;

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * Get affirm checkout (by cart id)
     */
    getAffirmCheckout(requestParameters: GetAffirmCheckoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartAffirmCheckoutResponse>;

    /**
     * Lookup the allowed countries for this merchant id 
     * @summary Allowed countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getAllowedCountriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutAllowedCountriesResponse>>;

    /**
     * Lookup the allowed countries for this merchant id 
     * Allowed countries
     */
    getAllowedCountries(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutAllowedCountriesResponse>;

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * @summary Get cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartRaw(requestParameters: GetCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>>;

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * Get cart
     */
    getCart(requestParameters: GetCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse>;

    /**
     * Get a cart specified by the cart_id parameter. 
     * @summary Get cart (by cart id)
     * @param {string} cartId Cart ID to retrieve
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByCartIdRaw(requestParameters: GetCartByCartIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>>;

    /**
     * Get a cart specified by the cart_id parameter. 
     * Get cart (by cart id)
     */
    getCartByCartId(requestParameters: GetCartByCartIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse>;

    /**
     * Get a cart specified by the return code parameter. 
     * @summary Get cart (by return code)
     * @param {string} returnCode Return code to lookup cart ID by
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByReturnCodeRaw(requestParameters: GetCartByReturnCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>>;

    /**
     * Get a cart specified by the return code parameter. 
     * Get cart (by return code)
     */
    getCartByReturnCode(requestParameters: GetCartByReturnCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse>;

    /**
     * Get a cart specified by the encrypted return token parameter. 
     * @summary Get cart (by return token)
     * @param {string} [returnToken] Return token provided by StoreFront Communications
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getCartByReturnTokenRaw(requestParameters: GetCartByReturnTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>>;

    /**
     * Get a cart specified by the encrypted return token parameter. 
     * Get cart (by return token)
     */
    getCartByReturnToken(requestParameters: GetCartByReturnTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse>;

    /**
     * Lookup a state/province list for a given country code 
     * @summary Get state/province list for a country code
     * @param {string} countryCode Two letter ISO country code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    getStateProvincesForCountryRaw(requestParameters: GetStateProvincesForCountryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutStateProvinceResponse>>;

    /**
     * Lookup a state/province list for a given country code 
     * Get state/province list for a country code
     */
    getStateProvincesForCountry(requestParameters: GetStateProvincesForCountryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutStateProvinceResponse>;

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
     * @summary Handoff cart
     * @param {CheckoutHandoffRequest} handoffRequest Handoff request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    handoffCartRaw(requestParameters: HandoffCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutHandoffResponse>>;

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
     * Handoff cart
     */
    handoffCart(requestParameters: HandoffCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutHandoffResponse>;

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * @summary Profile login
     * @param {CartProfileLoginRequest} loginRequest Login request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartProfileLoginResponse>>;

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * Profile login
     */
    login(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartProfileLoginResponse>;

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * @summary Profile logout
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    logoutRaw(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>>;

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * Profile logout
     */
    logout(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse>;

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * @summary Profile registration
     * @param {CartProfileRegisterRequest} registerRequest Register request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    registerRaw(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartProfileRegisterResponse>>;

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * Profile registration
     */
    register(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartProfileRegisterResponse>;

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * @summary Register affiliate click
     * @param {RegisterAffiliateClickRequest} registerAffiliateClickRequest Register affiliate click request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    registerAffiliateClickRaw(requestParameters: RegisterAffiliateClickOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegisterAffiliateClickResponse>>;

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * Register affiliate click
     */
    registerAffiliateClick(requestParameters: RegisterAffiliateClickOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegisterAffiliateClickResponse>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    relatedItemsForCartRaw(requestParameters: RelatedItemsForCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemsResponse>>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * Related items
     */
    relatedItemsForCart(requestParameters: RelatedItemsForCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemsResponse>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * @summary Related items (specific item)
     * @param {string} itemId Item ID to retrieve related items for
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See item resource documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    relatedItemsForItemRaw(requestParameters: RelatedItemsForItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemsResponse>>;

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * Related items (specific item)
     */
    relatedItemsForItem(requestParameters: RelatedItemsForItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemsResponse>;

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * @summary Setup Browser Application
     * @param {CheckoutSetupBrowserKeyRequest} browserKeyRequest Setup browser key request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    setupBrowserKeyRaw(requestParameters: SetupBrowserKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutSetupBrowserKeyResponse>>;

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * Setup Browser Application
     */
    setupBrowserKey(requestParameters: SetupBrowserKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutSetupBrowserKeyResponse>;

    /**
     * Update the cart. 
     * @summary Update cart
     * @param {Cart} cart Cart
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    updateCartRaw(requestParameters: UpdateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>>;

    /**
     * Update the cart. 
     * Update cart
     */
    updateCart(requestParameters: UpdateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse>;

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * @summary Validate
     * @param {CartValidationRequest} validationRequest Validation request
     * @param {string} [expand] The object expansion to perform on the result.  See documentation for examples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApiInterface
     */
    validateCartRaw(requestParameters: ValidateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartValidationResponse>>;

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * Validate
     */
    validateCart(requestParameters: ValidateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartValidationResponse>;

}

/**
 * 
 */
export class CheckoutApi extends runtime.BaseAPI implements CheckoutApiInterface {

    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * City/State for Zip
     */
    async cityStateRaw(requestParameters: CityStateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CityStateZip>> {
        if (requestParameters.cart === null || requestParameters.cart === undefined) {
            throw new runtime.RequiredError('cart','Required parameter requestParameters.cart was null or undefined when calling cityState.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/city_state`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartToJSON(requestParameters.cart),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CityStateZipFromJSON(jsonValue));
    }

    /**
     * Look up the city and state for the shipping zip code.  Useful for building an auto complete for parts of the shipping address 
     * City/State for Zip
     */
    async cityState(requestParameters: CityStateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CityStateZip> {
        const response = await this.cityStateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * Finalize Order
     */
    async finalizeOrderRaw(requestParameters: FinalizeOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartFinalizeOrderResponse>> {
        if (requestParameters.finalizeRequest === null || requestParameters.finalizeRequest === undefined) {
            throw new runtime.RequiredError('finalizeRequest','Required parameter requestParameters.finalizeRequest was null or undefined when calling finalizeOrder.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/finalizeOrder`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartFinalizeOrderRequestToJSON(requestParameters.finalizeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartFinalizeOrderResponseFromJSON(jsonValue));
    }

    /**
     * Finalize the cart into an order.  This method can not be called with browser key authentication.  It is ONLY meant for server side code to call. 
     * Finalize Order
     */
    async finalizeOrder(requestParameters: FinalizeOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartFinalizeOrderResponse> {
        const response = await this.finalizeOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * Get affirm checkout (by cart id)
     */
    async getAffirmCheckoutRaw(requestParameters: GetAffirmCheckoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartAffirmCheckoutResponse>> {
        if (requestParameters.cartId === null || requestParameters.cartId === undefined) {
            throw new runtime.RequiredError('cartId','Required parameter requestParameters.cartId was null or undefined when calling getAffirmCheckout.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/{cart_id}/affirmCheckout`.replace(`{${"cart_id"}}`, encodeURIComponent(String(requestParameters.cartId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartAffirmCheckoutResponseFromJSON(jsonValue));
    }

    /**
     * Get a Affirm checkout object for the specified cart_id parameter. 
     * Get affirm checkout (by cart id)
     */
    async getAffirmCheckout(requestParameters: GetAffirmCheckoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartAffirmCheckoutResponse> {
        const response = await this.getAffirmCheckoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lookup the allowed countries for this merchant id 
     * Allowed countries
     */
    async getAllowedCountriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutAllowedCountriesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/allowedCountries`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckoutAllowedCountriesResponseFromJSON(jsonValue));
    }

    /**
     * Lookup the allowed countries for this merchant id 
     * Allowed countries
     */
    async getAllowedCountries(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutAllowedCountriesResponse> {
        const response = await this.getAllowedCountriesRaw(initOverrides);
        return await response.value();
    }

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * Get cart
     */
    async getCartRaw(requestParameters: GetCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>> {
        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartResponseFromJSON(jsonValue));
    }

    /**
     * If the cookie is set on the browser making the request then it will return their active cart.  Otherwise it will create a new cart. 
     * Get cart
     */
    async getCart(requestParameters: GetCartRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse> {
        const response = await this.getCartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a cart specified by the cart_id parameter. 
     * Get cart (by cart id)
     */
    async getCartByCartIdRaw(requestParameters: GetCartByCartIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>> {
        if (requestParameters.cartId === null || requestParameters.cartId === undefined) {
            throw new runtime.RequiredError('cartId','Required parameter requestParameters.cartId was null or undefined when calling getCartByCartId.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/{cart_id}`.replace(`{${"cart_id"}}`, encodeURIComponent(String(requestParameters.cartId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartResponseFromJSON(jsonValue));
    }

    /**
     * Get a cart specified by the cart_id parameter. 
     * Get cart (by cart id)
     */
    async getCartByCartId(requestParameters: GetCartByCartIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse> {
        const response = await this.getCartByCartIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a cart specified by the return code parameter. 
     * Get cart (by return code)
     */
    async getCartByReturnCodeRaw(requestParameters: GetCartByReturnCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>> {
        if (requestParameters.returnCode === null || requestParameters.returnCode === undefined) {
            throw new runtime.RequiredError('returnCode','Required parameter requestParameters.returnCode was null or undefined when calling getCartByReturnCode.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/return/{return_code}`.replace(`{${"return_code"}}`, encodeURIComponent(String(requestParameters.returnCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartResponseFromJSON(jsonValue));
    }

    /**
     * Get a cart specified by the return code parameter. 
     * Get cart (by return code)
     */
    async getCartByReturnCode(requestParameters: GetCartByReturnCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse> {
        const response = await this.getCartByReturnCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a cart specified by the encrypted return token parameter. 
     * Get cart (by return token)
     */
    async getCartByReturnTokenRaw(requestParameters: GetCartByReturnTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>> {
        const queryParameters: any = {};

        if (requestParameters.returnToken !== undefined) {
            queryParameters['return_token'] = requestParameters.returnToken;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/return_token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartResponseFromJSON(jsonValue));
    }

    /**
     * Get a cart specified by the encrypted return token parameter. 
     * Get cart (by return token)
     */
    async getCartByReturnToken(requestParameters: GetCartByReturnTokenRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse> {
        const response = await this.getCartByReturnTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lookup a state/province list for a given country code 
     * Get state/province list for a country code
     */
    async getStateProvincesForCountryRaw(requestParameters: GetStateProvincesForCountryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutStateProvinceResponse>> {
        if (requestParameters.countryCode === null || requestParameters.countryCode === undefined) {
            throw new runtime.RequiredError('countryCode','Required parameter requestParameters.countryCode was null or undefined when calling getStateProvincesForCountry.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/stateProvincesForCountry/{country_code}`.replace(`{${"country_code"}}`, encodeURIComponent(String(requestParameters.countryCode))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckoutStateProvinceResponseFromJSON(jsonValue));
    }

    /**
     * Lookup a state/province list for a given country code 
     * Get state/province list for a country code
     */
    async getStateProvincesForCountry(requestParameters: GetStateProvincesForCountryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutStateProvinceResponse> {
        const response = await this.getStateProvincesForCountryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
     * Handoff cart
     */
    async handoffCartRaw(requestParameters: HandoffCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutHandoffResponse>> {
        if (requestParameters.handoffRequest === null || requestParameters.handoffRequest === undefined) {
            throw new runtime.RequiredError('handoffRequest','Required parameter requestParameters.handoffRequest was null or undefined when calling handoffCart.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/handoff`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CheckoutHandoffRequestToJSON(requestParameters.handoffRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckoutHandoffResponseFromJSON(jsonValue));
    }

    /**
     * Handoff the browser to UltraCart for view cart on StoreFront, transfer to PayPal, transfer to Affirm, transfer to Sezzle or finalization of the order (including upsell processing). 
     * Handoff cart
     */
    async handoffCart(requestParameters: HandoffCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutHandoffResponse> {
        const response = await this.handoffCartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * Profile login
     */
    async loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartProfileLoginResponse>> {
        if (requestParameters.loginRequest === null || requestParameters.loginRequest === undefined) {
            throw new runtime.RequiredError('loginRequest','Required parameter requestParameters.loginRequest was null or undefined when calling login.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/profile/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartProfileLoginRequestToJSON(requestParameters.loginRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartProfileLoginResponseFromJSON(jsonValue));
    }

    /**
     * Login in to the customer profile specified by cart.billing.email and password 
     * Profile login
     */
    async login(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartProfileLoginResponse> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * Profile logout
     */
    async logoutRaw(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>> {
        if (requestParameters.cart === null || requestParameters.cart === undefined) {
            throw new runtime.RequiredError('cart','Required parameter requestParameters.cart was null or undefined when calling logout.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/profile/logout`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartToJSON(requestParameters.cart),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartResponseFromJSON(jsonValue));
    }

    /**
     * Log the cart out of the current profile.  No error will occur if they are not logged in. 
     * Profile logout
     */
    async logout(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse> {
        const response = await this.logoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * Profile registration
     */
    async registerRaw(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartProfileRegisterResponse>> {
        if (requestParameters.registerRequest === null || requestParameters.registerRequest === undefined) {
            throw new runtime.RequiredError('registerRequest','Required parameter requestParameters.registerRequest was null or undefined when calling register.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/profile/register`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartProfileRegisterRequestToJSON(requestParameters.registerRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartProfileRegisterResponseFromJSON(jsonValue));
    }

    /**
     * Register a new customer profile.  Requires the cart.billing object to be populated along with the password. 
     * Profile registration
     */
    async register(requestParameters: RegisterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartProfileRegisterResponse> {
        const response = await this.registerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * Register affiliate click
     */
    async registerAffiliateClickRaw(requestParameters: RegisterAffiliateClickOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegisterAffiliateClickResponse>> {
        if (requestParameters.registerAffiliateClickRequest === null || requestParameters.registerAffiliateClickRequest === undefined) {
            throw new runtime.RequiredError('registerAffiliateClickRequest','Required parameter requestParameters.registerAffiliateClickRequest was null or undefined when calling registerAffiliateClick.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/affiliateClick/register`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterAffiliateClickRequestToJSON(requestParameters.registerAffiliateClickRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegisterAffiliateClickResponseFromJSON(jsonValue));
    }

    /**
     * Register an affiliate click.  Used by custom checkouts that are completely API based and do not perform checkout handoff. 
     * Register affiliate click
     */
    async registerAffiliateClick(requestParameters: RegisterAffiliateClickOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegisterAffiliateClickResponse> {
        const response = await this.registerAffiliateClickRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * Related items
     */
    async relatedItemsForCartRaw(requestParameters: RelatedItemsForCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemsResponse>> {
        if (requestParameters.cart === null || requestParameters.cart === undefined) {
            throw new runtime.RequiredError('cart','Required parameter requestParameters.cart was null or undefined when calling relatedItemsForCart.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/related_items`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartToJSON(requestParameters.cart),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * Related items
     */
    async relatedItemsForCart(requestParameters: RelatedItemsForCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemsResponse> {
        const response = await this.relatedItemsForCartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * Related items (specific item)
     */
    async relatedItemsForItemRaw(requestParameters: RelatedItemsForItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemsResponse>> {
        if (requestParameters.itemId === null || requestParameters.itemId === undefined) {
            throw new runtime.RequiredError('itemId','Required parameter requestParameters.itemId was null or undefined when calling relatedItemsForItem.');
        }

        if (requestParameters.cart === null || requestParameters.cart === undefined) {
            throw new runtime.RequiredError('cart','Required parameter requestParameters.cart was null or undefined when calling relatedItemsForItem.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/relatedItems/{item_id}`.replace(`{${"item_id"}}`, encodeURIComponent(String(requestParameters.itemId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartToJSON(requestParameters.cart),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all the related items for the cart contents.  Expansion is limited to content, content.assignments, content.attributes, content.multimedia, content.multimedia.thumbnails, options, pricing, and pricing.tiers. 
     * Related items (specific item)
     */
    async relatedItemsForItem(requestParameters: RelatedItemsForItemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemsResponse> {
        const response = await this.relatedItemsForItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * Setup Browser Application
     */
    async setupBrowserKeyRaw(requestParameters: SetupBrowserKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckoutSetupBrowserKeyResponse>> {
        if (requestParameters.browserKeyRequest === null || requestParameters.browserKeyRequest === undefined) {
            throw new runtime.RequiredError('browserKeyRequest','Required parameter requestParameters.browserKeyRequest was null or undefined when calling setupBrowserKey.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/browser_key`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CheckoutSetupBrowserKeyRequestToJSON(requestParameters.browserKeyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckoutSetupBrowserKeyResponseFromJSON(jsonValue));
    }

    /**
     * Setup a browser key authenticated application with checkout permissions.  This REST call must be made with an authentication scheme that is not browser key.  The new application will be linked to the application that makes this call.  If this application is disabled / deleted, then so will the application setup by this call.  The purpose of this call is to allow an OAuth application, such as the Wordpress plugin, to setup the proper browser based authentication for the REST checkout API to use. 
     * Setup Browser Application
     */
    async setupBrowserKey(requestParameters: SetupBrowserKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckoutSetupBrowserKeyResponse> {
        const response = await this.setupBrowserKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the cart. 
     * Update cart
     */
    async updateCartRaw(requestParameters: UpdateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartResponse>> {
        if (requestParameters.cart === null || requestParameters.cart === undefined) {
            throw new runtime.RequiredError('cart','Required parameter requestParameters.cart was null or undefined when calling updateCart.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CartToJSON(requestParameters.cart),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartResponseFromJSON(jsonValue));
    }

    /**
     * Update the cart. 
     * Update cart
     */
    async updateCart(requestParameters: UpdateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartResponse> {
        const response = await this.updateCartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * Validate
     */
    async validateCartRaw(requestParameters: ValidateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CartValidationResponse>> {
        if (requestParameters.validationRequest === null || requestParameters.validationRequest === undefined) {
            throw new runtime.RequiredError('validationRequest','Required parameter requestParameters.validationRequest was null or undefined when calling validateCart.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['_expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-browser-key"] = this.configuration.apiKey("x-ultracart-browser-key"); // ultraCartBrowserApiKey authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["checkout_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/checkout/cart/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CartValidationRequestToJSON(requestParameters.validationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CartValidationResponseFromJSON(jsonValue));
    }

    /**
     * Validate the cart for errors.  Specific checks can be passed and multiple validations can occur throughout your checkout flow. 
     * Validate
     */
    async validateCart(requestParameters: ValidateCartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CartValidationResponse> {
        const response = await this.validateCartRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
