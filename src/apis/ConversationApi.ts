/* tslint:disable */
/* eslint-disable */
/**
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ConversationAgentAuthResponse,
    ConversationAgentAuthResponseFromJSON,
    ConversationAgentAuthResponseToJSON,
    ConversationMessagesResponse,
    ConversationMessagesResponseFromJSON,
    ConversationMessagesResponseToJSON,
    ConversationMultimediaUploadUrlResponse,
    ConversationMultimediaUploadUrlResponseFromJSON,
    ConversationMultimediaUploadUrlResponseToJSON,
    ConversationResponse,
    ConversationResponseFromJSON,
    ConversationResponseToJSON,
    ConversationStartRequest,
    ConversationStartRequestFromJSON,
    ConversationStartRequestToJSON,
    ConversationStartResponse,
    ConversationStartResponseFromJSON,
    ConversationStartResponseToJSON,
    ConversationWebchatContext,
    ConversationWebchatContextFromJSON,
    ConversationWebchatContextToJSON,
    ConversationWebchatQueueStatusUpdateRequest,
    ConversationWebchatQueueStatusUpdateRequestFromJSON,
    ConversationWebchatQueueStatusUpdateRequestToJSON,
    ConversationWebchatQueueStatusesResponse,
    ConversationWebchatQueueStatusesResponseFromJSON,
    ConversationWebchatQueueStatusesResponseToJSON,
    ConversationsResponse,
    ConversationsResponseFromJSON,
    ConversationsResponseToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
} from '../models';

export interface GetConversationRequest {
    conversationUuid: string;
    limit?: number;
}

export interface GetConversationContextRequest {
    conversationUuid: string;
}

export interface GetConversationMessagesRequest {
    conversationUuid: string;
    since: number;
    limit?: number;
}

export interface GetConversationMultimediaUploadUrlRequest {
    extension: string;
}

export interface GetConversationsRequest {
    medium?: string;
    before?: string;
    limit?: number;
    offset?: number;
}

export interface JoinConversationRequest {
    conversationUuid: string;
}

export interface LeaveConversationRequest {
    conversationUuid: string;
}

export interface MarkReadConversationRequest {
    conversationUuid: string;
}

export interface StartConversationRequest {
    startRequest: ConversationStartRequest;
}

export interface UpdateConversationWebchatQueueStatusRequest {
    queueName: string;
    statusRequest: ConversationWebchatQueueStatusUpdateRequest;
}

/**
 * ConversationApi - interface
 * 
 * @export
 * @interface ConversationApiInterface
 */
export interface ConversationApiInterface {
    /**
     * Called periodically by the conversation API to keep the session alive. 
     * @summary Agent keep alive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentKeepAliveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Called periodically by the conversation API to keep the session alive. 
     * Agent keep alive
     */
    getAgentKeepAlive(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * @summary Get agent websocket authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentWebsocketAuthorizationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentAuthResponse>>;

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * Get agent websocket authorization
     */
    getAgentWebsocketAuthorization(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentAuthResponse>;

    /**
     * Retrieve a conversation including the participants and messages 
     * @summary Retrieve a conversation
     * @param {string} conversationUuid 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationRaw(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>>;

    /**
     * Retrieve a conversation including the participants and messages 
     * Retrieve a conversation
     */
    getConversation(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse>;

    /**
     * Get a webchat conversation context 
     * @summary Get a webchat conversation context
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationContextRaw(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatContext>>;

    /**
     * Get a webchat conversation context 
     * Get a webchat conversation context
     */
    getConversationContext(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatContext>;

    /**
     * Retrieve conversation messages since a particular time 
     * @summary Retrieve conversation messages
     * @param {string} conversationUuid 
     * @param {number} since 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationMessagesRaw(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMessagesResponse>>;

    /**
     * Retrieve conversation messages since a particular time 
     * Retrieve conversation messages
     */
    getConversationMessages(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMessagesResponse>;

    /**
     * Get a presigned conersation multimedia upload URL 
     * @summary Get a presigned conersation multimedia upload URL
     * @param {string} extension 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationMultimediaUploadUrlRaw(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMultimediaUploadUrlResponse>>;

    /**
     * Get a presigned conersation multimedia upload URL 
     * Get a presigned conersation multimedia upload URL
     */
    getConversationMultimediaUploadUrl(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMultimediaUploadUrlResponse>;

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * @summary Retrieve a conversation webchat queue statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationWebchatQueueStatusesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatQueueStatusesResponse>>;

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * Retrieve a conversation webchat queue statuses
     */
    getConversationWebchatQueueStatuses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatQueueStatusesResponse>;

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * @summary Retrieve a list of conversation summaries newest to oldest
     * @param {string} [medium] 
     * @param {string} [before] 
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationsRaw(requestParameters: GetConversationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationsResponse>>;

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * Retrieve a list of conversation summaries newest to oldest
     */
    getConversations(requestParameters: GetConversationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationsResponse>;

    /**
     * Join a conversation 
     * @summary Join a conversation
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    joinConversationRaw(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Join a conversation 
     * Join a conversation
     */
    joinConversation(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Leave a conversation 
     * @summary Leave a conversation
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    leaveConversationRaw(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Leave a conversation 
     * Leave a conversation
     */
    leaveConversation(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Mark a conversation as read 
     * @summary Mark a conversation as read
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    markReadConversationRaw(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Mark a conversation as read 
     * Mark a conversation as read
     */
    markReadConversation(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Start a new conversation 
     * @summary Start a conversation
     * @param {ConversationStartRequest} startRequest Start request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    startConversationRaw(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationStartResponse>>;

    /**
     * Start a new conversation 
     * Start a conversation
     */
    startConversation(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationStartResponse>;

    /**
     * Update status within the queue 
     * @summary Update status within the queue
     * @param {string} queueName 
     * @param {ConversationWebchatQueueStatusUpdateRequest} statusRequest Status request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateConversationWebchatQueueStatusRaw(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Update status within the queue 
     * Update status within the queue
     */
    updateConversationWebchatQueueStatus(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class ConversationApi extends runtime.BaseAPI implements ConversationApiInterface {

    /**
     * Called periodically by the conversation API to keep the session alive. 
     * Agent keep alive
     */
    async getAgentKeepAliveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/keepalive`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Called periodically by the conversation API to keep the session alive. 
     * Agent keep alive
     */
    async getAgentKeepAlive(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAgentKeepAliveRaw(initOverrides);
    }

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * Get agent websocket authorization
     */
    async getAgentWebsocketAuthorizationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentAuthResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/auth`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationAgentAuthResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * Get agent websocket authorization
     */
    async getAgentWebsocketAuthorization(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentAuthResponse> {
        const response = await this.getAgentWebsocketAuthorizationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a conversation including the participants and messages 
     * Retrieve a conversation
     */
    async getConversationRaw(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling getConversation.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a conversation including the participants and messages 
     * Retrieve a conversation
     */
    async getConversation(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse> {
        const response = await this.getConversationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a webchat conversation context 
     * Get a webchat conversation context
     */
    async getConversationContextRaw(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatContext>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling getConversationContext.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/context`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationWebchatContextFromJSON(jsonValue));
    }

    /**
     * Get a webchat conversation context 
     * Get a webchat conversation context
     */
    async getConversationContext(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatContext> {
        const response = await this.getConversationContextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve conversation messages since a particular time 
     * Retrieve conversation messages
     */
    async getConversationMessagesRaw(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMessagesResponse>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling getConversationMessages.');
        }

        if (requestParameters.since === null || requestParameters.since === undefined) {
            throw new runtime.RequiredError('since','Required parameter requestParameters.since was null or undefined when calling getConversationMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/messages/{since}`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))).replace(`{${"since"}}`, encodeURIComponent(String(requestParameters.since))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve conversation messages since a particular time 
     * Retrieve conversation messages
     */
    async getConversationMessages(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMessagesResponse> {
        const response = await this.getConversationMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a presigned conersation multimedia upload URL 
     * Get a presigned conersation multimedia upload URL
     */
    async getConversationMultimediaUploadUrlRaw(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMultimediaUploadUrlResponse>> {
        if (requestParameters.extension === null || requestParameters.extension === undefined) {
            throw new runtime.RequiredError('extension','Required parameter requestParameters.extension was null or undefined when calling getConversationMultimediaUploadUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/upload_url/{extension}`.replace(`{${"extension"}}`, encodeURIComponent(String(requestParameters.extension))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMultimediaUploadUrlResponseFromJSON(jsonValue));
    }

    /**
     * Get a presigned conersation multimedia upload URL 
     * Get a presigned conersation multimedia upload URL
     */
    async getConversationMultimediaUploadUrl(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMultimediaUploadUrlResponse> {
        const response = await this.getConversationMultimediaUploadUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * Retrieve a conversation webchat queue statuses
     */
    async getConversationWebchatQueueStatusesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatQueueStatusesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/queues/statuses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationWebchatQueueStatusesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * Retrieve a conversation webchat queue statuses
     */
    async getConversationWebchatQueueStatuses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatQueueStatusesResponse> {
        const response = await this.getConversationWebchatQueueStatusesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * Retrieve a list of conversation summaries newest to oldest
     */
    async getConversationsRaw(requestParameters: GetConversationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.medium !== undefined) {
            queryParameters['medium'] = requestParameters.medium;
        }

        if (requestParameters.before !== undefined) {
            queryParameters['before'] = requestParameters.before;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['_limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['_offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * Retrieve a list of conversation summaries newest to oldest
     */
    async getConversations(requestParameters: GetConversationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationsResponse> {
        const response = await this.getConversationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Join a conversation 
     * Join a conversation
     */
    async joinConversationRaw(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling joinConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/join`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Join a conversation 
     * Join a conversation
     */
    async joinConversation(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.joinConversationRaw(requestParameters, initOverrides);
    }

    /**
     * Leave a conversation 
     * Leave a conversation
     */
    async leaveConversationRaw(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling leaveConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/leave`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Leave a conversation 
     * Leave a conversation
     */
    async leaveConversation(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leaveConversationRaw(requestParameters, initOverrides);
    }

    /**
     * Mark a conversation as read 
     * Mark a conversation as read
     */
    async markReadConversationRaw(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling markReadConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/markread`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Mark a conversation as read 
     * Mark a conversation as read
     */
    async markReadConversation(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.markReadConversationRaw(requestParameters, initOverrides);
    }

    /**
     * Start a new conversation 
     * Start a conversation
     */
    async startConversationRaw(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationStartResponse>> {
        if (requestParameters.startRequest === null || requestParameters.startRequest === undefined) {
            throw new runtime.RequiredError('startRequest','Required parameter requestParameters.startRequest was null or undefined when calling startConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationStartRequestToJSON(requestParameters.startRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationStartResponseFromJSON(jsonValue));
    }

    /**
     * Start a new conversation 
     * Start a conversation
     */
    async startConversation(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationStartResponse> {
        const response = await this.startConversationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update status within the queue 
     * Update status within the queue
     */
    async updateConversationWebchatQueueStatusRaw(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.queueName === null || requestParameters.queueName === undefined) {
            throw new runtime.RequiredError('queueName','Required parameter requestParameters.queueName was null or undefined when calling updateConversationWebchatQueueStatus.');
        }

        if (requestParameters.statusRequest === null || requestParameters.statusRequest === undefined) {
            throw new runtime.RequiredError('statusRequest','Required parameter requestParameters.statusRequest was null or undefined when calling updateConversationWebchatQueueStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/queues/{queue_name}/status`.replace(`{${"queue_name"}}`, encodeURIComponent(String(requestParameters.queueName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationWebchatQueueStatusUpdateRequestToJSON(requestParameters.statusRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update status within the queue 
     * Update status within the queue
     */
    async updateConversationWebchatQueueStatus(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateConversationWebchatQueueStatusRaw(requestParameters, initOverrides);
    }

}
