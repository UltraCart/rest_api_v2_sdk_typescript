/* tslint:disable */
/* eslint-disable */
/**
 * UltraCart Rest API V2
 * UltraCart REST API Version 2
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@ultracart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    BaseResponse,
    BaseResponseFromJSON,
    BaseResponseToJSON,
    ConversationAgentAuthResponse,
    ConversationAgentAuthResponseFromJSON,
    ConversationAgentAuthResponseToJSON,
    ConversationAgentProfile,
    ConversationAgentProfileFromJSON,
    ConversationAgentProfileToJSON,
    ConversationAgentProfileResponse,
    ConversationAgentProfileResponseFromJSON,
    ConversationAgentProfileResponseToJSON,
    ConversationAgentProfilesResponse,
    ConversationAgentProfilesResponseFromJSON,
    ConversationAgentProfilesResponseToJSON,
    ConversationAutocompleteRequest,
    ConversationAutocompleteRequestFromJSON,
    ConversationAutocompleteRequestToJSON,
    ConversationAutocompleteResponse,
    ConversationAutocompleteResponseFromJSON,
    ConversationAutocompleteResponseToJSON,
    ConversationCannedMessage,
    ConversationCannedMessageFromJSON,
    ConversationCannedMessageToJSON,
    ConversationCannedMessageResponse,
    ConversationCannedMessageResponseFromJSON,
    ConversationCannedMessageResponseToJSON,
    ConversationCannedMessagesResponse,
    ConversationCannedMessagesResponseFromJSON,
    ConversationCannedMessagesResponseToJSON,
    ConversationCannedMessagesSearch,
    ConversationCannedMessagesSearchFromJSON,
    ConversationCannedMessagesSearchToJSON,
    ConversationDeleteKnowledgeBaseDocumentResponse,
    ConversationDeleteKnowledgeBaseDocumentResponseFromJSON,
    ConversationDeleteKnowledgeBaseDocumentResponseToJSON,
    ConversationDepartment,
    ConversationDepartmentFromJSON,
    ConversationDepartmentToJSON,
    ConversationDepartmentMembersResponse,
    ConversationDepartmentMembersResponseFromJSON,
    ConversationDepartmentMembersResponseToJSON,
    ConversationDepartmentResponse,
    ConversationDepartmentResponseFromJSON,
    ConversationDepartmentResponseToJSON,
    ConversationDepartmentsResponse,
    ConversationDepartmentsResponseFromJSON,
    ConversationDepartmentsResponseToJSON,
    ConversationEngagement,
    ConversationEngagementFromJSON,
    ConversationEngagementToJSON,
    ConversationEngagementResponse,
    ConversationEngagementResponseFromJSON,
    ConversationEngagementResponseToJSON,
    ConversationEngagementsResponse,
    ConversationEngagementsResponseFromJSON,
    ConversationEngagementsResponseToJSON,
    ConversationInsertKnowledgeBaseDocumentRequest,
    ConversationInsertKnowledgeBaseDocumentRequestFromJSON,
    ConversationInsertKnowledgeBaseDocumentRequestToJSON,
    ConversationInsertKnowledgeBaseDocumentResponse,
    ConversationInsertKnowledgeBaseDocumentResponseFromJSON,
    ConversationInsertKnowledgeBaseDocumentResponseToJSON,
    ConversationJoinRequest,
    ConversationJoinRequestFromJSON,
    ConversationJoinRequestToJSON,
    ConversationKnowledgeBaseDocumentUploadUrlResponse,
    ConversationKnowledgeBaseDocumentUploadUrlResponseFromJSON,
    ConversationKnowledgeBaseDocumentUploadUrlResponseToJSON,
    ConversationKnowledgeBaseDocumentsResponse,
    ConversationKnowledgeBaseDocumentsResponseFromJSON,
    ConversationKnowledgeBaseDocumentsResponseToJSON,
    ConversationLocationsResponse,
    ConversationLocationsResponseFromJSON,
    ConversationLocationsResponseToJSON,
    ConversationMcpServer,
    ConversationMcpServerFromJSON,
    ConversationMcpServerToJSON,
    ConversationMcpServerResponse,
    ConversationMcpServerResponseFromJSON,
    ConversationMcpServerResponseToJSON,
    ConversationMcpServerToolsResponse,
    ConversationMcpServerToolsResponseFromJSON,
    ConversationMcpServerToolsResponseToJSON,
    ConversationMcpServersResponse,
    ConversationMcpServersResponseFromJSON,
    ConversationMcpServersResponseToJSON,
    ConversationMessagesResponse,
    ConversationMessagesResponseFromJSON,
    ConversationMessagesResponseToJSON,
    ConversationMultimediaUploadUrlResponse,
    ConversationMultimediaUploadUrlResponseFromJSON,
    ConversationMultimediaUploadUrlResponseToJSON,
    ConversationPbxAddress,
    ConversationPbxAddressFromJSON,
    ConversationPbxAddressToJSON,
    ConversationPbxAddressResponse,
    ConversationPbxAddressResponseFromJSON,
    ConversationPbxAddressResponseToJSON,
    ConversationPbxAddressesResponse,
    ConversationPbxAddressesResponseFromJSON,
    ConversationPbxAddressesResponseToJSON,
    ConversationPbxAgent,
    ConversationPbxAgentFromJSON,
    ConversationPbxAgentToJSON,
    ConversationPbxAgentResponse,
    ConversationPbxAgentResponseFromJSON,
    ConversationPbxAgentResponseToJSON,
    ConversationPbxAgentsResponse,
    ConversationPbxAgentsResponseFromJSON,
    ConversationPbxAgentsResponseToJSON,
    ConversationPbxAudio,
    ConversationPbxAudioFromJSON,
    ConversationPbxAudioToJSON,
    ConversationPbxAudioResponse,
    ConversationPbxAudioResponseFromJSON,
    ConversationPbxAudioResponseToJSON,
    ConversationPbxAudioUploadUrlResponse,
    ConversationPbxAudioUploadUrlResponseFromJSON,
    ConversationPbxAudioUploadUrlResponseToJSON,
    ConversationPbxAudioUsageResponse,
    ConversationPbxAudioUsageResponseFromJSON,
    ConversationPbxAudioUsageResponseToJSON,
    ConversationPbxAudiosResponse,
    ConversationPbxAudiosResponseFromJSON,
    ConversationPbxAudiosResponseToJSON,
    ConversationPbxAvailablePhoneNumbersResponse,
    ConversationPbxAvailablePhoneNumbersResponseFromJSON,
    ConversationPbxAvailablePhoneNumbersResponseToJSON,
    ConversationPbxCallResponse,
    ConversationPbxCallResponseFromJSON,
    ConversationPbxCallResponseToJSON,
    ConversationPbxCallSearchRequest,
    ConversationPbxCallSearchRequestFromJSON,
    ConversationPbxCallSearchRequestToJSON,
    ConversationPbxCallSearchResponse,
    ConversationPbxCallSearchResponseFromJSON,
    ConversationPbxCallSearchResponseToJSON,
    ConversationPbxClassOfService,
    ConversationPbxClassOfServiceFromJSON,
    ConversationPbxClassOfServiceToJSON,
    ConversationPbxClassOfServiceResponse,
    ConversationPbxClassOfServiceResponseFromJSON,
    ConversationPbxClassOfServiceResponseToJSON,
    ConversationPbxClassOfServicesResponse,
    ConversationPbxClassOfServicesResponseFromJSON,
    ConversationPbxClassOfServicesResponseToJSON,
    ConversationPbxCosAuditLogsResponse,
    ConversationPbxCosAuditLogsResponseFromJSON,
    ConversationPbxCosAuditLogsResponseToJSON,
    ConversationPbxCustomerSnapshotRequest,
    ConversationPbxCustomerSnapshotRequestFromJSON,
    ConversationPbxCustomerSnapshotRequestToJSON,
    ConversationPbxCustomerSnapshotResponse,
    ConversationPbxCustomerSnapshotResponseFromJSON,
    ConversationPbxCustomerSnapshotResponseToJSON,
    ConversationPbxHardwarePhone,
    ConversationPbxHardwarePhoneFromJSON,
    ConversationPbxHardwarePhoneToJSON,
    ConversationPbxHardwarePhoneResponse,
    ConversationPbxHardwarePhoneResponseFromJSON,
    ConversationPbxHardwarePhoneResponseToJSON,
    ConversationPbxHardwarePhonesResponse,
    ConversationPbxHardwarePhonesResponseFromJSON,
    ConversationPbxHardwarePhonesResponseToJSON,
    ConversationPbxMenu,
    ConversationPbxMenuFromJSON,
    ConversationPbxMenuToJSON,
    ConversationPbxMenuResponse,
    ConversationPbxMenuResponseFromJSON,
    ConversationPbxMenuResponseToJSON,
    ConversationPbxMenusResponse,
    ConversationPbxMenusResponseFromJSON,
    ConversationPbxMenusResponseToJSON,
    ConversationPbxPhoneManufacturersResponse,
    ConversationPbxPhoneManufacturersResponseFromJSON,
    ConversationPbxPhoneManufacturersResponseToJSON,
    ConversationPbxPhoneNumber,
    ConversationPbxPhoneNumberFromJSON,
    ConversationPbxPhoneNumberToJSON,
    ConversationPbxPhoneNumberPurchaseRequest,
    ConversationPbxPhoneNumberPurchaseRequestFromJSON,
    ConversationPbxPhoneNumberPurchaseRequestToJSON,
    ConversationPbxPhoneNumberResponse,
    ConversationPbxPhoneNumberResponseFromJSON,
    ConversationPbxPhoneNumberResponseToJSON,
    ConversationPbxPhoneNumbersResponse,
    ConversationPbxPhoneNumbersResponseFromJSON,
    ConversationPbxPhoneNumbersResponseToJSON,
    ConversationPbxQueue,
    ConversationPbxQueueFromJSON,
    ConversationPbxQueueToJSON,
    ConversationPbxQueueResponse,
    ConversationPbxQueueResponseFromJSON,
    ConversationPbxQueueResponseToJSON,
    ConversationPbxQueuesResponse,
    ConversationPbxQueuesResponseFromJSON,
    ConversationPbxQueuesResponseToJSON,
    ConversationPbxTimeBased,
    ConversationPbxTimeBasedFromJSON,
    ConversationPbxTimeBasedToJSON,
    ConversationPbxTimeBasedResponse,
    ConversationPbxTimeBasedResponseFromJSON,
    ConversationPbxTimeBasedResponseToJSON,
    ConversationPbxTimeBasedsResponse,
    ConversationPbxTimeBasedsResponseFromJSON,
    ConversationPbxTimeBasedsResponseToJSON,
    ConversationPbxTimeRange,
    ConversationPbxTimeRangeFromJSON,
    ConversationPbxTimeRangeToJSON,
    ConversationPbxTimeRangeResponse,
    ConversationPbxTimeRangeResponseFromJSON,
    ConversationPbxTimeRangeResponseToJSON,
    ConversationPbxTimeRangesResponse,
    ConversationPbxTimeRangesResponseFromJSON,
    ConversationPbxTimeRangesResponseToJSON,
    ConversationPbxVoicemailMailbox,
    ConversationPbxVoicemailMailboxFromJSON,
    ConversationPbxVoicemailMailboxToJSON,
    ConversationPbxVoicemailMailboxResponse,
    ConversationPbxVoicemailMailboxResponseFromJSON,
    ConversationPbxVoicemailMailboxResponseToJSON,
    ConversationPbxVoicemailMailboxesResponse,
    ConversationPbxVoicemailMailboxesResponseFromJSON,
    ConversationPbxVoicemailMailboxesResponseToJSON,
    ConversationPbxVoicemailMessageResponse,
    ConversationPbxVoicemailMessageResponseFromJSON,
    ConversationPbxVoicemailMessageResponseToJSON,
    ConversationPbxVoicemailMessageSummariesResponse,
    ConversationPbxVoicemailMessageSummariesResponseFromJSON,
    ConversationPbxVoicemailMessageSummariesResponseToJSON,
    ConversationPermissionsResponse,
    ConversationPermissionsResponseFromJSON,
    ConversationPermissionsResponseToJSON,
    ConversationResponse,
    ConversationResponseFromJSON,
    ConversationResponseToJSON,
    ConversationSearchRequest,
    ConversationSearchRequestFromJSON,
    ConversationSearchRequestToJSON,
    ConversationSearchResponse,
    ConversationSearchResponseFromJSON,
    ConversationSearchResponseToJSON,
    ConversationStartRequest,
    ConversationStartRequestFromJSON,
    ConversationStartRequestToJSON,
    ConversationStartResponse,
    ConversationStartResponseFromJSON,
    ConversationStartResponseToJSON,
    ConversationVirtualAgentBudget,
    ConversationVirtualAgentBudgetFromJSON,
    ConversationVirtualAgentBudgetToJSON,
    ConversationVirtualAgentBudgetResponse,
    ConversationVirtualAgentBudgetResponseFromJSON,
    ConversationVirtualAgentBudgetResponseToJSON,
    ConversationVirtualAgentCapabilities,
    ConversationVirtualAgentCapabilitiesFromJSON,
    ConversationVirtualAgentCapabilitiesToJSON,
    ConversationVirtualAgentCapabilitiesResponse,
    ConversationVirtualAgentCapabilitiesResponseFromJSON,
    ConversationVirtualAgentCapabilitiesResponseToJSON,
    ConversationWebchatContext,
    ConversationWebchatContextFromJSON,
    ConversationWebchatContextToJSON,
    ConversationWebchatQueueStatusUpdateRequest,
    ConversationWebchatQueueStatusUpdateRequestFromJSON,
    ConversationWebchatQueueStatusUpdateRequestToJSON,
    ConversationWebchatQueueStatusesResponse,
    ConversationWebchatQueueStatusesResponseFromJSON,
    ConversationWebchatQueueStatusesResponseToJSON,
    ConversationsResponse,
    ConversationsResponseFromJSON,
    ConversationsResponseToJSON,
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
} from '../models';

export interface DeleteAgentProfileKnowledgeBaseDocumentRequest {
    userId: number;
    documentUuid: string;
}

export interface DeleteAgentProfileMcpRequest {
    userId: number;
    mcpServerUuid: string;
}

export interface DeleteConversationCannedMessageRequest {
    conversationCannedMessageOid: number;
}

export interface DeleteDepartmentRequest {
    conversationDepartmentOid: number;
}

export interface DeleteEngagementRequest {
    conversationEngagementOid: number;
}

export interface DeletePbxAddressRequest {
    conversationPbxAddressUuid: string;
}

export interface DeletePbxAgentVoicemailRequest {
    recordingSid: string;
}

export interface DeletePbxAudioRequest {
    conversationPbxAudioUuid: string;
}

export interface DeletePbxClassOfServiceRequest {
    classOfServiceUuid: string;
}

export interface DeletePbxHardwarePhoneRequest {
    conversationPbxHardwarePhoneUuid: string;
}

export interface DeletePbxMenuRequest {
    conversationPbxMenuUuid: string;
}

export interface DeletePbxPhoneNumberRequest {
    conversationPbxPhoneNumberUuid: string;
}

export interface DeletePbxQueueRequest {
    conversationPbxQueueUuid: string;
}

export interface DeletePbxQueueVoicemailRequest {
    queueUuid: string;
    recordingSid: string;
}

export interface DeletePbxTimeBasedRequest {
    conversationPbxTimeBasedUuid: string;
}

export interface DeletePbxTimeRangeRequest {
    conversationPbxTimeRangeUuid: string;
}

export interface DeletePbxVoicemailMailboxRequest {
    conversationPbxVoicemailMailboxUuid: string;
}

export interface GetAgentProfileKnowledgeBaseRequest {
    userId: number;
}

export interface GetAgentProfileMcpRequest {
    userId: number;
    mcpServerUuid: string;
}

export interface GetAgentProfileMcpToolsRequest {
    userId: number;
    mcpServerUuid: string;
}

export interface GetAgentProfileMcpsRequest {
    userId: number;
}

export interface GetConversationRequest {
    conversationUuid: string;
    limit?: number;
}

export interface GetConversationContextRequest {
    conversationUuid: string;
}

export interface GetConversationEngagementRequest {
    conversationEngagementOid: number;
}

export interface GetConversationKnowledgeBaseDocumentUploadUrlRequest {
    userId: number;
    extension: string;
}

export interface GetConversationMessagesRequest {
    conversationUuid: string;
    since: number;
    limit?: number;
}

export interface GetConversationMultimediaUploadUrlRequest {
    extension: string;
}

export interface GetConversationPbxAudioUploadUrlRequest {
    extension: string;
}

export interface GetConversationPbxCustomerSnapshotRequest {
    pbxCustomerSnapshotRequest: ConversationPbxCustomerSnapshotRequest;
}

export interface GetConversationsRequest {
    medium?: string;
    before?: string;
    limit?: number;
    offset?: number;
}

export interface GetConversationsAutocompleteRequest {
    autocompleteRequest: ConversationAutocompleteRequest;
}

export interface GetConversationsSearchRequest {
    searchRequest: ConversationSearchRequest;
}

export interface GetPbxAddressRequest {
    conversationPbxAddressUuid: string;
}

export interface GetPbxAgentRequest {
    conversationPbxAgentUuid: string;
}

export interface GetPbxAgentVoicemailRequest {
    recordingSid: string;
}

export interface GetPbxAudioRequest {
    conversationPbxAudioUuid: string;
}

export interface GetPbxAudioUsageRequest {
    conversationPbxAudioUuid: string;
}

export interface GetPbxCallRequest {
    callUuid: string;
}

export interface GetPbxClassOfServiceRequest {
    classOfServiceUuid: string;
}

export interface GetPbxCosAuditLogsRequest {
    since?: string;
    agentLogin?: string;
    limit?: number;
}

export interface GetPbxHardwarePhoneRequest {
    conversationPbxHardwarePhoneUuid: string;
}

export interface GetPbxMenuRequest {
    conversationPbxMenuUuid: string;
}

export interface GetPbxPhoneNumberRequest {
    conversationPbxPhoneNumberUuid: string;
}

export interface GetPbxQueueRequest {
    conversationPbxQueueUuid: string;
}

export interface GetPbxQueueVoicemailRequest {
    queueUuid: string;
    recordingSid: string;
}

export interface GetPbxQueueVoicemailsRequest {
    queueUuid: string;
}

export interface GetPbxTimeBasedRequest {
    conversationPbxTimeBasedUuid: string;
}

export interface GetPbxTimeRangeRequest {
    conversationPbxTimeRangeUuid: string;
}

export interface GetPbxVoicemailMailboxRequest {
    conversationPbxVoicemailMailboxUuid: string;
}

export interface InsertAgentProfileKnowledgeBaseDocumentRequest {
    userId: number;
    knowledgeBaseDocumentRequest: ConversationInsertKnowledgeBaseDocumentRequest;
}

export interface InsertAgentProfileMcpRequest {
    userId: number;
    mcpServer: ConversationMcpServer;
}

export interface InsertConversationCannedMessageRequest {
    cannedMessage: ConversationCannedMessage;
}

export interface InsertConversationDepartmentRequest {
    department: ConversationDepartment;
}

export interface InsertConversationEngagementRequest {
    engagement: ConversationEngagement;
}

export interface InsertPbxAddressRequest {
    pbxAddress: ConversationPbxAddress;
}

export interface InsertPbxAudioRequest {
    pbxAudio: ConversationPbxAudio;
}

export interface InsertPbxClassOfServiceRequest {
    classOfService: ConversationPbxClassOfService;
}

export interface InsertPbxHardwarePhoneRequest {
    pbxHardwarePhone: ConversationPbxHardwarePhone;
}

export interface InsertPbxMenuRequest {
    pbxMenu: ConversationPbxMenu;
}

export interface InsertPbxQueueRequest {
    pbxQueue: ConversationPbxQueue;
}

export interface InsertPbxTimeBasedRequest {
    pbxTimeBased: ConversationPbxTimeBased;
}

export interface InsertPbxTimeRangeRequest {
    pbxTimeRange: ConversationPbxTimeRange;
}

export interface InsertPbxVoicemailMailboxRequest {
    pbxVoicemailMailbox: ConversationPbxVoicemailMailbox;
}

export interface JoinConversationRequest {
    conversationUuid: string;
    joinRequest?: ConversationJoinRequest;
}

export interface LeaveConversationRequest {
    conversationUuid: string;
}

export interface ListenedPbxAgentVoicemailRequest {
    recordingSid: string;
}

export interface ListenedPbxQueueVoicemailRequest {
    queueUuid: string;
    recordingSid: string;
}

export interface MarkReadConversationRequest {
    conversationUuid: string;
}

export interface ProtectPbxPhoneNumberRequest {
    conversationPbxPhoneNumberUuid: string;
}

export interface PurchasePbxPhoneNumberRequest {
    phoneNumberPurchaseRequest: ConversationPbxPhoneNumberPurchaseRequest;
}

export interface RegeneratePasswordForPbxHardwarePhoneRequest {
    conversationPbxHardwarePhoneUuid: string;
    pbxHardwarePhone: ConversationPbxHardwarePhone;
}

export interface ResetConversationPbxQueueStatisticsRequest {
    queueUuid: string;
}

export interface SearchConversationCannedMessagesRequest {
    searchRequest: ConversationCannedMessagesSearch;
}

export interface SearchPbxAvailablePhoneNumbersRequest {
    country: string;
    areaCode?: string;
    contains?: string;
    smsEnabled?: boolean;
    voiceEnabled?: boolean;
    type?: string;
    limit?: number;
}

export interface SearchPbxCallsRequest {
    searchRequest: ConversationPbxCallSearchRequest;
    limit?: number;
    offset?: number;
    sort?: string;
}

export interface SmsUnsubscribeConversationRequest {
    conversationUuid: string;
}

export interface StartConversationRequest {
    startRequest: ConversationStartRequest;
}

export interface UpdateAgentProfileRequest {
    profileRequest: ConversationAgentProfile;
}

export interface UpdateAgentProfileMcpRequest {
    userId: number;
    mcpServerUuid: string;
    mcpServer: ConversationMcpServer;
}

export interface UpdateConversationCannedMessageRequest {
    conversationCannedMessageOid: number;
    cannedMessage: ConversationCannedMessage;
}

export interface UpdateConversationDepartmentRequest {
    conversationDepartmentOid: number;
    department: ConversationDepartment;
}

export interface UpdateConversationEngagementRequest {
    conversationEngagementOid: number;
    engagement: ConversationEngagement;
}

export interface UpdateConversationWebchatQueueStatusRequest {
    queueName: string;
    statusRequest: ConversationWebchatQueueStatusUpdateRequest;
}

export interface UpdatePbxAddressRequest {
    conversationPbxAddressUuid: string;
    pbxAddress: ConversationPbxAddress;
}

export interface UpdatePbxAgentRequest {
    conversationPbxAgentUuid: string;
    pbxAgent: ConversationPbxAgent;
}

export interface UpdatePbxAudioRequest {
    conversationPbxAudioUuid: string;
    pbxAudio: ConversationPbxAudio;
}

export interface UpdatePbxClassOfServiceRequest {
    classOfServiceUuid: string;
    classOfService: ConversationPbxClassOfService;
}

export interface UpdatePbxHardwarePhoneRequest {
    conversationPbxHardwarePhoneUuid: string;
    pbxHardwarePhone: ConversationPbxHardwarePhone;
}

export interface UpdatePbxMenuRequest {
    conversationPbxMenuUuid: string;
    pbxMenu: ConversationPbxMenu;
}

export interface UpdatePbxPhoneNumberRequest {
    conversationPbxPhoneNumberUuid: string;
    pbxPhoneNumber: ConversationPbxPhoneNumber;
}

export interface UpdatePbxQueueRequest {
    conversationPbxQueueUuid: string;
    pbxQueue: ConversationPbxQueue;
}

export interface UpdatePbxTimeBasedRequest {
    conversationPbxTimeBasedUuid: string;
    pbxTimeBased: ConversationPbxTimeBased;
}

export interface UpdatePbxTimeRangeRequest {
    conversationPbxTimeRangeUuid: string;
    pbxTimeRange: ConversationPbxTimeRange;
}

export interface UpdatePbxVoicemailMailboxRequest {
    conversationPbxVoicemailMailboxUuid: string;
    pbxVoicemailMailbox: ConversationPbxVoicemailMailbox;
}

export interface UpdateVirtualAgentBudgetRequest {
    virtualAgentBudget: ConversationVirtualAgentBudget;
}

export interface UpdateVirtualAgentCapabilitiesRequest {
    virtualAgentCapabilities: ConversationVirtualAgentCapabilities;
}

/**
 * ConversationApi - interface
 * 
 * @export
 * @interface ConversationApiInterface
 */
export interface ConversationApiInterface {
    /**
     * Delete a knowledge base document 
     * @summary Delete a knowledge base document
     * @param {number} userId 
     * @param {string} documentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deleteAgentProfileKnowledgeBaseDocumentRaw(requestParameters: DeleteAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDeleteKnowledgeBaseDocumentResponse>>;

    /**
     * Delete a knowledge base document 
     * Delete a knowledge base document
     */
    deleteAgentProfileKnowledgeBaseDocument(requestParameters: DeleteAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDeleteKnowledgeBaseDocumentResponse>;

    /**
     * Delete an agent MCP server 
     * @summary Delete an agent MCP server
     * @param {number} userId 
     * @param {string} mcpServerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deleteAgentProfileMcpRaw(requestParameters: DeleteAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete an agent MCP server 
     * Delete an agent MCP server
     */
    deleteAgentProfileMcp(requestParameters: DeleteAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete a conversation canned message 
     * @summary Delete a conversation canned message
     * @param {number} conversationCannedMessageOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deleteConversationCannedMessageRaw(requestParameters: DeleteConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete a conversation canned message 
     * Delete a conversation canned message
     */
    deleteConversationCannedMessage(requestParameters: DeleteConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete a conversation department 
     * @summary Delete a conversation department
     * @param {number} conversationDepartmentOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deleteDepartmentRaw(requestParameters: DeleteDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete a conversation department 
     * Delete a conversation department
     */
    deleteDepartment(requestParameters: DeleteDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete a conversation engagement 
     * @summary Delete a conversation engagement
     * @param {number} conversationEngagementOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deleteEngagementRaw(requestParameters: DeleteEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete a conversation engagement 
     * Delete a conversation engagement
     */
    deleteEngagement(requestParameters: DeleteEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete a pbx address 
     * @summary Delete pbx address
     * @param {string} conversationPbxAddressUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxAddressRaw(requestParameters: DeletePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>>;

    /**
     * Delete a pbx address 
     * Delete pbx address
     */
    deletePbxAddress(requestParameters: DeletePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse>;

    /**
     * Delete pbx agent Voicemail 
     * @summary Delete Agent Voicemail
     * @param {string} recordingSid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxAgentVoicemailRaw(requestParameters: DeletePbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete pbx agent Voicemail 
     * Delete Agent Voicemail
     */
    deletePbxAgentVoicemail(requestParameters: DeletePbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete a pbx audio 
     * @summary Delete pbx audio
     * @param {string} conversationPbxAudioUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxAudioRaw(requestParameters: DeletePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>>;

    /**
     * Delete a pbx audio 
     * Delete pbx audio
     */
    deletePbxAudio(requestParameters: DeletePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse>;

    /**
     * Delete a class of service 
     * @summary Delete pbx class of service
     * @param {string} classOfServiceUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxClassOfServiceRaw(requestParameters: DeletePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponse>>;

    /**
     * Delete a class of service 
     * Delete pbx class of service
     */
    deletePbxClassOfService(requestParameters: DeletePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponse>;

    /**
     * Delete a pbx hardware phone 
     * @summary Delete pbx hardware phone
     * @param {string} conversationPbxHardwarePhoneUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxHardwarePhoneRaw(requestParameters: DeletePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>>;

    /**
     * Delete a pbx hardware phone 
     * Delete pbx hardware phone
     */
    deletePbxHardwarePhone(requestParameters: DeletePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse>;

    /**
     * Delete a pbx menu 
     * @summary Delete pbx menu
     * @param {string} conversationPbxMenuUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxMenuRaw(requestParameters: DeletePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>>;

    /**
     * Delete a pbx menu 
     * Delete pbx menu
     */
    deletePbxMenu(requestParameters: DeletePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse>;

    /**
     * Delete a pbx phoneNumber. Only works if deletion_protected is false. 
     * @summary Delete pbx phoneNumber
     * @param {string} conversationPbxPhoneNumberUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxPhoneNumberRaw(requestParameters: DeletePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete a pbx phoneNumber. Only works if deletion_protected is false. 
     * Delete pbx phoneNumber
     */
    deletePbxPhoneNumber(requestParameters: DeletePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete a pbx queue 
     * @summary Delete pbx queue
     * @param {string} conversationPbxQueueUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxQueueRaw(requestParameters: DeletePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>>;

    /**
     * Delete a pbx queue 
     * Delete pbx queue
     */
    deletePbxQueue(requestParameters: DeletePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse>;

    /**
     * Delete pbx queue Voicemail 
     * @summary Delete Queue Voicemail
     * @param {string} queueUuid 
     * @param {string} recordingSid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxQueueVoicemailRaw(requestParameters: DeletePbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Delete pbx queue Voicemail 
     * Delete Queue Voicemail
     */
    deletePbxQueueVoicemail(requestParameters: DeletePbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Delete a pbx timeBased 
     * @summary Delete pbx timeBased
     * @param {string} conversationPbxTimeBasedUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxTimeBasedRaw(requestParameters: DeletePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>>;

    /**
     * Delete a pbx timeBased 
     * Delete pbx timeBased
     */
    deletePbxTimeBased(requestParameters: DeletePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse>;

    /**
     * Delete a pbx timeRange 
     * @summary Delete pbx timeRange
     * @param {string} conversationPbxTimeRangeUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxTimeRangeRaw(requestParameters: DeletePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>>;

    /**
     * Delete a pbx timeRange 
     * Delete pbx timeRange
     */
    deletePbxTimeRange(requestParameters: DeletePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse>;

    /**
     * Delete a pbx voicemailMailbox 
     * @summary Delete pbx voicemailMailbox
     * @param {string} conversationPbxVoicemailMailboxUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    deletePbxVoicemailMailboxRaw(requestParameters: DeletePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>>;

    /**
     * Delete a pbx voicemailMailbox 
     * Delete pbx voicemailMailbox
     */
    deletePbxVoicemailMailbox(requestParameters: DeletePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse>;

    /**
     * Called periodically by the conversation API to keep the session alive. 
     * @summary Agent keep alive
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentKeepAliveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Called periodically by the conversation API to keep the session alive. 
     * Agent keep alive
     */
    getAgentKeepAlive(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Retrieve the agents profile 
     * @summary Get agent profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentProfileRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentProfileResponse>>;

    /**
     * Retrieve the agents profile 
     * Get agent profile
     */
    getAgentProfile(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentProfileResponse>;

    /**
     * Retrieve knowledge base documents 
     * @summary Get the list of knowledge base documents associated with this agent profile
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentProfileKnowledgeBaseRaw(requestParameters: GetAgentProfileKnowledgeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationKnowledgeBaseDocumentsResponse>>;

    /**
     * Retrieve knowledge base documents 
     * Get the list of knowledge base documents associated with this agent profile
     */
    getAgentProfileKnowledgeBase(requestParameters: GetAgentProfileKnowledgeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationKnowledgeBaseDocumentsResponse>;

    /**
     * Retrieve MCP server associated with this agent 
     * @summary Get an MCP server associated with this agent
     * @param {number} userId 
     * @param {string} mcpServerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentProfileMcpRaw(requestParameters: GetAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerResponse>>;

    /**
     * Retrieve MCP server associated with this agent 
     * Get an MCP server associated with this agent
     */
    getAgentProfileMcp(requestParameters: GetAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerResponse>;

    /**
     * Get the tools available from the MCP server 
     * @summary Get the tools available from the MCP server
     * @param {number} userId 
     * @param {string} mcpServerUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentProfileMcpToolsRaw(requestParameters: GetAgentProfileMcpToolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerToolsResponse>>;

    /**
     * Get the tools available from the MCP server 
     * Get the tools available from the MCP server
     */
    getAgentProfileMcpTools(requestParameters: GetAgentProfileMcpToolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerToolsResponse>;

    /**
     * Retrieve MCP servers associated with this agent 
     * @summary Get the list of MCP servers associated with this agent
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentProfileMcpsRaw(requestParameters: GetAgentProfileMcpsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServersResponse>>;

    /**
     * Retrieve MCP servers associated with this agent 
     * Get the list of MCP servers associated with this agent
     */
    getAgentProfileMcps(requestParameters: GetAgentProfileMcpsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServersResponse>;

    /**
     * Retrieve the agents profile 
     * @summary Get agent profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentProfilesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentProfilesResponse>>;

    /**
     * Retrieve the agents profile 
     * Get agent profiles
     */
    getAgentProfiles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentProfilesResponse>;

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * @summary Get agent websocket authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getAgentWebsocketAuthorizationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentAuthResponse>>;

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * Get agent websocket authorization
     */
    getAgentWebsocketAuthorization(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentAuthResponse>;

    /**
     * Retrieve a conversation including the participants and messages 
     * @summary Retrieve a conversation
     * @param {string} conversationUuid 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationRaw(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>>;

    /**
     * Retrieve a conversation including the participants and messages 
     * Retrieve a conversation
     */
    getConversation(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse>;

    /**
     * Retrieve a list of canned messages ordered by short_code 
     * @summary Retrieve a list of canned messages ordered by short_code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationCannedMessagesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessagesResponse>>;

    /**
     * Retrieve a list of canned messages ordered by short_code 
     * Retrieve a list of canned messages ordered by short_code
     */
    getConversationCannedMessages(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessagesResponse>;

    /**
     * Get a webchat conversation context 
     * @summary Get a webchat conversation context
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationContextRaw(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatContext>>;

    /**
     * Get a webchat conversation context 
     * Get a webchat conversation context
     */
    getConversationContext(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatContext>;

    /**
     * Retrieve a list of possible department members 
     * @summary Retrieve a list of possible department members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationDepartmentMemberListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentMembersResponse>>;

    /**
     * Retrieve a list of possible department members 
     * Retrieve a list of possible department members
     */
    getConversationDepartmentMemberList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentMembersResponse>;

    /**
     * Retrieve a list of departments ordered by name 
     * @summary Retrieve a list of departments ordered by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationDepartmentsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentsResponse>>;

    /**
     * Retrieve a list of departments ordered by name 
     * Retrieve a list of departments ordered by name
     */
    getConversationDepartments(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentsResponse>;

    /**
     * Retrieve an engagement 
     * @summary Retrieve an engagement
     * @param {number} conversationEngagementOid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationEngagementRaw(requestParameters: GetConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementResponse>>;

    /**
     * Retrieve an engagement 
     * Retrieve an engagement
     */
    getConversationEngagement(requestParameters: GetConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementResponse>;

    /**
     * Retrieve a list of engagements ordered by name 
     * @summary Retrieve a list of engagements ordered by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationEngagementsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementsResponse>>;

    /**
     * Retrieve a list of engagements ordered by name 
     * Retrieve a list of engagements ordered by name
     */
    getConversationEngagements(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementsResponse>;

    /**
     * Get a pre-signed conversation knowledge base document upload URL 
     * @summary Get a pre-signed conversation knowledge base document upload URL
     * @param {number} userId 
     * @param {string} extension 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationKnowledgeBaseDocumentUploadUrlRaw(requestParameters: GetConversationKnowledgeBaseDocumentUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationKnowledgeBaseDocumentUploadUrlResponse>>;

    /**
     * Get a pre-signed conversation knowledge base document upload URL 
     * Get a pre-signed conversation knowledge base document upload URL
     */
    getConversationKnowledgeBaseDocumentUploadUrl(requestParameters: GetConversationKnowledgeBaseDocumentUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationKnowledgeBaseDocumentUploadUrlResponse>;

    /**
     * Retrieve conversation messages since a particular time 
     * @summary Retrieve conversation messages
     * @param {string} conversationUuid 
     * @param {number} since 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationMessagesRaw(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMessagesResponse>>;

    /**
     * Retrieve conversation messages since a particular time 
     * Retrieve conversation messages
     */
    getConversationMessages(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMessagesResponse>;

    /**
     * Get a presigned conversation multimedia upload URL 
     * @summary Get a presigned conversation multimedia upload URL
     * @param {string} extension 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationMultimediaUploadUrlRaw(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMultimediaUploadUrlResponse>>;

    /**
     * Get a presigned conversation multimedia upload URL 
     * Get a presigned conversation multimedia upload URL
     */
    getConversationMultimediaUploadUrl(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMultimediaUploadUrlResponse>;

    /**
     * Get a pre-signed conversation multimedia upload URL 
     * @summary Get a pre-signed conversation multimedia upload URL
     * @param {string} extension 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationPbxAudioUploadUrlRaw(requestParameters: GetConversationPbxAudioUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioUploadUrlResponse>>;

    /**
     * Get a pre-signed conversation multimedia upload URL 
     * Get a pre-signed conversation multimedia upload URL
     */
    getConversationPbxAudioUploadUrl(requestParameters: GetConversationPbxAudioUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioUploadUrlResponse>;

    /**
     * Retrieves all the orders, auto orders, and customer profile for a given phone number 
     * @summary Get orders and customer information for a phone number
     * @param {ConversationPbxCustomerSnapshotRequest} pbxCustomerSnapshotRequest Conversation pbx customer snapshot request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationPbxCustomerSnapshotRaw(requestParameters: GetConversationPbxCustomerSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCustomerSnapshotResponse>>;

    /**
     * Retrieves all the orders, auto orders, and customer profile for a given phone number 
     * Get orders and customer information for a phone number
     */
    getConversationPbxCustomerSnapshot(requestParameters: GetConversationPbxCustomerSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCustomerSnapshotResponse>;

    /**
     * Retrieve conversation permissions 
     * @summary Retrieve conversation permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationPermissionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPermissionsResponse>>;

    /**
     * Retrieve conversation permissions 
     * Retrieve conversation permissions
     */
    getConversationPermissions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPermissionsResponse>;

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * @summary Retrieve a conversation webchat queue statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationWebchatQueueStatusesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatQueueStatusesResponse>>;

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * Retrieve a conversation webchat queue statuses
     */
    getConversationWebchatQueueStatuses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatQueueStatusesResponse>;

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * @summary Retrieve a list of conversation summaries newest to oldest
     * @param {string} [medium] 
     * @param {string} [before] 
     * @param {number} [limit] The maximum number of records to return on this one API call. (Max 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationsRaw(requestParameters: GetConversationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationsResponse>>;

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * Retrieve a list of conversation summaries newest to oldest
     */
    getConversations(requestParameters: GetConversationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationsResponse>;

    /**
     * Retrieve a list of matching terms for a search field 
     * @summary Retrieve a list of matching terms for a search field
     * @param {ConversationAutocompleteRequest} autocompleteRequest Autocomplete Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationsAutocompleteRaw(requestParameters: GetConversationsAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAutocompleteResponse>>;

    /**
     * Retrieve a list of matching terms for a search field 
     * Retrieve a list of matching terms for a search field
     */
    getConversationsAutocomplete(requestParameters: GetConversationsAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAutocompleteResponse>;

    /**
     * Search conversations 
     * @summary Search conversations
     * @param {ConversationSearchRequest} searchRequest Search Request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getConversationsSearchRaw(requestParameters: GetConversationsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationSearchResponse>>;

    /**
     * Search conversations 
     * Search conversations
     */
    getConversationsSearch(requestParameters: GetConversationsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationSearchResponse>;

    /**
     * Get location data for engagement configuration 
     * @summary Get location data for engagement configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getLocationsForEngagementRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationLocationsResponse>>;

    /**
     * Get location data for engagement configuration 
     * Get location data for engagement configuration
     */
    getLocationsForEngagement(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationLocationsResponse>;

    /**
     * Retrieve a pbx address 
     * @summary Get pbx address
     * @param {string} conversationPbxAddressUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAddressRaw(requestParameters: GetPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>>;

    /**
     * Retrieve a pbx address 
     * Get pbx address
     */
    getPbxAddress(requestParameters: GetPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse>;

    /**
     * Retrieve pbx addresses 
     * @summary Get pbx addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAddressesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressesResponse>>;

    /**
     * Retrieve pbx addresses 
     * Get pbx addresses
     */
    getPbxAddresses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressesResponse>;

    /**
     * Retrieve a pbx agent 
     * @summary Get pbx agent
     * @param {string} conversationPbxAgentUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAgentRaw(requestParameters: GetPbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAgentResponse>>;

    /**
     * Retrieve a pbx agent 
     * Get pbx agent
     */
    getPbxAgent(requestParameters: GetPbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAgentResponse>;

    /**
     * Retrieve pbx agent Voicemail 
     * @summary Get Agent Voicemail
     * @param {string} recordingSid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAgentVoicemailRaw(requestParameters: GetPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageResponse>>;

    /**
     * Retrieve pbx agent Voicemail 
     * Get Agent Voicemail
     */
    getPbxAgentVoicemail(requestParameters: GetPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageResponse>;

    /**
     * Retrieve pbx agent Voicemails 
     * @summary Get Agent Voicemails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAgentVoicemailsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageSummariesResponse>>;

    /**
     * Retrieve pbx agent Voicemails 
     * Get Agent Voicemails
     */
    getPbxAgentVoicemails(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageSummariesResponse>;

    /**
     * Retrieve pbx agents 
     * @summary Get pbx agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAgentsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAgentsResponse>>;

    /**
     * Retrieve pbx agents 
     * Get pbx agents
     */
    getPbxAgents(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAgentsResponse>;

    /**
     * Retrieve a pbx audio 
     * @summary Get pbx audio
     * @param {string} conversationPbxAudioUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAudioRaw(requestParameters: GetPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>>;

    /**
     * Retrieve a pbx audio 
     * Get pbx audio
     */
    getPbxAudio(requestParameters: GetPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse>;

    /**
     * Retrieve a pbx audio usage 
     * @summary Get pbx audio usage
     * @param {string} conversationPbxAudioUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAudioUsageRaw(requestParameters: GetPbxAudioUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioUsageResponse>>;

    /**
     * Retrieve a pbx audio usage 
     * Get pbx audio usage
     */
    getPbxAudioUsage(requestParameters: GetPbxAudioUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioUsageResponse>;

    /**
     * Retrieve pbx audios 
     * @summary Get pbx audios
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxAudiosRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudiosResponse>>;

    /**
     * Retrieve pbx audios 
     * Get pbx audios
     */
    getPbxAudios(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudiosResponse>;

    /**
     * Retrieve a single PBX call record with full details 
     * @summary Get pbx call record
     * @param {string} callUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxCallRaw(requestParameters: GetPbxCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCallResponse>>;

    /**
     * Retrieve a single PBX call record with full details 
     * Get pbx call record
     */
    getPbxCall(requestParameters: GetPbxCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCallResponse>;

    /**
     * Retrieve a single class of service 
     * @summary Get pbx class of service
     * @param {string} classOfServiceUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxClassOfServiceRaw(requestParameters: GetPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServiceResponse>>;

    /**
     * Retrieve a single class of service 
     * Get pbx class of service
     */
    getPbxClassOfService(requestParameters: GetPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServiceResponse>;

    /**
     * Retrieve all classes of service for the merchant 
     * @summary Get pbx classes of service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxClassesOfServiceRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServicesResponse>>;

    /**
     * Retrieve all classes of service for the merchant 
     * Get pbx classes of service
     */
    getPbxClassesOfService(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServicesResponse>;

    /**
     * Retrieve audit log entries for class of service enforcement 
     * @summary Get pbx class of service audit logs
     * @param {string} [since] ISO timestamp to filter entries since
     * @param {string} [agentLogin] Filter by agent login
     * @param {number} [limit] Maximum number of entries to return (default 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxCosAuditLogsRaw(requestParameters: GetPbxCosAuditLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCosAuditLogsResponse>>;

    /**
     * Retrieve audit log entries for class of service enforcement 
     * Get pbx class of service audit logs
     */
    getPbxCosAuditLogs(requestParameters: GetPbxCosAuditLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCosAuditLogsResponse>;

    /**
     * Retrieve a pbx hardware phone 
     * @summary Get pbx hardware phone
     * @param {string} conversationPbxHardwarePhoneUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxHardwarePhoneRaw(requestParameters: GetPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>>;

    /**
     * Retrieve a pbx hardware phone 
     * Get pbx hardware phone
     */
    getPbxHardwarePhone(requestParameters: GetPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse>;

    /**
     * Retrieve pbx hardware phone manufacturers and models for auto-provisioning 
     * @summary Get pbx hardware phone manufacturers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxHardwarePhoneManufacturersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneManufacturersResponse>>;

    /**
     * Retrieve pbx hardware phone manufacturers and models for auto-provisioning 
     * Get pbx hardware phone manufacturers
     */
    getPbxHardwarePhoneManufacturers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneManufacturersResponse>;

    /**
     * Retrieve pbx hardware phones 
     * @summary Get pbx hardware phones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxHardwarePhonesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhonesResponse>>;

    /**
     * Retrieve pbx hardware phones 
     * Get pbx hardware phones
     */
    getPbxHardwarePhones(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhonesResponse>;

    /**
     * Retrieve a pbx menu 
     * @summary Get pbx menu
     * @param {string} conversationPbxMenuUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxMenuRaw(requestParameters: GetPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>>;

    /**
     * Retrieve a pbx menu 
     * Get pbx menu
     */
    getPbxMenu(requestParameters: GetPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse>;

    /**
     * Retrieve pbx menus 
     * @summary Get pbx menus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxMenusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenusResponse>>;

    /**
     * Retrieve pbx menus 
     * Get pbx menus
     */
    getPbxMenus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenusResponse>;

    /**
     * Retrieve a pbx phoneNumber 
     * @summary Get pbx phoneNumber
     * @param {string} conversationPbxPhoneNumberUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxPhoneNumberRaw(requestParameters: GetPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>>;

    /**
     * Retrieve a pbx phoneNumber 
     * Get pbx phoneNumber
     */
    getPbxPhoneNumber(requestParameters: GetPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse>;

    /**
     * Retrieve pbx phoneNumbers 
     * @summary Get pbx phoneNumbers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxPhoneNumbersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumbersResponse>>;

    /**
     * Retrieve pbx phoneNumbers 
     * Get pbx phoneNumbers
     */
    getPbxPhoneNumbers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumbersResponse>;

    /**
     * Retrieve a pbx queue 
     * @summary Get pbx queue
     * @param {string} conversationPbxQueueUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxQueueRaw(requestParameters: GetPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>>;

    /**
     * Retrieve a pbx queue 
     * Get pbx queue
     */
    getPbxQueue(requestParameters: GetPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse>;

    /**
     * Retrieve pbx queue Voicemail 
     * @summary Get Queue Voicemail
     * @param {string} queueUuid 
     * @param {string} recordingSid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxQueueVoicemailRaw(requestParameters: GetPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageResponse>>;

    /**
     * Retrieve pbx queue Voicemail 
     * Get Queue Voicemail
     */
    getPbxQueueVoicemail(requestParameters: GetPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageResponse>;

    /**
     * Retrieve pbx queue voicemails 
     * @summary Get Queue Voicemails
     * @param {string} queueUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxQueueVoicemailsRaw(requestParameters: GetPbxQueueVoicemailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageSummariesResponse>>;

    /**
     * Retrieve pbx queue voicemails 
     * Get Queue Voicemails
     */
    getPbxQueueVoicemails(requestParameters: GetPbxQueueVoicemailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageSummariesResponse>;

    /**
     * Retrieve pbx queues 
     * @summary Get pbx queues
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxQueuesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueuesResponse>>;

    /**
     * Retrieve pbx queues 
     * Get pbx queues
     */
    getPbxQueues(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueuesResponse>;

    /**
     * Retrieve a pbx timeBased 
     * @summary Get pbx timeBased
     * @param {string} conversationPbxTimeBasedUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxTimeBasedRaw(requestParameters: GetPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>>;

    /**
     * Retrieve a pbx timeBased 
     * Get pbx timeBased
     */
    getPbxTimeBased(requestParameters: GetPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse>;

    /**
     * Retrieve pbx timeBaseds 
     * @summary Get pbx timeBaseds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxTimeBasedsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedsResponse>>;

    /**
     * Retrieve pbx timeBaseds 
     * Get pbx timeBaseds
     */
    getPbxTimeBaseds(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedsResponse>;

    /**
     * Retrieve a pbx timeRange 
     * @summary Get pbx timeRange
     * @param {string} conversationPbxTimeRangeUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxTimeRangeRaw(requestParameters: GetPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>>;

    /**
     * Retrieve a pbx timeRange 
     * Get pbx timeRange
     */
    getPbxTimeRange(requestParameters: GetPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse>;

    /**
     * Retrieve pbx timeRanges 
     * @summary Get pbx timeRanges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxTimeRangesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangesResponse>>;

    /**
     * Retrieve pbx timeRanges 
     * Get pbx timeRanges
     */
    getPbxTimeRanges(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangesResponse>;

    /**
     * Retrieve a pbx voicemailMailbox 
     * @summary Get pbx voicemailMailbox
     * @param {string} conversationPbxVoicemailMailboxUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxVoicemailMailboxRaw(requestParameters: GetPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>>;

    /**
     * Retrieve a pbx voicemailMailbox 
     * Get pbx voicemailMailbox
     */
    getPbxVoicemailMailbox(requestParameters: GetPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse>;

    /**
     * Retrieve pbx voicemailMailboxes 
     * @summary Get pbx voicemailMailboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getPbxVoicemailMailboxesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxesResponse>>;

    /**
     * Retrieve pbx voicemailMailboxes 
     * Get pbx voicemailMailboxes
     */
    getPbxVoicemailMailboxes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxesResponse>;

    /**
     * Retrieve virtual agent budget 
     * @summary Get virtual agent budget
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getVirtualAgentBudgetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentBudgetResponse>>;

    /**
     * Retrieve virtual agent budget 
     * Get virtual agent budget
     */
    getVirtualAgentBudget(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentBudgetResponse>;

    /**
     * Retrieve virtual agent capabilities 
     * @summary Get virtual agent capabilities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    getVirtualAgentCapabilitiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentCapabilitiesResponse>>;

    /**
     * Retrieve virtual agent capabilities 
     * Get virtual agent capabilities
     */
    getVirtualAgentCapabilities(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentCapabilitiesResponse>;

    /**
     * Insert a knowledge base document 
     * @summary Insert a knowledge base document
     * @param {number} userId 
     * @param {ConversationInsertKnowledgeBaseDocumentRequest} knowledgeBaseDocumentRequest Insert request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertAgentProfileKnowledgeBaseDocumentRaw(requestParameters: InsertAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationInsertKnowledgeBaseDocumentResponse>>;

    /**
     * Insert a knowledge base document 
     * Insert a knowledge base document
     */
    insertAgentProfileKnowledgeBaseDocument(requestParameters: InsertAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationInsertKnowledgeBaseDocumentResponse>;

    /**
     * Insert an agent MCP server 
     * @summary Insert an agent MCP server
     * @param {number} userId 
     * @param {ConversationMcpServer} mcpServer MCP Server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertAgentProfileMcpRaw(requestParameters: InsertAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerResponse>>;

    /**
     * Insert an agent MCP server 
     * Insert an agent MCP server
     */
    insertAgentProfileMcp(requestParameters: InsertAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerResponse>;

    /**
     * Insert a canned message 
     * @summary Insert a canned message
     * @param {ConversationCannedMessage} cannedMessage Canned message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertConversationCannedMessageRaw(requestParameters: InsertConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessageResponse>>;

    /**
     * Insert a canned message 
     * Insert a canned message
     */
    insertConversationCannedMessage(requestParameters: InsertConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessageResponse>;

    /**
     * Insert a department 
     * @summary Insert a department
     * @param {ConversationDepartment} department Department
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertConversationDepartmentRaw(requestParameters: InsertConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentResponse>>;

    /**
     * Insert a department 
     * Insert a department
     */
    insertConversationDepartment(requestParameters: InsertConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentResponse>;

    /**
     * Insert a engagement 
     * @summary Insert a engagement
     * @param {ConversationEngagement} engagement Engagement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertConversationEngagementRaw(requestParameters: InsertConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementResponse>>;

    /**
     * Insert a engagement 
     * Insert a engagement
     */
    insertConversationEngagement(requestParameters: InsertConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementResponse>;

    /**
     * Insert a pbx address 
     * @summary Insert pbx address
     * @param {ConversationPbxAddress} pbxAddress Pbx Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxAddressRaw(requestParameters: InsertPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>>;

    /**
     * Insert a pbx address 
     * Insert pbx address
     */
    insertPbxAddress(requestParameters: InsertPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse>;

    /**
     * Insert a pbx audio 
     * @summary Insert pbx audio
     * @param {ConversationPbxAudio} pbxAudio Pbx Audio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxAudioRaw(requestParameters: InsertPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>>;

    /**
     * Insert a pbx audio 
     * Insert pbx audio
     */
    insertPbxAudio(requestParameters: InsertPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse>;

    /**
     * Create a new class of service 
     * @summary Insert pbx class of service
     * @param {ConversationPbxClassOfService} classOfService Class of service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxClassOfServiceRaw(requestParameters: InsertPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServiceResponse>>;

    /**
     * Create a new class of service 
     * Insert pbx class of service
     */
    insertPbxClassOfService(requestParameters: InsertPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServiceResponse>;

    /**
     * Insert a pbx hardware phone 
     * @summary Insert pbx hardware phone
     * @param {ConversationPbxHardwarePhone} pbxHardwarePhone Pbx Hardware Phone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxHardwarePhoneRaw(requestParameters: InsertPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>>;

    /**
     * Insert a pbx hardware phone 
     * Insert pbx hardware phone
     */
    insertPbxHardwarePhone(requestParameters: InsertPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse>;

    /**
     * Insert a pbx menu 
     * @summary Insert pbx menu
     * @param {ConversationPbxMenu} pbxMenu Pbx Menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxMenuRaw(requestParameters: InsertPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>>;

    /**
     * Insert a pbx menu 
     * Insert pbx menu
     */
    insertPbxMenu(requestParameters: InsertPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse>;

    /**
     * Insert a pbx queue 
     * @summary Insert pbx queue
     * @param {ConversationPbxQueue} pbxQueue Pbx Queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxQueueRaw(requestParameters: InsertPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>>;

    /**
     * Insert a pbx queue 
     * Insert pbx queue
     */
    insertPbxQueue(requestParameters: InsertPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse>;

    /**
     * Insert a pbx timeBased 
     * @summary Insert pbx timeBased
     * @param {ConversationPbxTimeBased} pbxTimeBased Pbx TimeBased
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxTimeBasedRaw(requestParameters: InsertPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>>;

    /**
     * Insert a pbx timeBased 
     * Insert pbx timeBased
     */
    insertPbxTimeBased(requestParameters: InsertPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse>;

    /**
     * Insert a pbx timeRange 
     * @summary Insert pbx timeRange
     * @param {ConversationPbxTimeRange} pbxTimeRange Pbx TimeRange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxTimeRangeRaw(requestParameters: InsertPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>>;

    /**
     * Insert a pbx timeRange 
     * Insert pbx timeRange
     */
    insertPbxTimeRange(requestParameters: InsertPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse>;

    /**
     * Insert a pbx voicemailMailbox 
     * @summary Insert pbx voicemailMailbox
     * @param {ConversationPbxVoicemailMailbox} pbxVoicemailMailbox Pbx VoicemailMailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    insertPbxVoicemailMailboxRaw(requestParameters: InsertPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>>;

    /**
     * Insert a pbx voicemailMailbox 
     * Insert pbx voicemailMailbox
     */
    insertPbxVoicemailMailbox(requestParameters: InsertPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse>;

    /**
     * Join a conversation 
     * @summary Join a conversation
     * @param {string} conversationUuid 
     * @param {ConversationJoinRequest} [joinRequest] Join request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    joinConversationRaw(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Join a conversation 
     * Join a conversation
     */
    joinConversation(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Leave a conversation 
     * @summary Leave a conversation
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    leaveConversationRaw(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Leave a conversation 
     * Leave a conversation
     */
    leaveConversation(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Listened pbx agent Voicemail 
     * @summary Listened Agent Voicemail
     * @param {string} recordingSid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    listenedPbxAgentVoicemailRaw(requestParameters: ListenedPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Listened pbx agent Voicemail 
     * Listened Agent Voicemail
     */
    listenedPbxAgentVoicemail(requestParameters: ListenedPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Listened pbx queue Voicemail 
     * @summary Listened Queue Voicemail
     * @param {string} queueUuid 
     * @param {string} recordingSid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    listenedPbxQueueVoicemailRaw(requestParameters: ListenedPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Listened pbx queue Voicemail 
     * Listened Queue Voicemail
     */
    listenedPbxQueueVoicemail(requestParameters: ListenedPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Mark a conversation as read 
     * @summary Mark a conversation as read
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    markReadConversationRaw(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Mark a conversation as read 
     * Mark a conversation as read
     */
    markReadConversation(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Protect a pbx phoneNumber from deletion. This is a one-way operation and cannot be undone through the API. 
     * @summary Protect pbx phoneNumber from deletion
     * @param {string} conversationPbxPhoneNumberUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    protectPbxPhoneNumberRaw(requestParameters: ProtectPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>>;

    /**
     * Protect a pbx phoneNumber from deletion. This is a one-way operation and cannot be undone through the API. 
     * Protect pbx phoneNumber from deletion
     */
    protectPbxPhoneNumber(requestParameters: ProtectPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse>;

    /**
     * Purchase a phone number from Twilio. The phone_number must be from the available phone number search results. 
     * @summary Purchase pbx phone number
     * @param {ConversationPbxPhoneNumberPurchaseRequest} phoneNumberPurchaseRequest Phone number purchase request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    purchasePbxPhoneNumberRaw(requestParameters: PurchasePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>>;

    /**
     * Purchase a phone number from Twilio. The phone_number must be from the available phone number search results. 
     * Purchase pbx phone number
     */
    purchasePbxPhoneNumber(requestParameters: PurchasePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse>;

    /**
     * Update a pbx hardware phone 
     * @summary Update pbx hardware phone
     * @param {string} conversationPbxHardwarePhoneUuid 
     * @param {ConversationPbxHardwarePhone} pbxHardwarePhone Pbx Hardware Phone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    regeneratePasswordForPbxHardwarePhoneRaw(requestParameters: RegeneratePasswordForPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>>;

    /**
     * Update a pbx hardware phone 
     * Update pbx hardware phone
     */
    regeneratePasswordForPbxHardwarePhone(requestParameters: RegeneratePasswordForPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse>;

    /**
     * reset statistics within the queue 
     * @summary reset statistics within the queue
     * @param {string} queueUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    resetConversationPbxQueueStatisticsRaw(requestParameters: ResetConversationPbxQueueStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * reset statistics within the queue 
     * reset statistics within the queue
     */
    resetConversationPbxQueueStatistics(requestParameters: ResetConversationPbxQueueStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Search for canned messages by short_code 
     * @summary Search for canned messages by short_code
     * @param {ConversationCannedMessagesSearch} searchRequest Search request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    searchConversationCannedMessagesRaw(requestParameters: SearchConversationCannedMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessagesResponse>>;

    /**
     * Search for canned messages by short_code 
     * Search for canned messages by short_code
     */
    searchConversationCannedMessages(requestParameters: SearchConversationCannedMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessagesResponse>;

    /**
     * Search for available phone numbers from Twilio that can be purchased 
     * @summary Search for available phone numbers
     * @param {string} country ISO country code (e.g., US, CA, GB)
     * @param {string} [areaCode] Area code filter (e.g., 614)
     * @param {string} [contains] Pattern to match (e.g., 555, *PIZZA)
     * @param {boolean} [smsEnabled] Filter for SMS capability
     * @param {boolean} [voiceEnabled] Filter for voice capability
     * @param {string} [type] Phone number type
     * @param {number} [limit] Max results (default 20, max 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    searchPbxAvailablePhoneNumbersRaw(requestParameters: SearchPbxAvailablePhoneNumbersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAvailablePhoneNumbersResponse>>;

    /**
     * Search for available phone numbers from Twilio that can be purchased 
     * Search for available phone numbers
     */
    searchPbxAvailablePhoneNumbers(requestParameters: SearchPbxAvailablePhoneNumbersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAvailablePhoneNumbersResponse>;

    /**
     * Search and list PBX call records with filtering, sorting, and pagination 
     * @summary Search pbx call records
     * @param {ConversationPbxCallSearchRequest} searchRequest Search Request
     * @param {number} [limit] The maximum number of records to return on this one API call. (Maximum 200)
     * @param {number} [offset] Pagination of the record set.  Offset is a zero based index.
     * @param {string} [sort] The sort order of the calls.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    searchPbxCallsRaw(requestParameters: SearchPbxCallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCallSearchResponse>>;

    /**
     * Search and list PBX call records with filtering, sorting, and pagination 
     * Search pbx call records
     */
    searchPbxCalls(requestParameters: SearchPbxCallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCallSearchResponse>;

    /**
     * Unsubscribe any SMS participants in this conversation 
     * @summary Unsubscribe any SMS participants in this conversation
     * @param {string} conversationUuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    smsUnsubscribeConversationRaw(requestParameters: SmsUnsubscribeConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Unsubscribe any SMS participants in this conversation 
     * Unsubscribe any SMS participants in this conversation
     */
    smsUnsubscribeConversation(requestParameters: SmsUnsubscribeConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Start a new conversation 
     * @summary Start a conversation
     * @param {ConversationStartRequest} startRequest Start request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    startConversationRaw(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationStartResponse>>;

    /**
     * Start a new conversation 
     * Start a conversation
     */
    startConversation(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationStartResponse>;

    /**
     * Update agent profile 
     * @summary Update agent profile
     * @param {ConversationAgentProfile} profileRequest Profile request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateAgentProfileRaw(requestParameters: UpdateAgentProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentProfileResponse>>;

    /**
     * Update agent profile 
     * Update agent profile
     */
    updateAgentProfile(requestParameters: UpdateAgentProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentProfileResponse>;

    /**
     * Update an agent MCP server 
     * @summary Update an agent MCP server
     * @param {number} userId 
     * @param {string} mcpServerUuid 
     * @param {ConversationMcpServer} mcpServer MCP Server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateAgentProfileMcpRaw(requestParameters: UpdateAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerResponse>>;

    /**
     * Update an agent MCP server 
     * Update an agent MCP server
     */
    updateAgentProfileMcp(requestParameters: UpdateAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerResponse>;

    /**
     * Update a canned message 
     * @summary Update a canned message
     * @param {number} conversationCannedMessageOid 
     * @param {ConversationCannedMessage} cannedMessage Canned message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateConversationCannedMessageRaw(requestParameters: UpdateConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessageResponse>>;

    /**
     * Update a canned message 
     * Update a canned message
     */
    updateConversationCannedMessage(requestParameters: UpdateConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessageResponse>;

    /**
     * Update a department 
     * @summary Update a department
     * @param {number} conversationDepartmentOid 
     * @param {ConversationDepartment} department Department
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateConversationDepartmentRaw(requestParameters: UpdateConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentResponse>>;

    /**
     * Update a department 
     * Update a department
     */
    updateConversationDepartment(requestParameters: UpdateConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentResponse>;

    /**
     * Update a engagement 
     * @summary Update a engagement
     * @param {number} conversationEngagementOid 
     * @param {ConversationEngagement} engagement Engagement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateConversationEngagementRaw(requestParameters: UpdateConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementResponse>>;

    /**
     * Update a engagement 
     * Update a engagement
     */
    updateConversationEngagement(requestParameters: UpdateConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementResponse>;

    /**
     * Update status within the queue 
     * @summary Update status within the queue
     * @param {string} queueName 
     * @param {ConversationWebchatQueueStatusUpdateRequest} statusRequest Status request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateConversationWebchatQueueStatusRaw(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Update status within the queue 
     * Update status within the queue
     */
    updateConversationWebchatQueueStatus(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Update a pbx address 
     * @summary Update pbx address
     * @param {string} conversationPbxAddressUuid 
     * @param {ConversationPbxAddress} pbxAddress Pbx Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxAddressRaw(requestParameters: UpdatePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>>;

    /**
     * Update a pbx address 
     * Update pbx address
     */
    updatePbxAddress(requestParameters: UpdatePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse>;

    /**
     * Update a pbx agent 
     * @summary Update pbx agent
     * @param {string} conversationPbxAgentUuid 
     * @param {ConversationPbxAgent} pbxAgent Pbx Agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxAgentRaw(requestParameters: UpdatePbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAgentResponse>>;

    /**
     * Update a pbx agent 
     * Update pbx agent
     */
    updatePbxAgent(requestParameters: UpdatePbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAgentResponse>;

    /**
     * Update a pbx audio 
     * @summary Update pbx audio
     * @param {string} conversationPbxAudioUuid 
     * @param {ConversationPbxAudio} pbxAudio Pbx Audio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxAudioRaw(requestParameters: UpdatePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>>;

    /**
     * Update a pbx audio 
     * Update pbx audio
     */
    updatePbxAudio(requestParameters: UpdatePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse>;

    /**
     * Update an existing class of service 
     * @summary Update pbx class of service
     * @param {string} classOfServiceUuid 
     * @param {ConversationPbxClassOfService} classOfService Class of service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxClassOfServiceRaw(requestParameters: UpdatePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServiceResponse>>;

    /**
     * Update an existing class of service 
     * Update pbx class of service
     */
    updatePbxClassOfService(requestParameters: UpdatePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServiceResponse>;

    /**
     * Update a pbx hardware phone 
     * @summary Update pbx hardware phone
     * @param {string} conversationPbxHardwarePhoneUuid 
     * @param {ConversationPbxHardwarePhone} pbxHardwarePhone Pbx Hardware Phone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxHardwarePhoneRaw(requestParameters: UpdatePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>>;

    /**
     * Update a pbx hardware phone 
     * Update pbx hardware phone
     */
    updatePbxHardwarePhone(requestParameters: UpdatePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse>;

    /**
     * Update a pbx menu 
     * @summary Update pbx menu
     * @param {string} conversationPbxMenuUuid 
     * @param {ConversationPbxMenu} pbxMenu Pbx Menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxMenuRaw(requestParameters: UpdatePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>>;

    /**
     * Update a pbx menu 
     * Update pbx menu
     */
    updatePbxMenu(requestParameters: UpdatePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse>;

    /**
     * Update a pbx phoneNumber 
     * @summary Update pbx phoneNumber
     * @param {string} conversationPbxPhoneNumberUuid 
     * @param {ConversationPbxPhoneNumber} pbxPhoneNumber Pbx PhoneNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxPhoneNumberRaw(requestParameters: UpdatePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>>;

    /**
     * Update a pbx phoneNumber 
     * Update pbx phoneNumber
     */
    updatePbxPhoneNumber(requestParameters: UpdatePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse>;

    /**
     * Update a pbx queue 
     * @summary Update pbx queue
     * @param {string} conversationPbxQueueUuid 
     * @param {ConversationPbxQueue} pbxQueue Pbx Queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxQueueRaw(requestParameters: UpdatePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>>;

    /**
     * Update a pbx queue 
     * Update pbx queue
     */
    updatePbxQueue(requestParameters: UpdatePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse>;

    /**
     * Update a pbx timeBased 
     * @summary Update pbx timeBased
     * @param {string} conversationPbxTimeBasedUuid 
     * @param {ConversationPbxTimeBased} pbxTimeBased Pbx TimeBased
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxTimeBasedRaw(requestParameters: UpdatePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>>;

    /**
     * Update a pbx timeBased 
     * Update pbx timeBased
     */
    updatePbxTimeBased(requestParameters: UpdatePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse>;

    /**
     * Update a pbx timeRange 
     * @summary Update pbx timeRange
     * @param {string} conversationPbxTimeRangeUuid 
     * @param {ConversationPbxTimeRange} pbxTimeRange Pbx TimeRange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxTimeRangeRaw(requestParameters: UpdatePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>>;

    /**
     * Update a pbx timeRange 
     * Update pbx timeRange
     */
    updatePbxTimeRange(requestParameters: UpdatePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse>;

    /**
     * Update a pbx voicemailMailbox 
     * @summary Update pbx voicemailMailbox
     * @param {string} conversationPbxVoicemailMailboxUuid 
     * @param {ConversationPbxVoicemailMailbox} pbxVoicemailMailbox Pbx VoicemailMailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updatePbxVoicemailMailboxRaw(requestParameters: UpdatePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>>;

    /**
     * Update a pbx voicemailMailbox 
     * Update pbx voicemailMailbox
     */
    updatePbxVoicemailMailbox(requestParameters: UpdatePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse>;

    /**
     * Update virtual agent budget 
     * @summary Update virtual agent budget
     * @param {ConversationVirtualAgentBudget} virtualAgentBudget Virtual Agent Budget
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateVirtualAgentBudgetRaw(requestParameters: UpdateVirtualAgentBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentBudgetResponse>>;

    /**
     * Update virtual agent budget 
     * Update virtual agent budget
     */
    updateVirtualAgentBudget(requestParameters: UpdateVirtualAgentBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentBudgetResponse>;

    /**
     * Update virtual agent capabilities 
     * @summary Update virtual agent capabilities
     * @param {ConversationVirtualAgentCapabilities} virtualAgentCapabilities Virtual Agent Capabilities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationApiInterface
     */
    updateVirtualAgentCapabilitiesRaw(requestParameters: UpdateVirtualAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentCapabilitiesResponse>>;

    /**
     * Update virtual agent capabilities 
     * Update virtual agent capabilities
     */
    updateVirtualAgentCapabilities(requestParameters: UpdateVirtualAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentCapabilitiesResponse>;

}

/**
 * 
 */
export class ConversationApi extends runtime.BaseAPI implements ConversationApiInterface {

    /**
     * Delete a knowledge base document 
     * Delete a knowledge base document
     */
    async deleteAgentProfileKnowledgeBaseDocumentRaw(requestParameters: DeleteAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDeleteKnowledgeBaseDocumentResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteAgentProfileKnowledgeBaseDocument.');
        }

        if (requestParameters.documentUuid === null || requestParameters.documentUuid === undefined) {
            throw new runtime.RequiredError('documentUuid','Required parameter requestParameters.documentUuid was null or undefined when calling deleteAgentProfileKnowledgeBaseDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/knowledge_base/{document_uuid}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"document_uuid"}}`, encodeURIComponent(String(requestParameters.documentUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationDeleteKnowledgeBaseDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Delete a knowledge base document 
     * Delete a knowledge base document
     */
    async deleteAgentProfileKnowledgeBaseDocument(requestParameters: DeleteAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDeleteKnowledgeBaseDocumentResponse> {
        const response = await this.deleteAgentProfileKnowledgeBaseDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an agent MCP server 
     * Delete an agent MCP server
     */
    async deleteAgentProfileMcpRaw(requestParameters: DeleteAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteAgentProfileMcp.');
        }

        if (requestParameters.mcpServerUuid === null || requestParameters.mcpServerUuid === undefined) {
            throw new runtime.RequiredError('mcpServerUuid','Required parameter requestParameters.mcpServerUuid was null or undefined when calling deleteAgentProfileMcp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/mcps/{mcp_server_uuid}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"mcp_server_uuid"}}`, encodeURIComponent(String(requestParameters.mcpServerUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an agent MCP server 
     * Delete an agent MCP server
     */
    async deleteAgentProfileMcp(requestParameters: DeleteAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAgentProfileMcpRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a conversation canned message 
     * Delete a conversation canned message
     */
    async deleteConversationCannedMessageRaw(requestParameters: DeleteConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationCannedMessageOid === null || requestParameters.conversationCannedMessageOid === undefined) {
            throw new runtime.RequiredError('conversationCannedMessageOid','Required parameter requestParameters.conversationCannedMessageOid was null or undefined when calling deleteConversationCannedMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/canned_messages/{conversation_canned_message_oid}`.replace(`{${"conversation_canned_message_oid"}}`, encodeURIComponent(String(requestParameters.conversationCannedMessageOid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a conversation canned message 
     * Delete a conversation canned message
     */
    async deleteConversationCannedMessage(requestParameters: DeleteConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteConversationCannedMessageRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a conversation department 
     * Delete a conversation department
     */
    async deleteDepartmentRaw(requestParameters: DeleteDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationDepartmentOid === null || requestParameters.conversationDepartmentOid === undefined) {
            throw new runtime.RequiredError('conversationDepartmentOid','Required parameter requestParameters.conversationDepartmentOid was null or undefined when calling deleteDepartment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/departments/{conversation_department_oid}`.replace(`{${"conversation_department_oid"}}`, encodeURIComponent(String(requestParameters.conversationDepartmentOid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a conversation department 
     * Delete a conversation department
     */
    async deleteDepartment(requestParameters: DeleteDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDepartmentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a conversation engagement 
     * Delete a conversation engagement
     */
    async deleteEngagementRaw(requestParameters: DeleteEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationEngagementOid === null || requestParameters.conversationEngagementOid === undefined) {
            throw new runtime.RequiredError('conversationEngagementOid','Required parameter requestParameters.conversationEngagementOid was null or undefined when calling deleteEngagement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/engagements/{conversation_engagement_oid}`.replace(`{${"conversation_engagement_oid"}}`, encodeURIComponent(String(requestParameters.conversationEngagementOid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a conversation engagement 
     * Delete a conversation engagement
     */
    async deleteEngagement(requestParameters: DeleteEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteEngagementRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a pbx address 
     * Delete pbx address
     */
    async deletePbxAddressRaw(requestParameters: DeletePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>> {
        if (requestParameters.conversationPbxAddressUuid === null || requestParameters.conversationPbxAddressUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAddressUuid','Required parameter requestParameters.conversationPbxAddressUuid was null or undefined when calling deletePbxAddress.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/address/{conversationPbxAddressUuid}`.replace(`{${"conversationPbxAddressUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAddressUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAddressResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx address 
     * Delete pbx address
     */
    async deletePbxAddress(requestParameters: DeletePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse> {
        const response = await this.deletePbxAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete pbx agent Voicemail 
     * Delete Agent Voicemail
     */
    async deletePbxAgentVoicemailRaw(requestParameters: DeletePbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.recordingSid === null || requestParameters.recordingSid === undefined) {
            throw new runtime.RequiredError('recordingSid','Required parameter requestParameters.recordingSid was null or undefined when calling deletePbxAgentVoicemail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/agent/voicemails/{recording_sid}`.replace(`{${"recording_sid"}}`, encodeURIComponent(String(requestParameters.recordingSid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete pbx agent Voicemail 
     * Delete Agent Voicemail
     */
    async deletePbxAgentVoicemail(requestParameters: DeletePbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePbxAgentVoicemailRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a pbx audio 
     * Delete pbx audio
     */
    async deletePbxAudioRaw(requestParameters: DeletePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>> {
        if (requestParameters.conversationPbxAudioUuid === null || requestParameters.conversationPbxAudioUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAudioUuid','Required parameter requestParameters.conversationPbxAudioUuid was null or undefined when calling deletePbxAudio.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/audio/{conversationPbxAudioUuid}`.replace(`{${"conversationPbxAudioUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAudioUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAudioResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx audio 
     * Delete pbx audio
     */
    async deletePbxAudio(requestParameters: DeletePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse> {
        const response = await this.deletePbxAudioRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a class of service 
     * Delete pbx class of service
     */
    async deletePbxClassOfServiceRaw(requestParameters: DeletePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponse>> {
        if (requestParameters.classOfServiceUuid === null || requestParameters.classOfServiceUuid === undefined) {
            throw new runtime.RequiredError('classOfServiceUuid','Required parameter requestParameters.classOfServiceUuid was null or undefined when calling deletePbxClassOfService.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/class_of_service/{classOfServiceUuid}`.replace(`{${"classOfServiceUuid"}}`, encodeURIComponent(String(requestParameters.classOfServiceUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseFromJSON(jsonValue));
    }

    /**
     * Delete a class of service 
     * Delete pbx class of service
     */
    async deletePbxClassOfService(requestParameters: DeletePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponse> {
        const response = await this.deletePbxClassOfServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a pbx hardware phone 
     * Delete pbx hardware phone
     */
    async deletePbxHardwarePhoneRaw(requestParameters: DeletePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>> {
        if (requestParameters.conversationPbxHardwarePhoneUuid === null || requestParameters.conversationPbxHardwarePhoneUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxHardwarePhoneUuid','Required parameter requestParameters.conversationPbxHardwarePhoneUuid was null or undefined when calling deletePbxHardwarePhone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/hardware_phone/{conversationPbxHardwarePhoneUuid}`.replace(`{${"conversationPbxHardwarePhoneUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxHardwarePhoneUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxHardwarePhoneResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx hardware phone 
     * Delete pbx hardware phone
     */
    async deletePbxHardwarePhone(requestParameters: DeletePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse> {
        const response = await this.deletePbxHardwarePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a pbx menu 
     * Delete pbx menu
     */
    async deletePbxMenuRaw(requestParameters: DeletePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>> {
        if (requestParameters.conversationPbxMenuUuid === null || requestParameters.conversationPbxMenuUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxMenuUuid','Required parameter requestParameters.conversationPbxMenuUuid was null or undefined when calling deletePbxMenu.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/menu/{conversationPbxMenuUuid}`.replace(`{${"conversationPbxMenuUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxMenuUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxMenuResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx menu 
     * Delete pbx menu
     */
    async deletePbxMenu(requestParameters: DeletePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse> {
        const response = await this.deletePbxMenuRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a pbx phoneNumber. Only works if deletion_protected is false. 
     * Delete pbx phoneNumber
     */
    async deletePbxPhoneNumberRaw(requestParameters: DeletePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationPbxPhoneNumberUuid === null || requestParameters.conversationPbxPhoneNumberUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxPhoneNumberUuid','Required parameter requestParameters.conversationPbxPhoneNumberUuid was null or undefined when calling deletePbxPhoneNumber.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/phone_number/{conversationPbxPhoneNumberUuid}`.replace(`{${"conversationPbxPhoneNumberUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxPhoneNumberUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a pbx phoneNumber. Only works if deletion_protected is false. 
     * Delete pbx phoneNumber
     */
    async deletePbxPhoneNumber(requestParameters: DeletePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePbxPhoneNumberRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a pbx queue 
     * Delete pbx queue
     */
    async deletePbxQueueRaw(requestParameters: DeletePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>> {
        if (requestParameters.conversationPbxQueueUuid === null || requestParameters.conversationPbxQueueUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxQueueUuid','Required parameter requestParameters.conversationPbxQueueUuid was null or undefined when calling deletePbxQueue.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queue/{conversationPbxQueueUuid}`.replace(`{${"conversationPbxQueueUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxQueueUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxQueueResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx queue 
     * Delete pbx queue
     */
    async deletePbxQueue(requestParameters: DeletePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse> {
        const response = await this.deletePbxQueueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete pbx queue Voicemail 
     * Delete Queue Voicemail
     */
    async deletePbxQueueVoicemailRaw(requestParameters: DeletePbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.queueUuid === null || requestParameters.queueUuid === undefined) {
            throw new runtime.RequiredError('queueUuid','Required parameter requestParameters.queueUuid was null or undefined when calling deletePbxQueueVoicemail.');
        }

        if (requestParameters.recordingSid === null || requestParameters.recordingSid === undefined) {
            throw new runtime.RequiredError('recordingSid','Required parameter requestParameters.recordingSid was null or undefined when calling deletePbxQueueVoicemail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queues/{queue_uuid}/voicemails/{recording_sid}`.replace(`{${"queue_uuid"}}`, encodeURIComponent(String(requestParameters.queueUuid))).replace(`{${"recording_sid"}}`, encodeURIComponent(String(requestParameters.recordingSid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete pbx queue Voicemail 
     * Delete Queue Voicemail
     */
    async deletePbxQueueVoicemail(requestParameters: DeletePbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePbxQueueVoicemailRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a pbx timeBased 
     * Delete pbx timeBased
     */
    async deletePbxTimeBasedRaw(requestParameters: DeletePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>> {
        if (requestParameters.conversationPbxTimeBasedUuid === null || requestParameters.conversationPbxTimeBasedUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxTimeBasedUuid','Required parameter requestParameters.conversationPbxTimeBasedUuid was null or undefined when calling deletePbxTimeBased.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_based/{conversationPbxTimeBasedUuid}`.replace(`{${"conversationPbxTimeBasedUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxTimeBasedUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeBasedResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx timeBased 
     * Delete pbx timeBased
     */
    async deletePbxTimeBased(requestParameters: DeletePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse> {
        const response = await this.deletePbxTimeBasedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a pbx timeRange 
     * Delete pbx timeRange
     */
    async deletePbxTimeRangeRaw(requestParameters: DeletePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>> {
        if (requestParameters.conversationPbxTimeRangeUuid === null || requestParameters.conversationPbxTimeRangeUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxTimeRangeUuid','Required parameter requestParameters.conversationPbxTimeRangeUuid was null or undefined when calling deletePbxTimeRange.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_range/{conversationPbxTimeRangeUuid}`.replace(`{${"conversationPbxTimeRangeUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxTimeRangeUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeRangeResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx timeRange 
     * Delete pbx timeRange
     */
    async deletePbxTimeRange(requestParameters: DeletePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse> {
        const response = await this.deletePbxTimeRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a pbx voicemailMailbox 
     * Delete pbx voicemailMailbox
     */
    async deletePbxVoicemailMailboxRaw(requestParameters: DeletePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>> {
        if (requestParameters.conversationPbxVoicemailMailboxUuid === null || requestParameters.conversationPbxVoicemailMailboxUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxVoicemailMailboxUuid','Required parameter requestParameters.conversationPbxVoicemailMailboxUuid was null or undefined when calling deletePbxVoicemailMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/voicemail_mailbox/{conversationPbxVoicemailMailboxUuid}`.replace(`{${"conversationPbxVoicemailMailboxUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxVoicemailMailboxUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMailboxResponseFromJSON(jsonValue));
    }

    /**
     * Delete a pbx voicemailMailbox 
     * Delete pbx voicemailMailbox
     */
    async deletePbxVoicemailMailbox(requestParameters: DeletePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse> {
        const response = await this.deletePbxVoicemailMailboxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Called periodically by the conversation API to keep the session alive. 
     * Agent keep alive
     */
    async getAgentKeepAliveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/keepalive`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Called periodically by the conversation API to keep the session alive. 
     * Agent keep alive
     */
    async getAgentKeepAlive(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAgentKeepAliveRaw(initOverrides);
    }

    /**
     * Retrieve the agents profile 
     * Get agent profile
     */
    async getAgentProfileRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentProfileResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profile`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationAgentProfileResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the agents profile 
     * Get agent profile
     */
    async getAgentProfile(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentProfileResponse> {
        const response = await this.getAgentProfileRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve knowledge base documents 
     * Get the list of knowledge base documents associated with this agent profile
     */
    async getAgentProfileKnowledgeBaseRaw(requestParameters: GetAgentProfileKnowledgeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationKnowledgeBaseDocumentsResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getAgentProfileKnowledgeBase.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/knowledge_base`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationKnowledgeBaseDocumentsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve knowledge base documents 
     * Get the list of knowledge base documents associated with this agent profile
     */
    async getAgentProfileKnowledgeBase(requestParameters: GetAgentProfileKnowledgeBaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationKnowledgeBaseDocumentsResponse> {
        const response = await this.getAgentProfileKnowledgeBaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve MCP server associated with this agent 
     * Get an MCP server associated with this agent
     */
    async getAgentProfileMcpRaw(requestParameters: GetAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getAgentProfileMcp.');
        }

        if (requestParameters.mcpServerUuid === null || requestParameters.mcpServerUuid === undefined) {
            throw new runtime.RequiredError('mcpServerUuid','Required parameter requestParameters.mcpServerUuid was null or undefined when calling getAgentProfileMcp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/mcps/{mcp_server_uuid}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"mcp_server_uuid"}}`, encodeURIComponent(String(requestParameters.mcpServerUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMcpServerResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve MCP server associated with this agent 
     * Get an MCP server associated with this agent
     */
    async getAgentProfileMcp(requestParameters: GetAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerResponse> {
        const response = await this.getAgentProfileMcpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the tools available from the MCP server 
     * Get the tools available from the MCP server
     */
    async getAgentProfileMcpToolsRaw(requestParameters: GetAgentProfileMcpToolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerToolsResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getAgentProfileMcpTools.');
        }

        if (requestParameters.mcpServerUuid === null || requestParameters.mcpServerUuid === undefined) {
            throw new runtime.RequiredError('mcpServerUuid','Required parameter requestParameters.mcpServerUuid was null or undefined when calling getAgentProfileMcpTools.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/mcps/{mcp_server_uuid}/tools`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"mcp_server_uuid"}}`, encodeURIComponent(String(requestParameters.mcpServerUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMcpServerToolsResponseFromJSON(jsonValue));
    }

    /**
     * Get the tools available from the MCP server 
     * Get the tools available from the MCP server
     */
    async getAgentProfileMcpTools(requestParameters: GetAgentProfileMcpToolsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerToolsResponse> {
        const response = await this.getAgentProfileMcpToolsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve MCP servers associated with this agent 
     * Get the list of MCP servers associated with this agent
     */
    async getAgentProfileMcpsRaw(requestParameters: GetAgentProfileMcpsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServersResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getAgentProfileMcps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/mcps`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMcpServersResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve MCP servers associated with this agent 
     * Get the list of MCP servers associated with this agent
     */
    async getAgentProfileMcps(requestParameters: GetAgentProfileMcpsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServersResponse> {
        const response = await this.getAgentProfileMcpsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the agents profile 
     * Get agent profiles
     */
    async getAgentProfilesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentProfilesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationAgentProfilesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the agents profile 
     * Get agent profiles
     */
    async getAgentProfiles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentProfilesResponse> {
        const response = await this.getAgentProfilesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * Get agent websocket authorization
     */
    async getAgentWebsocketAuthorizationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentAuthResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/auth`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationAgentAuthResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a JWT to authorize an agent to make a websocket connection. 
     * Get agent websocket authorization
     */
    async getAgentWebsocketAuthorization(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentAuthResponse> {
        const response = await this.getAgentWebsocketAuthorizationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a conversation including the participants and messages 
     * Retrieve a conversation
     */
    async getConversationRaw(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling getConversation.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a conversation including the participants and messages 
     * Retrieve a conversation
     */
    async getConversation(requestParameters: GetConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse> {
        const response = await this.getConversationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of canned messages ordered by short_code 
     * Retrieve a list of canned messages ordered by short_code
     */
    async getConversationCannedMessagesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessagesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/canned_messages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationCannedMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of canned messages ordered by short_code 
     * Retrieve a list of canned messages ordered by short_code
     */
    async getConversationCannedMessages(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessagesResponse> {
        const response = await this.getConversationCannedMessagesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a webchat conversation context 
     * Get a webchat conversation context
     */
    async getConversationContextRaw(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatContext>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling getConversationContext.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/context`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationWebchatContextFromJSON(jsonValue));
    }

    /**
     * Get a webchat conversation context 
     * Get a webchat conversation context
     */
    async getConversationContext(requestParameters: GetConversationContextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatContext> {
        const response = await this.getConversationContextRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of possible department members 
     * Retrieve a list of possible department members
     */
    async getConversationDepartmentMemberListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentMembersResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/department_members`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationDepartmentMembersResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of possible department members 
     * Retrieve a list of possible department members
     */
    async getConversationDepartmentMemberList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentMembersResponse> {
        const response = await this.getConversationDepartmentMemberListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of departments ordered by name 
     * Retrieve a list of departments ordered by name
     */
    async getConversationDepartmentsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/departments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationDepartmentsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of departments ordered by name 
     * Retrieve a list of departments ordered by name
     */
    async getConversationDepartments(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentsResponse> {
        const response = await this.getConversationDepartmentsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an engagement 
     * Retrieve an engagement
     */
    async getConversationEngagementRaw(requestParameters: GetConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementResponse>> {
        if (requestParameters.conversationEngagementOid === null || requestParameters.conversationEngagementOid === undefined) {
            throw new runtime.RequiredError('conversationEngagementOid','Required parameter requestParameters.conversationEngagementOid was null or undefined when calling getConversationEngagement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/engagements/{conversation_engagement_oid}`.replace(`{${"conversation_engagement_oid"}}`, encodeURIComponent(String(requestParameters.conversationEngagementOid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationEngagementResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve an engagement 
     * Retrieve an engagement
     */
    async getConversationEngagement(requestParameters: GetConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementResponse> {
        const response = await this.getConversationEngagementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of engagements ordered by name 
     * Retrieve a list of engagements ordered by name
     */
    async getConversationEngagementsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/engagements`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationEngagementsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of engagements ordered by name 
     * Retrieve a list of engagements ordered by name
     */
    async getConversationEngagements(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementsResponse> {
        const response = await this.getConversationEngagementsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a pre-signed conversation knowledge base document upload URL 
     * Get a pre-signed conversation knowledge base document upload URL
     */
    async getConversationKnowledgeBaseDocumentUploadUrlRaw(requestParameters: GetConversationKnowledgeBaseDocumentUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationKnowledgeBaseDocumentUploadUrlResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getConversationKnowledgeBaseDocumentUploadUrl.');
        }

        if (requestParameters.extension === null || requestParameters.extension === undefined) {
            throw new runtime.RequiredError('extension','Required parameter requestParameters.extension was null or undefined when calling getConversationKnowledgeBaseDocumentUploadUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/knowledge_base/upload_url/{extension}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"extension"}}`, encodeURIComponent(String(requestParameters.extension))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationKnowledgeBaseDocumentUploadUrlResponseFromJSON(jsonValue));
    }

    /**
     * Get a pre-signed conversation knowledge base document upload URL 
     * Get a pre-signed conversation knowledge base document upload URL
     */
    async getConversationKnowledgeBaseDocumentUploadUrl(requestParameters: GetConversationKnowledgeBaseDocumentUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationKnowledgeBaseDocumentUploadUrlResponse> {
        const response = await this.getConversationKnowledgeBaseDocumentUploadUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve conversation messages since a particular time 
     * Retrieve conversation messages
     */
    async getConversationMessagesRaw(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMessagesResponse>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling getConversationMessages.');
        }

        if (requestParameters.since === null || requestParameters.since === undefined) {
            throw new runtime.RequiredError('since','Required parameter requestParameters.since was null or undefined when calling getConversationMessages.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/messages/{since}`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))).replace(`{${"since"}}`, encodeURIComponent(String(requestParameters.since))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve conversation messages since a particular time 
     * Retrieve conversation messages
     */
    async getConversationMessages(requestParameters: GetConversationMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMessagesResponse> {
        const response = await this.getConversationMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a presigned conversation multimedia upload URL 
     * Get a presigned conversation multimedia upload URL
     */
    async getConversationMultimediaUploadUrlRaw(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMultimediaUploadUrlResponse>> {
        if (requestParameters.extension === null || requestParameters.extension === undefined) {
            throw new runtime.RequiredError('extension','Required parameter requestParameters.extension was null or undefined when calling getConversationMultimediaUploadUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/upload_url/{extension}`.replace(`{${"extension"}}`, encodeURIComponent(String(requestParameters.extension))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMultimediaUploadUrlResponseFromJSON(jsonValue));
    }

    /**
     * Get a presigned conversation multimedia upload URL 
     * Get a presigned conversation multimedia upload URL
     */
    async getConversationMultimediaUploadUrl(requestParameters: GetConversationMultimediaUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMultimediaUploadUrlResponse> {
        const response = await this.getConversationMultimediaUploadUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a pre-signed conversation multimedia upload URL 
     * Get a pre-signed conversation multimedia upload URL
     */
    async getConversationPbxAudioUploadUrlRaw(requestParameters: GetConversationPbxAudioUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioUploadUrlResponse>> {
        if (requestParameters.extension === null || requestParameters.extension === undefined) {
            throw new runtime.RequiredError('extension','Required parameter requestParameters.extension was null or undefined when calling getConversationPbxAudioUploadUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/audio/upload_url/{extension}`.replace(`{${"extension"}}`, encodeURIComponent(String(requestParameters.extension))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAudioUploadUrlResponseFromJSON(jsonValue));
    }

    /**
     * Get a pre-signed conversation multimedia upload URL 
     * Get a pre-signed conversation multimedia upload URL
     */
    async getConversationPbxAudioUploadUrl(requestParameters: GetConversationPbxAudioUploadUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioUploadUrlResponse> {
        const response = await this.getConversationPbxAudioUploadUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all the orders, auto orders, and customer profile for a given phone number 
     * Get orders and customer information for a phone number
     */
    async getConversationPbxCustomerSnapshotRaw(requestParameters: GetConversationPbxCustomerSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCustomerSnapshotResponse>> {
        if (requestParameters.pbxCustomerSnapshotRequest === null || requestParameters.pbxCustomerSnapshotRequest === undefined) {
            throw new runtime.RequiredError('pbxCustomerSnapshotRequest','Required parameter requestParameters.pbxCustomerSnapshotRequest was null or undefined when calling getConversationPbxCustomerSnapshot.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/customer_snapshot`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxCustomerSnapshotRequestToJSON(requestParameters.pbxCustomerSnapshotRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxCustomerSnapshotResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves all the orders, auto orders, and customer profile for a given phone number 
     * Get orders and customer information for a phone number
     */
    async getConversationPbxCustomerSnapshot(requestParameters: GetConversationPbxCustomerSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCustomerSnapshotResponse> {
        const response = await this.getConversationPbxCustomerSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve conversation permissions 
     * Retrieve conversation permissions
     */
    async getConversationPermissionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPermissionsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/permissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPermissionsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve conversation permissions 
     * Retrieve conversation permissions
     */
    async getConversationPermissions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPermissionsResponse> {
        const response = await this.getConversationPermissionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * Retrieve a conversation webchat queue statuses
     */
    async getConversationWebchatQueueStatusesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWebchatQueueStatusesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/queues/statuses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationWebchatQueueStatusesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a conversation webchat queue statuses including agent status and queue entries 
     * Retrieve a conversation webchat queue statuses
     */
    async getConversationWebchatQueueStatuses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWebchatQueueStatusesResponse> {
        const response = await this.getConversationWebchatQueueStatusesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * Retrieve a list of conversation summaries newest to oldest
     */
    async getConversationsRaw(requestParameters: GetConversationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.medium !== undefined) {
            queryParameters['medium'] = requestParameters.medium;
        }

        if (requestParameters.before !== undefined) {
            queryParameters['before'] = requestParameters.before;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['_limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['_offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of conversation summaries that are ordered newest to oldest, include the most recent message and whether its been read. 
     * Retrieve a list of conversation summaries newest to oldest
     */
    async getConversations(requestParameters: GetConversationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationsResponse> {
        const response = await this.getConversationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of matching terms for a search field 
     * Retrieve a list of matching terms for a search field
     */
    async getConversationsAutocompleteRaw(requestParameters: GetConversationsAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAutocompleteResponse>> {
        if (requestParameters.autocompleteRequest === null || requestParameters.autocompleteRequest === undefined) {
            throw new runtime.RequiredError('autocompleteRequest','Required parameter requestParameters.autocompleteRequest was null or undefined when calling getConversationsAutocomplete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/autocomplete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationAutocompleteRequestToJSON(requestParameters.autocompleteRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationAutocompleteResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a list of matching terms for a search field 
     * Retrieve a list of matching terms for a search field
     */
    async getConversationsAutocomplete(requestParameters: GetConversationsAutocompleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAutocompleteResponse> {
        const response = await this.getConversationsAutocompleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search conversations 
     * Search conversations
     */
    async getConversationsSearchRaw(requestParameters: GetConversationsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationSearchResponse>> {
        if (requestParameters.searchRequest === null || requestParameters.searchRequest === undefined) {
            throw new runtime.RequiredError('searchRequest','Required parameter requestParameters.searchRequest was null or undefined when calling getConversationsSearch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationSearchRequestToJSON(requestParameters.searchRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationSearchResponseFromJSON(jsonValue));
    }

    /**
     * Search conversations 
     * Search conversations
     */
    async getConversationsSearch(requestParameters: GetConversationsSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationSearchResponse> {
        const response = await this.getConversationsSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get location data for engagement configuration 
     * Get location data for engagement configuration
     */
    async getLocationsForEngagementRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationLocationsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/locations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationLocationsResponseFromJSON(jsonValue));
    }

    /**
     * Get location data for engagement configuration 
     * Get location data for engagement configuration
     */
    async getLocationsForEngagement(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationLocationsResponse> {
        const response = await this.getLocationsForEngagementRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx address 
     * Get pbx address
     */
    async getPbxAddressRaw(requestParameters: GetPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>> {
        if (requestParameters.conversationPbxAddressUuid === null || requestParameters.conversationPbxAddressUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAddressUuid','Required parameter requestParameters.conversationPbxAddressUuid was null or undefined when calling getPbxAddress.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/address/{conversationPbxAddressUuid}`.replace(`{${"conversationPbxAddressUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAddressUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAddressResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx address 
     * Get pbx address
     */
    async getPbxAddress(requestParameters: GetPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse> {
        const response = await this.getPbxAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx addresses 
     * Get pbx addresses
     */
    async getPbxAddressesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/address`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAddressesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx addresses 
     * Get pbx addresses
     */
    async getPbxAddresses(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressesResponse> {
        const response = await this.getPbxAddressesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx agent 
     * Get pbx agent
     */
    async getPbxAgentRaw(requestParameters: GetPbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAgentResponse>> {
        if (requestParameters.conversationPbxAgentUuid === null || requestParameters.conversationPbxAgentUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAgentUuid','Required parameter requestParameters.conversationPbxAgentUuid was null or undefined when calling getPbxAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/agent/{conversationPbxAgentUuid}`.replace(`{${"conversationPbxAgentUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAgentUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAgentResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx agent 
     * Get pbx agent
     */
    async getPbxAgent(requestParameters: GetPbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAgentResponse> {
        const response = await this.getPbxAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx agent Voicemail 
     * Get Agent Voicemail
     */
    async getPbxAgentVoicemailRaw(requestParameters: GetPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageResponse>> {
        if (requestParameters.recordingSid === null || requestParameters.recordingSid === undefined) {
            throw new runtime.RequiredError('recordingSid','Required parameter requestParameters.recordingSid was null or undefined when calling getPbxAgentVoicemail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/agent/voicemails/{recording_sid}`.replace(`{${"recording_sid"}}`, encodeURIComponent(String(requestParameters.recordingSid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMessageResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx agent Voicemail 
     * Get Agent Voicemail
     */
    async getPbxAgentVoicemail(requestParameters: GetPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageResponse> {
        const response = await this.getPbxAgentVoicemailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx agent Voicemails 
     * Get Agent Voicemails
     */
    async getPbxAgentVoicemailsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageSummariesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/agent/voicemails`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMessageSummariesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx agent Voicemails 
     * Get Agent Voicemails
     */
    async getPbxAgentVoicemails(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageSummariesResponse> {
        const response = await this.getPbxAgentVoicemailsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx agents 
     * Get pbx agents
     */
    async getPbxAgentsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAgentsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/agent`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAgentsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx agents 
     * Get pbx agents
     */
    async getPbxAgents(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAgentsResponse> {
        const response = await this.getPbxAgentsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx audio 
     * Get pbx audio
     */
    async getPbxAudioRaw(requestParameters: GetPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>> {
        if (requestParameters.conversationPbxAudioUuid === null || requestParameters.conversationPbxAudioUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAudioUuid','Required parameter requestParameters.conversationPbxAudioUuid was null or undefined when calling getPbxAudio.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/audio/{conversationPbxAudioUuid}`.replace(`{${"conversationPbxAudioUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAudioUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAudioResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx audio 
     * Get pbx audio
     */
    async getPbxAudio(requestParameters: GetPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse> {
        const response = await this.getPbxAudioRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx audio usage 
     * Get pbx audio usage
     */
    async getPbxAudioUsageRaw(requestParameters: GetPbxAudioUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioUsageResponse>> {
        if (requestParameters.conversationPbxAudioUuid === null || requestParameters.conversationPbxAudioUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAudioUuid','Required parameter requestParameters.conversationPbxAudioUuid was null or undefined when calling getPbxAudioUsage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/audio/{conversationPbxAudioUuid}/usage`.replace(`{${"conversationPbxAudioUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAudioUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAudioUsageResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx audio usage 
     * Get pbx audio usage
     */
    async getPbxAudioUsage(requestParameters: GetPbxAudioUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioUsageResponse> {
        const response = await this.getPbxAudioUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx audios 
     * Get pbx audios
     */
    async getPbxAudiosRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudiosResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/audio`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAudiosResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx audios 
     * Get pbx audios
     */
    async getPbxAudios(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudiosResponse> {
        const response = await this.getPbxAudiosRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a single PBX call record with full details 
     * Get pbx call record
     */
    async getPbxCallRaw(requestParameters: GetPbxCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCallResponse>> {
        if (requestParameters.callUuid === null || requestParameters.callUuid === undefined) {
            throw new runtime.RequiredError('callUuid','Required parameter requestParameters.callUuid was null or undefined when calling getPbxCall.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/call/{callUuid}`.replace(`{${"callUuid"}}`, encodeURIComponent(String(requestParameters.callUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxCallResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a single PBX call record with full details 
     * Get pbx call record
     */
    async getPbxCall(requestParameters: GetPbxCallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCallResponse> {
        const response = await this.getPbxCallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a single class of service 
     * Get pbx class of service
     */
    async getPbxClassOfServiceRaw(requestParameters: GetPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServiceResponse>> {
        if (requestParameters.classOfServiceUuid === null || requestParameters.classOfServiceUuid === undefined) {
            throw new runtime.RequiredError('classOfServiceUuid','Required parameter requestParameters.classOfServiceUuid was null or undefined when calling getPbxClassOfService.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/class_of_service/{classOfServiceUuid}`.replace(`{${"classOfServiceUuid"}}`, encodeURIComponent(String(requestParameters.classOfServiceUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxClassOfServiceResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a single class of service 
     * Get pbx class of service
     */
    async getPbxClassOfService(requestParameters: GetPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServiceResponse> {
        const response = await this.getPbxClassOfServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all classes of service for the merchant 
     * Get pbx classes of service
     */
    async getPbxClassesOfServiceRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServicesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/class_of_service`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxClassOfServicesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all classes of service for the merchant 
     * Get pbx classes of service
     */
    async getPbxClassesOfService(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServicesResponse> {
        const response = await this.getPbxClassesOfServiceRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve audit log entries for class of service enforcement 
     * Get pbx class of service audit logs
     */
    async getPbxCosAuditLogsRaw(requestParameters: GetPbxCosAuditLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCosAuditLogsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.since !== undefined) {
            queryParameters['since'] = requestParameters.since;
        }

        if (requestParameters.agentLogin !== undefined) {
            queryParameters['agent_login'] = requestParameters.agentLogin;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/class_of_service/audit_log`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxCosAuditLogsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve audit log entries for class of service enforcement 
     * Get pbx class of service audit logs
     */
    async getPbxCosAuditLogs(requestParameters: GetPbxCosAuditLogsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCosAuditLogsResponse> {
        const response = await this.getPbxCosAuditLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx hardware phone 
     * Get pbx hardware phone
     */
    async getPbxHardwarePhoneRaw(requestParameters: GetPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>> {
        if (requestParameters.conversationPbxHardwarePhoneUuid === null || requestParameters.conversationPbxHardwarePhoneUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxHardwarePhoneUuid','Required parameter requestParameters.conversationPbxHardwarePhoneUuid was null or undefined when calling getPbxHardwarePhone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/hardware_phone/{conversationPbxHardwarePhoneUuid}`.replace(`{${"conversationPbxHardwarePhoneUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxHardwarePhoneUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxHardwarePhoneResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx hardware phone 
     * Get pbx hardware phone
     */
    async getPbxHardwarePhone(requestParameters: GetPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse> {
        const response = await this.getPbxHardwarePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx hardware phone manufacturers and models for auto-provisioning 
     * Get pbx hardware phone manufacturers
     */
    async getPbxHardwarePhoneManufacturersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneManufacturersResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/hardware_phone/manufacturers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxPhoneManufacturersResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx hardware phone manufacturers and models for auto-provisioning 
     * Get pbx hardware phone manufacturers
     */
    async getPbxHardwarePhoneManufacturers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneManufacturersResponse> {
        const response = await this.getPbxHardwarePhoneManufacturersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx hardware phones 
     * Get pbx hardware phones
     */
    async getPbxHardwarePhonesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhonesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/hardware_phone`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxHardwarePhonesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx hardware phones 
     * Get pbx hardware phones
     */
    async getPbxHardwarePhones(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhonesResponse> {
        const response = await this.getPbxHardwarePhonesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx menu 
     * Get pbx menu
     */
    async getPbxMenuRaw(requestParameters: GetPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>> {
        if (requestParameters.conversationPbxMenuUuid === null || requestParameters.conversationPbxMenuUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxMenuUuid','Required parameter requestParameters.conversationPbxMenuUuid was null or undefined when calling getPbxMenu.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/menu/{conversationPbxMenuUuid}`.replace(`{${"conversationPbxMenuUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxMenuUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxMenuResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx menu 
     * Get pbx menu
     */
    async getPbxMenu(requestParameters: GetPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse> {
        const response = await this.getPbxMenuRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx menus 
     * Get pbx menus
     */
    async getPbxMenusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenusResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/menu`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxMenusResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx menus 
     * Get pbx menus
     */
    async getPbxMenus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenusResponse> {
        const response = await this.getPbxMenusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx phoneNumber 
     * Get pbx phoneNumber
     */
    async getPbxPhoneNumberRaw(requestParameters: GetPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>> {
        if (requestParameters.conversationPbxPhoneNumberUuid === null || requestParameters.conversationPbxPhoneNumberUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxPhoneNumberUuid','Required parameter requestParameters.conversationPbxPhoneNumberUuid was null or undefined when calling getPbxPhoneNumber.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/phone_number/{conversationPbxPhoneNumberUuid}`.replace(`{${"conversationPbxPhoneNumberUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxPhoneNumberUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxPhoneNumberResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx phoneNumber 
     * Get pbx phoneNumber
     */
    async getPbxPhoneNumber(requestParameters: GetPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse> {
        const response = await this.getPbxPhoneNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx phoneNumbers 
     * Get pbx phoneNumbers
     */
    async getPbxPhoneNumbersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumbersResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/phone_number`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxPhoneNumbersResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx phoneNumbers 
     * Get pbx phoneNumbers
     */
    async getPbxPhoneNumbers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumbersResponse> {
        const response = await this.getPbxPhoneNumbersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx queue 
     * Get pbx queue
     */
    async getPbxQueueRaw(requestParameters: GetPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>> {
        if (requestParameters.conversationPbxQueueUuid === null || requestParameters.conversationPbxQueueUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxQueueUuid','Required parameter requestParameters.conversationPbxQueueUuid was null or undefined when calling getPbxQueue.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queue/{conversationPbxQueueUuid}`.replace(`{${"conversationPbxQueueUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxQueueUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxQueueResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx queue 
     * Get pbx queue
     */
    async getPbxQueue(requestParameters: GetPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse> {
        const response = await this.getPbxQueueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx queue Voicemail 
     * Get Queue Voicemail
     */
    async getPbxQueueVoicemailRaw(requestParameters: GetPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageResponse>> {
        if (requestParameters.queueUuid === null || requestParameters.queueUuid === undefined) {
            throw new runtime.RequiredError('queueUuid','Required parameter requestParameters.queueUuid was null or undefined when calling getPbxQueueVoicemail.');
        }

        if (requestParameters.recordingSid === null || requestParameters.recordingSid === undefined) {
            throw new runtime.RequiredError('recordingSid','Required parameter requestParameters.recordingSid was null or undefined when calling getPbxQueueVoicemail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queues/{queue_uuid}/voicemails/{recording_sid}`.replace(`{${"queue_uuid"}}`, encodeURIComponent(String(requestParameters.queueUuid))).replace(`{${"recording_sid"}}`, encodeURIComponent(String(requestParameters.recordingSid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMessageResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx queue Voicemail 
     * Get Queue Voicemail
     */
    async getPbxQueueVoicemail(requestParameters: GetPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageResponse> {
        const response = await this.getPbxQueueVoicemailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx queue voicemails 
     * Get Queue Voicemails
     */
    async getPbxQueueVoicemailsRaw(requestParameters: GetPbxQueueVoicemailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMessageSummariesResponse>> {
        if (requestParameters.queueUuid === null || requestParameters.queueUuid === undefined) {
            throw new runtime.RequiredError('queueUuid','Required parameter requestParameters.queueUuid was null or undefined when calling getPbxQueueVoicemails.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queues/{queue_uuid}/voicemails`.replace(`{${"queue_uuid"}}`, encodeURIComponent(String(requestParameters.queueUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMessageSummariesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx queue voicemails 
     * Get Queue Voicemails
     */
    async getPbxQueueVoicemails(requestParameters: GetPbxQueueVoicemailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMessageSummariesResponse> {
        const response = await this.getPbxQueueVoicemailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx queues 
     * Get pbx queues
     */
    async getPbxQueuesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueuesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxQueuesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx queues 
     * Get pbx queues
     */
    async getPbxQueues(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueuesResponse> {
        const response = await this.getPbxQueuesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx timeBased 
     * Get pbx timeBased
     */
    async getPbxTimeBasedRaw(requestParameters: GetPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>> {
        if (requestParameters.conversationPbxTimeBasedUuid === null || requestParameters.conversationPbxTimeBasedUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxTimeBasedUuid','Required parameter requestParameters.conversationPbxTimeBasedUuid was null or undefined when calling getPbxTimeBased.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_based/{conversationPbxTimeBasedUuid}`.replace(`{${"conversationPbxTimeBasedUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxTimeBasedUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeBasedResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx timeBased 
     * Get pbx timeBased
     */
    async getPbxTimeBased(requestParameters: GetPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse> {
        const response = await this.getPbxTimeBasedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx timeBaseds 
     * Get pbx timeBaseds
     */
    async getPbxTimeBasedsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_based`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeBasedsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx timeBaseds 
     * Get pbx timeBaseds
     */
    async getPbxTimeBaseds(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedsResponse> {
        const response = await this.getPbxTimeBasedsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx timeRange 
     * Get pbx timeRange
     */
    async getPbxTimeRangeRaw(requestParameters: GetPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>> {
        if (requestParameters.conversationPbxTimeRangeUuid === null || requestParameters.conversationPbxTimeRangeUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxTimeRangeUuid','Required parameter requestParameters.conversationPbxTimeRangeUuid was null or undefined when calling getPbxTimeRange.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_range/{conversationPbxTimeRangeUuid}`.replace(`{${"conversationPbxTimeRangeUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxTimeRangeUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeRangeResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx timeRange 
     * Get pbx timeRange
     */
    async getPbxTimeRange(requestParameters: GetPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse> {
        const response = await this.getPbxTimeRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx timeRanges 
     * Get pbx timeRanges
     */
    async getPbxTimeRangesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_range`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeRangesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx timeRanges 
     * Get pbx timeRanges
     */
    async getPbxTimeRanges(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangesResponse> {
        const response = await this.getPbxTimeRangesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a pbx voicemailMailbox 
     * Get pbx voicemailMailbox
     */
    async getPbxVoicemailMailboxRaw(requestParameters: GetPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>> {
        if (requestParameters.conversationPbxVoicemailMailboxUuid === null || requestParameters.conversationPbxVoicemailMailboxUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxVoicemailMailboxUuid','Required parameter requestParameters.conversationPbxVoicemailMailboxUuid was null or undefined when calling getPbxVoicemailMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/voicemail_mailbox/{conversationPbxVoicemailMailboxUuid}`.replace(`{${"conversationPbxVoicemailMailboxUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxVoicemailMailboxUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMailboxResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a pbx voicemailMailbox 
     * Get pbx voicemailMailbox
     */
    async getPbxVoicemailMailbox(requestParameters: GetPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse> {
        const response = await this.getPbxVoicemailMailboxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve pbx voicemailMailboxes 
     * Get pbx voicemailMailboxes
     */
    async getPbxVoicemailMailboxesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/voicemail_mailbox`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMailboxesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve pbx voicemailMailboxes 
     * Get pbx voicemailMailboxes
     */
    async getPbxVoicemailMailboxes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxesResponse> {
        const response = await this.getPbxVoicemailMailboxesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve virtual agent budget 
     * Get virtual agent budget
     */
    async getVirtualAgentBudgetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentBudgetResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/virtualagent/budget`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationVirtualAgentBudgetResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve virtual agent budget 
     * Get virtual agent budget
     */
    async getVirtualAgentBudget(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentBudgetResponse> {
        const response = await this.getVirtualAgentBudgetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve virtual agent capabilities 
     * Get virtual agent capabilities
     */
    async getVirtualAgentCapabilitiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentCapabilitiesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/virtualagent/capabilities`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationVirtualAgentCapabilitiesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve virtual agent capabilities 
     * Get virtual agent capabilities
     */
    async getVirtualAgentCapabilities(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentCapabilitiesResponse> {
        const response = await this.getVirtualAgentCapabilitiesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Insert a knowledge base document 
     * Insert a knowledge base document
     */
    async insertAgentProfileKnowledgeBaseDocumentRaw(requestParameters: InsertAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationInsertKnowledgeBaseDocumentResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling insertAgentProfileKnowledgeBaseDocument.');
        }

        if (requestParameters.knowledgeBaseDocumentRequest === null || requestParameters.knowledgeBaseDocumentRequest === undefined) {
            throw new runtime.RequiredError('knowledgeBaseDocumentRequest','Required parameter requestParameters.knowledgeBaseDocumentRequest was null or undefined when calling insertAgentProfileKnowledgeBaseDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/knowledge_base`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationInsertKnowledgeBaseDocumentRequestToJSON(requestParameters.knowledgeBaseDocumentRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationInsertKnowledgeBaseDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Insert a knowledge base document 
     * Insert a knowledge base document
     */
    async insertAgentProfileKnowledgeBaseDocument(requestParameters: InsertAgentProfileKnowledgeBaseDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationInsertKnowledgeBaseDocumentResponse> {
        const response = await this.insertAgentProfileKnowledgeBaseDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert an agent MCP server 
     * Insert an agent MCP server
     */
    async insertAgentProfileMcpRaw(requestParameters: InsertAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling insertAgentProfileMcp.');
        }

        if (requestParameters.mcpServer === null || requestParameters.mcpServer === undefined) {
            throw new runtime.RequiredError('mcpServer','Required parameter requestParameters.mcpServer was null or undefined when calling insertAgentProfileMcp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/mcps`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationMcpServerToJSON(requestParameters.mcpServer),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMcpServerResponseFromJSON(jsonValue));
    }

    /**
     * Insert an agent MCP server 
     * Insert an agent MCP server
     */
    async insertAgentProfileMcp(requestParameters: InsertAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerResponse> {
        const response = await this.insertAgentProfileMcpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a canned message 
     * Insert a canned message
     */
    async insertConversationCannedMessageRaw(requestParameters: InsertConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessageResponse>> {
        if (requestParameters.cannedMessage === null || requestParameters.cannedMessage === undefined) {
            throw new runtime.RequiredError('cannedMessage','Required parameter requestParameters.cannedMessage was null or undefined when calling insertConversationCannedMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/canned_messages`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationCannedMessageToJSON(requestParameters.cannedMessage),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationCannedMessageResponseFromJSON(jsonValue));
    }

    /**
     * Insert a canned message 
     * Insert a canned message
     */
    async insertConversationCannedMessage(requestParameters: InsertConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessageResponse> {
        const response = await this.insertConversationCannedMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a department 
     * Insert a department
     */
    async insertConversationDepartmentRaw(requestParameters: InsertConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentResponse>> {
        if (requestParameters.department === null || requestParameters.department === undefined) {
            throw new runtime.RequiredError('department','Required parameter requestParameters.department was null or undefined when calling insertConversationDepartment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/departments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationDepartmentToJSON(requestParameters.department),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationDepartmentResponseFromJSON(jsonValue));
    }

    /**
     * Insert a department 
     * Insert a department
     */
    async insertConversationDepartment(requestParameters: InsertConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentResponse> {
        const response = await this.insertConversationDepartmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a engagement 
     * Insert a engagement
     */
    async insertConversationEngagementRaw(requestParameters: InsertConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementResponse>> {
        if (requestParameters.engagement === null || requestParameters.engagement === undefined) {
            throw new runtime.RequiredError('engagement','Required parameter requestParameters.engagement was null or undefined when calling insertConversationEngagement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/engagements`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationEngagementToJSON(requestParameters.engagement),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationEngagementResponseFromJSON(jsonValue));
    }

    /**
     * Insert a engagement 
     * Insert a engagement
     */
    async insertConversationEngagement(requestParameters: InsertConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementResponse> {
        const response = await this.insertConversationEngagementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx address 
     * Insert pbx address
     */
    async insertPbxAddressRaw(requestParameters: InsertPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>> {
        if (requestParameters.pbxAddress === null || requestParameters.pbxAddress === undefined) {
            throw new runtime.RequiredError('pbxAddress','Required parameter requestParameters.pbxAddress was null or undefined when calling insertPbxAddress.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/address`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxAddressToJSON(requestParameters.pbxAddress),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAddressResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx address 
     * Insert pbx address
     */
    async insertPbxAddress(requestParameters: InsertPbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse> {
        const response = await this.insertPbxAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx audio 
     * Insert pbx audio
     */
    async insertPbxAudioRaw(requestParameters: InsertPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>> {
        if (requestParameters.pbxAudio === null || requestParameters.pbxAudio === undefined) {
            throw new runtime.RequiredError('pbxAudio','Required parameter requestParameters.pbxAudio was null or undefined when calling insertPbxAudio.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/audio`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxAudioToJSON(requestParameters.pbxAudio),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAudioResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx audio 
     * Insert pbx audio
     */
    async insertPbxAudio(requestParameters: InsertPbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse> {
        const response = await this.insertPbxAudioRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new class of service 
     * Insert pbx class of service
     */
    async insertPbxClassOfServiceRaw(requestParameters: InsertPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServiceResponse>> {
        if (requestParameters.classOfService === null || requestParameters.classOfService === undefined) {
            throw new runtime.RequiredError('classOfService','Required parameter requestParameters.classOfService was null or undefined when calling insertPbxClassOfService.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json; charset=UTF-8';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/class_of_service`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxClassOfServiceToJSON(requestParameters.classOfService),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxClassOfServiceResponseFromJSON(jsonValue));
    }

    /**
     * Create a new class of service 
     * Insert pbx class of service
     */
    async insertPbxClassOfService(requestParameters: InsertPbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServiceResponse> {
        const response = await this.insertPbxClassOfServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx hardware phone 
     * Insert pbx hardware phone
     */
    async insertPbxHardwarePhoneRaw(requestParameters: InsertPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>> {
        if (requestParameters.pbxHardwarePhone === null || requestParameters.pbxHardwarePhone === undefined) {
            throw new runtime.RequiredError('pbxHardwarePhone','Required parameter requestParameters.pbxHardwarePhone was null or undefined when calling insertPbxHardwarePhone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/hardware_phone`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxHardwarePhoneToJSON(requestParameters.pbxHardwarePhone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxHardwarePhoneResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx hardware phone 
     * Insert pbx hardware phone
     */
    async insertPbxHardwarePhone(requestParameters: InsertPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse> {
        const response = await this.insertPbxHardwarePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx menu 
     * Insert pbx menu
     */
    async insertPbxMenuRaw(requestParameters: InsertPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>> {
        if (requestParameters.pbxMenu === null || requestParameters.pbxMenu === undefined) {
            throw new runtime.RequiredError('pbxMenu','Required parameter requestParameters.pbxMenu was null or undefined when calling insertPbxMenu.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/menu`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxMenuToJSON(requestParameters.pbxMenu),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxMenuResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx menu 
     * Insert pbx menu
     */
    async insertPbxMenu(requestParameters: InsertPbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse> {
        const response = await this.insertPbxMenuRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx queue 
     * Insert pbx queue
     */
    async insertPbxQueueRaw(requestParameters: InsertPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>> {
        if (requestParameters.pbxQueue === null || requestParameters.pbxQueue === undefined) {
            throw new runtime.RequiredError('pbxQueue','Required parameter requestParameters.pbxQueue was null or undefined when calling insertPbxQueue.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queue`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxQueueToJSON(requestParameters.pbxQueue),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxQueueResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx queue 
     * Insert pbx queue
     */
    async insertPbxQueue(requestParameters: InsertPbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse> {
        const response = await this.insertPbxQueueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx timeBased 
     * Insert pbx timeBased
     */
    async insertPbxTimeBasedRaw(requestParameters: InsertPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>> {
        if (requestParameters.pbxTimeBased === null || requestParameters.pbxTimeBased === undefined) {
            throw new runtime.RequiredError('pbxTimeBased','Required parameter requestParameters.pbxTimeBased was null or undefined when calling insertPbxTimeBased.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_based`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxTimeBasedToJSON(requestParameters.pbxTimeBased),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeBasedResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx timeBased 
     * Insert pbx timeBased
     */
    async insertPbxTimeBased(requestParameters: InsertPbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse> {
        const response = await this.insertPbxTimeBasedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx timeRange 
     * Insert pbx timeRange
     */
    async insertPbxTimeRangeRaw(requestParameters: InsertPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>> {
        if (requestParameters.pbxTimeRange === null || requestParameters.pbxTimeRange === undefined) {
            throw new runtime.RequiredError('pbxTimeRange','Required parameter requestParameters.pbxTimeRange was null or undefined when calling insertPbxTimeRange.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_range`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxTimeRangeToJSON(requestParameters.pbxTimeRange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeRangeResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx timeRange 
     * Insert pbx timeRange
     */
    async insertPbxTimeRange(requestParameters: InsertPbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse> {
        const response = await this.insertPbxTimeRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Insert a pbx voicemailMailbox 
     * Insert pbx voicemailMailbox
     */
    async insertPbxVoicemailMailboxRaw(requestParameters: InsertPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>> {
        if (requestParameters.pbxVoicemailMailbox === null || requestParameters.pbxVoicemailMailbox === undefined) {
            throw new runtime.RequiredError('pbxVoicemailMailbox','Required parameter requestParameters.pbxVoicemailMailbox was null or undefined when calling insertPbxVoicemailMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/voicemail_mailbox`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxVoicemailMailboxToJSON(requestParameters.pbxVoicemailMailbox),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMailboxResponseFromJSON(jsonValue));
    }

    /**
     * Insert a pbx voicemailMailbox 
     * Insert pbx voicemailMailbox
     */
    async insertPbxVoicemailMailbox(requestParameters: InsertPbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse> {
        const response = await this.insertPbxVoicemailMailboxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Join a conversation 
     * Join a conversation
     */
    async joinConversationRaw(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling joinConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/join`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationJoinRequestToJSON(requestParameters.joinRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Join a conversation 
     * Join a conversation
     */
    async joinConversation(requestParameters: JoinConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.joinConversationRaw(requestParameters, initOverrides);
    }

    /**
     * Leave a conversation 
     * Leave a conversation
     */
    async leaveConversationRaw(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling leaveConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/leave`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Leave a conversation 
     * Leave a conversation
     */
    async leaveConversation(requestParameters: LeaveConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leaveConversationRaw(requestParameters, initOverrides);
    }

    /**
     * Listened pbx agent Voicemail 
     * Listened Agent Voicemail
     */
    async listenedPbxAgentVoicemailRaw(requestParameters: ListenedPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.recordingSid === null || requestParameters.recordingSid === undefined) {
            throw new runtime.RequiredError('recordingSid','Required parameter requestParameters.recordingSid was null or undefined when calling listenedPbxAgentVoicemail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/agent/voicemails/{recording_sid}/listened`.replace(`{${"recording_sid"}}`, encodeURIComponent(String(requestParameters.recordingSid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Listened pbx agent Voicemail 
     * Listened Agent Voicemail
     */
    async listenedPbxAgentVoicemail(requestParameters: ListenedPbxAgentVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listenedPbxAgentVoicemailRaw(requestParameters, initOverrides);
    }

    /**
     * Listened pbx queue Voicemail 
     * Listened Queue Voicemail
     */
    async listenedPbxQueueVoicemailRaw(requestParameters: ListenedPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.queueUuid === null || requestParameters.queueUuid === undefined) {
            throw new runtime.RequiredError('queueUuid','Required parameter requestParameters.queueUuid was null or undefined when calling listenedPbxQueueVoicemail.');
        }

        if (requestParameters.recordingSid === null || requestParameters.recordingSid === undefined) {
            throw new runtime.RequiredError('recordingSid','Required parameter requestParameters.recordingSid was null or undefined when calling listenedPbxQueueVoicemail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queues/{queue_uuid}/voicemails/{recording_sid}/listened`.replace(`{${"queue_uuid"}}`, encodeURIComponent(String(requestParameters.queueUuid))).replace(`{${"recording_sid"}}`, encodeURIComponent(String(requestParameters.recordingSid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Listened pbx queue Voicemail 
     * Listened Queue Voicemail
     */
    async listenedPbxQueueVoicemail(requestParameters: ListenedPbxQueueVoicemailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.listenedPbxQueueVoicemailRaw(requestParameters, initOverrides);
    }

    /**
     * Mark a conversation as read 
     * Mark a conversation as read
     */
    async markReadConversationRaw(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling markReadConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/markread`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Mark a conversation as read 
     * Mark a conversation as read
     */
    async markReadConversation(requestParameters: MarkReadConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.markReadConversationRaw(requestParameters, initOverrides);
    }

    /**
     * Protect a pbx phoneNumber from deletion. This is a one-way operation and cannot be undone through the API. 
     * Protect pbx phoneNumber from deletion
     */
    async protectPbxPhoneNumberRaw(requestParameters: ProtectPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>> {
        if (requestParameters.conversationPbxPhoneNumberUuid === null || requestParameters.conversationPbxPhoneNumberUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxPhoneNumberUuid','Required parameter requestParameters.conversationPbxPhoneNumberUuid was null or undefined when calling protectPbxPhoneNumber.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/phone_number/{conversationPbxPhoneNumberUuid}/protect`.replace(`{${"conversationPbxPhoneNumberUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxPhoneNumberUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxPhoneNumberResponseFromJSON(jsonValue));
    }

    /**
     * Protect a pbx phoneNumber from deletion. This is a one-way operation and cannot be undone through the API. 
     * Protect pbx phoneNumber from deletion
     */
    async protectPbxPhoneNumber(requestParameters: ProtectPbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse> {
        const response = await this.protectPbxPhoneNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Purchase a phone number from Twilio. The phone_number must be from the available phone number search results. 
     * Purchase pbx phone number
     */
    async purchasePbxPhoneNumberRaw(requestParameters: PurchasePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>> {
        if (requestParameters.phoneNumberPurchaseRequest === null || requestParameters.phoneNumberPurchaseRequest === undefined) {
            throw new runtime.RequiredError('phoneNumberPurchaseRequest','Required parameter requestParameters.phoneNumberPurchaseRequest was null or undefined when calling purchasePbxPhoneNumber.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/phone_number`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxPhoneNumberPurchaseRequestToJSON(requestParameters.phoneNumberPurchaseRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxPhoneNumberResponseFromJSON(jsonValue));
    }

    /**
     * Purchase a phone number from Twilio. The phone_number must be from the available phone number search results. 
     * Purchase pbx phone number
     */
    async purchasePbxPhoneNumber(requestParameters: PurchasePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse> {
        const response = await this.purchasePbxPhoneNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx hardware phone 
     * Update pbx hardware phone
     */
    async regeneratePasswordForPbxHardwarePhoneRaw(requestParameters: RegeneratePasswordForPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>> {
        if (requestParameters.conversationPbxHardwarePhoneUuid === null || requestParameters.conversationPbxHardwarePhoneUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxHardwarePhoneUuid','Required parameter requestParameters.conversationPbxHardwarePhoneUuid was null or undefined when calling regeneratePasswordForPbxHardwarePhone.');
        }

        if (requestParameters.pbxHardwarePhone === null || requestParameters.pbxHardwarePhone === undefined) {
            throw new runtime.RequiredError('pbxHardwarePhone','Required parameter requestParameters.pbxHardwarePhone was null or undefined when calling regeneratePasswordForPbxHardwarePhone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/hardware_phone/{conversationPbxHardwarePhoneUuid}/regenerate_password`.replace(`{${"conversationPbxHardwarePhoneUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxHardwarePhoneUuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxHardwarePhoneToJSON(requestParameters.pbxHardwarePhone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxHardwarePhoneResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx hardware phone 
     * Update pbx hardware phone
     */
    async regeneratePasswordForPbxHardwarePhone(requestParameters: RegeneratePasswordForPbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse> {
        const response = await this.regeneratePasswordForPbxHardwarePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * reset statistics within the queue 
     * reset statistics within the queue
     */
    async resetConversationPbxQueueStatisticsRaw(requestParameters: ResetConversationPbxQueueStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.queueUuid === null || requestParameters.queueUuid === undefined) {
            throw new runtime.RequiredError('queueUuid','Required parameter requestParameters.queueUuid was null or undefined when calling resetConversationPbxQueueStatistics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queues/{queue_uuid}/reset_statistics`.replace(`{${"queue_uuid"}}`, encodeURIComponent(String(requestParameters.queueUuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * reset statistics within the queue 
     * reset statistics within the queue
     */
    async resetConversationPbxQueueStatistics(requestParameters: ResetConversationPbxQueueStatisticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resetConversationPbxQueueStatisticsRaw(requestParameters, initOverrides);
    }

    /**
     * Search for canned messages by short_code 
     * Search for canned messages by short_code
     */
    async searchConversationCannedMessagesRaw(requestParameters: SearchConversationCannedMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessagesResponse>> {
        if (requestParameters.searchRequest === null || requestParameters.searchRequest === undefined) {
            throw new runtime.RequiredError('searchRequest','Required parameter requestParameters.searchRequest was null or undefined when calling searchConversationCannedMessages.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/canned_messages/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationCannedMessagesSearchToJSON(requestParameters.searchRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationCannedMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Search for canned messages by short_code 
     * Search for canned messages by short_code
     */
    async searchConversationCannedMessages(requestParameters: SearchConversationCannedMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessagesResponse> {
        const response = await this.searchConversationCannedMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for available phone numbers from Twilio that can be purchased 
     * Search for available phone numbers
     */
    async searchPbxAvailablePhoneNumbersRaw(requestParameters: SearchPbxAvailablePhoneNumbersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAvailablePhoneNumbersResponse>> {
        if (requestParameters.country === null || requestParameters.country === undefined) {
            throw new runtime.RequiredError('country','Required parameter requestParameters.country was null or undefined when calling searchPbxAvailablePhoneNumbers.');
        }

        const queryParameters: any = {};

        if (requestParameters.country !== undefined) {
            queryParameters['country'] = requestParameters.country;
        }

        if (requestParameters.areaCode !== undefined) {
            queryParameters['area_code'] = requestParameters.areaCode;
        }

        if (requestParameters.contains !== undefined) {
            queryParameters['contains'] = requestParameters.contains;
        }

        if (requestParameters.smsEnabled !== undefined) {
            queryParameters['sms_enabled'] = requestParameters.smsEnabled;
        }

        if (requestParameters.voiceEnabled !== undefined) {
            queryParameters['voice_enabled'] = requestParameters.voiceEnabled;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/phone_number/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAvailablePhoneNumbersResponseFromJSON(jsonValue));
    }

    /**
     * Search for available phone numbers from Twilio that can be purchased 
     * Search for available phone numbers
     */
    async searchPbxAvailablePhoneNumbers(requestParameters: SearchPbxAvailablePhoneNumbersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAvailablePhoneNumbersResponse> {
        const response = await this.searchPbxAvailablePhoneNumbersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search and list PBX call records with filtering, sorting, and pagination 
     * Search pbx call records
     */
    async searchPbxCallsRaw(requestParameters: SearchPbxCallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxCallSearchResponse>> {
        if (requestParameters.searchRequest === null || requestParameters.searchRequest === undefined) {
            throw new runtime.RequiredError('searchRequest','Required parameter requestParameters.searchRequest was null or undefined when calling searchPbxCalls.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['_limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['_offset'] = requestParameters.offset;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['_sort'] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/call/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxCallSearchRequestToJSON(requestParameters.searchRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxCallSearchResponseFromJSON(jsonValue));
    }

    /**
     * Search and list PBX call records with filtering, sorting, and pagination 
     * Search pbx call records
     */
    async searchPbxCalls(requestParameters: SearchPbxCallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxCallSearchResponse> {
        const response = await this.searchPbxCallsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unsubscribe any SMS participants in this conversation 
     * Unsubscribe any SMS participants in this conversation
     */
    async smsUnsubscribeConversationRaw(requestParameters: SmsUnsubscribeConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.conversationUuid === null || requestParameters.conversationUuid === undefined) {
            throw new runtime.RequiredError('conversationUuid','Required parameter requestParameters.conversationUuid was null or undefined when calling smsUnsubscribeConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/{conversation_uuid}/sms_unsubscribe`.replace(`{${"conversation_uuid"}}`, encodeURIComponent(String(requestParameters.conversationUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unsubscribe any SMS participants in this conversation 
     * Unsubscribe any SMS participants in this conversation
     */
    async smsUnsubscribeConversation(requestParameters: SmsUnsubscribeConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.smsUnsubscribeConversationRaw(requestParameters, initOverrides);
    }

    /**
     * Start a new conversation 
     * Start a conversation
     */
    async startConversationRaw(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationStartResponse>> {
        if (requestParameters.startRequest === null || requestParameters.startRequest === undefined) {
            throw new runtime.RequiredError('startRequest','Required parameter requestParameters.startRequest was null or undefined when calling startConversation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationStartRequestToJSON(requestParameters.startRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationStartResponseFromJSON(jsonValue));
    }

    /**
     * Start a new conversation 
     * Start a conversation
     */
    async startConversation(requestParameters: StartConversationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationStartResponse> {
        const response = await this.startConversationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update agent profile 
     * Update agent profile
     */
    async updateAgentProfileRaw(requestParameters: UpdateAgentProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationAgentProfileResponse>> {
        if (requestParameters.profileRequest === null || requestParameters.profileRequest === undefined) {
            throw new runtime.RequiredError('profileRequest','Required parameter requestParameters.profileRequest was null or undefined when calling updateAgentProfile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profile`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationAgentProfileToJSON(requestParameters.profileRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationAgentProfileResponseFromJSON(jsonValue));
    }

    /**
     * Update agent profile 
     * Update agent profile
     */
    async updateAgentProfile(requestParameters: UpdateAgentProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationAgentProfileResponse> {
        const response = await this.updateAgentProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an agent MCP server 
     * Update an agent MCP server
     */
    async updateAgentProfileMcpRaw(requestParameters: UpdateAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationMcpServerResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling updateAgentProfileMcp.');
        }

        if (requestParameters.mcpServerUuid === null || requestParameters.mcpServerUuid === undefined) {
            throw new runtime.RequiredError('mcpServerUuid','Required parameter requestParameters.mcpServerUuid was null or undefined when calling updateAgentProfileMcp.');
        }

        if (requestParameters.mcpServer === null || requestParameters.mcpServer === undefined) {
            throw new runtime.RequiredError('mcpServer','Required parameter requestParameters.mcpServer was null or undefined when calling updateAgentProfileMcp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/agent/profiles/{user_id}/mcps/{mcp_server_uuid}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"mcp_server_uuid"}}`, encodeURIComponent(String(requestParameters.mcpServerUuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationMcpServerToJSON(requestParameters.mcpServer),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationMcpServerResponseFromJSON(jsonValue));
    }

    /**
     * Update an agent MCP server 
     * Update an agent MCP server
     */
    async updateAgentProfileMcp(requestParameters: UpdateAgentProfileMcpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationMcpServerResponse> {
        const response = await this.updateAgentProfileMcpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a canned message 
     * Update a canned message
     */
    async updateConversationCannedMessageRaw(requestParameters: UpdateConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationCannedMessageResponse>> {
        if (requestParameters.conversationCannedMessageOid === null || requestParameters.conversationCannedMessageOid === undefined) {
            throw new runtime.RequiredError('conversationCannedMessageOid','Required parameter requestParameters.conversationCannedMessageOid was null or undefined when calling updateConversationCannedMessage.');
        }

        if (requestParameters.cannedMessage === null || requestParameters.cannedMessage === undefined) {
            throw new runtime.RequiredError('cannedMessage','Required parameter requestParameters.cannedMessage was null or undefined when calling updateConversationCannedMessage.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/canned_messages/{conversation_canned_message_oid}`.replace(`{${"conversation_canned_message_oid"}}`, encodeURIComponent(String(requestParameters.conversationCannedMessageOid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationCannedMessageToJSON(requestParameters.cannedMessage),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationCannedMessageResponseFromJSON(jsonValue));
    }

    /**
     * Update a canned message 
     * Update a canned message
     */
    async updateConversationCannedMessage(requestParameters: UpdateConversationCannedMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationCannedMessageResponse> {
        const response = await this.updateConversationCannedMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a department 
     * Update a department
     */
    async updateConversationDepartmentRaw(requestParameters: UpdateConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDepartmentResponse>> {
        if (requestParameters.conversationDepartmentOid === null || requestParameters.conversationDepartmentOid === undefined) {
            throw new runtime.RequiredError('conversationDepartmentOid','Required parameter requestParameters.conversationDepartmentOid was null or undefined when calling updateConversationDepartment.');
        }

        if (requestParameters.department === null || requestParameters.department === undefined) {
            throw new runtime.RequiredError('department','Required parameter requestParameters.department was null or undefined when calling updateConversationDepartment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/departments/{conversation_department_oid}`.replace(`{${"conversation_department_oid"}}`, encodeURIComponent(String(requestParameters.conversationDepartmentOid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationDepartmentToJSON(requestParameters.department),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationDepartmentResponseFromJSON(jsonValue));
    }

    /**
     * Update a department 
     * Update a department
     */
    async updateConversationDepartment(requestParameters: UpdateConversationDepartmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDepartmentResponse> {
        const response = await this.updateConversationDepartmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a engagement 
     * Update a engagement
     */
    async updateConversationEngagementRaw(requestParameters: UpdateConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationEngagementResponse>> {
        if (requestParameters.conversationEngagementOid === null || requestParameters.conversationEngagementOid === undefined) {
            throw new runtime.RequiredError('conversationEngagementOid','Required parameter requestParameters.conversationEngagementOid was null or undefined when calling updateConversationEngagement.');
        }

        if (requestParameters.engagement === null || requestParameters.engagement === undefined) {
            throw new runtime.RequiredError('engagement','Required parameter requestParameters.engagement was null or undefined when calling updateConversationEngagement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_read"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/engagements/{conversation_engagement_oid}`.replace(`{${"conversation_engagement_oid"}}`, encodeURIComponent(String(requestParameters.conversationEngagementOid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationEngagementToJSON(requestParameters.engagement),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationEngagementResponseFromJSON(jsonValue));
    }

    /**
     * Update a engagement 
     * Update a engagement
     */
    async updateConversationEngagement(requestParameters: UpdateConversationEngagementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationEngagementResponse> {
        const response = await this.updateConversationEngagementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update status within the queue 
     * Update status within the queue
     */
    async updateConversationWebchatQueueStatusRaw(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.queueName === null || requestParameters.queueName === undefined) {
            throw new runtime.RequiredError('queueName','Required parameter requestParameters.queueName was null or undefined when calling updateConversationWebchatQueueStatus.');
        }

        if (requestParameters.statusRequest === null || requestParameters.statusRequest === undefined) {
            throw new runtime.RequiredError('statusRequest','Required parameter requestParameters.statusRequest was null or undefined when calling updateConversationWebchatQueueStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/conversations/queues/{queue_name}/status`.replace(`{${"queue_name"}}`, encodeURIComponent(String(requestParameters.queueName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationWebchatQueueStatusUpdateRequestToJSON(requestParameters.statusRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update status within the queue 
     * Update status within the queue
     */
    async updateConversationWebchatQueueStatus(requestParameters: UpdateConversationWebchatQueueStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateConversationWebchatQueueStatusRaw(requestParameters, initOverrides);
    }

    /**
     * Update a pbx address 
     * Update pbx address
     */
    async updatePbxAddressRaw(requestParameters: UpdatePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAddressResponse>> {
        if (requestParameters.conversationPbxAddressUuid === null || requestParameters.conversationPbxAddressUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAddressUuid','Required parameter requestParameters.conversationPbxAddressUuid was null or undefined when calling updatePbxAddress.');
        }

        if (requestParameters.pbxAddress === null || requestParameters.pbxAddress === undefined) {
            throw new runtime.RequiredError('pbxAddress','Required parameter requestParameters.pbxAddress was null or undefined when calling updatePbxAddress.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/address/{conversationPbxAddressUuid}`.replace(`{${"conversationPbxAddressUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAddressUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxAddressToJSON(requestParameters.pbxAddress),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAddressResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx address 
     * Update pbx address
     */
    async updatePbxAddress(requestParameters: UpdatePbxAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAddressResponse> {
        const response = await this.updatePbxAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx agent 
     * Update pbx agent
     */
    async updatePbxAgentRaw(requestParameters: UpdatePbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAgentResponse>> {
        if (requestParameters.conversationPbxAgentUuid === null || requestParameters.conversationPbxAgentUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAgentUuid','Required parameter requestParameters.conversationPbxAgentUuid was null or undefined when calling updatePbxAgent.');
        }

        if (requestParameters.pbxAgent === null || requestParameters.pbxAgent === undefined) {
            throw new runtime.RequiredError('pbxAgent','Required parameter requestParameters.pbxAgent was null or undefined when calling updatePbxAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/agent/{conversationPbxAgentUuid}`.replace(`{${"conversationPbxAgentUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAgentUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxAgentToJSON(requestParameters.pbxAgent),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAgentResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx agent 
     * Update pbx agent
     */
    async updatePbxAgent(requestParameters: UpdatePbxAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAgentResponse> {
        const response = await this.updatePbxAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx audio 
     * Update pbx audio
     */
    async updatePbxAudioRaw(requestParameters: UpdatePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxAudioResponse>> {
        if (requestParameters.conversationPbxAudioUuid === null || requestParameters.conversationPbxAudioUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxAudioUuid','Required parameter requestParameters.conversationPbxAudioUuid was null or undefined when calling updatePbxAudio.');
        }

        if (requestParameters.pbxAudio === null || requestParameters.pbxAudio === undefined) {
            throw new runtime.RequiredError('pbxAudio','Required parameter requestParameters.pbxAudio was null or undefined when calling updatePbxAudio.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/audio/{conversationPbxAudioUuid}`.replace(`{${"conversationPbxAudioUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxAudioUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxAudioToJSON(requestParameters.pbxAudio),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxAudioResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx audio 
     * Update pbx audio
     */
    async updatePbxAudio(requestParameters: UpdatePbxAudioRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxAudioResponse> {
        const response = await this.updatePbxAudioRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing class of service 
     * Update pbx class of service
     */
    async updatePbxClassOfServiceRaw(requestParameters: UpdatePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxClassOfServiceResponse>> {
        if (requestParameters.classOfServiceUuid === null || requestParameters.classOfServiceUuid === undefined) {
            throw new runtime.RequiredError('classOfServiceUuid','Required parameter requestParameters.classOfServiceUuid was null or undefined when calling updatePbxClassOfService.');
        }

        if (requestParameters.classOfService === null || requestParameters.classOfService === undefined) {
            throw new runtime.RequiredError('classOfService','Required parameter requestParameters.classOfService was null or undefined when calling updatePbxClassOfService.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json; charset=UTF-8';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/class_of_service/{classOfServiceUuid}`.replace(`{${"classOfServiceUuid"}}`, encodeURIComponent(String(requestParameters.classOfServiceUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxClassOfServiceToJSON(requestParameters.classOfService),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxClassOfServiceResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing class of service 
     * Update pbx class of service
     */
    async updatePbxClassOfService(requestParameters: UpdatePbxClassOfServiceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxClassOfServiceResponse> {
        const response = await this.updatePbxClassOfServiceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx hardware phone 
     * Update pbx hardware phone
     */
    async updatePbxHardwarePhoneRaw(requestParameters: UpdatePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxHardwarePhoneResponse>> {
        if (requestParameters.conversationPbxHardwarePhoneUuid === null || requestParameters.conversationPbxHardwarePhoneUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxHardwarePhoneUuid','Required parameter requestParameters.conversationPbxHardwarePhoneUuid was null or undefined when calling updatePbxHardwarePhone.');
        }

        if (requestParameters.pbxHardwarePhone === null || requestParameters.pbxHardwarePhone === undefined) {
            throw new runtime.RequiredError('pbxHardwarePhone','Required parameter requestParameters.pbxHardwarePhone was null or undefined when calling updatePbxHardwarePhone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/hardware_phone/{conversationPbxHardwarePhoneUuid}`.replace(`{${"conversationPbxHardwarePhoneUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxHardwarePhoneUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxHardwarePhoneToJSON(requestParameters.pbxHardwarePhone),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxHardwarePhoneResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx hardware phone 
     * Update pbx hardware phone
     */
    async updatePbxHardwarePhone(requestParameters: UpdatePbxHardwarePhoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxHardwarePhoneResponse> {
        const response = await this.updatePbxHardwarePhoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx menu 
     * Update pbx menu
     */
    async updatePbxMenuRaw(requestParameters: UpdatePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxMenuResponse>> {
        if (requestParameters.conversationPbxMenuUuid === null || requestParameters.conversationPbxMenuUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxMenuUuid','Required parameter requestParameters.conversationPbxMenuUuid was null or undefined when calling updatePbxMenu.');
        }

        if (requestParameters.pbxMenu === null || requestParameters.pbxMenu === undefined) {
            throw new runtime.RequiredError('pbxMenu','Required parameter requestParameters.pbxMenu was null or undefined when calling updatePbxMenu.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/menu/{conversationPbxMenuUuid}`.replace(`{${"conversationPbxMenuUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxMenuUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxMenuToJSON(requestParameters.pbxMenu),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxMenuResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx menu 
     * Update pbx menu
     */
    async updatePbxMenu(requestParameters: UpdatePbxMenuRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxMenuResponse> {
        const response = await this.updatePbxMenuRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx phoneNumber 
     * Update pbx phoneNumber
     */
    async updatePbxPhoneNumberRaw(requestParameters: UpdatePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxPhoneNumberResponse>> {
        if (requestParameters.conversationPbxPhoneNumberUuid === null || requestParameters.conversationPbxPhoneNumberUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxPhoneNumberUuid','Required parameter requestParameters.conversationPbxPhoneNumberUuid was null or undefined when calling updatePbxPhoneNumber.');
        }

        if (requestParameters.pbxPhoneNumber === null || requestParameters.pbxPhoneNumber === undefined) {
            throw new runtime.RequiredError('pbxPhoneNumber','Required parameter requestParameters.pbxPhoneNumber was null or undefined when calling updatePbxPhoneNumber.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/phone_number/{conversationPbxPhoneNumberUuid}`.replace(`{${"conversationPbxPhoneNumberUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxPhoneNumberUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxPhoneNumberToJSON(requestParameters.pbxPhoneNumber),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxPhoneNumberResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx phoneNumber 
     * Update pbx phoneNumber
     */
    async updatePbxPhoneNumber(requestParameters: UpdatePbxPhoneNumberRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxPhoneNumberResponse> {
        const response = await this.updatePbxPhoneNumberRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx queue 
     * Update pbx queue
     */
    async updatePbxQueueRaw(requestParameters: UpdatePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxQueueResponse>> {
        if (requestParameters.conversationPbxQueueUuid === null || requestParameters.conversationPbxQueueUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxQueueUuid','Required parameter requestParameters.conversationPbxQueueUuid was null or undefined when calling updatePbxQueue.');
        }

        if (requestParameters.pbxQueue === null || requestParameters.pbxQueue === undefined) {
            throw new runtime.RequiredError('pbxQueue','Required parameter requestParameters.pbxQueue was null or undefined when calling updatePbxQueue.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/queue/{conversationPbxQueueUuid}`.replace(`{${"conversationPbxQueueUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxQueueUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxQueueToJSON(requestParameters.pbxQueue),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxQueueResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx queue 
     * Update pbx queue
     */
    async updatePbxQueue(requestParameters: UpdatePbxQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxQueueResponse> {
        const response = await this.updatePbxQueueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx timeBased 
     * Update pbx timeBased
     */
    async updatePbxTimeBasedRaw(requestParameters: UpdatePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeBasedResponse>> {
        if (requestParameters.conversationPbxTimeBasedUuid === null || requestParameters.conversationPbxTimeBasedUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxTimeBasedUuid','Required parameter requestParameters.conversationPbxTimeBasedUuid was null or undefined when calling updatePbxTimeBased.');
        }

        if (requestParameters.pbxTimeBased === null || requestParameters.pbxTimeBased === undefined) {
            throw new runtime.RequiredError('pbxTimeBased','Required parameter requestParameters.pbxTimeBased was null or undefined when calling updatePbxTimeBased.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_based/{conversationPbxTimeBasedUuid}`.replace(`{${"conversationPbxTimeBasedUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxTimeBasedUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxTimeBasedToJSON(requestParameters.pbxTimeBased),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeBasedResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx timeBased 
     * Update pbx timeBased
     */
    async updatePbxTimeBased(requestParameters: UpdatePbxTimeBasedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeBasedResponse> {
        const response = await this.updatePbxTimeBasedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx timeRange 
     * Update pbx timeRange
     */
    async updatePbxTimeRangeRaw(requestParameters: UpdatePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxTimeRangeResponse>> {
        if (requestParameters.conversationPbxTimeRangeUuid === null || requestParameters.conversationPbxTimeRangeUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxTimeRangeUuid','Required parameter requestParameters.conversationPbxTimeRangeUuid was null or undefined when calling updatePbxTimeRange.');
        }

        if (requestParameters.pbxTimeRange === null || requestParameters.pbxTimeRange === undefined) {
            throw new runtime.RequiredError('pbxTimeRange','Required parameter requestParameters.pbxTimeRange was null or undefined when calling updatePbxTimeRange.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/time_range/{conversationPbxTimeRangeUuid}`.replace(`{${"conversationPbxTimeRangeUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxTimeRangeUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxTimeRangeToJSON(requestParameters.pbxTimeRange),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxTimeRangeResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx timeRange 
     * Update pbx timeRange
     */
    async updatePbxTimeRange(requestParameters: UpdatePbxTimeRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxTimeRangeResponse> {
        const response = await this.updatePbxTimeRangeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a pbx voicemailMailbox 
     * Update pbx voicemailMailbox
     */
    async updatePbxVoicemailMailboxRaw(requestParameters: UpdatePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationPbxVoicemailMailboxResponse>> {
        if (requestParameters.conversationPbxVoicemailMailboxUuid === null || requestParameters.conversationPbxVoicemailMailboxUuid === undefined) {
            throw new runtime.RequiredError('conversationPbxVoicemailMailboxUuid','Required parameter requestParameters.conversationPbxVoicemailMailboxUuid was null or undefined when calling updatePbxVoicemailMailbox.');
        }

        if (requestParameters.pbxVoicemailMailbox === null || requestParameters.pbxVoicemailMailbox === undefined) {
            throw new runtime.RequiredError('pbxVoicemailMailbox','Required parameter requestParameters.pbxVoicemailMailbox was null or undefined when calling updatePbxVoicemailMailbox.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/pbx/voicemail_mailbox/{conversationPbxVoicemailMailboxUuid}`.replace(`{${"conversationPbxVoicemailMailboxUuid"}}`, encodeURIComponent(String(requestParameters.conversationPbxVoicemailMailboxUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationPbxVoicemailMailboxToJSON(requestParameters.pbxVoicemailMailbox),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationPbxVoicemailMailboxResponseFromJSON(jsonValue));
    }

    /**
     * Update a pbx voicemailMailbox 
     * Update pbx voicemailMailbox
     */
    async updatePbxVoicemailMailbox(requestParameters: UpdatePbxVoicemailMailboxRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationPbxVoicemailMailboxResponse> {
        const response = await this.updatePbxVoicemailMailboxRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update virtual agent budget 
     * Update virtual agent budget
     */
    async updateVirtualAgentBudgetRaw(requestParameters: UpdateVirtualAgentBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentBudgetResponse>> {
        if (requestParameters.virtualAgentBudget === null || requestParameters.virtualAgentBudget === undefined) {
            throw new runtime.RequiredError('virtualAgentBudget','Required parameter requestParameters.virtualAgentBudget was null or undefined when calling updateVirtualAgentBudget.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/virtualagent/budget`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationVirtualAgentBudgetToJSON(requestParameters.virtualAgentBudget),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationVirtualAgentBudgetResponseFromJSON(jsonValue));
    }

    /**
     * Update virtual agent budget 
     * Update virtual agent budget
     */
    async updateVirtualAgentBudget(requestParameters: UpdateVirtualAgentBudgetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentBudgetResponse> {
        const response = await this.updateVirtualAgentBudgetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update virtual agent capabilities 
     * Update virtual agent capabilities
     */
    async updateVirtualAgentCapabilitiesRaw(requestParameters: UpdateVirtualAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationVirtualAgentCapabilitiesResponse>> {
        if (requestParameters.virtualAgentCapabilities === null || requestParameters.virtualAgentCapabilities === undefined) {
            throw new runtime.RequiredError('virtualAgentCapabilities','Required parameter requestParameters.virtualAgentCapabilities was null or undefined when calling updateVirtualAgentCapabilities.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("ultraCartOauth", ["conversation_write"]);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-ultracart-simple-key"] = this.configuration.apiKey("x-ultracart-simple-key"); // ultraCartSimpleApiKey authentication
        }

        const response = await this.request({
            path: `/conversation/virtualagent/capabilities`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationVirtualAgentCapabilitiesToJSON(requestParameters.virtualAgentCapabilities),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationVirtualAgentCapabilitiesResponseFromJSON(jsonValue));
    }

    /**
     * Update virtual agent capabilities 
     * Update virtual agent capabilities
     */
    async updateVirtualAgentCapabilities(requestParameters: UpdateVirtualAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationVirtualAgentCapabilitiesResponse> {
        const response = await this.updateVirtualAgentCapabilitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
